unit fhir5_resources_clinical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Fri, Aug 21, 2020 11:27+1000 for FHIR v4.5.0

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base;

type
{$IFDEF FHIR_ADVERSEEVENT}
  TFhirAdverseEventParticipant = class;
  TFhirAdverseEventParticipantList = class;
  TFhirAdverseEventSuspectEntity = class;
  TFhirAdverseEventSuspectEntityList = class;
  TFhirAdverseEventSuspectEntityCausality = class;
  TFhirAdverseEventSuspectEntityCausalityList = class;
  TFhirAdverseEventContributingFactor = class;
  TFhirAdverseEventContributingFactorList = class;
  TFhirAdverseEventPreventiveAction = class;
  TFhirAdverseEventPreventiveActionList = class;
  TFhirAdverseEventMitigatingAction = class;
  TFhirAdverseEventMitigatingActionList = class;
  TFhirAdverseEventSupportingInfo = class;
  TFhirAdverseEventSupportingInfoList = class;
  TFhirAdverseEvent = class;
  TFhirAdverseEventList = class;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  TFhirAllergyIntoleranceReaction = class;
  TFhirAllergyIntoleranceReactionList = class;
  TFhirAllergyIntolerance = class;
  TFhirAllergyIntoleranceList = class;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  TFhirAppointmentParticipant = class;
  TFhirAppointmentParticipantList = class;
  TFhirAppointment = class;
  TFhirAppointmentList = class;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  TFhirAppointmentResponse = class;
  TFhirAppointmentResponseList = class;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  TFhirBasic = class;
  TFhirBasicList = class;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  TFhirBiologicallyDerivedProductCollection = class;
  TFhirBiologicallyDerivedProductCollectionList = class;
  TFhirBiologicallyDerivedProductProcessing = class;
  TFhirBiologicallyDerivedProductProcessingList = class;
  TFhirBiologicallyDerivedProductManipulation = class;
  TFhirBiologicallyDerivedProductManipulationList = class;
  TFhirBiologicallyDerivedProductStorage = class;
  TFhirBiologicallyDerivedProductStorageList = class;
  TFhirBiologicallyDerivedProduct = class;
  TFhirBiologicallyDerivedProductList = class;
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  TFhirBodyStructure = class;
  TFhirBodyStructureList = class;
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivityDetail = class;
  TFhirCarePlanActivityDetailList = class;
  TFhirCarePlan = class;
  TFhirCarePlanList = class;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  TFhirCareTeamParticipant = class;
  TFhirCareTeamParticipantList = class;
  TFhirCareTeam = class;
  TFhirCareTeamList = class;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
  TFhirClinicalImpressionFinding = class;
  TFhirClinicalImpressionFindingList = class;
  TFhirClinicalImpression = class;
  TFhirClinicalImpressionList = class;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEISSUE}
  TFhirClinicalUseIssueContraindication = class;
  TFhirClinicalUseIssueContraindicationList = class;
  TFhirClinicalUseIssueContraindicationOtherTherapy = class;
  TFhirClinicalUseIssueContraindicationOtherTherapyList = class;
  TFhirClinicalUseIssueIndication = class;
  TFhirClinicalUseIssueIndicationList = class;
  TFhirClinicalUseIssueInteraction = class;
  TFhirClinicalUseIssueInteractionList = class;
  TFhirClinicalUseIssueInteractionInteractant = class;
  TFhirClinicalUseIssueInteractionInteractantList = class;
  TFhirClinicalUseIssueUndesirableEffect = class;
  TFhirClinicalUseIssueUndesirableEffectList = class;
  TFhirClinicalUseIssue = class;
  TFhirClinicalUseIssueList = class;
{$ENDIF FHIR_CLINICALUSEISSUE}
{$IFDEF FHIR_COMMUNICATION}
  TFhirCommunicationPayload = class;
  TFhirCommunicationPayloadList = class;
  TFhirCommunication = class;
  TFhirCommunicationList = class;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  TFhirCommunicationRequestPayload = class;
  TFhirCommunicationRequestPayloadList = class;
  TFhirCommunicationRequest = class;
  TFhirCommunicationRequestList = class;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionRelatesTo = class;
  TFhirCompositionRelatesToList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirComposition = class;
  TFhirCompositionList = class;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirCondition = class;
  TFhirConditionList = class;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
  TFhirDetectedIssueEvidence = class;
  TFhirDetectedIssueEvidenceList = class;
  TFhirDetectedIssueMitigation = class;
  TFhirDetectedIssueMitigationList = class;
  TFhirDetectedIssue = class;
  TFhirDetectedIssueList = class;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
  TFhirDeviceRequestParameter = class;
  TFhirDeviceRequestParameterList = class;
  TFhirDeviceRequest = class;
  TFhirDeviceRequestList = class;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  TFhirDeviceUseStatement = class;
  TFhirDeviceUseStatementList = class;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  TFhirDiagnosticReportMedia = class;
  TFhirDiagnosticReportMediaList = class;
  TFhirDiagnosticReport = class;
  TFhirDiagnosticReportList = class;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  TFhirDocumentManifestRelated = class;
  TFhirDocumentManifestRelatedList = class;
  TFhirDocumentManifest = class;
  TFhirDocumentManifestList = class;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  TFhirDocumentReferenceAttester = class;
  TFhirDocumentReferenceAttesterList = class;
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceContent = class;
  TFhirDocumentReferenceContentList = class;
  TFhirDocumentReference = class;
  TFhirDocumentReferenceList = class;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
  TFhirEpisodeOfCareStatusHistory = class;
  TFhirEpisodeOfCareStatusHistoryList = class;
  TFhirEpisodeOfCareDiagnosis = class;
  TFhirEpisodeOfCareDiagnosisList = class;
  TFhirEpisodeOfCare = class;
  TFhirEpisodeOfCareList = class;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  TFhirFamilyMemberHistoryCondition = class;
  TFhirFamilyMemberHistoryConditionList = class;
  TFhirFamilyMemberHistoryProcedure = class;
  TFhirFamilyMemberHistoryProcedureList = class;
  TFhirFamilyMemberHistory = class;
  TFhirFamilyMemberHistoryList = class;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  TFhirFlag = class;
  TFhirFlagList = class;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  TFhirGoalTarget = class;
  TFhirGoalTargetList = class;
  TFhirGoal = class;
  TFhirGoalList = class;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
  TFhirImagingStudyProcedure = class;
  TFhirImagingStudyProcedureList = class;
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesPerformer = class;
  TFhirImagingStudySeriesPerformerList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImagingStudy = class;
  TFhirImagingStudyList = class;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  TFhirImmunizationPerformer = class;
  TFhirImmunizationPerformerList = class;
  TFhirImmunizationEducation = class;
  TFhirImmunizationEducationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationProtocolApplied = class;
  TFhirImmunizationProtocolAppliedList = class;
  TFhirImmunization = class;
  TFhirImmunizationList = class;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  TFhirImmunizationEvaluation = class;
  TFhirImmunizationEvaluationList = class;
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendation = class;
  TFhirImmunizationRecommendationList = class;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  TFhirMedicationAdministrationPerformer = class;
  TFhirMedicationAdministrationPerformerList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationAdministration = class;
  TFhirMedicationAdministrationList = class;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  TFhirMedicationDispensePerformer = class;
  TFhirMedicationDispensePerformerList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationDispense = class;
  TFhirMedicationDispenseList = class;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  TFhirMedicationRequestDispenseRequest = class;
  TFhirMedicationRequestDispenseRequestList = class;
  TFhirMedicationRequestDispenseRequestInitialFill = class;
  TFhirMedicationRequestDispenseRequestInitialFillList = class;
  TFhirMedicationRequestSubstitution = class;
  TFhirMedicationRequestSubstitutionList = class;
  TFhirMedicationRequest = class;
  TFhirMedicationRequestList = class;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  TFhirMedicationUsage = class;
  TFhirMedicationUsageList = class;
{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  TFhirMolecularSequenceReferenceSeq = class;
  TFhirMolecularSequenceReferenceSeqList = class;
  TFhirMolecularSequenceVariant = class;
  TFhirMolecularSequenceVariantList = class;
  TFhirMolecularSequenceQuality = class;
  TFhirMolecularSequenceQualityList = class;
  TFhirMolecularSequenceQualityRoc = class;
  TFhirMolecularSequenceQualityRocList = class;
  TFhirMolecularSequenceRepository = class;
  TFhirMolecularSequenceRepositoryList = class;
  TFhirMolecularSequenceStructureVariant = class;
  TFhirMolecularSequenceStructureVariantList = class;
  TFhirMolecularSequenceStructureVariantOuter = class;
  TFhirMolecularSequenceStructureVariantOuterList = class;
  TFhirMolecularSequenceStructureVariantInner = class;
  TFhirMolecularSequenceStructureVariantInnerList = class;
  TFhirMolecularSequence = class;
  TFhirMolecularSequenceList = class;
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONINTAKE}
  TFhirNutritionIntakeConsumedItem = class;
  TFhirNutritionIntakeConsumedItemList = class;
  TFhirNutritionIntakeIngredientLabel = class;
  TFhirNutritionIntakeIngredientLabelList = class;
  TFhirNutritionIntakePerformer = class;
  TFhirNutritionIntakePerformerList = class;
  TFhirNutritionIntake = class;
  TFhirNutritionIntakeList = class;
{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  TFhirNutritionOrderOralDiet = class;
  TFhirNutritionOrderOralDietList = class;
  TFhirNutritionOrderOralDietNutrient = class;
  TFhirNutritionOrderOralDietNutrientList = class;
  TFhirNutritionOrderOralDietTexture = class;
  TFhirNutritionOrderOralDietTextureList = class;
  TFhirNutritionOrderSupplement = class;
  TFhirNutritionOrderSupplementList = class;
  TFhirNutritionOrderEnteralFormula = class;
  TFhirNutritionOrderEnteralFormulaList = class;
  TFhirNutritionOrderEnteralFormulaAdministration = class;
  TFhirNutritionOrderEnteralFormulaAdministrationList = class;
  TFhirNutritionOrder = class;
  TFhirNutritionOrderList = class;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationComponent = class;
  TFhirObservationComponentList = class;
  TFhirObservation = class;
  TFhirObservationList = class;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureFocalDevice = class;
  TFhirProcedureFocalDeviceList = class;
  TFhirProcedure = class;
  TFhirProcedureList = class;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
  TFhirRiskAssessmentPrediction = class;
  TFhirRiskAssessmentPredictionList = class;
  TFhirRiskAssessment = class;
  TFhirRiskAssessmentList = class;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
  TFhirServiceRequest = class;
  TFhirServiceRequestList = class;
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenProcessing = class;
  TFhirSpecimenProcessingList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSpecimen = class;
  TFhirSpecimenList = class;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  TFhirSupplyDeliverySuppliedItem = class;
  TFhirSupplyDeliverySuppliedItemList = class;
  TFhirSupplyDelivery = class;
  TFhirSupplyDeliveryList = class;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  TFhirSupplyRequestParameter = class;
  TFhirSupplyRequestParameterList = class;
  TFhirSupplyRequest = class;
  TFhirSupplyRequestList = class;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  TFhirVisionPrescriptionLensSpecification = class;
  TFhirVisionPrescriptionLensSpecificationList = class;
  TFhirVisionPrescriptionLensSpecificationPrism = class;
  TFhirVisionPrescriptionLensSpecificationPrismList = class;
  TFhirVisionPrescription = class;
  TFhirVisionPrescriptionList = class;
{$ENDIF FHIR_VISIONPRESCRIPTION}

{$IFDEF FHIR_ADVERSEEVENT}
  // Indicates who or what participated in the adverse event and how they were involved.
  TFhirAdverseEventParticipant = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventParticipant; overload;
    function Clone : TFhirAdverseEventParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the actor in the adverse event, such as contributor or informant. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the actor in the adverse event, such as contributor or informant.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what participated in the event. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what participated in the event.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirAdverseEventParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventParticipantList;
    function GetCurrent : TFhirAdverseEventParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventParticipant read GetCurrent;
  end;

  TFhirAdverseEventParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventParticipant;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventParticipantList; overload;
    function Clone : TFhirAdverseEventParticipantList; overload;
    function GetEnumerator : TFhirAdverseEventParticipantListEnumerator;
    
    //  Add a FhirAdverseEventParticipant to the end of the list.
    function Append : TFhirAdverseEventParticipant;
    
    // Add an already existing FhirAdverseEventParticipant to the end of the list.
    procedure AddItem(value : TFhirAdverseEventParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventParticipant) : Integer;
    
    // Insert FhirAdverseEventParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventParticipant;
    
    // Insert an existing FhirAdverseEventParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventParticipant);
    
    // Get the iIndexth FhirAdverseEventParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventParticipants[index : Integer] : TFhirAdverseEventParticipant read GetItemN write SetItemN; default;
  End;

  // Describes the entity that is suspected to have caused the adverse event.
  TFhirAdverseEventSuspectEntity = class (TFhirBackboneElement)
  protected
    FInstance : TFhirDataType;
    FCausality : TFhirAdverseEventSuspectEntityCausality;
    procedure SetInstance(value : TFhirDataType);
    procedure SetCausality(value : TFhirAdverseEventSuspectEntityCausality);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSuspectEntity; overload;
    function Clone : TFhirAdverseEventSuspectEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device. (defined for API consistency)
    property instance : TFhirDataType read FInstance write SetInstance;
    // Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device.
    property instanceElement : TFhirDataType read FInstance write SetInstance;

    // Typed access to Information on the possible cause of the event. (defined for API consistency)
    property causality : TFhirAdverseEventSuspectEntityCausality read FCausality write SetCausality;
    // Information on the possible cause of the event.
    property causalityElement : TFhirAdverseEventSuspectEntityCausality read FCausality write SetCausality;

  end;

  TFhirAdverseEventSuspectEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSuspectEntityList;
    function GetCurrent : TFhirAdverseEventSuspectEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSuspectEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSuspectEntity read GetCurrent;
  end;

  TFhirAdverseEventSuspectEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventSuspectEntity;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSuspectEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventSuspectEntityList; overload;
    function Clone : TFhirAdverseEventSuspectEntityList; overload;
    function GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;
    
    //  Add a FhirAdverseEventSuspectEntity to the end of the list.
    function Append : TFhirAdverseEventSuspectEntity;
    
    // Add an already existing FhirAdverseEventSuspectEntity to the end of the list.
    procedure AddItem(value : TFhirAdverseEventSuspectEntity); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSuspectEntity) : Integer;
    
    // Insert FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSuspectEntity;
    
    // Insert an existing FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSuspectEntity);
    
    // Get the iIndexth FhirAdverseEventSuspectEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSuspectEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSuspectEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventSuspectEntities[index : Integer] : TFhirAdverseEventSuspectEntity read GetItemN write SetItemN; default;
  End;

  // Information on the possible cause of the event.
  TFhirAdverseEventSuspectEntityCausality = class (TFhirBackboneElement)
  protected
    FAssessmentMethod : TFhirCodeableConcept;
    FEntityRelatedness : TFhirCodeableConcept;
    FAuthor : TFhirReference;
    procedure SetAssessmentMethod(value : TFhirCodeableConcept);
    procedure SetEntityRelatedness(value : TFhirCodeableConcept);
    procedure SetAuthor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSuspectEntityCausality; overload;
    function Clone : TFhirAdverseEventSuspectEntityCausality; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The method of evaluating the relatedness of the suspected entity to the event. (defined for API consistency)
    property assessmentMethod : TFhirCodeableConcept read FAssessmentMethod write SetAssessmentMethod;
    // The method of evaluating the relatedness of the suspected entity to the event.
    property assessmentMethodElement : TFhirCodeableConcept read FAssessmentMethod write SetAssessmentMethod;

    // Typed access to The result of the assessment regarding the relatedness of the suspected entity to the event. (defined for API consistency)
    property entityRelatedness : TFhirCodeableConcept read FEntityRelatedness write SetEntityRelatedness;
    // The result of the assessment regarding the relatedness of the suspected entity to the event.
    property entityRelatednessElement : TFhirCodeableConcept read FEntityRelatedness write SetEntityRelatedness;

    // Typed access to The author of the information on the possible cause of the event. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The author of the information on the possible cause of the event.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirAdverseEventSuspectEntityCausalityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSuspectEntityCausalityList;
    function GetCurrent : TFhirAdverseEventSuspectEntityCausality;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSuspectEntityCausalityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSuspectEntityCausality read GetCurrent;
  end;

  TFhirAdverseEventSuspectEntityCausalityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventSuspectEntityCausalityList; overload;
    function Clone : TFhirAdverseEventSuspectEntityCausalityList; overload;
    function GetEnumerator : TFhirAdverseEventSuspectEntityCausalityListEnumerator;
    
    //  Add a FhirAdverseEventSuspectEntityCausality to the end of the list.
    function Append : TFhirAdverseEventSuspectEntityCausality;
    
    // Add an already existing FhirAdverseEventSuspectEntityCausality to the end of the list.
    procedure AddItem(value : TFhirAdverseEventSuspectEntityCausality); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSuspectEntityCausality) : Integer;
    
    // Insert FhirAdverseEventSuspectEntityCausality before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    
    // Insert an existing FhirAdverseEventSuspectEntityCausality before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
    
    // Get the iIndexth FhirAdverseEventSuspectEntityCausality. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventSuspectEntityCausalities[index : Integer] : TFhirAdverseEventSuspectEntityCausality read GetItemN write SetItemN; default;
  End;

  // The contributing factors suspected to have increased the probability or severity of the adverse event.
  TFhirAdverseEventContributingFactor = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventContributingFactor; overload;
    function Clone : TFhirAdverseEventContributingFactor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The item that is suspected to have increased the probability or severity of the adverse event. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The item that is suspected to have increased the probability or severity of the adverse event.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirAdverseEventContributingFactorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventContributingFactorList;
    function GetCurrent : TFhirAdverseEventContributingFactor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventContributingFactorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventContributingFactor read GetCurrent;
  end;

  TFhirAdverseEventContributingFactorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventContributingFactor;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventContributingFactor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventContributingFactorList; overload;
    function Clone : TFhirAdverseEventContributingFactorList; overload;
    function GetEnumerator : TFhirAdverseEventContributingFactorListEnumerator;
    
    //  Add a FhirAdverseEventContributingFactor to the end of the list.
    function Append : TFhirAdverseEventContributingFactor;
    
    // Add an already existing FhirAdverseEventContributingFactor to the end of the list.
    procedure AddItem(value : TFhirAdverseEventContributingFactor); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventContributingFactor) : Integer;
    
    // Insert FhirAdverseEventContributingFactor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventContributingFactor;
    
    // Insert an existing FhirAdverseEventContributingFactor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventContributingFactor);
    
    // Get the iIndexth FhirAdverseEventContributingFactor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventContributingFactor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventContributingFactor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventContributingFactors[index : Integer] : TFhirAdverseEventContributingFactor read GetItemN write SetItemN; default;
  End;

  // Preventive actions that contributed to avoiding the adverse event.
  TFhirAdverseEventPreventiveAction = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventPreventiveAction; overload;
    function Clone : TFhirAdverseEventPreventiveAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The action that contributed to avoiding the adverse event. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The action that contributed to avoiding the adverse event.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirAdverseEventPreventiveActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventPreventiveActionList;
    function GetCurrent : TFhirAdverseEventPreventiveAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventPreventiveActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventPreventiveAction read GetCurrent;
  end;

  TFhirAdverseEventPreventiveActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventPreventiveAction;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventPreventiveAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventPreventiveActionList; overload;
    function Clone : TFhirAdverseEventPreventiveActionList; overload;
    function GetEnumerator : TFhirAdverseEventPreventiveActionListEnumerator;
    
    //  Add a FhirAdverseEventPreventiveAction to the end of the list.
    function Append : TFhirAdverseEventPreventiveAction;
    
    // Add an already existing FhirAdverseEventPreventiveAction to the end of the list.
    procedure AddItem(value : TFhirAdverseEventPreventiveAction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventPreventiveAction) : Integer;
    
    // Insert FhirAdverseEventPreventiveAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventPreventiveAction;
    
    // Insert an existing FhirAdverseEventPreventiveAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventPreventiveAction);
    
    // Get the iIndexth FhirAdverseEventPreventiveAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventPreventiveAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventPreventiveAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventPreventiveActions[index : Integer] : TFhirAdverseEventPreventiveAction read GetItemN write SetItemN; default;
  End;

  // The ameliorating action taken after the adverse event occured in order to reduce the extent of harm.
  TFhirAdverseEventMitigatingAction = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventMitigatingAction; overload;
    function Clone : TFhirAdverseEventMitigatingAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ameliorating action taken after the adverse event occured in order to reduce the extent of harm. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The ameliorating action taken after the adverse event occured in order to reduce the extent of harm.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirAdverseEventMitigatingActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventMitigatingActionList;
    function GetCurrent : TFhirAdverseEventMitigatingAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventMitigatingActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventMitigatingAction read GetCurrent;
  end;

  TFhirAdverseEventMitigatingActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventMitigatingAction;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventMitigatingAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventMitigatingActionList; overload;
    function Clone : TFhirAdverseEventMitigatingActionList; overload;
    function GetEnumerator : TFhirAdverseEventMitigatingActionListEnumerator;
    
    //  Add a FhirAdverseEventMitigatingAction to the end of the list.
    function Append : TFhirAdverseEventMitigatingAction;
    
    // Add an already existing FhirAdverseEventMitigatingAction to the end of the list.
    procedure AddItem(value : TFhirAdverseEventMitigatingAction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventMitigatingAction) : Integer;
    
    // Insert FhirAdverseEventMitigatingAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventMitigatingAction;
    
    // Insert an existing FhirAdverseEventMitigatingAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventMitigatingAction);
    
    // Get the iIndexth FhirAdverseEventMitigatingAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventMitigatingAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventMitigatingAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventMitigatingActions[index : Integer] : TFhirAdverseEventMitigatingAction read GetItemN write SetItemN; default;
  End;

  // Supporting information relevant to the event.
  TFhirAdverseEventSupportingInfo = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSupportingInfo; overload;
    function Clone : TFhirAdverseEventSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Relevant past history for the subject. In a clinical care context, an example being a patient had an adverse event following a pencillin administration and the patient had a previously documented penicillin allergy. In a clinical trials context, an example is a bunion or rash that was present prior to the study. Additionally, the supporting item can be a document that is relevant to this instance of the adverse event that is not part of the subject's medical history. For example, a clinical note, staff list, or material safety data sheet (MSDS).  Supporting information is not a contributing factor, preventive action, or mitigating action. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // Relevant past history for the subject. In a clinical care context, an example being a patient had an adverse event following a pencillin administration and the patient had a previously documented penicillin allergy. In a clinical trials context, an example is a bunion or rash that was present prior to the study. Additionally, the supporting item can be a document that is relevant to this instance of the adverse event that is not part of the subject's medical history. For example, a clinical note, staff list, or material safety data sheet (MSDS).  Supporting information is not a contributing factor, preventive action, or mitigating action.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirAdverseEventSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSupportingInfoList;
    function GetCurrent : TFhirAdverseEventSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSupportingInfo read GetCurrent;
  end;

  TFhirAdverseEventSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventSupportingInfoList; overload;
    function Clone : TFhirAdverseEventSupportingInfoList; overload;
    function GetEnumerator : TFhirAdverseEventSupportingInfoListEnumerator;
    
    //  Add a FhirAdverseEventSupportingInfo to the end of the list.
    function Append : TFhirAdverseEventSupportingInfo;
    
    // Add an already existing FhirAdverseEventSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirAdverseEventSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSupportingInfo) : Integer;
    
    // Insert FhirAdverseEventSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSupportingInfo;
    
    // Insert an existing FhirAdverseEventSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSupportingInfo);
    
    // Get the iIndexth FhirAdverseEventSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventSupportingInfos[index : Integer] : TFhirAdverseEventSupportingInfo read GetItemN write SetItemN; default;
  End;

  // An event (i.e. any change to current patient status) that may be related to unintended effects on a patient or research subject.  The unintended effects may require additional monitoring, treatment or hospitalization or may result in death.  The AdverseEvent resource also extends to potential or avoided events that could have had such effects.
  TFhirAdverseEvent = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FActuality : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FDetected : TFhirDateTime;
    FRecordedDate : TFhirDateTime;
    FresultingConditionList : TFhirReferenceList;
    FLocation : TFhirReference;
    FSeriousness : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FRecorder : TFhirReference;
    FparticipantList : TFhirAdverseEventParticipantList;
    FsuspectEntityList : TFhirAdverseEventSuspectEntityList;
    FcontributingFactorList : TFhirAdverseEventContributingFactorList;
    FpreventiveActionList : TFhirAdverseEventPreventiveActionList;
    FmitigatingActionList : TFhirAdverseEventMitigatingActionList;
    FsupportingInfoList : TFhirAdverseEventSupportingInfoList;
    FstudyList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirAdverseEventStatusEnum;
    procedure SetStatusST(value : TFhirAdverseEventStatusEnum);
    procedure SetActuality(value : TFhirEnum);
    function GetActualityST : TFhirAdverseEventActualityEnum;
    procedure SetActualityST(value : TFhirAdverseEventActualityEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetDetected(value : TFhirDateTime);
    function GetDetectedST : TFslDateTime;
    procedure SetDetectedST(value : TFslDateTime);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    function GetResultingConditionList : TFhirReferenceList;
    function GetHasResultingConditionList : Boolean;
    procedure SetLocation(value : TFhirReference);
    procedure SetSeriousness(value : TFhirCodeableConcept);
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetRecorder(value : TFhirReference);
    function GetParticipantList : TFhirAdverseEventParticipantList;
    function GetHasParticipantList : Boolean;
    function GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
    function GetHasSuspectEntityList : Boolean;
    function GetContributingFactorList : TFhirAdverseEventContributingFactorList;
    function GetHasContributingFactorList : Boolean;
    function GetPreventiveActionList : TFhirAdverseEventPreventiveActionList;
    function GetHasPreventiveActionList : Boolean;
    function GetMitigatingActionList : TFhirAdverseEventMitigatingActionList;
    function GetHasMitigatingActionList : Boolean;
    function GetSupportingInfoList : TFhirAdverseEventSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetStudyList : TFhirReferenceList;
    function GetHasStudyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEvent; overload;
    function Clone : TFhirAdverseEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this adverse event by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the adverse event or potential adverse event.
    property status : TFhirAdverseEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the event actually happened, or just had the potential to. Note that this is independent of whether anyone was affected or harmed or how severely.
    property actuality : TFhirAdverseEventActualityEnum read GetActualityST write SetActualityST;
    property actualityElement : TFhirEnum read FActuality write SetActuality;

    // The overall type of event, intended for search and filtering purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Specific event that occurred or that was averted, such as patient fall, wrong organ removed, or wrong blood transfused. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Specific event that occurred or that was averted, such as patient fall, wrong organ removed, or wrong blood transfused.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to This subject or group impacted by the event. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // This subject or group impacted by the event.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter associated with the start of the AdverseEvent. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter associated with the start of the AdverseEvent.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and perhaps time) when the adverse event occurred. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date (and perhaps time) when the adverse event occurred.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to Estimated or actual date the AdverseEvent began, in the opinion of the reporter.
    property detected : TFslDateTime read GetDetectedST write SetDetectedST;
    // Estimated or actual date the AdverseEvent began, in the opinion of the reporter.
    property detectedElement : TFhirDateTime read FDetected write SetDetected;

    // Typed access to The date on which the existence of the AdverseEvent was first recorded.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The date on which the existence of the AdverseEvent was first recorded.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Includes information about the reaction that occurred as a result of exposure to a substance (for example, a drug or a chemical).
    property resultingConditionList : TFhirReferenceList read GetResultingConditionList;
    property hasResultingConditionList : boolean read GetHasResultingConditionList;

    // Typed access to The information about where the adverse event occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The information about where the adverse event occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to Assessment whether this event, or averted event, was of clinical importance. (defined for API consistency)
    property seriousness : TFhirCodeableConcept read FSeriousness write SetSeriousness;
    // Assessment whether this event, or averted event, was of clinical importance.
    property seriousnessElement : TFhirCodeableConcept read FSeriousness write SetSeriousness;

    // Typed access to Describes the type of outcome from the adverse event, such as resolved, recovering, ongoing, resolved-with-sequelae, or fatal. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Describes the type of outcome from the adverse event, such as resolved, recovering, ongoing, resolved-with-sequelae, or fatal.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Information on who recorded the adverse event.  May be the patient or a practitioner. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Information on who recorded the adverse event.  May be the patient or a practitioner.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Indicates who or what participated in the adverse event and how they were involved.
    property participantList : TFhirAdverseEventParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Describes the entity that is suspected to have caused the adverse event.
    property suspectEntityList : TFhirAdverseEventSuspectEntityList read GetSuspectEntityList;
    property hasSuspectEntityList : boolean read GetHasSuspectEntityList;

    // The contributing factors suspected to have increased the probability or severity of the adverse event.
    property contributingFactorList : TFhirAdverseEventContributingFactorList read GetContributingFactorList;
    property hasContributingFactorList : boolean read GetHasContributingFactorList;

    // Preventive actions that contributed to avoiding the adverse event.
    property preventiveActionList : TFhirAdverseEventPreventiveActionList read GetPreventiveActionList;
    property hasPreventiveActionList : boolean read GetHasPreventiveActionList;

    // The ameliorating action taken after the adverse event occured in order to reduce the extent of harm.
    property mitigatingActionList : TFhirAdverseEventMitigatingActionList read GetMitigatingActionList;
    property hasMitigatingActionList : boolean read GetHasMitigatingActionList;

    // Supporting information relevant to the event.
    property supportingInfoList : TFhirAdverseEventSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // The research study that the subject is enrolled in.
    property studyList : TFhirReferenceList read GetStudyList;
    property hasStudyList : boolean read GetHasStudyList;

  end;

  TFhirAdverseEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventList;
    function GetCurrent : TFhirAdverseEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEvent read GetCurrent;
  end;

  TFhirAdverseEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEvent;
    procedure SetItemN(index : Integer; value : TFhirAdverseEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventList; overload;
    function Clone : TFhirAdverseEventList; overload;
    function GetEnumerator : TFhirAdverseEventListEnumerator;
    
    //  Add a FhirAdverseEvent to the end of the list.
    function Append : TFhirAdverseEvent;
    
    // Add an already existing FhirAdverseEvent to the end of the list.
    procedure AddItem(value : TFhirAdverseEvent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEvent) : Integer;
    
    // Insert FhirAdverseEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEvent;
    
    // Insert an existing FhirAdverseEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEvent);
    
    // Get the iIndexth FhirAdverseEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEvents[index : Integer] : TFhirAdverseEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  // Details about each adverse reaction event linked to exposure to the identified substance.
  TFhirAllergyIntoleranceReaction = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FmanifestationList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FOnset : TFhirDateTime;
    FSeverity : TFhirEnum;
    FExposureRoute : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    procedure SetSubstance(value : TFhirCodeableConcept);
    function GetManifestationList : TFhirCodeableConceptList;
    function GetHasManifestationList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetOnset(value : TFhirDateTime);
    function GetOnsetST : TFslDateTime;
    procedure SetOnsetST(value : TFslDateTime);
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirAllergyIntoleranceSeverityEnum;
    procedure SetSeverityST(value : TFhirAllergyIntoleranceSeverityEnum);
    procedure SetExposureRoute(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntoleranceReaction; overload;
    function Clone : TFhirAllergyIntoleranceReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Clinical symptoms and/or signs that are observed or associated with the adverse reaction event.
    property manifestationList : TFhirCodeableConceptList read GetManifestationList;
    property hasManifestationList : boolean read GetHasManifestationList;

    // Typed access to Text description about the reaction as a whole, including details of the manifestation if required.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text description about the reaction as a whole, including details of the manifestation if required.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Record of the date and/or time of the onset of the Reaction.
    property onset : TFslDateTime read GetOnsetST write SetOnsetST;
    // Record of the date and/or time of the onset of the Reaction.
    property onsetElement : TFhirDateTime read FOnset write SetOnset;

    // Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations.
    property severity : TFhirAllergyIntoleranceSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Identification of the route by which the subject was exposed to the substance. (defined for API consistency)
    property exposureRoute : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;
    // Identification of the route by which the subject was exposed to the substance.
    property exposureRouteElement : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;

    // Additional text about the adverse reaction event not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirAllergyIntoleranceReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceReactionList;
    function GetCurrent : TFhirAllergyIntoleranceReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntoleranceReaction read GetCurrent;
  end;

  TFhirAllergyIntoleranceReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAllergyIntoleranceReaction;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntoleranceReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAllergyIntoleranceReactionList; overload;
    function Clone : TFhirAllergyIntoleranceReactionList; overload;
    function GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
    
    //  Add a FhirAllergyIntoleranceReaction to the end of the list.
    function Append : TFhirAllergyIntoleranceReaction;
    
    // Add an already existing FhirAllergyIntoleranceReaction to the end of the list.
    procedure AddItem(value : TFhirAllergyIntoleranceReaction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntoleranceReaction) : Integer;
    
    // Insert FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntoleranceReaction;
    
    // Insert an existing FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntoleranceReaction);
    
    // Get the iIndexth FhirAllergyIntoleranceReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntoleranceReaction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntoleranceReaction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAllergyIntoleranceReactions[index : Integer] : TFhirAllergyIntoleranceReaction read GetItemN write SetItemN; default;
  End;

  // Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
  TFhirAllergyIntolerance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirCodeableConcept;
    FVerificationStatus : TFhirCodeableConcept;
    FType_ : TFhirEnum;
    FCategory : TFhirEnumList;
    FCriticality : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FOnset : TFhirDataType;
    FRecordedDate : TFhirDateTime;
    FRecorder : TFhirReference;
    FAsserter : TFhirReference;
    FLastOccurrence : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FreactionList : TFhirAllergyIntoleranceReactionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetClinicalStatus(value : TFhirCodeableConcept);
    procedure SetVerificationStatus(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirAllergyIntoleranceTypeEnum;
    procedure SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
    function GetCategory : TFhirEnumList;
    function GetHasCategory : Boolean;
    function GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
    procedure SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
    procedure SetCriticality(value : TFhirEnum);
    function GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
    procedure SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOnset(value : TFhirDataType);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    procedure SetRecorder(value : TFhirReference);
    procedure SetAsserter(value : TFhirReference);
    procedure SetLastOccurrence(value : TFhirDateTime);
    function GetLastOccurrenceST : TFslDateTime;
    procedure SetLastOccurrenceST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetReactionList : TFhirAllergyIntoleranceReactionList;
    function GetHasReactionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntolerance; overload;
    function Clone : TFhirAllergyIntolerance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this AllergyIntolerance by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The clinical status of the allergy or intolerance. (defined for API consistency)
    property clinicalStatus : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;
    // The clinical status of the allergy or intolerance.
    property clinicalStatusElement : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;

    // Typed access to Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified substance (including pharmaceutical product). (defined for API consistency)
    property verificationStatus : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;
    // Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified substance (including pharmaceutical product).
    property verificationStatusElement : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;

    // Identification of the underlying physiological mechanism for the reaction risk.
    property type_ : TFhirAllergyIntoleranceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Category of the identified substance.
    property category : TFhirAllergyIntoleranceCategoryEnumList read GetCategoryST write SetCategoryST;
    property categoryList : TFhirEnumList read GetCategory;
    property hasCategory : boolean read GetHasCategory;
    // Estimate of the potential clinical harm, or seriousness, of the reaction to the identified substance.
    property criticality : TFhirAllergyIntoleranceCriticalityEnum read GetCriticalityST write SetCriticalityST;
    property criticalityElement : TFhirEnum read FCriticality write SetCriticality;

    // Typed access to Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies").  Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within
    //  the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies").  Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within
    //  the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient who has the allergy or intolerance. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who has the allergy or intolerance.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The encounter when the allergy or intolerance was asserted. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter when the allergy or intolerance was asserted.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date,  date-time, or age when allergy or intolerance was identified. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Estimated or actual date,  date-time, or age when allergy or intolerance was identified.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // Typed access to The recordedDate represents when this particular AllergyIntolerance record was created in the system, which is often a system-generated date.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The recordedDate represents when this particular AllergyIntolerance record was created in the system, which is often a system-generated date.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to The source of the information about the allergy that is recorded. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // The source of the information about the allergy that is recorded.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // Typed access to Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrence : TFslDateTime read GetLastOccurrenceST write SetLastOccurrenceST;
    // Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrenceElement : TFhirDateTime read FLastOccurrence write SetLastOccurrence;

    // Additional narrative about the propensity for the Adverse Reaction, not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Details about each adverse reaction event linked to exposure to the identified substance.
    property reactionList : TFhirAllergyIntoleranceReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

  end;

  TFhirAllergyIntoleranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceList;
    function GetCurrent : TFhirAllergyIntolerance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntolerance read GetCurrent;
  end;

  TFhirAllergyIntoleranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAllergyIntolerance;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntolerance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAllergyIntoleranceList; overload;
    function Clone : TFhirAllergyIntoleranceList; overload;
    function GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
    
    //  Add a FhirAllergyIntolerance to the end of the list.
    function Append : TFhirAllergyIntolerance;
    
    // Add an already existing FhirAllergyIntolerance to the end of the list.
    procedure AddItem(value : TFhirAllergyIntolerance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntolerance) : Integer;
    
    // Insert FhirAllergyIntolerance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntolerance;
    
    // Insert an existing FhirAllergyIntolerance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntolerance);
    
    // Get the iIndexth FhirAllergyIntolerance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntolerance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntolerance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAllergyIntolerances[index : Integer] : TFhirAllergyIntolerance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  // List of participants involved in the appointment.
  TFhirAppointmentParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FActor : TFhirReference;
    FRequired : TFhirEnum;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetActor(value : TFhirReference);
    procedure SetRequired(value : TFhirEnum);
    function GetRequiredST : TFhirParticipantRequiredEnum;
    procedure SetRequiredST(value : TFhirParticipantRequiredEnum);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirParticipationStatusEnum;
    procedure SetStatusST(value : TFhirParticipationStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentParticipant; overload;
    function Clone : TFhirAppointmentParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in the appointment.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference read FActor write SetActor;

    // Whether this participant is required to be present at the meeting. This covers a use-case where two doctors need to meet to discuss the results for a specific patient, and the patient is not required to be present.
    property required : TFhirParticipantRequiredEnum read GetRequiredST write SetRequiredST;
    property requiredElement : TFhirEnum read FRequired write SetRequired;

    // Participation status of the actor.
    property status : TFhirParticipationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Participation period of the actor. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Participation period of the actor.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAppointmentParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentParticipantList;
    function GetCurrent : TFhirAppointmentParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentParticipant read GetCurrent;
  end;

  TFhirAppointmentParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointmentParticipant;
    procedure SetItemN(index : Integer; value : TFhirAppointmentParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentParticipantList; overload;
    function Clone : TFhirAppointmentParticipantList; overload;
    function GetEnumerator : TFhirAppointmentParticipantListEnumerator;
    
    //  Add a FhirAppointmentParticipant to the end of the list.
    function Append : TFhirAppointmentParticipant;
    
    // Add an already existing FhirAppointmentParticipant to the end of the list.
    procedure AddItem(value : TFhirAppointmentParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentParticipant) : Integer;
    
    // Insert FhirAppointmentParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentParticipant;
    
    // Insert an existing FhirAppointmentParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentParticipant);
    
    // Get the iIndexth FhirAppointmentParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointmentParticipants[index : Integer] : TFhirAppointmentParticipant read GetItemN write SetItemN; default;
  End;

  // A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).
  TFhirAppointment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCancelationReason : TFhirCodeableConcept;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FreasonList : TFhirCodeableReferenceList;
    FPriority : TFhirUnsignedInt;
    FDescription : TFhirString;
    FsupportingInformationList : TFhirReferenceList;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FMinutesDuration : TFhirPositiveInt;
    FslotList : TFhirReferenceList;
    FCreated : TFhirDateTime;
    FComment : TFhirString;
    FPatientInstruction : TFhirString;
    FbasedOnList : TFhirReferenceList;
    FparticipantList : TFhirAppointmentParticipantList;
    FrequestedPeriodList : TFhirPeriodList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirAppointmentStatusEnum;
    procedure SetStatusST(value : TFhirAppointmentStatusEnum);
    procedure SetCancelationReason(value : TFhirCodeableConcept);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    procedure SetAppointmentType(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    procedure SetPriority(value : TFhirUnsignedInt);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetMinutesDuration(value : TFhirPositiveInt);
    function GetMinutesDurationST : String;
    procedure SetMinutesDurationST(value : String);
    function GetSlotList : TFhirReferenceList;
    function GetHasSlotList : Boolean;
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetPatientInstruction(value : TFhirString);
    function GetPatientInstructionST : String;
    procedure SetPatientInstructionST(value : String);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetParticipantList : TFhirAppointmentParticipantList;
    function GetHasParticipantList : Boolean;
    function GetRequestedPeriodList : TFhirPeriodList;
    function GetHasRequestedPeriodList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointment; overload;
    function Clone : TFhirAppointment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The overall status of the Appointment. Each of the participants has their own participation status which indicates their involvement in the process, however this status indicates the shared status.
    property status : TFhirAppointmentStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The coded reason for the appointment being cancelled. This is often used in reporting/billing/futher processing to determine if further actions are required, or specific fees apply. (defined for API consistency)
    property cancelationReason : TFhirCodeableConcept read FCancelationReason write SetCancelationReason;
    // The coded reason for the appointment being cancelled. This is often used in reporting/billing/futher processing to determine if further actions are required, or specific fees apply.
    property cancelationReasonElement : TFhirCodeableConcept read FCancelationReason write SetCancelationReason;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that has been booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that has been booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // The reason that this appointment is being scheduled. This is more clinical than administrative. This can be coded, or as specified using information from another resource. When the patient arrives and the encounter begins it may be used as the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priorityElement : TFhirUnsignedInt read FPriority write SetPriority;

    // Typed access to The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Additional information to support the appointment provided when making the appointment.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to Date/Time that the appointment is to take place.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the appointment is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the appointment is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to Number of minutes that the appointment is to take. This can be less than the duration between the start and end times.  For example, where the actual time of appointment is only an estimate or if a 30 minute appointment is being requested, but any time would work.  Also, if there is, for example, a planned 15 minute break in the middle of a long appointment, the duration may be 15 minutes less than the difference between the start and end.
    property minutesDuration : String read GetMinutesDurationST write SetMinutesDurationST;
    // Number of minutes that the appointment is to take. This can be less than the duration between the start and end times.  For example, where the actual time of appointment is only an estimate or if a 30 minute appointment is being requested, but any time would work.  Also, if there is, for example, a planned 15 minute break in the middle of a long appointment, the duration may be 15 minutes less than the difference between the start and end.
    property minutesDurationElement : TFhirPositiveInt read FMinutesDuration write SetMinutesDuration;

    // The slots from the participants' schedules that will be filled by the appointment.
    property slotList : TFhirReferenceList read GetSlotList;
    property hasSlotList : boolean read GetHasSlotList;

    // Typed access to The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to While Appointment.comment contains information for internal use, Appointment.patientInstructions is used to capture patient facing information about the Appointment (e.g. please bring your referral or fast from 8pm night before).
    property patientInstruction : String read GetPatientInstructionST write SetPatientInstructionST;
    // While Appointment.comment contains information for internal use, Appointment.patientInstructions is used to capture patient facing information about the Appointment (e.g. please bring your referral or fast from 8pm night before).
    property patientInstructionElement : TFhirString read FPatientInstruction write SetPatientInstruction;

    // The service request this appointment is allocated to assess (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // List of participants involved in the appointment.
    property participantList : TFhirAppointmentParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // A set of date ranges (potentially including times) that the appointment is preferred to be scheduled within.  The duration (usually in minutes) could also be provided to indicate the length of the appointment to fill and populate the start/end times for the actual allocated time. However, in other situations the duration may be calculated by the scheduling system.
    property requestedPeriodList : TFhirPeriodList read GetRequestedPeriodList;
    property hasRequestedPeriodList : boolean read GetHasRequestedPeriodList;

  end;

  TFhirAppointmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentList;
    function GetCurrent : TFhirAppointment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointment read GetCurrent;
  end;

  TFhirAppointmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointment;
    procedure SetItemN(index : Integer; value : TFhirAppointment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentList; overload;
    function Clone : TFhirAppointmentList; overload;
    function GetEnumerator : TFhirAppointmentListEnumerator;
    
    //  Add a FhirAppointment to the end of the list.
    function Append : TFhirAppointment;
    
    // Add an already existing FhirAppointment to the end of the list.
    procedure AddItem(value : TFhirAppointment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointment) : Integer;
    
    // Insert FhirAppointment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointment;
    
    // Insert an existing FhirAppointment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointment);
    
    // Get the iIndexth FhirAppointment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointments[index : Integer] : TFhirAppointment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  // A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.
  TFhirAppointmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAppointment : TFhirReference;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FparticipantTypeList : TFhirCodeableConceptList;
    FActor : TFhirReference;
    FParticipantStatus : TFhirEnum;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetAppointment(value : TFhirReference);
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    function GetParticipantTypeList : TFhirCodeableConceptList;
    function GetHasParticipantTypeList : Boolean;
    procedure SetActor(value : TFhirReference);
    procedure SetParticipantStatus(value : TFhirEnum);
    function GetParticipantStatusST : TFhirParticipationStatusEnum;
    procedure SetParticipantStatusST(value : TFhirParticipationStatusEnum);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentResponse; overload;
    function Clone : TFhirAppointmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment response concern that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Appointment that this response is replying to. (defined for API consistency)
    property appointment : TFhirReference read FAppointment write SetAppointment;
    // Appointment that this response is replying to.
    property appointmentElement : TFhirReference read FAppointment write SetAppointment;

    // Typed access to Date/Time that the appointment is to take place, or requested new start time.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place, or requested new start time.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Role of participant in the appointment.
    property participantTypeList : TFhirCodeableConceptList read GetParticipantTypeList;
    property hasParticipantTypeList : boolean read GetHasParticipantTypeList;

    // Typed access to A Person, Location, HealthcareService, or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // A Person, Location, HealthcareService, or Device that is participating in the appointment.
    property actorElement : TFhirReference read FActor write SetActor;

    // Participation status of the participant. When the status is declined or tentative if the start/end times are different to the appointment, then these times should be interpreted as a requested time change. When the status is accepted, the times can either be the time of the appointment (as a confirmation of the time) or can be empty.
    property participantStatus : TFhirParticipationStatusEnum read GetParticipantStatusST write SetParticipantStatusST;
    property participantStatusElement : TFhirEnum read FParticipantStatus write SetParticipantStatus;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirAppointmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentResponseList;
    function GetCurrent : TFhirAppointmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentResponse read GetCurrent;
  end;

  TFhirAppointmentResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointmentResponse;
    procedure SetItemN(index : Integer; value : TFhirAppointmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentResponseList; overload;
    function Clone : TFhirAppointmentResponseList; overload;
    function GetEnumerator : TFhirAppointmentResponseListEnumerator;
    
    //  Add a FhirAppointmentResponse to the end of the list.
    function Append : TFhirAppointmentResponse;
    
    // Add an already existing FhirAppointmentResponse to the end of the list.
    procedure AddItem(value : TFhirAppointmentResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentResponse) : Integer;
    
    // Insert FhirAppointmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentResponse;
    
    // Insert an existing FhirAppointmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentResponse);
    
    // Get the iIndexth FhirAppointmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointmentResponses[index : Integer] : TFhirAppointmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  // Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.
  TFhirBasic = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FCreated : TFhirDate;
    FAuthor : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetCreated(value : TFhirDate);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBasic; overload;
    function Clone : TFhirBasic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier assigned to the resource for business purposes, outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the 'type' of resource - equivalent to the resource name for other resources. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the 'type' of resource - equivalent to the resource name for other resources.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Identifies when the resource was first created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Identifies when the resource was first created.
    property createdElement : TFhirDate read FCreated write SetCreated;

    // Typed access to Indicates who was responsible for creating the resource instance. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Indicates who was responsible for creating the resource instance.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirBasicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBasicList;
    function GetCurrent : TFhirBasic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBasicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBasic read GetCurrent;
  end;

  TFhirBasicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBasic;
    procedure SetItemN(index : Integer; value : TFhirBasic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBasicList; overload;
    function Clone : TFhirBasicList; overload;
    function GetEnumerator : TFhirBasicListEnumerator;
    
    //  Add a FhirBasic to the end of the list.
    function Append : TFhirBasic;
    
    // Add an already existing FhirBasic to the end of the list.
    procedure AddItem(value : TFhirBasic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBasic) : Integer;
    
    // Insert FhirBasic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBasic;
    
    // Insert an existing FhirBasic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBasic);
    
    // Get the iIndexth FhirBasic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBasic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBasic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBasics[index : Integer] : TFhirBasic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  // How this product was collected.
  TFhirBiologicallyDerivedProductCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference;
    FSource : TFhirReference;
    FCollected : TFhirDataType;
    procedure SetCollector(value : TFhirReference);
    procedure SetSource(value : TFhirReference);
    procedure SetCollected(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductCollection; overload;
    function Clone : TFhirBiologicallyDerivedProductCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Healthcare professional who is performing the collection. (defined for API consistency)
    property collector : TFhirReference read FCollector write SetCollector;
    // Healthcare professional who is performing the collection.
    property collectorElement : TFhirReference read FCollector write SetCollector;

    // Typed access to The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to Time of product collection. (defined for API consistency)
    property collected : TFhirDataType read FCollected write SetCollected;
    // Time of product collection.
    property collectedElement : TFhirDataType read FCollected write SetCollected;

  end;

  TFhirBiologicallyDerivedProductCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductCollectionList;
    function GetCurrent : TFhirBiologicallyDerivedProductCollection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductCollection read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductCollectionList; overload;
    function Clone : TFhirBiologicallyDerivedProductCollectionList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductCollection to the end of the list.
    function Append : TFhirBiologicallyDerivedProductCollection;
    
    // Add an already existing FhirBiologicallyDerivedProductCollection to the end of the list.
    procedure AddItem(value : TFhirBiologicallyDerivedProductCollection); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductCollection) : Integer;
    
    // Insert FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    
    // Insert an existing FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // Get the iIndexth FhirBiologicallyDerivedProductCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductCollections[index : Integer] : TFhirBiologicallyDerivedProductCollection read GetItemN write SetItemN; default;
  End;

  // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
  TFhirBiologicallyDerivedProductProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FAdditive : TFhirReference;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetProcedure_(value : TFhirCodeableConcept);
    procedure SetAdditive(value : TFhirReference);
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductProcessing; overload;
    function Clone : TFhirBiologicallyDerivedProductProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of of processing.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of of processing.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Procesing code. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // Procesing code.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Typed access to Substance added during processing. (defined for API consistency)
    property additive : TFhirReference read FAdditive write SetAdditive;
    // Substance added during processing.
    property additiveElement : TFhirReference read FAdditive write SetAdditive;

    // Typed access to Time of processing. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // Time of processing.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductProcessingList;
    function GetCurrent : TFhirBiologicallyDerivedProductProcessing;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductProcessing read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductProcessingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductProcessingList; overload;
    function Clone : TFhirBiologicallyDerivedProductProcessingList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductProcessing to the end of the list.
    function Append : TFhirBiologicallyDerivedProductProcessing;
    
    // Add an already existing FhirBiologicallyDerivedProductProcessing to the end of the list.
    procedure AddItem(value : TFhirBiologicallyDerivedProductProcessing); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductProcessing) : Integer;
    
    // Insert FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    
    // Insert an existing FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // Get the iIndexth FhirBiologicallyDerivedProductProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductProcessings[index : Integer] : TFhirBiologicallyDerivedProductProcessing read GetItemN write SetItemN; default;
  End;

  // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
  TFhirBiologicallyDerivedProductManipulation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductManipulation; overload;
    function Clone : TFhirBiologicallyDerivedProductManipulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of manipulation.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of manipulation.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Time of manipulation. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // Time of manipulation.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductManipulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductManipulationList;
    function GetCurrent : TFhirBiologicallyDerivedProductManipulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductManipulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductManipulation read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductManipulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductManipulationList; overload;
    function Clone : TFhirBiologicallyDerivedProductManipulationList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductManipulation to the end of the list.
    function Append : TFhirBiologicallyDerivedProductManipulation;
    
    // Add an already existing FhirBiologicallyDerivedProductManipulation to the end of the list.
    procedure AddItem(value : TFhirBiologicallyDerivedProductManipulation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductManipulation) : Integer;
    
    // Insert FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    
    // Insert an existing FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // Get the iIndexth FhirBiologicallyDerivedProductManipulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductManipulations[index : Integer] : TFhirBiologicallyDerivedProductManipulation read GetItemN write SetItemN; default;
  End;

  // Product storage.
  TFhirBiologicallyDerivedProductStorage = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTemperature : TFhirDecimal;
    FScale : TFhirEnum;
    FDuration : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTemperature(value : TFhirDecimal);
    function GetTemperatureST : String;
    procedure SetTemperatureST(value : String);
    procedure SetScale(value : TFhirEnum);
    function GetScaleST : TFhirBiologicallyDerivedProductStorageScaleEnum;
    procedure SetScaleST(value : TFhirBiologicallyDerivedProductStorageScaleEnum);
    procedure SetDuration(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductStorage; overload;
    function Clone : TFhirBiologicallyDerivedProductStorage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of storage.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of storage.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Storage temperature.
    property temperature : String read GetTemperatureST write SetTemperatureST;
    // Storage temperature.
    property temperatureElement : TFhirDecimal read FTemperature write SetTemperature;

    // Temperature scale used.
    property scale : TFhirBiologicallyDerivedProductStorageScaleEnum read GetScaleST write SetScaleST;
    property scaleElement : TFhirEnum read FScale write SetScale;

    // Typed access to Storage timeperiod. (defined for API consistency)
    property duration : TFhirPeriod read FDuration write SetDuration;
    // Storage timeperiod.
    property durationElement : TFhirPeriod read FDuration write SetDuration;

  end;

  TFhirBiologicallyDerivedProductStorageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductStorageList;
    function GetCurrent : TFhirBiologicallyDerivedProductStorage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductStorageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductStorage read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductStorageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductStorageList; overload;
    function Clone : TFhirBiologicallyDerivedProductStorageList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductStorage to the end of the list.
    function Append : TFhirBiologicallyDerivedProductStorage;
    
    // Add an already existing FhirBiologicallyDerivedProductStorage to the end of the list.
    procedure AddItem(value : TFhirBiologicallyDerivedProductStorage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductStorage) : Integer;
    
    // Insert FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    
    // Insert an existing FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // Get the iIndexth FhirBiologicallyDerivedProductStorage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductStorages[index : Integer] : TFhirBiologicallyDerivedProductStorage read GetItemN write SetItemN; default;
  End;

  // A material substance originating from a biological entity intended to be transplanted or infused into another (possibly the same) biological entity.
  TFhirBiologicallyDerivedProduct = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FProductCategory : TFhirEnum;
    FProductCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FrequestList : TFhirReferenceList;
    FQuantity : TFhirInteger;
    FparentList : TFhirReferenceList;
    FCollection : TFhirBiologicallyDerivedProductCollection;
    FprocessingList : TFhirBiologicallyDerivedProductProcessingList;
    FManipulation : TFhirBiologicallyDerivedProductManipulation;
    FstorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetProductCategory(value : TFhirEnum);
    function GetProductCategoryST : TFhirBiologicallyDerivedProductCategoryEnum;
    procedure SetProductCategoryST(value : TFhirBiologicallyDerivedProductCategoryEnum);
    procedure SetProductCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirBiologicallyDerivedProductStatusEnum;
    procedure SetStatusST(value : TFhirBiologicallyDerivedProductStatusEnum);
    function GetRequestList : TFhirReferenceList;
    function GetHasRequestList : Boolean;
    procedure SetQuantity(value : TFhirInteger);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    function GetParentList : TFhirReferenceList;
    function GetHasParentList : Boolean;
    procedure SetCollection(value : TFhirBiologicallyDerivedProductCollection);
    function GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
    function GetHasProcessingList : Boolean;
    procedure SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
    function GetStorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetHasStorageList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProduct; overload;
    function Clone : TFhirBiologicallyDerivedProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this biologically derived product instance that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Broad category of this product.
    property productCategory : TFhirBiologicallyDerivedProductCategoryEnum read GetProductCategoryST write SetProductCategoryST;
    property productCategoryElement : TFhirEnum read FProductCategory write SetProductCategory;

    // Typed access to A code that identifies the kind of this biologically derived product (SNOMED Ctcode). (defined for API consistency)
    property productCode : TFhirCodeableConcept read FProductCode write SetProductCode;
    // A code that identifies the kind of this biologically derived product (SNOMED Ctcode).
    property productCodeElement : TFhirCodeableConcept read FProductCode write SetProductCode;

    // Whether the product is currently available.
    property status : TFhirBiologicallyDerivedProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Procedure request to obtain this biologically derived product.
    property requestList : TFhirReferenceList read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Number of discrete units within this product.
    property quantity : String read GetQuantityST write SetQuantityST;
    // Number of discrete units within this product.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Parent product (if any).
    property parentList : TFhirReferenceList read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to How this product was collected. (defined for API consistency)
    property collection : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;
    // How this product was collected.
    property collectionElement : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;

    // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
    property processingList : TFhirBiologicallyDerivedProductProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // Typed access to Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion. (defined for API consistency)
    property manipulation : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;
    // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
    property manipulationElement : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;

    // Product storage.
    property storageList : TFhirBiologicallyDerivedProductStorageList read GetStorageList;
    property hasStorageList : boolean read GetHasStorageList;

  end;

  TFhirBiologicallyDerivedProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductList;
    function GetCurrent : TFhirBiologicallyDerivedProduct;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProduct read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProduct;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductList; overload;
    function Clone : TFhirBiologicallyDerivedProductList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProduct to the end of the list.
    function Append : TFhirBiologicallyDerivedProduct;
    
    // Add an already existing FhirBiologicallyDerivedProduct to the end of the list.
    procedure AddItem(value : TFhirBiologicallyDerivedProduct); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProduct) : Integer;
    
    // Insert FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProduct;
    
    // Insert an existing FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // Get the iIndexth FhirBiologicallyDerivedProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProduct;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProducts[index : Integer] : TFhirBiologicallyDerivedProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  // Record details about an anatomical structure.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.
  TFhirBodyStructure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FMorphology : TFhirCodeableConcept;
    FLocation : TFhirCodeableConcept;
    FlocationQualifierList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FimageList : TFhirAttachmentList;
    FPatient : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetMorphology(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirCodeableConcept);
    function GetLocationQualifierList : TFhirCodeableConceptList;
    function GetHasLocationQualifierList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;
    procedure SetPatient(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBodyStructure; overload;
    function Clone : TFhirBodyStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for this instance of the anatomical structure.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this body site is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this body site is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The kind of structure being represented by the body structure at `BodyStructure.location`.  This can define both normal and abnormal morphologies. (defined for API consistency)
    property morphology : TFhirCodeableConcept read FMorphology write SetMorphology;
    // The kind of structure being represented by the body structure at `BodyStructure.location`.  This can define both normal and abnormal morphologies.
    property morphologyElement : TFhirCodeableConcept read FMorphology write SetMorphology;

    // Typed access to The anatomical location or region of the specimen, lesion, or body structure. (defined for API consistency)
    property location : TFhirCodeableConcept read FLocation write SetLocation;
    // The anatomical location or region of the specimen, lesion, or body structure.
    property locationElement : TFhirCodeableConcept read FLocation write SetLocation;

    // Qualifier to refine the anatomical location.  These include qualifiers for laterality, relative location, directionality, number, and plane.
    property locationQualifierList : TFhirCodeableConceptList read GetLocationQualifierList;
    property hasLocationQualifierList : boolean read GetHasLocationQualifierList;

    // Typed access to A summary, characterization or explanation of the body structure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary, characterization or explanation of the body structure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Image or images used to identify a location.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to The person to which the body site belongs. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person to which the body site belongs.
    property patientElement : TFhirReference read FPatient write SetPatient;

  end;

  TFhirBodyStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBodyStructureList;
    function GetCurrent : TFhirBodyStructure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBodyStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBodyStructure read GetCurrent;
  end;

  TFhirBodyStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBodyStructure;
    procedure SetItemN(index : Integer; value : TFhirBodyStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBodyStructureList; overload;
    function Clone : TFhirBodyStructureList; overload;
    function GetEnumerator : TFhirBodyStructureListEnumerator;
    
    //  Add a FhirBodyStructure to the end of the list.
    function Append : TFhirBodyStructure;
    
    // Add an already existing FhirBodyStructure to the end of the list.
    procedure AddItem(value : TFhirBodyStructure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBodyStructure) : Integer;
    
    // Insert FhirBodyStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBodyStructure;
    
    // Insert an existing FhirBodyStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBodyStructure);
    
    // Get the iIndexth FhirBodyStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBodyStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBodyStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBodyStructures[index : Integer] : TFhirBodyStructure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
  // Identifies an action that has occurred or is a planned action to occur as part of the plan. For example, a medication to be used, lab tests to perform, self-monitoring that has occurred, education etc.
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  protected
    FoutcomeList : TFhirCodeableReferenceList;
    FprogressList : TFhirAnnotationList;
    FReference : TFhirReference;
    FDetail : TFhirCarePlanActivityDetail;
    function GetOutcomeList : TFhirCodeableReferenceList;
    function GetHasOutcomeList : Boolean;
    function GetProgressList : TFhirAnnotationList;
    function GetHasProgressList : Boolean;
    procedure SetReference(value : TFhirReference);
    procedure SetDetail(value : TFhirCarePlanActivityDetail);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies the outcome at the point when the status of the activity is assessed.  For example, the outcome of an education activity could be patient understands (or not).  The reference to an "event" resource, such as Procedure or Encounter or Observation, is the result/outcome of the activity itself.  The activity can be conveyed using CarePlan.activity.detail OR using the CarePlan.activity.reference (a reference to a “request” resource).
    property outcomeList : TFhirCodeableReferenceList read GetOutcomeList;
    property hasOutcomeList : boolean read GetHasOutcomeList;

    // Notes about the adherence/status/progress of the activity.
    property progressList : TFhirAnnotationList read GetProgressList;
    property hasProgressList : boolean read GetHasProgressList;

    // Typed access to The details of the proposed activity represented in a specific resource. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // The details of the proposed activity represented in a specific resource.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Typed access to A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc. (defined for API consistency)
    property detail : TFhirCarePlanActivityDetail read FDetail write SetDetail;
    // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    property detailElement : TFhirCarePlanActivityDetail read FDetail write SetDetail;

  end;

  TFhirCarePlanActivityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityList;
    function GetCurrent : TFhirCarePlanActivity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivity read GetCurrent;
  end;

  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanActivityList; overload;
    function Clone : TFhirCarePlanActivityList; overload;
    function GetEnumerator : TFhirCarePlanActivityListEnumerator;
    
    //  Add a FhirCarePlanActivity to the end of the list.
    function Append : TFhirCarePlanActivity;
    
    // Add an already existing FhirCarePlanActivity to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivity); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivity) : Integer;
    
    // Insert FhirCarePlanActivity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivity;
    
    // Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);
    
    // Get the iIndexth FhirCarePlanActivity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;

  // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  TFhirCarePlanActivityDetail = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FCode : TFhirCodeableConcept;
    FreasonList : TFhirCodeableReferenceList;
    FgoalList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FDoNotPerform : TFhirBoolean;
    FScheduled : TFhirDataType;
    FLocation : TFhirCodeableReference;
    FReported : TFhirDataType;
    FperformerList : TFhirReferenceList;
    FProduct : TFhirDataType;
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDescription : TFhirString;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirCarePlanActivityKindEnum;
    procedure SetKindST(value : TFhirCarePlanActivityKindEnum);
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCarePlanActivityStatusEnum;
    procedure SetStatusST(value : TFhirCarePlanActivityStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetScheduled(value : TFhirDataType);
    procedure SetLocation(value : TFhirCodeableReference);
    procedure SetReported(value : TFhirDataType);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    procedure SetDailyAmount(value : TFhirQuantity);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivityDetail; overload;
    function Clone : TFhirCarePlanActivityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A description of the kind of resource the in-line definition of a care plan activity is representing.  The CarePlan.activity.detail is an in-line definition when a resource is not referenced using CarePlan.activity.reference.  For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest.
    property kind : TFhirCarePlanActivityKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan activity.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan activity.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Typed access to Detailed description of the type of planned activity; e.g. what lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of planned activity; e.g. what lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Provides the rationale that drove the inclusion of this particular activity as part of the plan or the reason why the activity was prohibited - either a coded concept, or another resource, such as the health condition(s), whose existence justifies this request and drove the inclusion of this particular activity as part of the plan.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies what progress is being made for the specific activity.
    property status : TFhirCarePlanActivityStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Provides reason why the activity isn't yet started, is on hold, was cancelled, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Provides reason why the activity isn't yet started, is on hold, was cancelled, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, or missing, indicates that the described activity is one that should be engaged in when following the plan.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, or missing, indicates that the described activity is one that should be engaged in when following the plan.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property scheduled : TFhirDataType read FScheduled write SetScheduled;
    // The period, timing or frequency upon which the described activity is to occur.
    property scheduledElement : TFhirDataType read FScheduled write SetScheduled;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirCodeableReference read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirCodeableReference read FLocation write SetLocation;

    // Typed access to Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report. (defined for API consistency)
    property reported : TFhirDataType read FReported write SetReported;
    // Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report.
    property reportedElement : TFhirDataType read FReported write SetReported;

    // Identifies who's expected to be involved in the activity.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Identifies the food, drug or other product to be consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the food, drug or other product to be consumed or supplied in the activity.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed in a given day. (defined for API consistency)
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;
    // Identifies the quantity expected to be consumed in a given day.
    property dailyAmountElement : TFhirQuantity read FDailyAmount write SetDailyAmount;

    // Typed access to Identifies the quantity expected to be supplied, administered or consumed by the subject. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be supplied, administered or consumed by the subject.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirCarePlanActivityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityDetailList;
    function GetCurrent : TFhirCarePlanActivityDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivityDetail read GetCurrent;
  end;

  TFhirCarePlanActivityDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivityDetail;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanActivityDetailList; overload;
    function Clone : TFhirCarePlanActivityDetailList; overload;
    function GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
    
    //  Add a FhirCarePlanActivityDetail to the end of the list.
    function Append : TFhirCarePlanActivityDetail;
    
    // Add an already existing FhirCarePlanActivityDetail to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivityDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivityDetail) : Integer;
    
    // Insert FhirCarePlanActivityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivityDetail;
    
    // Insert an existing FhirCarePlanActivityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivityDetail);
    
    // Get the iIndexth FhirCarePlanActivityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivityDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivityDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlanActivityDetails[index : Integer] : TFhirCarePlanActivityDetail read GetItemN write SetItemN; default;
  End;

  // Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
  TFhirCarePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FAuthor : TFhirReference;
    FcontributorList : TFhirReferenceList;
    FcareTeamList : TFhirReferenceList;
    FaddressesList : TFhirCodeableReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FgoalList : TFhirReferenceList;
    FactivityList : TFhirCarePlanActivityList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirCarePlanIntentEnum;
    procedure SetIntentST(value : TFhirCarePlanIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    function GetContributorList : TFhirReferenceList;
    function GetHasContributorList : Boolean;
    function GetCareTeamList : TFhirReferenceList;
    function GetHasCareTeamList : Boolean;
    function GetAddressesList : TFhirCodeableReferenceList;
    function GetHasAddressesList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetActivityList : TFhirCarePlanActivityList;
    function GetHasActivityList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlan; overload;
    function Clone : TFhirCarePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this care plan by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A care plan that is fulfilled in whole or in part by this care plan.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated care plan whose function is taken by this new care plan.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // A larger care plan of which this particular care plan is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the care plan and where the care plan fits into the workflow chain.
    property intent : TFhirCarePlanIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Identifies what "kind" of plan this is to support differentiation between multiple co-existing plans; e.g. "Home health", "psychiatric", "asthma", "disease management", "wellness plan", etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Human-friendly name for the care plan.
    property title : String read GetTitleST write SetTitleST;
    // Human-friendly name for the care plan.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A description of the scope and nature of the plan.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the scope and nature of the plan.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Identifies the patient or group whose intended care is described by the plan. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is described by the plan.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the plan did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the plan did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Represents when this particular CarePlan record was created in the system, which is often a system-generated date.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Represents when this particular CarePlan record was created in the system, which is often a system-generated date.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to When populated, the author is responsible for the care plan.  The care plan is attributed to the author. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // When populated, the author is responsible for the care plan.  The care plan is attributed to the author.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Identifies the individual(s) or organization who provided the contents of the care plan.
    property contributorList : TFhirReferenceList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
    property careTeamList : TFhirReferenceList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan.
    property addressesList : TFhirCodeableReferenceList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Identifies portions of the patient's record that specifically influenced the formation of the plan.  These might include comorbidities, recent procedures, limitations, recent assessments, etc.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Describes the intended objective(s) of carrying out the care plan.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies an action that has occurred or is a planned action to occur as part of the plan. For example, a medication to be used, lab tests to perform, self-monitoring that has occurred, education etc.
    property activityList : TFhirCarePlanActivityList read GetActivityList;
    property hasActivityList : boolean read GetHasActivityList;

    // General notes about the care plan not covered elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCarePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanList;
    function GetCurrent : TFhirCarePlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlan read GetCurrent;
  end;

  TFhirCarePlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlan;
    procedure SetItemN(index : Integer; value : TFhirCarePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanList; overload;
    function Clone : TFhirCarePlanList; overload;
    function GetEnumerator : TFhirCarePlanListEnumerator;
    
    //  Add a FhirCarePlan to the end of the list.
    function Append : TFhirCarePlan;
    
    // Add an already existing FhirCarePlan to the end of the list.
    procedure AddItem(value : TFhirCarePlan); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlan) : Integer;
    
    // Insert FhirCarePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlan;
    
    // Insert an existing FhirCarePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlan);
    
    // Get the iIndexth FhirCarePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlans[index : Integer] : TFhirCarePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  // Identifies all people and organizations who are expected to be involved in the care team.
  TFhirCareTeamParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FMember : TFhirReference;
    FOnBehalfOf : TFhirReference;
    FCoverage : TFhirDataType;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetMember(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
    procedure SetCoverage(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeamParticipant; overload;
    function Clone : TFhirCareTeamParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates specific responsibility of an individual within the care team, such as "Primary care physician", "Trained social worker counselor", "Caregiver", etc. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Indicates specific responsibility of an individual within the care team, such as "Primary care physician", "Trained social worker counselor", "Caregiver", etc.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The specific person or organization who is participating/expected to participate in the care team. (defined for API consistency)
    property member : TFhirReference read FMember write SetMember;
    // The specific person or organization who is participating/expected to participate in the care team.
    property memberElement : TFhirReference read FMember write SetMember;

    // Typed access to The organization of the practitioner. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The organization of the practitioner.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to When the member is generally available within this care team. (defined for API consistency)
    property coverage : TFhirDataType read FCoverage write SetCoverage;
    // When the member is generally available within this care team.
    property coverageElement : TFhirDataType read FCoverage write SetCoverage;

  end;

  TFhirCareTeamParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamParticipantList;
    function GetCurrent : TFhirCareTeamParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeamParticipant read GetCurrent;
  end;

  TFhirCareTeamParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCareTeamParticipant;
    procedure SetItemN(index : Integer; value : TFhirCareTeamParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCareTeamParticipantList; overload;
    function Clone : TFhirCareTeamParticipantList; overload;
    function GetEnumerator : TFhirCareTeamParticipantListEnumerator;
    
    //  Add a FhirCareTeamParticipant to the end of the list.
    function Append : TFhirCareTeamParticipant;
    
    // Add an already existing FhirCareTeamParticipant to the end of the list.
    procedure AddItem(value : TFhirCareTeamParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeamParticipant) : Integer;
    
    // Insert FhirCareTeamParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeamParticipant;
    
    // Insert an existing FhirCareTeamParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeamParticipant);
    
    // Get the iIndexth FhirCareTeamParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeamParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeamParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCareTeamParticipants[index : Integer] : TFhirCareTeamParticipant read GetItemN write SetItemN; default;
  End;

  // The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care.
  TFhirCareTeam = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FName : TFhirString;
    FSubject : TFhirReference;
    FPeriod : TFhirPeriod;
    FparticipantList : TFhirCareTeamParticipantList;
    FreasonList : TFhirCodeableReferenceList;
    FmanagingOrganizationList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCareTeamStatusEnum;
    procedure SetStatusST(value : TFhirCareTeamStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    function GetParticipantList : TFhirCareTeamParticipantList;
    function GetHasParticipantList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetManagingOrganizationList : TFhirReferenceList;
    function GetHasManagingOrganizationList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeam; overload;
    function Clone : TFhirCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this care team by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of the care team.
    property status : TFhirCareTeamStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Identifies what kind of team.  This is to support differentiation between multiple co-existing teams, such as care plan team, episode of care team, longitudinal care team.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property name : String read GetNameST write SetNameST;
    // A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the patient or group whose intended care is handled by the team. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is handled by the team.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Indicates when the team did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the team did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Identifies all people and organizations who are expected to be involved in the care team.
    property participantList : TFhirCareTeamParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Describes why the care team exists.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The organization responsible for the care team.
    property managingOrganizationList : TFhirReferenceList read GetManagingOrganizationList;
    property hasManagingOrganizationList : boolean read GetHasManagingOrganizationList;

    // A central contact detail for the care team (that applies to all members).
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Comments made about the CareTeam.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamList;
    function GetCurrent : TFhirCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeam read GetCurrent;
  end;

  TFhirCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCareTeam;
    procedure SetItemN(index : Integer; value : TFhirCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCareTeamList; overload;
    function Clone : TFhirCareTeamList; overload;
    function GetEnumerator : TFhirCareTeamListEnumerator;
    
    //  Add a FhirCareTeam to the end of the list.
    function Append : TFhirCareTeam;
    
    // Add an already existing FhirCareTeam to the end of the list.
    procedure AddItem(value : TFhirCareTeam); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeam) : Integer;
    
    // Insert FhirCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeam;
    
    // Insert an existing FhirCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeam);
    
    // Get the iIndexth FhirCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCareTeams[index : Integer] : TFhirCareTeam read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
  // Specific findings or diagnoses that were considered likely or relevant to ongoing treatment.
  TFhirClinicalImpressionFinding = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FBasis : TFhirString;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetBasis(value : TFhirString);
    function GetBasisST : String;
    procedure SetBasisST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionFinding; overload;
    function Clone : TFhirClinicalImpressionFinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific text, code or reference for finding or diagnosis, which may include ruled-out or resolved conditions. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // Specific text, code or reference for finding or diagnosis, which may include ruled-out or resolved conditions.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to Which investigations support finding or diagnosis.
    property basis : String read GetBasisST write SetBasisST;
    // Which investigations support finding or diagnosis.
    property basisElement : TFhirString read FBasis write SetBasis;

  end;

  TFhirClinicalImpressionFindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionFindingList;
    function GetCurrent : TFhirClinicalImpressionFinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionFindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionFinding read GetCurrent;
  end;

  TFhirClinicalImpressionFindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalImpressionFinding;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionFinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalImpressionFindingList; overload;
    function Clone : TFhirClinicalImpressionFindingList; overload;
    function GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
    
    //  Add a FhirClinicalImpressionFinding to the end of the list.
    function Append : TFhirClinicalImpressionFinding;
    
    // Add an already existing FhirClinicalImpressionFinding to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionFinding); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionFinding) : Integer;
    
    // Insert FhirClinicalImpressionFinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionFinding;
    
    // Insert an existing FhirClinicalImpressionFinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionFinding);
    
    // Get the iIndexth FhirClinicalImpressionFinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionFinding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionFinding;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalImpressionFindings[index : Integer] : TFhirClinicalImpressionFinding read GetItemN write SetItemN; default;
  End;

  // A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
  TFhirClinicalImpression = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FDescription : TFhirString;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FDate : TFhirDateTime;
    FPerformer : TFhirReference;
    FPrevious : TFhirReference;
    FproblemList : TFhirReferenceList;
    FprotocolList : TFhirUriList;
    FSummary : TFhirString;
    FfindingList : TFhirClinicalImpressionFindingList;
    FprognosisCodeableConceptList : TFhirCodeableConceptList;
    FprognosisReferenceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPerformer(value : TFhirReference);
    procedure SetPrevious(value : TFhirReference);
    function GetProblemList : TFhirReferenceList;
    function GetHasProblemList : Boolean;
    function GetProtocolList : TFhirUriList;
    function GetHasProtocolList : Boolean;
    procedure SetSummary(value : TFhirString);
    function GetSummaryST : String;
    procedure SetSummaryST(value : String);
    function GetFindingList : TFhirClinicalImpressionFindingList;
    function GetHasFindingList : Boolean;
    function GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
    function GetHasPrognosisCodeableConceptList : Boolean;
    function GetPrognosisReferenceList : TFhirReferenceList;
    function GetHasPrognosisReferenceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpression; overload;
    function Clone : TFhirClinicalImpression; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this clinical impression by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Identifies the workflow status of the assessment.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the ClinicalImpression. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the ClinicalImpression.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to A summary of the context and/or cause of the assessment - why / where it was performed, and what patient events/status prompted it.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary of the context and/or cause of the assessment - why / where it was performed, and what patient events/status prompted it.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The patient or group of individuals assessed as part of this record. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group of individuals assessed as part of this record.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this ClinicalImpression was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this ClinicalImpression was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The point in time or period over which the subject was assessed. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The point in time or period over which the subject was assessed.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to Indicates when the documentation of the assessment was complete.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the documentation of the assessment was complete.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The clinician performing the assessment. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The clinician performing the assessment.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Typed access to A reference to the last assessment that was conducted on this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes. (defined for API consistency)
    property previous : TFhirReference read FPrevious write SetPrevious;
    // A reference to the last assessment that was conducted on this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes.
    property previousElement : TFhirReference read FPrevious write SetPrevious;

    // A list of the relevant problems/conditions for a patient.
    property problemList : TFhirReferenceList read GetProblemList;
    property hasProblemList : boolean read GetHasProblemList;

    // Reference to a specific {$IFNDEF FPC}published{$ENDIF} clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    property protocolList : TFhirUriList read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // Typed access to A text summary of the investigations and the diagnosis.
    property summary : String read GetSummaryST write SetSummaryST;
    // A text summary of the investigations and the diagnosis.
    property summaryElement : TFhirString read FSummary write SetSummary;

    // Specific findings or diagnoses that were considered likely or relevant to ongoing treatment.
    property findingList : TFhirClinicalImpressionFindingList read GetFindingList;
    property hasFindingList : boolean read GetHasFindingList;

    // Estimate of likely outcome.
    property prognosisCodeableConceptList : TFhirCodeableConceptList read GetPrognosisCodeableConceptList;
    property hasPrognosisCodeableConceptList : boolean read GetHasPrognosisCodeableConceptList;

    // RiskAssessment expressing likely outcome.
    property prognosisReferenceList : TFhirReferenceList read GetPrognosisReferenceList;
    property hasPrognosisReferenceList : boolean read GetHasPrognosisReferenceList;

    // Information supporting the clinical impression, which can contain investigation results.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Commentary about the impression, typically recorded after the impression itself was made, though supplemental notes by the original author could also appear.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirClinicalImpressionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionList;
    function GetCurrent : TFhirClinicalImpression;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpression read GetCurrent;
  end;

  TFhirClinicalImpressionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalImpression;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpression);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalImpressionList; overload;
    function Clone : TFhirClinicalImpressionList; overload;
    function GetEnumerator : TFhirClinicalImpressionListEnumerator;
    
    //  Add a FhirClinicalImpression to the end of the list.
    function Append : TFhirClinicalImpression;
    
    // Add an already existing FhirClinicalImpression to the end of the list.
    procedure AddItem(value : TFhirClinicalImpression); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpression) : Integer;
    
    // Insert FhirClinicalImpression before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpression;
    
    // Insert an existing FhirClinicalImpression before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpression);
    
    // Get the iIndexth FhirClinicalImpression. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpression);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpression;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalImpressions[index : Integer] : TFhirClinicalImpression read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEISSUE}
  // Specifics for when this is a contraindication.
  TFhirClinicalUseIssueContraindication = class (TFhirBackboneElement)
  protected
    FDiseaseSymptomProcedure : TFhirCodeableConcept;
    FDiseaseStatus : TFhirCodeableConcept;
    FcomorbidityList : TFhirCodeableConceptList;
    FindicationList : TFhirReferenceList;
    FotherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
    procedure SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
    procedure SetDiseaseStatus(value : TFhirCodeableConcept);
    function GetComorbidityList : TFhirCodeableConceptList;
    function GetHasComorbidityList : Boolean;
    function GetIndicationList : TFhirReferenceList;
    function GetHasIndicationList : Boolean;
    function GetOtherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueContraindication; overload;
    function Clone : TFhirClinicalUseIssueContraindication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation that is being documented as contraindicating against this item. (defined for API consistency)
    property diseaseSymptomProcedure : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;
    // The situation that is being documented as contraindicating against this item.
    property diseaseSymptomProcedureElement : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;

    // Typed access to The status of the disease or symptom for the contraindication. (defined for API consistency)
    property diseaseStatus : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for the contraindication.
    property diseaseStatusElement : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;

    // A comorbidity (concurrent condition) or coinfection.
    property comorbidityList : TFhirCodeableConceptList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // The indication which this is a contraidication for.
    property indicationList : TFhirReferenceList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
    property otherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

  end;

  TFhirClinicalUseIssueContraindicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueContraindicationList;
    function GetCurrent : TFhirClinicalUseIssueContraindication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueContraindicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueContraindication read GetCurrent;
  end;

  TFhirClinicalUseIssueContraindicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueContraindication;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueContraindication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueContraindicationList; overload;
    function Clone : TFhirClinicalUseIssueContraindicationList; overload;
    function GetEnumerator : TFhirClinicalUseIssueContraindicationListEnumerator;
    
    //  Add a FhirClinicalUseIssueContraindication to the end of the list.
    function Append : TFhirClinicalUseIssueContraindication;
    
    // Add an already existing FhirClinicalUseIssueContraindication to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueContraindication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueContraindication) : Integer;
    
    // Insert FhirClinicalUseIssueContraindication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueContraindication;
    
    // Insert an existing FhirClinicalUseIssueContraindication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueContraindication);
    
    // Get the iIndexth FhirClinicalUseIssueContraindication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueContraindication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueContraindication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueContraindications[index : Integer] : TFhirClinicalUseIssueContraindication read GetItemN write SetItemN; default;
  End;

  // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  TFhirClinicalUseIssueContraindicationOtherTherapy = class (TFhirBackboneElement)
  protected
    FTherapyRelationshipType : TFhirCodeableConcept;
    FMedication : TFhirDataType;
    procedure SetTherapyRelationshipType(value : TFhirCodeableConcept);
    procedure SetMedication(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueContraindicationOtherTherapy; overload;
    function Clone : TFhirClinicalUseIssueContraindicationOtherTherapy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of relationship between the medicinal product indication or contraindication and another therapy. (defined for API consistency)
    property therapyRelationshipType : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;
    // The type of relationship between the medicinal product indication or contraindication and another therapy.
    property therapyRelationshipTypeElement : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;

    // Typed access to Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication. (defined for API consistency)
    property medication : TFhirDataType read FMedication write SetMedication;
    // Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
    property medicationElement : TFhirDataType read FMedication write SetMedication;

  end;

  TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
    function GetCurrent : TFhirClinicalUseIssueContraindicationOtherTherapy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueContraindicationOtherTherapyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueContraindicationOtherTherapy read GetCurrent;
  end;

  TFhirClinicalUseIssueContraindicationOtherTherapyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueContraindicationOtherTherapy;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueContraindicationOtherTherapy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueContraindicationOtherTherapyList; overload;
    function Clone : TFhirClinicalUseIssueContraindicationOtherTherapyList; overload;
    function GetEnumerator : TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator;
    
    //  Add a FhirClinicalUseIssueContraindicationOtherTherapy to the end of the list.
    function Append : TFhirClinicalUseIssueContraindicationOtherTherapy;
    
    // Add an already existing FhirClinicalUseIssueContraindicationOtherTherapy to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueContraindicationOtherTherapy); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueContraindicationOtherTherapy) : Integer;
    
    // Insert FhirClinicalUseIssueContraindicationOtherTherapy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueContraindicationOtherTherapy;
    
    // Insert an existing FhirClinicalUseIssueContraindicationOtherTherapy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueContraindicationOtherTherapy);
    
    // Get the iIndexth FhirClinicalUseIssueContraindicationOtherTherapy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueContraindicationOtherTherapy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueContraindicationOtherTherapy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueContraindicationOtherTherapies[index : Integer] : TFhirClinicalUseIssueContraindicationOtherTherapy read GetItemN write SetItemN; default;
  End;

  // Specifics for when this is an indication.
  TFhirClinicalUseIssueIndication = class (TFhirBackboneElement)
  protected
    FDiseaseSymptomProcedure : TFhirCodeableConcept;
    FDiseaseStatus : TFhirCodeableConcept;
    FcomorbidityList : TFhirCodeableConceptList;
    FIntendedEffect : TFhirCodeableConcept;
    FDuration : TFhirQuantity;
    FundesirableEffectList : TFhirReferenceList;
    FotherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
    procedure SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
    procedure SetDiseaseStatus(value : TFhirCodeableConcept);
    function GetComorbidityList : TFhirCodeableConceptList;
    function GetHasComorbidityList : Boolean;
    procedure SetIntendedEffect(value : TFhirCodeableConcept);
    procedure SetDuration(value : TFhirQuantity);
    function GetUndesirableEffectList : TFhirReferenceList;
    function GetHasUndesirableEffectList : Boolean;
    function GetOtherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueIndication; overload;
    function Clone : TFhirClinicalUseIssueIndication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation that is being documented as an indicaton for this item. (defined for API consistency)
    property diseaseSymptomProcedure : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;
    // The situation that is being documented as an indicaton for this item.
    property diseaseSymptomProcedureElement : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;

    // Typed access to The status of the disease or symptom for the indication. (defined for API consistency)
    property diseaseStatus : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for the indication.
    property diseaseStatusElement : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;

    // A comorbidity (concurrent condition) or coinfection as part of the indication.
    property comorbidityList : TFhirCodeableConceptList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // Typed access to For an indication - the intended effect, aim or strategy to be achieved. (defined for API consistency)
    property intendedEffect : TFhirCodeableConcept read FIntendedEffect write SetIntendedEffect;
    // For an indication - the intended effect, aim or strategy to be achieved.
    property intendedEffectElement : TFhirCodeableConcept read FIntendedEffect write SetIntendedEffect;

    // Typed access to For an indication - timing or duration information. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // For an indication - timing or duration information.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // For an indicaton - the specific undesirable effects of the medicinal product.
    property undesirableEffectList : TFhirReferenceList read GetUndesirableEffectList;
    property hasUndesirableEffectList : boolean read GetHasUndesirableEffectList;

    // Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
    property otherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

  end;

  TFhirClinicalUseIssueIndicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueIndicationList;
    function GetCurrent : TFhirClinicalUseIssueIndication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueIndicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueIndication read GetCurrent;
  end;

  TFhirClinicalUseIssueIndicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueIndication;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueIndication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueIndicationList; overload;
    function Clone : TFhirClinicalUseIssueIndicationList; overload;
    function GetEnumerator : TFhirClinicalUseIssueIndicationListEnumerator;
    
    //  Add a FhirClinicalUseIssueIndication to the end of the list.
    function Append : TFhirClinicalUseIssueIndication;
    
    // Add an already existing FhirClinicalUseIssueIndication to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueIndication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueIndication) : Integer;
    
    // Insert FhirClinicalUseIssueIndication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueIndication;
    
    // Insert an existing FhirClinicalUseIssueIndication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueIndication);
    
    // Get the iIndexth FhirClinicalUseIssueIndication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueIndication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueIndication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueIndications[index : Integer] : TFhirClinicalUseIssueIndication read GetItemN write SetItemN; default;
  End;

  // Specifics for when this is an interaction.
  TFhirClinicalUseIssueInteraction = class (TFhirBackboneElement)
  protected
    FinteractantList : TFhirClinicalUseIssueInteractionInteractantList;
    FType_ : TFhirCodeableConcept;
    FEffect : TFhirCodeableConcept;
    FIncidence : TFhirCodeableConcept;
    FManagement : TFhirCodeableConcept;
    function GetInteractantList : TFhirClinicalUseIssueInteractionInteractantList;
    function GetHasInteractantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetEffect(value : TFhirCodeableConcept);
    procedure SetIncidence(value : TFhirCodeableConcept);
    procedure SetManagement(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueInteraction; overload;
    function Clone : TFhirClinicalUseIssueInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The specific medication, food or laboratory test that interacts.
    property interactantList : TFhirClinicalUseIssueInteractionInteractantList read GetInteractantList;
    property hasInteractantList : boolean read GetHasInteractantList;

    // Typed access to The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The effect of the interaction, for example "reduced gastric absorption of primary medication". (defined for API consistency)
    property effect : TFhirCodeableConcept read FEffect write SetEffect;
    // The effect of the interaction, for example "reduced gastric absorption of primary medication".
    property effectElement : TFhirCodeableConcept read FEffect write SetEffect;

    // Typed access to The incidence of the interaction, e.g. theoretical, observed. (defined for API consistency)
    property incidence : TFhirCodeableConcept read FIncidence write SetIncidence;
    // The incidence of the interaction, e.g. theoretical, observed.
    property incidenceElement : TFhirCodeableConcept read FIncidence write SetIncidence;

    // Typed access to Actions for managing the interaction. (defined for API consistency)
    property management : TFhirCodeableConcept read FManagement write SetManagement;
    // Actions for managing the interaction.
    property managementElement : TFhirCodeableConcept read FManagement write SetManagement;

  end;

  TFhirClinicalUseIssueInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueInteractionList;
    function GetCurrent : TFhirClinicalUseIssueInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueInteraction read GetCurrent;
  end;

  TFhirClinicalUseIssueInteractionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueInteraction;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueInteractionList; overload;
    function Clone : TFhirClinicalUseIssueInteractionList; overload;
    function GetEnumerator : TFhirClinicalUseIssueInteractionListEnumerator;
    
    //  Add a FhirClinicalUseIssueInteraction to the end of the list.
    function Append : TFhirClinicalUseIssueInteraction;
    
    // Add an already existing FhirClinicalUseIssueInteraction to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueInteraction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueInteraction) : Integer;
    
    // Insert FhirClinicalUseIssueInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueInteraction;
    
    // Insert an existing FhirClinicalUseIssueInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueInteraction);
    
    // Get the iIndexth FhirClinicalUseIssueInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueInteraction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueInteractions[index : Integer] : TFhirClinicalUseIssueInteraction read GetItemN write SetItemN; default;
  End;

  // The specific medication, food or laboratory test that interacts.
  TFhirClinicalUseIssueInteractionInteractant = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueInteractionInteractant; overload;
    function Clone : TFhirClinicalUseIssueInteractionInteractant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific medication, food or laboratory test that interacts. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The specific medication, food or laboratory test that interacts.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirClinicalUseIssueInteractionInteractantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueInteractionInteractantList;
    function GetCurrent : TFhirClinicalUseIssueInteractionInteractant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueInteractionInteractantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueInteractionInteractant read GetCurrent;
  end;

  TFhirClinicalUseIssueInteractionInteractantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueInteractionInteractant;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueInteractionInteractant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueInteractionInteractantList; overload;
    function Clone : TFhirClinicalUseIssueInteractionInteractantList; overload;
    function GetEnumerator : TFhirClinicalUseIssueInteractionInteractantListEnumerator;
    
    //  Add a FhirClinicalUseIssueInteractionInteractant to the end of the list.
    function Append : TFhirClinicalUseIssueInteractionInteractant;
    
    // Add an already existing FhirClinicalUseIssueInteractionInteractant to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueInteractionInteractant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueInteractionInteractant) : Integer;
    
    // Insert FhirClinicalUseIssueInteractionInteractant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueInteractionInteractant;
    
    // Insert an existing FhirClinicalUseIssueInteractionInteractant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueInteractionInteractant);
    
    // Get the iIndexth FhirClinicalUseIssueInteractionInteractant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueInteractionInteractant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueInteractionInteractant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueInteractionInteractants[index : Integer] : TFhirClinicalUseIssueInteractionInteractant read GetItemN write SetItemN; default;
  End;

  // Describe the undesirable effects of the medicinal product.
  TFhirClinicalUseIssueUndesirableEffect = class (TFhirBackboneElement)
  protected
    FSymptomConditionEffect : TFhirCodeableConcept;
    FClassification : TFhirCodeableConcept;
    FFrequencyOfOccurrence : TFhirCodeableConcept;
    procedure SetSymptomConditionEffect(value : TFhirCodeableConcept);
    procedure SetClassification(value : TFhirCodeableConcept);
    procedure SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssueUndesirableEffect; overload;
    function Clone : TFhirClinicalUseIssueUndesirableEffect; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation in which the undesirable effect may manifest. (defined for API consistency)
    property symptomConditionEffect : TFhirCodeableConcept read FSymptomConditionEffect write SetSymptomConditionEffect;
    // The situation in which the undesirable effect may manifest.
    property symptomConditionEffectElement : TFhirCodeableConcept read FSymptomConditionEffect write SetSymptomConditionEffect;

    // Typed access to High level classification of the effect. (defined for API consistency)
    property classification : TFhirCodeableConcept read FClassification write SetClassification;
    // High level classification of the effect.
    property classificationElement : TFhirCodeableConcept read FClassification write SetClassification;

    // Typed access to How often the effect is seen. (defined for API consistency)
    property frequencyOfOccurrence : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;
    // How often the effect is seen.
    property frequencyOfOccurrenceElement : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;

  end;

  TFhirClinicalUseIssueUndesirableEffectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueUndesirableEffectList;
    function GetCurrent : TFhirClinicalUseIssueUndesirableEffect;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueUndesirableEffectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssueUndesirableEffect read GetCurrent;
  end;

  TFhirClinicalUseIssueUndesirableEffectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssueUndesirableEffect;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssueUndesirableEffect);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueUndesirableEffectList; overload;
    function Clone : TFhirClinicalUseIssueUndesirableEffectList; overload;
    function GetEnumerator : TFhirClinicalUseIssueUndesirableEffectListEnumerator;
    
    //  Add a FhirClinicalUseIssueUndesirableEffect to the end of the list.
    function Append : TFhirClinicalUseIssueUndesirableEffect;
    
    // Add an already existing FhirClinicalUseIssueUndesirableEffect to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssueUndesirableEffect); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssueUndesirableEffect) : Integer;
    
    // Insert FhirClinicalUseIssueUndesirableEffect before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssueUndesirableEffect;
    
    // Insert an existing FhirClinicalUseIssueUndesirableEffect before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssueUndesirableEffect);
    
    // Get the iIndexth FhirClinicalUseIssueUndesirableEffect. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssueUndesirableEffect);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssueUndesirableEffect;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssueUndesirableEffects[index : Integer] : TFhirClinicalUseIssueUndesirableEffect read GetItemN write SetItemN; default;
  End;

  // A single usage issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure.
  TFhirClinicalUseIssue = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FsubjectList : TFhirReferenceList;
    FStatus : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FContraindication : TFhirClinicalUseIssueContraindication;
    FIndication : TFhirClinicalUseIssueIndication;
    FInteraction : TFhirClinicalUseIssueInteraction;
    FpopulationList : TFhirPopulationList;
    FUndesirableEffect : TFhirClinicalUseIssueUndesirableEffect;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirClinicalUseIssueTypeEnum;
    procedure SetType_ST(value : TFhirClinicalUseIssueTypeEnum);
    procedure SetCategory(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetContraindication(value : TFhirClinicalUseIssueContraindication);
    procedure SetIndication(value : TFhirClinicalUseIssueIndication);
    procedure SetInteraction(value : TFhirClinicalUseIssueInteraction);
    function GetPopulationList : TFhirPopulationList;
    function GetHasPopulationList : Boolean;
    procedure SetUndesirableEffect(value : TFhirClinicalUseIssueUndesirableEffect);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseIssue; overload;
    function Clone : TFhirClinicalUseIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this issue.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // indication | contraindication | interaction | undesirable-effect | warning.
    property type_ : TFhirClinicalUseIssueTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines". (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // The medication or procedure for which this is an indication.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Whether this is a current issue or one that has been retired etc. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Whether this is a current issue or one that has been retired etc.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to General description of an effect (particularly for a general warning, rather than any of the more specific types such as indication) for when a distinct coded or textual description is not appropriate using  Indication.diseaseSymptomProcedure.text, Contraindication.diseaseSymptomProcedure.text etc. For example "May affect ability to drive".
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of an effect (particularly for a general warning, rather than any of the more specific types such as indication) for when a distinct coded or textual description is not appropriate using  Indication.diseaseSymptomProcedure.text, Contraindication.diseaseSymptomProcedure.text etc. For example "May affect ability to drive".
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Specifics for when this is a contraindication. (defined for API consistency)
    property contraindication : TFhirClinicalUseIssueContraindication read FContraindication write SetContraindication;
    // Specifics for when this is a contraindication.
    property contraindicationElement : TFhirClinicalUseIssueContraindication read FContraindication write SetContraindication;

    // Typed access to Specifics for when this is an indication. (defined for API consistency)
    property indication : TFhirClinicalUseIssueIndication read FIndication write SetIndication;
    // Specifics for when this is an indication.
    property indicationElement : TFhirClinicalUseIssueIndication read FIndication write SetIndication;

    // Typed access to Specifics for when this is an interaction. (defined for API consistency)
    property interaction : TFhirClinicalUseIssueInteraction read FInteraction write SetInteraction;
    // Specifics for when this is an interaction.
    property interactionElement : TFhirClinicalUseIssueInteraction read FInteraction write SetInteraction;

    // The population group to which this applies.
    property populationList : TFhirPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to Describe the undesirable effects of the medicinal product. (defined for API consistency)
    property undesirableEffect : TFhirClinicalUseIssueUndesirableEffect read FUndesirableEffect write SetUndesirableEffect;
    // Describe the undesirable effects of the medicinal product.
    property undesirableEffectElement : TFhirClinicalUseIssueUndesirableEffect read FUndesirableEffect write SetUndesirableEffect;

  end;

  TFhirClinicalUseIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseIssueList;
    function GetCurrent : TFhirClinicalUseIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseIssue read GetCurrent;
  end;

  TFhirClinicalUseIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseIssue;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseIssueList; overload;
    function Clone : TFhirClinicalUseIssueList; overload;
    function GetEnumerator : TFhirClinicalUseIssueListEnumerator;
    
    //  Add a FhirClinicalUseIssue to the end of the list.
    function Append : TFhirClinicalUseIssue;
    
    // Add an already existing FhirClinicalUseIssue to the end of the list.
    procedure AddItem(value : TFhirClinicalUseIssue); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseIssue) : Integer;
    
    // Insert FhirClinicalUseIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseIssue;
    
    // Insert an existing FhirClinicalUseIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseIssue);
    
    // Get the iIndexth FhirClinicalUseIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseIssues[index : Integer] : TFhirClinicalUseIssue read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALUSEISSUE}
{$IFDEF FHIR_COMMUNICATION}
  // Text, attachment(s), or resource(s) that was communicated to the recipient.
  TFhirCommunicationPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationPayload; overload;
    function Clone : TFhirCommunicationPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // A communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirCommunicationPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationPayloadList;
    function GetCurrent : TFhirCommunicationPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationPayload read GetCurrent;
  end;

  TFhirCommunicationPayloadList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationPayloadList; overload;
    function Clone : TFhirCommunicationPayloadList; overload;
    function GetEnumerator : TFhirCommunicationPayloadListEnumerator;
    
    //  Add a FhirCommunicationPayload to the end of the list.
    function Append : TFhirCommunicationPayload;
    
    // Add an already existing FhirCommunicationPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationPayload); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationPayload) : Integer;
    
    // Insert FhirCommunicationPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationPayload;
    
    // Insert an existing FhirCommunicationPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationPayload);
    
    // Get the iIndexth FhirCommunicationPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationPayload);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationPayload;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationPayloads[index : Integer] : TFhirCommunicationPayload read GetItemN write SetItemN; default;
  End;

  // A clinical or business level record of information being transmitted or shared; e.g. an alert that was sent to a responsible provider, a public health agency communication to a provider/reporter in response to a case report for a reportable condition.
  TFhirCommunication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FinResponseToList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FTopic : TFhirCodeableConcept;
    FaboutList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FSent : TFhirDateTime;
    FReceived : TFhirDateTime;
    FrecipientList : TFhirReferenceList;
    FSender : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FpayloadList : TFhirCommunicationPayloadList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    function GetInResponseToList : TFhirReferenceList;
    function GetHasInResponseToList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetTopic(value : TFhirCodeableConcept);
    function GetAboutList : TFhirReferenceList;
    function GetHasAboutList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    procedure SetSent(value : TFhirDateTime);
    function GetSentST : TFslDateTime;
    procedure SetSentST(value : TFslDateTime);
    procedure SetReceived(value : TFhirDateTime);
    function GetReceivedST : TFslDateTime;
    procedure SetReceivedST(value : TFslDateTime);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    procedure SetSender(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetPayloadList : TFhirCommunicationPayloadList;
    function GetHasPayloadList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunication; overload;
    function Clone : TFhirCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this communication by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Communication.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Communication.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // An order, proposal or plan fulfilled in whole or in part by this Communication.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event (e.g. Communication, Procedure) of which this particular communication is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Prior communication that this communication is in response to.
    property inResponseToList : TFhirReferenceList read GetInResponseToList;
    property hasInResponseToList : boolean read GetHasInResponseToList;

    // The status of the transmission.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the Communication. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the Communication.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // The type of message conveyed such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Characterizes how quickly the planned or in progress communication must be addressed. Includes concepts such as stat, urgent, routine.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that was the focus of this communication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group that was the focus of this communication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Description of the purpose/content, similar to a subject line in an email. (defined for API consistency)
    property topic : TFhirCodeableConcept read FTopic write SetTopic;
    // Description of the purpose/content, similar to a subject line in an email.
    property topicElement : TFhirCodeableConcept read FTopic write SetTopic;

    // Other resources that pertain to this communication and to which this communication should be associated.
    property aboutList : TFhirReferenceList read GetAboutList;
    property hasAboutList : boolean read GetHasAboutList;

    // Typed access to The Encounter during which this Communication was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Communication was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time when this communication was sent.
    property sent : TFslDateTime read GetSentST write SetSentST;
    // The time when this communication was sent.
    property sentElement : TFhirDateTime read FSent write SetSent;

    // Typed access to The time when this communication arrived at the destination.
    property received : TFslDateTime read GetReceivedST write SetReceivedST;
    // The time when this communication arrived at the destination.
    property receivedElement : TFhirDateTime read FReceived write SetReceived;

    // The entity (e.g. person, organization, clinical information system, care team or device) which is the target of the communication.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which is the source of the communication. (defined for API consistency)
    property sender : TFhirReference read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which is the source of the communication.
    property senderElement : TFhirReference read FSender write SetSender;

    // The reason or justification for the communication.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Text, attachment(s), or resource(s) that was communicated to the recipient.
    property payloadList : TFhirCommunicationPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Additional notes or commentary about the communication by the sender, receiver or other interested parties.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationList;
    function GetCurrent : TFhirCommunication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunication read GetCurrent;
  end;

  TFhirCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunication;
    procedure SetItemN(index : Integer; value : TFhirCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationList; overload;
    function Clone : TFhirCommunicationList; overload;
    function GetEnumerator : TFhirCommunicationListEnumerator;
    
    //  Add a FhirCommunication to the end of the list.
    function Append : TFhirCommunication;
    
    // Add an already existing FhirCommunication to the end of the list.
    procedure AddItem(value : TFhirCommunication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunication) : Integer;
    
    // Insert FhirCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunication;
    
    // Insert an existing FhirCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunication);
    
    // Get the iIndexth FhirCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunications[index : Integer] : TFhirCommunication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  // Text, attachment(s), or resource(s) to be communicated to the recipient.
  TFhirCommunicationRequestPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequestPayload; overload;
    function Clone : TFhirCommunicationRequestPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // The communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirCommunicationRequestPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestPayloadList;
    function GetCurrent : TFhirCommunicationRequestPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequestPayload read GetCurrent;
  end;

  TFhirCommunicationRequestPayloadList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationRequestPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequestPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationRequestPayloadList; overload;
    function Clone : TFhirCommunicationRequestPayloadList; overload;
    function GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
    
    //  Add a FhirCommunicationRequestPayload to the end of the list.
    function Append : TFhirCommunicationRequestPayload;
    
    // Add an already existing FhirCommunicationRequestPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequestPayload); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequestPayload) : Integer;
    
    // Insert FhirCommunicationRequestPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequestPayload;
    
    // Insert an existing FhirCommunicationRequestPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequestPayload);
    
    // Get the iIndexth FhirCommunicationRequestPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequestPayload);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequestPayload;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationRequestPayloads[index : Integer] : TFhirCommunicationRequestPayload read GetItemN write SetItemN; default;
  End;

  // A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
  TFhirCommunicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FaboutList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FpayloadList : TFhirCommunicationRequestPayloadList;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FrecipientList : TFhirReferenceList;
    FinformationProviderList : TFhirReferenceList;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    procedure SetSubject(value : TFhirReference);
    function GetAboutList : TFhirReferenceList;
    function GetHasAboutList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    function GetPayloadList : TFhirCommunicationRequestPayloadList;
    function GetHasPayloadList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    function GetInformationProviderList : TFhirReferenceList;
    function GetHasInformationProviderList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequest; overload;
    function Clone : TFhirCommunicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this communication request by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan or proposal that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the proposal or order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the CommunicationRequest. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the CommunicationRequest.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // The type of message to be sent such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to If true indicates that the CommunicationRequest is asking for the specified action to *not* occur.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true indicates that the CommunicationRequest is asking for the specified action to *not* occur.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that is the focus of this communication request. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group that is the focus of this communication request.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Other resources that pertain to this communication request and to which this communication request should be associated.
    property aboutList : TFhirReferenceList read GetAboutList;
    property hasAboutList : boolean read GetHasAboutList;

    // Typed access to The Encounter during which this CommunicationRequest was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this CommunicationRequest was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Text, attachment(s), or resource(s) to be communicated to the recipient.
    property payloadList : TFhirCommunicationRequestPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Typed access to The time when this communication is to occur. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The time when this communication is to occur.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The device, individual, or organization who asks for the information to be shared. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The device, individual, or organization who asks for the information to be shared.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // The entity (e.g. person, organization, clinical information system, device, group, or care team) which is the intended target of the communication.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication.
    property informationProviderList : TFhirReferenceList read GetInformationProviderList;
    property hasInformationProviderList : boolean read GetHasInformationProviderList;

    // Describes why the request is being made in coded or textual form.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Comments made about the request by the requester, sender, recipient, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestList;
    function GetCurrent : TFhirCommunicationRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequest read GetCurrent;
  end;

  TFhirCommunicationRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationRequest;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationRequestList; overload;
    function Clone : TFhirCommunicationRequestList; overload;
    function GetEnumerator : TFhirCommunicationRequestListEnumerator;
    
    //  Add a FhirCommunicationRequest to the end of the list.
    function Append : TFhirCommunicationRequest;
    
    // Add an already existing FhirCommunicationRequest to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequest) : Integer;
    
    // Insert FhirCommunicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequest;
    
    // Insert an existing FhirCommunicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequest);
    
    // Get the iIndexth FhirCommunicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationRequests[index : Integer] : TFhirCommunicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  // A participant who has attested to the accuracy of the composition/document.
  TFhirCompositionAttester = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FTime : TFhirDateTime;
    FParty : TFhirReference;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirCompositionAttestationModeEnum;
    procedure SetModeST(value : TFhirCompositionAttestationModeEnum);
    procedure SetTime(value : TFhirDateTime);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of attestation the authenticator offers.
    property mode : TFhirCompositionAttestationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When the composition was attested by the party.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // When the composition was attested by the party.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Who attested the composition in the specified way. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Who attested the composition in the specified way.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirCompositionAttesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionAttesterList;
    function GetCurrent : TFhirCompositionAttester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionAttesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionAttester read GetCurrent;
  end;

  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionAttesterList; overload;
    function Clone : TFhirCompositionAttesterList; overload;
    function GetEnumerator : TFhirCompositionAttesterListEnumerator;
    
    //  Add a FhirCompositionAttester to the end of the list.
    function Append : TFhirCompositionAttester;
    
    // Add an already existing FhirCompositionAttester to the end of the list.
    procedure AddItem(value : TFhirCompositionAttester); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionAttester) : Integer;
    
    // Insert FhirCompositionAttester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionAttester;
    
    // Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);
    
    // Get the iIndexth FhirCompositionAttester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionAttester;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;

  // Relationships that this composition has with other compositions or documents that already exist.
  TFhirCompositionRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirDataType;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    procedure SetTarget(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionRelatesTo; overload;
    function Clone : TFhirCompositionRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this composition has with anther composition or document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target composition/document of this relationship. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The target composition/document of this relationship.
    property targetElement : TFhirDataType read FTarget write SetTarget;

  end;

  TFhirCompositionRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionRelatesToList;
    function GetCurrent : TFhirCompositionRelatesTo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionRelatesTo read GetCurrent;
  end;

  TFhirCompositionRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirCompositionRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionRelatesToList; overload;
    function Clone : TFhirCompositionRelatesToList; overload;
    function GetEnumerator : TFhirCompositionRelatesToListEnumerator;
    
    //  Add a FhirCompositionRelatesTo to the end of the list.
    function Append : TFhirCompositionRelatesTo;
    
    // Add an already existing FhirCompositionRelatesTo to the end of the list.
    procedure AddItem(value : TFhirCompositionRelatesTo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionRelatesTo) : Integer;
    
    // Insert FhirCompositionRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionRelatesTo;
    
    // Insert an existing FhirCompositionRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionRelatesTo);
    
    // Get the iIndexth FhirCompositionRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionRelatesTos[index : Integer] : TFhirCompositionRelatesTo read GetItemN write SetItemN; default;
  End;

  // The clinical service, such as a colonoscopy or an appendectomy, being documented.
  TFhirCompositionEvent = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCompositionEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionEventList;
    function GetCurrent : TFhirCompositionEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionEvent read GetCurrent;
  end;

  TFhirCompositionEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionEventList; overload;
    function Clone : TFhirCompositionEventList; overload;
    function GetEnumerator : TFhirCompositionEventListEnumerator;
    
    //  Add a FhirCompositionEvent to the end of the list.
    function Append : TFhirCompositionEvent;
    
    // Add an already existing FhirCompositionEvent to the end of the list.
    procedure AddItem(value : TFhirCompositionEvent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionEvent) : Integer;
    
    // Insert FhirCompositionEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionEvent;
    
    // Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);
    
    // Get the iIndexth FhirCompositionEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirCompositionSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FauthorList : TFhirReferenceList;
    FFocus : TFhirReference;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryList : TFhirReferenceList;
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirCompositionSectionList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetFocus(value : TFhirReference);
    procedure SetText(value : TFhirNarrative);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryList : TFhirReferenceList;
    function GetHasEntryList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This must be consistent with the section title. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code identifying the kind of content contained within the section. This must be consistent with the section title.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Identifies who is responsible for the information in this section, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to The actual focus of the section when it is not the subject of the composition, but instead represents something or someone associated with the subject such as (for a patient subject) a spouse, parent, fetus, or donor. If not focus is specified, the focus is assumed to be focus of the parent section, or, for a section in the Composition itself, the subject of the composition. Sections with a focus SHALL only include resources where the logical subject (patient, subject, focus, etc.) matches the section focus, or the resources have no logical subject (few resources). (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The actual focus of the section when it is not the subject of the composition, but instead represents something or someone associated with the subject such as (for a patient subject) a spouse, parent, fetus, or donor. If not focus is specified, the focus is assumed to be focus of the parent section, or, for a section in the Composition itself, the subject of the composition. Sections with a focus SHALL only include resources where the logical subject (patient, subject, focus, etc.) matches the section focus, or the resources have no logical subject (few resources).
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryList : TFhirReferenceList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionSectionList;
    function GetCurrent : TFhirCompositionSection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionSection read GetCurrent;
  end;

  TFhirCompositionSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionSectionList; overload;
    function Clone : TFhirCompositionSectionList; overload;
    function GetEnumerator : TFhirCompositionSectionListEnumerator;
    
    //  Add a FhirCompositionSection to the end of the list.
    function Append : TFhirCompositionSection;
    
    // Add an already existing FhirCompositionSection to the end of the list.
    procedure AddItem(value : TFhirCompositionSection); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionSection) : Integer;
    
    // Insert FhirCompositionSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionSection;
    
    // Insert an existing FhirCompositionSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);
    
    // Get the iIndexth FhirCompositionSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionSection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;

  // A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.).
  TFhirComposition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FDate : TFhirDateTime;
    FauthorList : TFhirReferenceList;
    FTitle : TFhirString;
    FConfidentiality : TFhirCode;
    FattesterList : TFhirCompositionAttesterList;
    FCustodian : TFhirReference;
    FrelatesToList : TFhirCompositionRelatesToList;
    FeventList : TFhirCompositionEventList;
    FsectionList : TFhirCompositionSectionList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCompositionStatusEnum;
    procedure SetStatusST(value : TFhirCompositionStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetConfidentiality(value : TFhirCode);
    function GetConfidentialityST : String;
    procedure SetConfidentialityST(value : String);
    function GetAttesterList : TFhirCompositionAttesterList;
    function GetHasAttesterList : Boolean;
    procedure SetCustodian(value : TFhirReference);
    function GetRelatesToList : TFhirCompositionRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetEventList : TFhirCompositionEventList;
    function GetHasEventList : Boolean;
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirComposition; overload;
    function Clone : TFhirComposition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A version-independent identifier for the Composition. This identifier stays constant as the composition is changed over time. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A version-independent identifier for the Composition. This identifier stays constant as the composition is changed over time.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document.
    property status : TFhirCompositionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Describes the clinical encounter or type of care this documentation is associated with. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care this documentation is associated with.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The composition editing time, when the composition was last logically changed by the author.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The composition editing time, when the composition was last logically changed by the author.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Identifies who is responsible for the information in the composition, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Official human-readable label for the composition.
    property title : String read GetTitleST write SetTitleST;
    // Official human-readable label for the composition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The code specifying the level of confidentiality of the Composition.
    property confidentiality : String read GetConfidentialityST write SetConfidentialityST;
    // The code specifying the level of confidentiality of the Composition.
    property confidentialityElement : TFhirCode read FConfidentiality write SetConfidentiality;

    // A participant who has attested to the accuracy of the composition/document.
    property attesterList : TFhirCompositionAttesterList read GetAttesterList;
    property hasAttesterList : boolean read GetHasAttesterList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information. (defined for API consistency)
    property custodian : TFhirReference read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information.
    property custodianElement : TFhirReference read FCustodian write SetCustodian;

    // Relationships that this composition has with other compositions or documents that already exist.
    property relatesToList : TFhirCompositionRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // The clinical service, such as a colonoscopy or an appendectomy, being documented.
    property eventList : TFhirCompositionEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // The root of the sections that make up the composition.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionList;
    function GetCurrent : TFhirComposition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirComposition read GetCurrent;
  end;

  TFhirCompositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirComposition;
    procedure SetItemN(index : Integer; value : TFhirComposition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionList; overload;
    function Clone : TFhirCompositionList; overload;
    function GetEnumerator : TFhirCompositionListEnumerator;
    
    //  Add a FhirComposition to the end of the list.
    function Append : TFhirComposition;
    
    // Add an already existing FhirComposition to the end of the list.
    procedure AddItem(value : TFhirComposition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirComposition) : Integer;
    
    // Insert FhirComposition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirComposition;
    
    // Insert an existing FhirComposition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirComposition);
    
    // Get the iIndexth FhirComposition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirComposition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirComposition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositions[index : Integer] : TFhirComposition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  // Clinical stage or grade of a condition. May include formal severity assessments.
  TFhirConditionStage = class (TFhirBackboneElement)
  protected
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    procedure SetSummary(value : TFhirCodeableConcept);
    function GetAssessmentList : TFhirReferenceList;
    function GetHasAssessmentList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific. (defined for API consistency)
    property summary : TFhirCodeableConcept read FSummary write SetSummary;
    // A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    property summaryElement : TFhirCodeableConcept read FSummary write SetSummary;

    // Reference to a formal record of the evidence on which the staging assessment is based.
    property assessmentList : TFhirReferenceList read GetAssessmentList;
    property hasAssessmentList : boolean read GetHasAssessmentList;

    // Typed access to The kind of staging, such as pathological or clinical staging. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of staging, such as pathological or clinical staging.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirConditionStageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionStageList;
    function GetCurrent : TFhirConditionStage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionStageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionStage read GetCurrent;
  end;

  TFhirConditionStageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionStageList; overload;
    function Clone : TFhirConditionStageList; overload;
    function GetEnumerator : TFhirConditionStageListEnumerator;
    
    //  Add a FhirConditionStage to the end of the list.
    function Append : TFhirConditionStage;
    
    // Add an already existing FhirConditionStage to the end of the list.
    procedure AddItem(value : TFhirConditionStage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionStage) : Integer;
    
    // Insert FhirConditionStage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionStage;
    
    // Insert an existing FhirConditionStage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionStage);
    
    // Get the iIndexth FhirConditionStage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionStage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;

  // Supporting evidence / manifestations that are the basis of the Condition's verification status, such as evidence that confirmed or refuted the condition.
  TFhirConditionEvidence = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A manifestation or symptom that led to the recording of this condition.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Links to other relevant information, including pathology reports.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirConditionEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionEvidenceList;
    function GetCurrent : TFhirConditionEvidence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionEvidence read GetCurrent;
  end;

  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionEvidenceList; overload;
    function Clone : TFhirConditionEvidenceList; overload;
    function GetEnumerator : TFhirConditionEvidenceListEnumerator;
    
    //  Add a FhirConditionEvidence to the end of the list.
    function Append : TFhirConditionEvidence;
    
    // Add an already existing FhirConditionEvidence to the end of the list.
    procedure AddItem(value : TFhirConditionEvidence); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionEvidence) : Integer;
    
    // Insert FhirConditionEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionEvidence;
    
    // Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);
    
    // Get the iIndexth FhirConditionEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;

  // A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
  TFhirCondition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirCodeableConcept;
    FVerificationStatus : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSeverity : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FbodySiteList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOnset : TFhirDataType;
    FAbatement : TFhirDataType;
    FRecordedDate : TFhirDateTime;
    FRecorder : TFhirReference;
    FAsserter : TFhirReference;
    FstageList : TFhirConditionStageList;
    FevidenceList : TFhirConditionEvidenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetClinicalStatus(value : TFhirCodeableConcept);
    procedure SetVerificationStatus(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSeverity(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOnset(value : TFhirDataType);
    procedure SetAbatement(value : TFhirDataType);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    procedure SetRecorder(value : TFhirReference);
    procedure SetAsserter(value : TFhirReference);
    function GetStageList : TFhirConditionStageList;
    function GetHasStageList : Boolean;
    function GetEvidenceList : TFhirConditionEvidenceList;
    function GetHasEvidenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCondition; overload;
    function Clone : TFhirCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this condition by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The clinical status of the condition. (defined for API consistency)
    property clinicalStatus : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;
    // The clinical status of the condition.
    property clinicalStatusElement : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;

    // Typed access to The verification status to support the clinical status of the condition. (defined for API consistency)
    property verificationStatus : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;
    // The verification status to support the clinical status of the condition.
    property verificationStatusElement : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;

    // A category assigned to the condition.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A subjective assessment of the severity of the condition as evaluated by the clinician. (defined for API consistency)
    property severity : TFhirCodeableConcept read FSeverity write SetSeverity;
    // A subjective assessment of the severity of the condition as evaluated by the clinician.
    property severityElement : TFhirCodeableConcept read FSeverity write SetSeverity;

    // Typed access to Identification of the condition, problem or diagnosis. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identification of the condition, problem or diagnosis.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The anatomical location where this condition manifests itself.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to Indicates the patient or group who the condition record is associated with. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Indicates the patient or group who the condition record is associated with.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this Condition was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Condition was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date or date-time  the condition began, in the opinion of the clinician. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // Typed access to The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Some conditions, such as chronic conditions, are never really resolved, but they can abate. (defined for API consistency)
    property abatement : TFhirDataType read FAbatement write SetAbatement;
    // The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Some conditions, such as chronic conditions, are never really resolved, but they can abate.
    property abatementElement : TFhirDataType read FAbatement write SetAbatement;

    // Typed access to The recordedDate represents when this particular Condition record was created in the system, which is often a system-generated date.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The recordedDate represents when this particular Condition record was created in the system, which is often a system-generated date.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to Individual or device that is making the condition statement. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // Individual or device that is making the condition statement.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // Clinical stage or grade of a condition. May include formal severity assessments.
    property stageList : TFhirConditionStageList read GetStageList;
    property hasStageList : boolean read GetHasStageList;

    // Supporting evidence / manifestations that are the basis of the Condition's verification status, such as evidence that confirmed or refuted the condition.
    property evidenceList : TFhirConditionEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionList;
    function GetCurrent : TFhirCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCondition read GetCurrent;
  end;

  TFhirConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCondition;
    procedure SetItemN(index : Integer; value : TFhirCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionList; overload;
    function Clone : TFhirConditionList; overload;
    function GetEnumerator : TFhirConditionListEnumerator;
    
    //  Add a FhirCondition to the end of the list.
    function Append : TFhirCondition;
    
    // Add an already existing FhirCondition to the end of the list.
    procedure AddItem(value : TFhirCondition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCondition) : Integer;
    
    // Insert FhirCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCondition;
    
    // Insert an existing FhirCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCondition);
    
    // Get the iIndexth FhirCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditions[index : Integer] : TFhirCondition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
  // Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
  TFhirDetectedIssueEvidence = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueEvidence; overload;
    function Clone : TFhirDetectedIssueEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A manifestation that led to the recording of this detected issue.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirDetectedIssueEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueEvidenceList;
    function GetCurrent : TFhirDetectedIssueEvidence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueEvidence read GetCurrent;
  end;

  TFhirDetectedIssueEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssueEvidence;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueEvidenceList; overload;
    function Clone : TFhirDetectedIssueEvidenceList; overload;
    function GetEnumerator : TFhirDetectedIssueEvidenceListEnumerator;
    
    //  Add a FhirDetectedIssueEvidence to the end of the list.
    function Append : TFhirDetectedIssueEvidence;
    
    // Add an already existing FhirDetectedIssueEvidence to the end of the list.
    procedure AddItem(value : TFhirDetectedIssueEvidence); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueEvidence) : Integer;
    
    // Insert FhirDetectedIssueEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueEvidence;
    
    // Insert an existing FhirDetectedIssueEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueEvidence);
    
    // Get the iIndexth FhirDetectedIssueEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssueEvidences[index : Integer] : TFhirDetectedIssueEvidence read GetItemN write SetItemN; default;
  End;

  // Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
  TFhirDetectedIssueMitigation = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    FAuthor : TFhirReference;
    procedure SetAction(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueMitigation; overload;
    function Clone : TFhirDetectedIssueMitigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to Indicates when the mitigating action was documented.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the mitigating action was documented.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirDetectedIssueMitigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueMitigationList;
    function GetCurrent : TFhirDetectedIssueMitigation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueMitigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueMitigation read GetCurrent;
  end;

  TFhirDetectedIssueMitigationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssueMitigation;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueMitigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueMitigationList; overload;
    function Clone : TFhirDetectedIssueMitigationList; overload;
    function GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
    
    //  Add a FhirDetectedIssueMitigation to the end of the list.
    function Append : TFhirDetectedIssueMitigation;
    
    // Add an already existing FhirDetectedIssueMitigation to the end of the list.
    procedure AddItem(value : TFhirDetectedIssueMitigation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueMitigation) : Integer;
    
    // Insert FhirDetectedIssueMitigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueMitigation;
    
    // Insert an existing FhirDetectedIssueMitigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueMitigation);
    
    // Get the iIndexth FhirDetectedIssueMitigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueMitigation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueMitigation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssueMitigations[index : Integer] : TFhirDetectedIssueMitigation read GetItemN write SetItemN; default;
  End;

  // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
  TFhirDetectedIssue = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    FPatient : TFhirReference;
    FIdentified : TFhirDataType;
    FAuthor : TFhirReference;
    FimplicatedList : TFhirReferenceList;
    FevidenceList : TFhirDetectedIssueEvidenceList;
    FDetail : TFhirString;
    FReference : TFhirUri;
    FmitigationList : TFhirDetectedIssueMitigationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirDetectedIssueSeverityEnum;
    procedure SetSeverityST(value : TFhirDetectedIssueSeverityEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetIdentified(value : TFhirDataType);
    procedure SetAuthor(value : TFhirReference);
    function GetImplicatedList : TFhirReferenceList;
    function GetHasImplicatedList : Boolean;
    function GetEvidenceList : TFhirDetectedIssueEvidenceList;
    function GetHasEvidenceList : Boolean;
    procedure SetDetail(value : TFhirString);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
    procedure SetReference(value : TFhirUri);
    function GetReferenceST : String;
    procedure SetReferenceST(value : String);
    function GetMitigationList : TFhirDetectedIssueMitigationList;
    function GetHasMitigationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssue; overload;
    function Clone : TFhirDetectedIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier associated with the detected issue record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the status of the detected issue.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifies the general type of issue identified. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the general type of issue identified.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
    property severity : TFhirDetectedIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Indicates the patient whose record the detected issue is associated with. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // Indicates the patient whose record the detected issue is associated with.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or period when the detected issue was initially identified. (defined for API consistency)
    property identified : TFhirDataType read FIdentified write SetIdentified;
    // The date or period when the detected issue was initially identified.
    property identifiedElement : TFhirDataType read FIdentified write SetIdentified;

    // Typed access to Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Indicates the resource representing the current activity or proposed activity that is potentially problematic.
    property implicatedList : TFhirReferenceList read GetImplicatedList;
    property hasImplicatedList : boolean read GetHasImplicatedList;

    // Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
    property evidenceList : TFhirDetectedIssueEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // Typed access to A textual explanation of the detected issue.
    property detail : String read GetDetailST write SetDetailST;
    // A textual explanation of the detected issue.
    property detailElement : TFhirString read FDetail write SetDetail;

    // Typed access to The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property reference : String read GetReferenceST write SetReferenceST;
    // The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
    property mitigationList : TFhirDetectedIssueMitigationList read GetMitigationList;
    property hasMitigationList : boolean read GetHasMitigationList;

  end;

  TFhirDetectedIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueList;
    function GetCurrent : TFhirDetectedIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssue read GetCurrent;
  end;

  TFhirDetectedIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssue;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueList; overload;
    function Clone : TFhirDetectedIssueList; overload;
    function GetEnumerator : TFhirDetectedIssueListEnumerator;
    
    //  Add a FhirDetectedIssue to the end of the list.
    function Append : TFhirDetectedIssue;
    
    // Add an already existing FhirDetectedIssue to the end of the list.
    procedure AddItem(value : TFhirDetectedIssue); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssue) : Integer;
    
    // Insert FhirDetectedIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssue;
    
    // Insert an existing FhirDetectedIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssue);
    
    // Get the iIndexth FhirDetectedIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssues[index : Integer] : TFhirDetectedIssue read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
  // Specific parameters for the ordered item.  For example, the prism value for lenses.
  TFhirDeviceRequestParameter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequestParameter; overload;
    function Clone : TFhirDeviceRequestParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or string that identifies the device detail being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or string that identifies the device detail being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the device detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the device detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirDeviceRequestParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestParameterList;
    function GetCurrent : TFhirDeviceRequestParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequestParameter read GetCurrent;
  end;

  TFhirDeviceRequestParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceRequestParameter;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequestParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceRequestParameterList; overload;
    function Clone : TFhirDeviceRequestParameterList; overload;
    function GetEnumerator : TFhirDeviceRequestParameterListEnumerator;
    
    //  Add a FhirDeviceRequestParameter to the end of the list.
    function Append : TFhirDeviceRequestParameter;
    
    // Add an already existing FhirDeviceRequestParameter to the end of the list.
    procedure AddItem(value : TFhirDeviceRequestParameter); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequestParameter) : Integer;
    
    // Insert FhirDeviceRequestParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequestParameter;
    
    // Insert an existing FhirDeviceRequestParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequestParameter);
    
    // Get the iIndexth FhirDeviceRequestParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequestParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequestParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceRequestParameters[index : Integer] : TFhirDeviceRequestParameter read GetItemN write SetItemN; default;
  End;

  // Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.
  TFhirDeviceRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpriorRequestList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableReference;
    FparameterList : TFhirDeviceRequestParameterList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FPerformer : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FinsuranceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPriorRequestList : TFhirReferenceList;
    function GetHasPriorRequestList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirCodeableReference);
    function GetParameterList : TFhirDeviceRequestParameterList;
    function GetHasParameterList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequest; overload;
    function Clone : TFhirDeviceRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the orderer or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this DeviceRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this DeviceRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property priorRequestList : TFhirReferenceList read GetPriorRequestList;
    property hasPriorRequestList : boolean read GetHasPriorRequestList;

    // Typed access to Composite request this is part of. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // Composite request this is part of.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the request.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the {{title)))) should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The details of the device to be used. (defined for API consistency)
    property code : TFhirCodeableReference read FCode write SetCode;
    // The details of the device to be used.
    property codeElement : TFhirCodeableReference read FCode write SetCode;

    // Specific parameters for the ordered item.  For example, the prism value for lenses.
    property parameterList : TFhirDeviceRequestParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Typed access to The patient who will use the device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient who will use the device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to An encounter that provides additional context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the diagnostic testing. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the diagnostic testing.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The desired performer for doing the diagnostic testing. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The desired performer for doing the diagnostic testing.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Reason or justification for the use of this device.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be required for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Additional clinical information about the patient that may influence the request fulfilment.  For example, this may include where on the subject's body the device will be used (i.e. the target site).
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Details about this request that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirDeviceRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestList;
    function GetCurrent : TFhirDeviceRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequest read GetCurrent;
  end;

  TFhirDeviceRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceRequest;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceRequestList; overload;
    function Clone : TFhirDeviceRequestList; overload;
    function GetEnumerator : TFhirDeviceRequestListEnumerator;
    
    //  Add a FhirDeviceRequest to the end of the list.
    function Append : TFhirDeviceRequest;
    
    // Add an already existing FhirDeviceRequest to the end of the list.
    procedure AddItem(value : TFhirDeviceRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequest) : Integer;
    
    // Insert FhirDeviceRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequest;
    
    // Insert an existing FhirDeviceRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequest);
    
    // Get the iIndexth FhirDeviceRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceRequests[index : Integer] : TFhirDeviceRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  // A record of a device being used by a patient where the record is the result of a report from the patient or a clinician.
  TFhirDeviceUseStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FderivedFromList : TFhirReferenceList;
    FContext : TFhirReference;
    FTiming : TFhirDataType;
    FDateAsserted : TFhirDateTime;
    FUsageStatus : TFhirCodeableConcept;
    FusageReasonList : TFhirCodeableConceptList;
    FInformationSource : TFhirReference;
    FDevice : TFhirCodeableReference;
    FreasonList : TFhirCodeableReferenceList;
    FBodySite : TFhirCodeableReference;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDeviceUseStatementStatusEnum;
    procedure SetStatusST(value : TFhirDeviceUseStatementStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    procedure SetContext(value : TFhirReference);
    procedure SetTiming(value : TFhirDataType);
    procedure SetDateAsserted(value : TFhirDateTime);
    function GetDateAssertedST : TFslDateTime;
    procedure SetDateAssertedST(value : TFslDateTime);
    procedure SetUsageStatus(value : TFhirCodeableConcept);
    function GetUsageReasonList : TFhirCodeableConceptList;
    function GetHasUsageReasonList : Boolean;
    procedure SetInformationSource(value : TFhirReference);
    procedure SetDevice(value : TFhirCodeableReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    procedure SetBodySite(value : TFhirCodeableReference);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUseStatement; overload;
    function Clone : TFhirDeviceUseStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An external identifier for this statement such as an IRI.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this DeviceUseStatement.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A code representing the patient or other source's judgment about the state of the device used that this statement is about.  Generally this will be active or completed.
    property status : TFhirDeviceUseStatementStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // This attribute indicates a category for the statement - The device statement may be made in an inpatient or outpatient settting (inpatient | outpatient | community | patientspecified).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The patient who used the device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient who used the device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Allows linking the DeviceUseStatement to the underlying Request, or to other information that supports or is used to derive the DeviceUseStatement.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // Typed access to The encounter or episode of care that establishes the context for this device use statement. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this device use statement.
    property contextElement : TFhirReference read FContext write SetContext;

    // Typed access to How often the device was used. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // How often the device was used.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to The time at which the statement was recorded by informationSource.
    property dateAsserted : TFslDateTime read GetDateAssertedST write SetDateAssertedST;
    // The time at which the statement was recorded by informationSource.
    property dateAssertedElement : TFhirDateTime read FDateAsserted write SetDateAsserted;

    // Typed access to The status of the device usage, for example always, sometimes, never. This is not the same as the status of the statement. (defined for API consistency)
    property usageStatus : TFhirCodeableConcept read FUsageStatus write SetUsageStatus;
    // The status of the device usage, for example always, sometimes, never. This is not the same as the status of the statement.
    property usageStatusElement : TFhirCodeableConcept read FUsageStatus write SetUsageStatus;

    // The reason for asserting the usage status - for example forgot, lost, stolen, broken.
    property usageReasonList : TFhirCodeableConceptList read GetUsageReasonList;
    property hasUsageReasonList : boolean read GetHasUsageReasonList;

    // Typed access to Who reported the device was being used by the patient. (defined for API consistency)
    property informationSource : TFhirReference read FInformationSource write SetInformationSource;
    // Who reported the device was being used by the patient.
    property informationSourceElement : TFhirReference read FInformationSource write SetInformationSource;

    // Typed access to Code or Reference to device used. (defined for API consistency)
    property device : TFhirCodeableReference read FDevice write SetDevice;
    // Code or Reference to device used.
    property deviceElement : TFhirCodeableReference read FDevice write SetDevice;

    // Reason or justification for the use of the device. A coded concept, or another resource whose existence justifies this DeviceUseStatement.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to Indicates the anotomic location on the subject's body where the device was used ( i.e. the target). (defined for API consistency)
    property bodySite : TFhirCodeableReference read FBodySite write SetBodySite;
    // Indicates the anotomic location on the subject's body where the device was used ( i.e. the target).
    property bodySiteElement : TFhirCodeableReference read FBodySite write SetBodySite;

    // Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirDeviceUseStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUseStatementList;
    function GetCurrent : TFhirDeviceUseStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUseStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUseStatement read GetCurrent;
  end;

  TFhirDeviceUseStatementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceUseStatement;
    procedure SetItemN(index : Integer; value : TFhirDeviceUseStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceUseStatementList; overload;
    function Clone : TFhirDeviceUseStatementList; overload;
    function GetEnumerator : TFhirDeviceUseStatementListEnumerator;
    
    //  Add a FhirDeviceUseStatement to the end of the list.
    function Append : TFhirDeviceUseStatement;
    
    // Add an already existing FhirDeviceUseStatement to the end of the list.
    procedure AddItem(value : TFhirDeviceUseStatement); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUseStatement) : Integer;
    
    // Insert FhirDeviceUseStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUseStatement;
    
    // Insert an existing FhirDeviceUseStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUseStatement);
    
    // Get the iIndexth FhirDeviceUseStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUseStatement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUseStatement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceUseStatements[index : Integer] : TFhirDeviceUseStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  TFhirDiagnosticReportMedia = class (TFhirBackboneElement)
  protected
    FComment : TFhirString;
    FLink_ : TFhirReference;
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetLink_(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReportMedia; overload;
    function Clone : TFhirDiagnosticReportMedia; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property comment : String read GetCommentST write SetCommentST;
    // A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Reference to the image source. (defined for API consistency)
    property link_ : TFhirReference read FLink_ write SetLink_;
    // Reference to the image source.
    property link_Element : TFhirReference read FLink_ write SetLink_;

  end;

  TFhirDiagnosticReportMediaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportMediaList;
    function GetCurrent : TFhirDiagnosticReportMedia;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportMediaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportMedia read GetCurrent;
  end;

  TFhirDiagnosticReportMediaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportMedia;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportMedia);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDiagnosticReportMediaList; overload;
    function Clone : TFhirDiagnosticReportMediaList; overload;
    function GetEnumerator : TFhirDiagnosticReportMediaListEnumerator;
    
    //  Add a FhirDiagnosticReportMedia to the end of the list.
    function Append : TFhirDiagnosticReportMedia;
    
    // Add an already existing FhirDiagnosticReportMedia to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReportMedia); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReportMedia) : Integer;
    
    // Insert FhirDiagnosticReportMedia before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReportMedia;
    
    // Insert an existing FhirDiagnosticReportMedia before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportMedia);
    
    // Get the iIndexth FhirDiagnosticReportMedia. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportMedia);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReportMedia;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDiagnosticReportMedia[index : Integer] : TFhirDiagnosticReportMedia read GetItemN write SetItemN; default;
  End;

  // The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  TFhirDiagnosticReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList;
    FresultsInterpreterList : TFhirReferenceList;
    FspecimenList : TFhirReferenceList;
    FresultList : TFhirReferenceList;
    FimagingStudyList : TFhirReferenceList;
    FmediaList : TFhirDiagnosticReportMediaList;
    FConclusion : TFhirString;
    FconclusionCodeList : TFhirCodeableConceptList;
    FpresentedFormList : TFhirAttachmentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDiagnosticReportStatusEnum;
    procedure SetStatusST(value : TFhirDiagnosticReportStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetIssued(value : TFhirInstant);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    function GetResultsInterpreterList : TFhirReferenceList;
    function GetHasResultsInterpreterList : Boolean;
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    function GetResultList : TFhirReferenceList;
    function GetHasResultList : Boolean;
    function GetImagingStudyList : TFhirReferenceList;
    function GetHasImagingStudyList : Boolean;
    function GetMediaList : TFhirDiagnosticReportMediaList;
    function GetHasMediaList : Boolean;
    procedure SetConclusion(value : TFhirString);
    function GetConclusionST : String;
    procedure SetConclusionST(value : String);
    function GetConclusionCodeList : TFhirCodeableConceptList;
    function GetHasConclusionCodeList : Boolean;
    function GetPresentedFormList : TFhirAttachmentList;
    function GetHasPresentedFormList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReport; overload;
    function Clone : TFhirDiagnosticReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this report by the performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Details concerning a service requested.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The status of the diagnostic report.
    property status : TFhirDiagnosticReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code or name that describes this diagnostic report. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or name that describes this diagnostic report.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject of the report. Usually, but not always, this is a patient. However, diagnostic services also perform analyses on specimens collected from a variety of other sources. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject of the report. Usually, but not always, this is a patient. However, diagnostic services also perform analyses on specimens collected from a variety of other sources.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date and time that this version of the report was made available to providers, typically after the report was reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time that this version of the report was made available to providers, typically after the report was reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // The diagnostic service that is responsible for issuing the report.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The practitioner or organization that is responsible for the report's conclusions and interpretations.
    property resultsInterpreterList : TFhirReferenceList read GetResultsInterpreterList;
    property hasResultsInterpreterList : boolean read GetHasResultsInterpreterList;

    // Details about the specimens on which this diagnostic report is based.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // [Observations](observation.html)  that are part of this diagnostic report.
    property resultList : TFhirReferenceList read GetResultList;
    property hasResultList : boolean read GetHasResultList;

    // One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    property imagingStudyList : TFhirReferenceList read GetImagingStudyList;
    property hasImagingStudyList : boolean read GetHasImagingStudyList;

    // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    property mediaList : TFhirDiagnosticReportMediaList read GetMediaList;
    property hasMediaList : boolean read GetHasMediaList;

    // Typed access to Concise and clinically contextualized summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusion : String read GetConclusionST write SetConclusionST;
    // Concise and clinically contextualized summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusionElement : TFhirString read FConclusion write SetConclusion;

    // One or more codes that represent the summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusionCodeList : TFhirCodeableConceptList read GetConclusionCodeList;
    property hasConclusionCodeList : boolean read GetHasConclusionCodeList;

    // Rich text representation of the entire result as issued by the diagnostic service. Multiple formats are allowed but they SHALL be semantically equivalent.
    property presentedFormList : TFhirAttachmentList read GetPresentedFormList;
    property hasPresentedFormList : boolean read GetHasPresentedFormList;

  end;

  TFhirDiagnosticReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportList;
    function GetCurrent : TFhirDiagnosticReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReport read GetCurrent;
  end;

  TFhirDiagnosticReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReport;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDiagnosticReportList; overload;
    function Clone : TFhirDiagnosticReportList; overload;
    function GetEnumerator : TFhirDiagnosticReportListEnumerator;
    
    //  Add a FhirDiagnosticReport to the end of the list.
    function Append : TFhirDiagnosticReport;
    
    // Add an already existing FhirDiagnosticReport to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReport); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReport) : Integer;
    
    // Insert FhirDiagnosticReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReport;
    
    // Insert an existing FhirDiagnosticReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReport);
    
    // Get the iIndexth FhirDiagnosticReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDiagnosticReports[index : Integer] : TFhirDiagnosticReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  // Related identifiers or resources associated with the DocumentManifest.
  TFhirDocumentManifestRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetRef(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestRelated; overload;
    function Clone : TFhirDocumentManifestRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc. (defined for API consistency)
    property ref : TFhirReference read FRef write SetRef;
    // Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc.
    property refElement : TFhirReference read FRef write SetRef;

  end;

  TFhirDocumentManifestRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestRelatedList;
    function GetCurrent : TFhirDocumentManifestRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestRelated read GetCurrent;
  end;

  TFhirDocumentManifestRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentManifestRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentManifestRelatedList; overload;
    function Clone : TFhirDocumentManifestRelatedList; overload;
    function GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
    
    //  Add a FhirDocumentManifestRelated to the end of the list.
    function Append : TFhirDocumentManifestRelated;
    
    // Add an already existing FhirDocumentManifestRelated to the end of the list.
    procedure AddItem(value : TFhirDocumentManifestRelated); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestRelated) : Integer;
    
    // Insert FhirDocumentManifestRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestRelated;
    
    // Insert an existing FhirDocumentManifestRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestRelated);
    
    // Get the iIndexth FhirDocumentManifestRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentManifestRelateds[index : Integer] : TFhirDocumentManifestRelated read GetItemN write SetItemN; default;
  End;

  // A collection of documents compiled for a purpose together with metadata that applies to the collection.
  TFhirDocumentManifest = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FCreated : TFhirDateTime;
    FauthorList : TFhirReferenceList;
    FrecipientList : TFhirReferenceList;
    FSource : TFhirUri;
    FDescription : TFhirString;
    FcontentList : TFhirReferenceList;
    FrelatedList : TFhirDocumentManifestRelatedList;
    procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDocumentReferenceStatusEnum;
    procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    procedure SetSource(value : TFhirUri);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetContentList : TFhirReferenceList;
    function GetHasContentList : Boolean;
    function GetRelatedList : TFhirDocumentManifestRelatedList;
    function GetHasRelatedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifest; overload;
    function Clone : TFhirDocumentManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document manifest, including version independent  identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this document manifest.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The code specifying the type of clinical activity that resulted in placing the associated content into the DocumentManifest. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The code specifying the type of clinical activity that resulted in placing the associated content into the DocumentManifest.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Identifies who is the author of the manifest. Manifest author is not necessarly the author of the references included.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // A patient, practitioner, or organization for which this set of documents is intended.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to Identifies the source system, application, or software that produced the document manifest.
    property source : String read GetSourceST write SetSourceST;
    // Identifies the source system, application, or software that produced the document manifest.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The list of Resources that consist of the parts of this manifest.
    property contentList : TFhirReferenceList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Related identifiers or resources associated with the DocumentManifest.
    property relatedList : TFhirDocumentManifestRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestList;
    function GetCurrent : TFhirDocumentManifest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifest read GetCurrent;
  end;

  TFhirDocumentManifestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentManifest;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentManifestList; overload;
    function Clone : TFhirDocumentManifestList; overload;
    function GetEnumerator : TFhirDocumentManifestListEnumerator;
    
    //  Add a FhirDocumentManifest to the end of the list.
    function Append : TFhirDocumentManifest;
    
    // Add an already existing FhirDocumentManifest to the end of the list.
    procedure AddItem(value : TFhirDocumentManifest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifest) : Integer;
    
    // Insert FhirDocumentManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifest;
    
    // Insert an existing FhirDocumentManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifest);
    
    // Get the iIndexth FhirDocumentManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentManifests[index : Integer] : TFhirDocumentManifest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  // A participant who has attested to the accuracy of the composition/document.
  TFhirDocumentReferenceAttester = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FTime : TFhirDateTime;
    FParty : TFhirReference;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirDocumentAttestationModeEnum;
    procedure SetModeST(value : TFhirDocumentAttestationModeEnum);
    procedure SetTime(value : TFhirDateTime);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceAttester; overload;
    function Clone : TFhirDocumentReferenceAttester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of attestation the authenticator offers.
    property mode : TFhirDocumentAttestationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When the composition was attested by the party.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // When the composition was attested by the party.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Who attested the composition in the specified way. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Who attested the composition in the specified way.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirDocumentReferenceAttesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceAttesterList;
    function GetCurrent : TFhirDocumentReferenceAttester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceAttesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceAttester read GetCurrent;
  end;

  TFhirDocumentReferenceAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceAttester;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceAttester);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceAttesterList; overload;
    function Clone : TFhirDocumentReferenceAttesterList; overload;
    function GetEnumerator : TFhirDocumentReferenceAttesterListEnumerator;
    
    //  Add a FhirDocumentReferenceAttester to the end of the list.
    function Append : TFhirDocumentReferenceAttester;
    
    // Add an already existing FhirDocumentReferenceAttester to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceAttester); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceAttester) : Integer;
    
    // Insert FhirDocumentReferenceAttester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceAttester;
    
    // Insert an existing FhirDocumentReferenceAttester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceAttester);
    
    // Get the iIndexth FhirDocumentReferenceAttester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceAttester);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceAttester;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceAttesters[index : Integer] : TFhirDocumentReferenceAttester read GetItemN write SetItemN; default;
  End;

  // Relationships that this document has with other document references that already exist.
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirReference;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    procedure SetTarget(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this document has with anther document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target document of this relationship. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The target document of this relationship.
    property targetElement : TFhirReference read FTarget write SetTarget;

  end;

  TFhirDocumentReferenceRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceRelatesToList;
    function GetCurrent : TFhirDocumentReferenceRelatesTo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceRelatesTo read GetCurrent;
  end;

  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceRelatesToList; overload;
    function Clone : TFhirDocumentReferenceRelatesToList; overload;
    function GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
    
    //  Add a FhirDocumentReferenceRelatesTo to the end of the list.
    function Append : TFhirDocumentReferenceRelatesTo;
    
    // Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceRelatesTo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;
    
    // Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    // Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    // Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;

  // The document and format referenced.  If there are multiple content element repetitions, these must all represent the same document in different format, or attachment metadata.
  TFhirDocumentReferenceContent = class (TFhirBackboneElement)
  protected
    FAttachment : TFhirAttachment;
    FFormat : TFhirCoding;
    FIdentifier : TFhirIdentifier;
    procedure SetAttachment(value : TFhirAttachment);
    procedure SetFormat(value : TFhirCoding);
    procedure SetIdentifier(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContent; overload;
    function Clone : TFhirDocumentReferenceContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The document or URL of the document along with critical metadata to prove content has integrity. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // The document or URL of the document along with critical metadata to prove content has integrity.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

    // Typed access to An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType. (defined for API consistency)
    property format : TFhirCoding read FFormat write SetFormat;
    // An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType.
    property formatElement : TFhirCoding read FFormat write SetFormat;

    // Typed access to Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirDocumentReferenceContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContentList;
    function GetCurrent : TFhirDocumentReferenceContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContent read GetCurrent;
  end;

  TFhirDocumentReferenceContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceContentList; overload;
    function Clone : TFhirDocumentReferenceContentList; overload;
    function GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
    
    //  Add a FhirDocumentReferenceContent to the end of the list.
    function Append : TFhirDocumentReferenceContent;
    
    // Add an already existing FhirDocumentReferenceContent to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContent) : Integer;
    
    // Insert FhirDocumentReferenceContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContent;
    
    // Insert an existing FhirDocumentReferenceContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContent);
    
    // Get the iIndexth FhirDocumentReferenceContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceContents[index : Integer] : TFhirDocumentReferenceContent read GetItemN write SetItemN; default;
  End;

  // A reference to a document of any kind for any purpose. While the term “document” implies a more narrow focus, for this resource this "document" encompasses *any* serialized object with a mime-type, it includes formal patient-centric documents (CDA), clinical notes, scanned paper, non-patient specific documents like policy text, as well as a photo, video, or audio recording acquired or used in healthcare.  The DocumentReference resource provides metadata about the document so that the document can be discovered and managed.  The actual content may be inline base64 encoded data or provided by direct reference.
  TFhirDocumentReference = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FDocStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FencounterList : TFhirReferenceList;
    FeventList : TFhirCodeableConceptList;
    FFacilityType : TFhirCodeableConcept;
    FPracticeSetting : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FDate : TFhirInstant;
    FauthorList : TFhirReferenceList;
    FattesterList : TFhirDocumentReferenceAttesterList;
    FCustodian : TFhirReference;
    FrelatesToList : TFhirDocumentReferenceRelatesToList;
    FDescription : TFhirMarkdown;
    FsecurityLabelList : TFhirCodeableConceptList;
    FcontentList : TFhirDocumentReferenceContentList;
    FSourcePatientInfo : TFhirReference;
    FrelatedList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDocumentReferenceStatusEnum;
    procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    procedure SetDocStatus(value : TFhirEnum);
    function GetDocStatusST : TFhirCompositionStatusEnum;
    procedure SetDocStatusST(value : TFhirCompositionStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetEventList : TFhirCodeableConceptList;
    function GetHasEventList : Boolean;
    procedure SetFacilityType(value : TFhirCodeableConcept);
    procedure SetPracticeSetting(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetDate(value : TFhirInstant);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    function GetAttesterList : TFhirDocumentReferenceAttesterList;
    function GetHasAttesterList : Boolean;
    procedure SetCustodian(value : TFhirReference);
    function GetRelatesToList : TFhirDocumentReferenceRelatesToList;
    function GetHasRelatesToList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSecurityLabelList : TFhirCodeableConceptList;
    function GetHasSecurityLabelList : Boolean;
    function GetContentList : TFhirDocumentReferenceContentList;
    function GetHasContentList : Boolean;
    procedure SetSourcePatientInfo(value : TFhirReference);
    function GetRelatedList : TFhirReferenceList;
    function GetHasRelatedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReference; overload;
    function Clone : TFhirDocumentReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Other identifiers associated with the document, including version independent identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A procedure that is fulfilled in whole or in part by the creation of this media.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The status of this document reference.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status of the underlying document.
    property docStatus : TFhirCompositionStatusEnum read GetDocStatusST write SetDocStatusST;
    property docStatusElement : TFhirEnum read FDocStatus write SetDocStatus;

    // Typed access to Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Describes the clinical encounter or type of care that the document content is associated with.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the type Code, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property eventList : TFhirCodeableConceptList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to The kind of facility where the patient was seen. (defined for API consistency)
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;
    // The kind of facility where the patient was seen.
    property facilityTypeElement : TFhirCodeableConcept read FFacilityType write SetFacilityType;

    // Typed access to This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty. (defined for API consistency)
    property practiceSetting : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;
    // This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty.
    property practiceSettingElement : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;

    // Typed access to The time period over which the service that is described by the document was provided. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time period over which the service that is described by the document was provided.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to When the document reference was created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When the document reference was created.
    property dateElement : TFhirInstant read FDate write SetDate;

    // Identifies who is responsible for adding the information to the document.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // A participant who has attested to the accuracy of the composition/document.
    property attesterList : TFhirDocumentReferenceAttesterList read GetAttesterList;
    property hasAttesterList : boolean read GetHasAttesterList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. (defined for API consistency)
    property custodian : TFhirReference read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the document.
    property custodianElement : TFhirReference read FCustodian write SetCustodian;

    // Relationships that this document has with other document references that already exist.
    property relatesToList : TFhirDocumentReferenceRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // Typed access to Human-readable description of the source document.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A set of Security-Tag codes specifying the level of privacy/security of the Document. Note that DocumentReference.meta.security contains the security labels of the "reference" to the document, while DocumentReference.securityLabel contains a snapshot of the security labels on the document the reference refers to.
    property securityLabelList : TFhirCodeableConceptList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The document and format referenced.  If there are multiple content element repetitions, these must all represent the same document in different format, or attachment metadata.
    property contentList : TFhirDocumentReferenceContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Typed access to The Patient Information as known when the document was {$IFNDEF FPC}published{$ENDIF}. May be a reference to a version specific, or contained. (defined for API consistency)
    property sourcePatientInfo : TFhirReference read FSourcePatientInfo write SetSourcePatientInfo;
    // The Patient Information as known when the document was {$IFNDEF FPC}published{$ENDIF}. May be a reference to a version specific, or contained.
    property sourcePatientInfoElement : TFhirReference read FSourcePatientInfo write SetSourcePatientInfo;

    // Related identifiers or resources associated with the DocumentReference.
    property relatedList : TFhirReferenceList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceList;
    function GetCurrent : TFhirDocumentReference;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReference read GetCurrent;
  end;

  TFhirDocumentReferenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReference;
    procedure SetItemN(index : Integer; value : TFhirDocumentReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceList; overload;
    function Clone : TFhirDocumentReferenceList; overload;
    function GetEnumerator : TFhirDocumentReferenceListEnumerator;
    
    //  Add a FhirDocumentReference to the end of the list.
    function Append : TFhirDocumentReference;
    
    // Add an already existing FhirDocumentReference to the end of the list.
    procedure AddItem(value : TFhirDocumentReference); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReference) : Integer;
    
    // Insert FhirDocumentReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReference;
    
    // Insert an existing FhirDocumentReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReference);
    
    // Get the iIndexth FhirDocumentReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReference;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferences[index : Integer] : TFhirDocumentReference read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
  // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
  TFhirEpisodeOfCareStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareStatusHistory; overload;
    function Clone : TFhirEpisodeOfCareStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period during this EpisodeOfCare that the specific status applied. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during this EpisodeOfCare that the specific status applied.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEpisodeOfCareStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareStatusHistoryList;
    function GetCurrent : TFhirEpisodeOfCareStatusHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareStatusHistory read GetCurrent;
  end;

  TFhirEpisodeOfCareStatusHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareStatusHistoryList; overload;
    function Clone : TFhirEpisodeOfCareStatusHistoryList; overload;
    function GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
    
    //  Add a FhirEpisodeOfCareStatusHistory to the end of the list.
    function Append : TFhirEpisodeOfCareStatusHistory;
    
    // Add an already existing FhirEpisodeOfCareStatusHistory to the end of the list.
    procedure AddItem(value : TFhirEpisodeOfCareStatusHistory); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareStatusHistory) : Integer;
    
    // Insert FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    
    // Insert an existing FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // Get the iIndexth FhirEpisodeOfCareStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCareStatusHistories[index : Integer] : TFhirEpisodeOfCareStatusHistory read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this episode of care.
  TFhirEpisodeOfCareDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference;
    FRole : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    procedure SetCondition(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetRank(value : TFhirPositiveInt);
    function GetRankST : String;
    procedure SetRankST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareDiagnosis; overload;
    function Clone : TFhirEpisodeOfCareDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge …). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge …).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEpisodeOfCareDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareDiagnosisList;
    function GetCurrent : TFhirEpisodeOfCareDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareDiagnosis read GetCurrent;
  end;

  TFhirEpisodeOfCareDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareDiagnosisList; overload;
    function Clone : TFhirEpisodeOfCareDiagnosisList; overload;
    function GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
    
    //  Add a FhirEpisodeOfCareDiagnosis to the end of the list.
    function Append : TFhirEpisodeOfCareDiagnosis;
    
    // Add an already existing FhirEpisodeOfCareDiagnosis to the end of the list.
    procedure AddItem(value : TFhirEpisodeOfCareDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareDiagnosis) : Integer;
    
    // Insert FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    
    // Insert an existing FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // Get the iIndexth FhirEpisodeOfCareDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCareDiagnoses[index : Integer] : TFhirEpisodeOfCareDiagnosis read GetItemN write SetItemN; default;
  End;

  // An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.
  TFhirEpisodeOfCare = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FdiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    FPatient : TFhirReference;
    FManagingOrganization : TFhirReference;
    FPeriod : TFhirPeriod;
    FreferralRequestList : TFhirReferenceList;
    FCareManager : TFhirReference;
    FteamList : TFhirReferenceList;
    FaccountList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    function GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    function GetReferralRequestList : TFhirReferenceList;
    function GetHasReferralRequestList : Boolean;
    procedure SetCareManager(value : TFhirReference);
    function GetTeamList : TFhirReferenceList;
    function GetHasTeamList : Boolean;
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCare; overload;
    function Clone : TFhirEpisodeOfCare; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The EpisodeOfCare may be known by different identifiers for different contexts of use, such as when an external agency is tracking the Episode for funding purposes.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
    property statusHistoryList : TFhirEpisodeOfCareStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // A classification of the type of episode of care; e.g. specialist referral, disease management, type of funded care.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The list of diagnosis relevant to this episode of care.
    property diagnosisList : TFhirEpisodeOfCareDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Typed access to The patient who is the focus of this episode of care. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who is the focus of this episode of care.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The organization that has assumed the specific responsibilities for the specified duration. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that has assumed the specific responsibilities for the specified duration.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to The interval during which the managing organization assumes the defined responsibility. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the managing organization assumes the defined responsibility.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming referrals.
    property referralRequestList : TFhirReferenceList read GetReferralRequestList;
    property hasReferralRequestList : boolean read GetHasReferralRequestList;

    // Typed access to The practitioner that is the care manager/care coordinator for this patient. (defined for API consistency)
    property careManager : TFhirReference read FCareManager write SetCareManager;
    // The practitioner that is the care manager/care coordinator for this patient.
    property careManagerElement : TFhirReference read FCareManager write SetCareManager;

    // The list of practitioners that may be facilitating this episode of care for specific purposes.
    property teamList : TFhirReferenceList read GetTeamList;
    property hasTeamList : boolean read GetHasTeamList;

    // The set of accounts that may be used for billing for this EpisodeOfCare.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

  end;

  TFhirEpisodeOfCareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareList;
    function GetCurrent : TFhirEpisodeOfCare;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCare read GetCurrent;
  end;

  TFhirEpisodeOfCareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCare;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCare);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareList; overload;
    function Clone : TFhirEpisodeOfCareList; overload;
    function GetEnumerator : TFhirEpisodeOfCareListEnumerator;
    
    //  Add a FhirEpisodeOfCare to the end of the list.
    function Append : TFhirEpisodeOfCare;
    
    // Add an already existing FhirEpisodeOfCare to the end of the list.
    procedure AddItem(value : TFhirEpisodeOfCare); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCare) : Integer;
    
    // Insert FhirEpisodeOfCare before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCare;
    
    // Insert an existing FhirEpisodeOfCare before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCare);
    
    // Get the iIndexth FhirEpisodeOfCare. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCare);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCare;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCares[index : Integer] : TFhirEpisodeOfCare read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  TFhirFamilyMemberHistoryCondition = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FContributedToDeath : TFhirBoolean;
    FOnset : TFhirDataType;
    FnoteList : TFhirAnnotationList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetContributedToDeath(value : TFhirBoolean);
    function GetContributedToDeathST : Boolean;
    procedure SetContributedToDeathST(value : Boolean);
    procedure SetOnset(value : TFhirDataType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistoryCondition; overload;
    function Clone : TFhirFamilyMemberHistoryCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Indicates what happened following the condition.  If the condition resulted in death, deceased date is captured on the relation. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Indicates what happened following the condition.  If the condition resulted in death, deceased date is captured on the relation.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to This condition contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeath : Boolean read GetContributedToDeathST write SetContributedToDeathST;
    // This condition contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeathElement : TFhirBoolean read FContributedToDeath write SetContributedToDeath;

    // Typed access to Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // An area where general notes can be placed about this specific condition.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirFamilyMemberHistoryConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryConditionList;
    function GetCurrent : TFhirFamilyMemberHistoryCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistoryCondition read GetCurrent;
  end;

  TFhirFamilyMemberHistoryConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyMemberHistoryCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistoryCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFamilyMemberHistoryConditionList; overload;
    function Clone : TFhirFamilyMemberHistoryConditionList; overload;
    function GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
    
    //  Add a FhirFamilyMemberHistoryCondition to the end of the list.
    function Append : TFhirFamilyMemberHistoryCondition;
    
    // Add an already existing FhirFamilyMemberHistoryCondition to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistoryCondition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistoryCondition) : Integer;
    
    // Insert FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistoryCondition;
    
    // Insert an existing FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistoryCondition);
    
    // Get the iIndexth FhirFamilyMemberHistoryCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistoryCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistoryCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFamilyMemberHistoryConditions[index : Integer] : TFhirFamilyMemberHistoryCondition read GetItemN write SetItemN; default;
  End;

  // The significant Procedures (or procedure) that the family member had. This is a repeating section to allow a system to represent more than one procedure per resource, though there is nothing stopping multiple resources - one per procedure.
  TFhirFamilyMemberHistoryProcedure = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FContributedToDeath : TFhirBoolean;
    FPerformed : TFhirDataType;
    FnoteList : TFhirAnnotationList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetContributedToDeath(value : TFhirBoolean);
    function GetContributedToDeathST : Boolean;
    procedure SetContributedToDeathST(value : Boolean);
    procedure SetPerformed(value : TFhirDataType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistoryProcedure; overload;
    function Clone : TFhirFamilyMemberHistoryProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual procedure specified. Could be a coded procedure or a less specific string depending on how much is known about the procedure and the capabilities of the creating system. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual procedure specified. Could be a coded procedure or a less specific string depending on how much is known about the procedure and the capabilities of the creating system.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Indicates what happened following the procedure. If the procedure resulted in death, deceased date is captured on the relation. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Indicates what happened following the procedure. If the procedure resulted in death, deceased date is captured on the relation.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to This procedure contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeath : Boolean read GetContributedToDeathST write SetContributedToDeathST;
    // This procedure contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeathElement : TFhirBoolean read FContributedToDeath write SetContributedToDeath;

    // Typed access to Estimated or actual date, date-time, period, or age when the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured. (defined for API consistency)
    property performed : TFhirDataType read FPerformed write SetPerformed;
    // Estimated or actual date, date-time, period, or age when the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    property performedElement : TFhirDataType read FPerformed write SetPerformed;

    // An area where general notes can be placed about this specific procedure.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirFamilyMemberHistoryProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryProcedureList;
    function GetCurrent : TFhirFamilyMemberHistoryProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistoryProcedure read GetCurrent;
  end;

  TFhirFamilyMemberHistoryProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyMemberHistoryProcedure;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistoryProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFamilyMemberHistoryProcedureList; overload;
    function Clone : TFhirFamilyMemberHistoryProcedureList; overload;
    function GetEnumerator : TFhirFamilyMemberHistoryProcedureListEnumerator;
    
    //  Add a FhirFamilyMemberHistoryProcedure to the end of the list.
    function Append : TFhirFamilyMemberHistoryProcedure;
    
    // Add an already existing FhirFamilyMemberHistoryProcedure to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistoryProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistoryProcedure) : Integer;
    
    // Insert FhirFamilyMemberHistoryProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistoryProcedure;
    
    // Insert an existing FhirFamilyMemberHistoryProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistoryProcedure);
    
    // Get the iIndexth FhirFamilyMemberHistoryProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistoryProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistoryProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFamilyMemberHistoryProcedures[index : Integer] : TFhirFamilyMemberHistoryProcedure read GetItemN write SetItemN; default;
  End;

  // Significant health conditions for a person related to the patient relevant in the context of care for the patient.
  TFhirFamilyMemberHistory = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FStatus : TFhirEnum;
    FDataAbsentReason : TFhirCodeableConcept;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FSex : TFhirCodeableConcept;
    FBorn : TFhirDataType;
    FAge : TFhirDataType;
    FEstimatedAge : TFhirBoolean;
    FDeceased : TFhirDataType;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    FconditionList : TFhirFamilyMemberHistoryConditionList;
    Fprocedure_List : TFhirFamilyMemberHistoryProcedureList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFamilyHistoryStatusEnum;
    procedure SetStatusST(value : TFhirFamilyHistoryStatusEnum);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetSex(value : TFhirCodeableConcept);
    procedure SetBorn(value : TFhirDataType);
    procedure SetAge(value : TFhirDataType);
    procedure SetEstimatedAge(value : TFhirBoolean);
    function GetEstimatedAgeST : Boolean;
    procedure SetEstimatedAgeST(value : Boolean);
    procedure SetDeceased(value : TFhirDataType);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetConditionList : TFhirFamilyMemberHistoryConditionList;
    function GetHasConditionList : Boolean;
    function GetProcedure_List : TFhirFamilyMemberHistoryProcedureList;
    function GetHasProcedure_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistory; overload;
    function Clone : TFhirFamilyMemberHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this family member history by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this FamilyMemberHistory.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this FamilyMemberHistory.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A code specifying the status of the record of the family history of a specific family member.
    property status : TFhirFamilyHistoryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes why the family member's history is not available. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Describes why the family member's history is not available.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Typed access to The person who this history concerns. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person who this history concerns.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date (and possibly time) when the family member history was recorded or last updated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and possibly time) when the family member history was recorded or last updated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property name : String read GetNameST write SetNameST;
    // This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The type of relationship this person has to the patient (father, mother, brother etc.). (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The type of relationship this person has to the patient (father, mother, brother etc.).
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to The birth sex of the family member. (defined for API consistency)
    property sex : TFhirCodeableConcept read FSex write SetSex;
    // The birth sex of the family member.
    property sexElement : TFhirCodeableConcept read FSex write SetSex;

    // Typed access to The actual or approximate date of birth of the relative. (defined for API consistency)
    property born : TFhirDataType read FBorn write SetBorn;
    // The actual or approximate date of birth of the relative.
    property bornElement : TFhirDataType read FBorn write SetBorn;

    // Typed access to The age of the relative at the time the family member history is recorded. (defined for API consistency)
    property age : TFhirDataType read FAge write SetAge;
    // The age of the relative at the time the family member history is recorded.
    property ageElement : TFhirDataType read FAge write SetAge;

    // Typed access to If true, indicates that the age value specified is an estimated value.
    property estimatedAge : Boolean read GetEstimatedAgeST write SetEstimatedAgeST;
    // If true, indicates that the age value specified is an estimated value.
    property estimatedAgeElement : TFhirBoolean read FEstimatedAge write SetEstimatedAge;

    // Typed access to Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // Describes why the family member history occurred in coded or textual form, or Indicates a Condition, Observation, AllergyIntolerance, or QuestionnaireResponse that justifies this family member history event.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    property conditionList : TFhirFamilyMemberHistoryConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // The significant Procedures (or procedure) that the family member had. This is a repeating section to allow a system to represent more than one procedure per resource, though there is nothing stopping multiple resources - one per procedure.
    property procedure_List : TFhirFamilyMemberHistoryProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

  end;

  TFhirFamilyMemberHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryList;
    function GetCurrent : TFhirFamilyMemberHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistory read GetCurrent;
  end;

  TFhirFamilyMemberHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyMemberHistory;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFamilyMemberHistoryList; overload;
    function Clone : TFhirFamilyMemberHistoryList; overload;
    function GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
    
    //  Add a FhirFamilyMemberHistory to the end of the list.
    function Append : TFhirFamilyMemberHistory;
    
    // Add an already existing FhirFamilyMemberHistory to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistory); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistory) : Integer;
    
    // Insert FhirFamilyMemberHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistory;
    
    // Insert an existing FhirFamilyMemberHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistory);
    
    // Get the iIndexth FhirFamilyMemberHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFamilyMemberHistories[index : Integer] : TFhirFamilyMemberHistory read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  // Prospective warnings of potential issues when providing care to the patient.
  TFhirFlag = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FPeriod : TFhirPeriod;
    FEncounter : TFhirReference;
    FAuthor : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFlagStatusEnum;
    procedure SetStatusST(value : TFhirFlagStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthor(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFlag; overload;
    function Clone : TFhirFlag; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this flag by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Supports basic workflow.
    property status : TFhirFlagStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Allows a flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The coded value or textual component of the flag to display to the user. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The coded value or textual component of the flag to display to the user.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to This alert is only relevant during the encounter. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // This alert is only relevant during the encounter.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The person, organization or device that created the flag. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The person, organization or device that created the flag.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirFlagListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFlagList;
    function GetCurrent : TFhirFlag;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFlagList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFlag read GetCurrent;
  end;

  TFhirFlagList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFlag;
    procedure SetItemN(index : Integer; value : TFhirFlag);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFlagList; overload;
    function Clone : TFhirFlagList; overload;
    function GetEnumerator : TFhirFlagListEnumerator;
    
    //  Add a FhirFlag to the end of the list.
    function Append : TFhirFlag;
    
    // Add an already existing FhirFlag to the end of the list.
    procedure AddItem(value : TFhirFlag); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFlag) : Integer;
    
    // Insert FhirFlag before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFlag;
    
    // Insert an existing FhirFlag before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFlag);
    
    // Get the iIndexth FhirFlag. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFlag);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFlag;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFlags[index : Integer] : TFhirFlag read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  // Indicates what should be done by when.
  TFhirGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirDataType;
    FDue : TFhirDataType;
    procedure SetMeasure(value : TFhirCodeableConcept);
    procedure SetDetail(value : TFhirDataType);
    procedure SetDue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoalTarget; overload;
    function Clone : TFhirGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value. (defined for API consistency)
    property detail : TFhirDataType read FDetail write SetDetail;
    // The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
    property detailElement : TFhirDataType read FDetail write SetDetail;

    // Typed access to Indicates either the date or the duration after start by which the goal should be met. (defined for API consistency)
    property due : TFhirDataType read FDue write SetDue;
    // Indicates either the date or the duration after start by which the goal should be met.
    property dueElement : TFhirDataType read FDue write SetDue;

  end;

  TFhirGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalTargetList;
    function GetCurrent : TFhirGoalTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoalTarget read GetCurrent;
  end;

  TFhirGoalTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGoalTargetList; overload;
    function Clone : TFhirGoalTargetList; overload;
    function GetEnumerator : TFhirGoalTargetListEnumerator;
    
    //  Add a FhirGoalTarget to the end of the list.
    function Append : TFhirGoalTarget;
    
    // Add an already existing FhirGoalTarget to the end of the list.
    procedure AddItem(value : TFhirGoalTarget); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoalTarget) : Integer;
    
    // Insert FhirGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoalTarget;
    
    // Insert an existing FhirGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoalTarget);
    
    // Get the iIndexth FhirGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoalTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGoalTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGoalTargets[index : Integer] : TFhirGoalTarget read GetItemN write SetItemN; default;
  End;

  // Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
  TFhirGoal = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FLifecycleStatus : TFhirEnum;
    FAchievementStatus : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FContinuous : TFhirBoolean;
    FPriority : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FStart : TFhirDataType;
    FtargetList : TFhirGoalTargetList;
    FStatusDate : TFhirDate;
    FStatusReason : TFhirString;
    FExpressedBy : TFhirReference;
    FaddressesList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FoutcomeList : TFhirCodeableReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetLifecycleStatus(value : TFhirEnum);
    function GetLifecycleStatusST : TFhirGoalLifecycleStatusEnum;
    procedure SetLifecycleStatusST(value : TFhirGoalLifecycleStatusEnum);
    procedure SetAchievementStatus(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetContinuous(value : TFhirBoolean);
    function GetContinuousST : Boolean;
    procedure SetContinuousST(value : Boolean);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetStart(value : TFhirDataType);
    function GetTargetList : TFhirGoalTargetList;
    function GetHasTargetList : Boolean;
    procedure SetStatusDate(value : TFhirDate);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetStatusReason(value : TFhirString);
    function GetStatusReasonST : String;
    procedure SetStatusReasonST(value : String);
    procedure SetExpressedBy(value : TFhirReference);
    function GetAddressesList : TFhirReferenceList;
    function GetHasAddressesList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetOutcomeList : TFhirCodeableReferenceList;
    function GetHasOutcomeList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoal; overload;
    function Clone : TFhirGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this goal by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The state of the goal throughout its lifecycle.
    property lifecycleStatus : TFhirGoalLifecycleStatusEnum read GetLifecycleStatusST write SetLifecycleStatusST;
    property lifecycleStatusElement : TFhirEnum read FLifecycleStatus write SetLifecycleStatus;

    // Typed access to Describes the progression, or lack thereof, towards the goal against the target. (defined for API consistency)
    property achievementStatus : TFhirCodeableConcept read FAchievementStatus write SetAchievementStatus;
    // Describes the progression, or lack thereof, towards the goal against the target.
    property achievementStatusElement : TFhirCodeableConcept read FAchievementStatus write SetAchievementStatus;

    // Indicates a category the goal falls within.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to After meeting the goal, ongoing activity is needed to sustain the goal objective.
    property continuous : Boolean read GetContinuousST write SetContinuousST;
    // After meeting the goal, ongoing activity is needed to sustain the goal objective.
    property continuousElement : TFhirBoolean read FContinuous write SetContinuous;

    // Typed access to Identifies the mutually agreed level of importance associated with reaching/sustaining the goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the mutually agreed level of importance associated with reaching/sustaining the goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the patient, group or organization for whom the goal is being established. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient, group or organization for whom the goal is being established.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The date or event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirDataType read FStart write SetStart;
    // The date or event after which the goal should begin being pursued.
    property startElement : TFhirDataType read FStart write SetStart;

    // Indicates what should be done by when.
    property targetList : TFhirGoalTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDateElement : TFhirDate read FStatusDate write SetStatusDate;

    // Typed access to Captures the reason for the current status.
    property statusReason : String read GetStatusReasonST write SetStatusReasonST;
    // Captures the reason for the current status.
    property statusReasonElement : TFhirString read FStatusReason write SetStatusReason;

    // Typed access to Indicates whose goal this is - patient goal, practitioner goal, etc. (defined for API consistency)
    property expressedBy : TFhirReference read FExpressedBy write SetExpressedBy;
    // Indicates whose goal this is - patient goal, practitioner goal, etc.
    property expressedByElement : TFhirReference read FExpressedBy write SetExpressedBy;

    // The identified conditions and other health record elements that are intended to be addressed by the goal.
    property addressesList : TFhirReferenceList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Any comments related to the goal.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Identifies the change (or lack of change) at the point when the status of the goal is assessed.
    property outcomeList : TFhirCodeableReferenceList read GetOutcomeList;
    property hasOutcomeList : boolean read GetHasOutcomeList;

  end;

  TFhirGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalList;
    function GetCurrent : TFhirGoal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoal read GetCurrent;
  end;

  TFhirGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGoal;
    procedure SetItemN(index : Integer; value : TFhirGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGoalList; overload;
    function Clone : TFhirGoalList; overload;
    function GetEnumerator : TFhirGoalListEnumerator;
    
    //  Add a FhirGoal to the end of the list.
    function Append : TFhirGoal;
    
    // Add an already existing FhirGoal to the end of the list.
    procedure AddItem(value : TFhirGoal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoal) : Integer;
    
    // Insert FhirGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoal;
    
    // Insert an existing FhirGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoal);
    
    // Get the iIndexth FhirGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGoal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGoals[index : Integer] : TFhirGoal read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
  // The procedure or code from which this ImagingStudy was part of.
  TFhirImagingStudyProcedure = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudyProcedure; overload;
    function Clone : TFhirImagingStudyProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The procedure which this ImagingStudy was part of. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The procedure which this ImagingStudy was part of.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirImagingStudyProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudyProcedureList;
    function GetCurrent : TFhirImagingStudyProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudyProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudyProcedure read GetCurrent;
  end;

  TFhirImagingStudyProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudyProcedure;
    procedure SetItemN(index : Integer; value : TFhirImagingStudyProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudyProcedureList; overload;
    function Clone : TFhirImagingStudyProcedureList; overload;
    function GetEnumerator : TFhirImagingStudyProcedureListEnumerator;
    
    //  Add a FhirImagingStudyProcedure to the end of the list.
    function Append : TFhirImagingStudyProcedure;
    
    // Add an already existing FhirImagingStudyProcedure to the end of the list.
    procedure AddItem(value : TFhirImagingStudyProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudyProcedure) : Integer;
    
    // Insert FhirImagingStudyProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudyProcedure;
    
    // Insert an existing FhirImagingStudyProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudyProcedure);
    
    // Get the iIndexth FhirImagingStudyProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudyProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudyProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudyProcedures[index : Integer] : TFhirImagingStudyProcedure read GetItemN write SetItemN; default;
  End;

  // Each study has one or more series of images or other content.
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  protected
    FUid : TFhirId;
    FNumber : TFhirUnsignedInt;
    FModality : TFhirCoding;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirUnsignedInt;
    FendpointList : TFhirReferenceList;
    FBodySite : TFhirCoding;
    FLaterality : TFhirCoding;
    FspecimenList : TFhirReferenceList;
    FStarted : TFhirDateTime;
    FperformerList : TFhirImagingStudySeriesPerformerList;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    procedure SetUid(value : TFhirId);
    function GetUidST : String;
    procedure SetUidST(value : String);
    procedure SetNumber(value : TFhirUnsignedInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetModality(value : TFhirCoding);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    function GetNumberOfInstancesST : String;
    procedure SetNumberOfInstancesST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    procedure SetBodySite(value : TFhirCoding);
    procedure SetLaterality(value : TFhirCoding);
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    procedure SetStarted(value : TFhirDateTime);
    function GetStartedST : TFslDateTime;
    procedure SetStartedST(value : TFslDateTime);
    function GetPerformerList : TFhirImagingStudySeriesPerformerList;
    function GetHasPerformerList : Boolean;
    function GetInstanceList : TFhirImagingStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The DICOM Series Instance UID for the series.
    property uid : String read GetUidST write SetUidST;
    // The DICOM Series Instance UID for the series.
    property uidElement : TFhirId read FUid write SetUid;

    // Typed access to The numeric identifier of this series in the study.
    property number : String read GetNumberST write SetNumberST;
    // The numeric identifier of this series in the study.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The distinct modality for this series. This may include both aquisition and non-aquisition modalities. (defined for API consistency)
    property modality : TFhirCoding read FModality write SetModality;
    // The distinct modality for this series. This may include both aquisition and non-aquisition modalities.
    property modalityElement : TFhirCoding read FModality write SetModality;

    // Typed access to A description of the series.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the series.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // The network service providing access (e.g., query, view, or retrieval) for this series. See implementation notes for information about using DICOM endpoints. A series-level endpoint, if present, has precedence over a study-level endpoint with the same Endpoint.connectionType.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality. (defined for API consistency)
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    // The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality.
    property bodySiteElement : TFhirCoding read FBodySite write SetBodySite;

    // Typed access to The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite. (defined for API consistency)
    property laterality : TFhirCoding read FLaterality write SetLaterality;
    // The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite.
    property lateralityElement : TFhirCoding read FLaterality write SetLaterality;

    // The specimen imaged, e.g., for whole slide imaging of a biopsy.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Typed access to The date and time the series was started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // The date and time the series was started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // Indicates who or what performed the series and how they were involved.
    property performerList : TFhirImagingStudySeriesPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // A single SOP instance within the series, e.g. an image, or presentation state.
    property instanceList : TFhirImagingStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesList;
    function GetCurrent : TFhirImagingStudySeries;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeries read GetCurrent;
  end;

  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesList; overload;
    function Clone : TFhirImagingStudySeriesList; overload;
    function GetEnumerator : TFhirImagingStudySeriesListEnumerator;
    
    //  Add a FhirImagingStudySeries to the end of the list.
    function Append : TFhirImagingStudySeries;
    
    // Add an already existing FhirImagingStudySeries to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeries); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeries) : Integer;
    
    // Insert FhirImagingStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeries;
    
    // Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);
    
    // Get the iIndexth FhirImagingStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeries;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;

  // Indicates who or what performed the series and how they were involved.
  TFhirImagingStudySeriesPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesPerformer; overload;
    function Clone : TFhirImagingStudySeriesPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the series. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the series.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what performed the series. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what performed the series.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirImagingStudySeriesPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesPerformerList;
    function GetCurrent : TFhirImagingStudySeriesPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesPerformer read GetCurrent;
  end;

  TFhirImagingStudySeriesPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesPerformer;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesPerformerList; overload;
    function Clone : TFhirImagingStudySeriesPerformerList; overload;
    function GetEnumerator : TFhirImagingStudySeriesPerformerListEnumerator;
    
    //  Add a FhirImagingStudySeriesPerformer to the end of the list.
    function Append : TFhirImagingStudySeriesPerformer;
    
    // Add an already existing FhirImagingStudySeriesPerformer to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeriesPerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesPerformer) : Integer;
    
    // Insert FhirImagingStudySeriesPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesPerformer;
    
    // Insert an existing FhirImagingStudySeriesPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesPerformer);
    
    // Get the iIndexth FhirImagingStudySeriesPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeriesPerformers[index : Integer] : TFhirImagingStudySeriesPerformer read GetItemN write SetItemN; default;
  End;

  // A single SOP instance within the series, e.g. an image, or presentation state.
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FUid : TFhirId;
    FSopClass : TFhirCoding;
    FNumber : TFhirUnsignedInt;
    FTitle : TFhirString;
    procedure SetUid(value : TFhirId);
    function GetUidST : String;
    procedure SetUidST(value : String);
    procedure SetSopClass(value : TFhirCoding);
    procedure SetNumber(value : TFhirUnsignedInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The DICOM SOP Instance UID for this image or other DICOM content.
    property uid : String read GetUidST write SetUidST;
    // The DICOM SOP Instance UID for this image or other DICOM content.
    property uidElement : TFhirId read FUid write SetUid;

    // Typed access to DICOM instance  type. (defined for API consistency)
    property sopClass : TFhirCoding read FSopClass write SetSopClass;
    // DICOM instance  type.
    property sopClassElement : TFhirCoding read FSopClass write SetSopClass;

    // Typed access to The number of instance in the series.
    property number : String read GetNumberST write SetNumberST;
    // The number of instance in the series.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The description of the instance.
    property title : String read GetTitleST write SetTitleST;
    // The description of the instance.
    property titleElement : TFhirString read FTitle write SetTitle;

  end;

  TFhirImagingStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesInstanceList;
    function GetCurrent : TFhirImagingStudySeriesInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesInstanceList; overload;
    function Clone : TFhirImagingStudySeriesInstanceList; overload;
    function GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
    
    //  Add a FhirImagingStudySeriesInstance to the end of the list.
    function Append : TFhirImagingStudySeriesInstance;
    
    // Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeriesInstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;
    
    // Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;
    
    // Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    // Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
  TFhirImagingStudy = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FmodalityList : TFhirCodingList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FStarted : TFhirDateTime;
    FbasedOnList : TFhirReferenceList;
    FReferrer : TFhirReference;
    FinterpreterList : TFhirReferenceList;
    FendpointList : TFhirReferenceList;
    FNumberOfSeries : TFhirUnsignedInt;
    FNumberOfInstances : TFhirUnsignedInt;
    Fprocedure_List : TFhirImagingStudyProcedureList;
    FLocation : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    FDescription : TFhirString;
    FseriesList : TFhirImagingStudySeriesList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImagingStudyStatusEnum;
    procedure SetStatusST(value : TFhirImagingStudyStatusEnum);
    function GetModalityList : TFhirCodingList;
    function GetHasModalityList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetStarted(value : TFhirDateTime);
    function GetStartedST : TFslDateTime;
    procedure SetStartedST(value : TFslDateTime);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetReferrer(value : TFhirReference);
    function GetInterpreterList : TFhirReferenceList;
    function GetHasInterpreterList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    procedure SetNumberOfSeries(value : TFhirUnsignedInt);
    function GetNumberOfSeriesST : String;
    procedure SetNumberOfSeriesST(value : String);
    procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    function GetNumberOfInstancesST : String;
    procedure SetNumberOfInstancesST(value : String);
    function GetProcedure_List : TFhirImagingStudyProcedureList;
    function GetHasProcedure_List : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSeriesList : TFhirImagingStudySeriesList;
    function GetHasSeriesList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudy; overload;
    function Clone : TFhirImagingStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers for the ImagingStudy such as DICOM Study Instance UID, and Accession Number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the ImagingStudy.
    property status : TFhirImagingStudyStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A list of all the distinct values of series.modality. This may include both aquisition and non-aquisition modalities.
    property modalityList : TFhirCodingList read GetModalityList;
    property hasModalityList : boolean read GetHasModalityList;

    // Typed access to The subject, typically a patient, of the imaging study. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject, typically a patient, of the imaging study.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Date and time the study started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // Date and time the study started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // A list of the diagnostic requests that resulted in this imaging study being performed.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to The requesting/referring physician. (defined for API consistency)
    property referrer : TFhirReference read FReferrer write SetReferrer;
    // The requesting/referring physician.
    property referrerElement : TFhirReference read FReferrer write SetReferrer;

    // Who read the study and interpreted the images or other content.
    property interpreterList : TFhirReferenceList read GetInterpreterList;
    property hasInterpreterList : boolean read GetHasInterpreterList;

    // The network service providing access (e.g., query, view, or retrieval) for the study. See implementation notes for information about using DICOM endpoints. A study-level endpoint applies to each series in the study, unless overridden by a series-level endpoint with the same Endpoint.connectionType.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeries : String read GetNumberOfSeriesST write SetNumberOfSeriesST;
    // Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeriesElement : TFhirUnsignedInt read FNumberOfSeries write SetNumberOfSeries;

    // Typed access to Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // The procedure or code from which this ImagingStudy was part of.
    property procedure_List : TFhirImagingStudyProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to The principal physical location where the ImagingStudy was performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The principal physical location where the ImagingStudy was performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Description of clinical condition indicating why the ImagingStudy was requested, and/or Indicates another resource whose existence justifies this Study.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Per the recommended DICOM mapping, this element is derived from the Study Description attribute (0008,1030). Observations or findings about the imaging study should be recorded in another resource, e.g. Observation, and not in this element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The Imaging Manager description of the study. Institution-generated description or classification of the Study (component) performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The Imaging Manager description of the study. Institution-generated description or classification of the Study (component) performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Each study has one or more series of images or other content.
    property seriesList : TFhirImagingStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudyList;
    function GetCurrent : TFhirImagingStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudy read GetCurrent;
  end;

  TFhirImagingStudyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudyList; overload;
    function Clone : TFhirImagingStudyList; overload;
    function GetEnumerator : TFhirImagingStudyListEnumerator;
    
    //  Add a FhirImagingStudy to the end of the list.
    function Append : TFhirImagingStudy;
    
    // Add an already existing FhirImagingStudy to the end of the list.
    procedure AddItem(value : TFhirImagingStudy); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudy) : Integer;
    
    // Insert FhirImagingStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudy;
    
    // Insert an existing FhirImagingStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudy);
    
    // Get the iIndexth FhirImagingStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudies[index : Integer] : TFhirImagingStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  // Indicates who performed the immunization event.
  TFhirImmunizationPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationPerformer; overload;
    function Clone : TFhirImmunizationPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of performance (e.g. ordering provider, administering provider, etc.). (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Describes the type of performance (e.g. ordering provider, administering provider, etc.).
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The practitioner or organization who performed the action. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The practitioner or organization who performed the action.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirImmunizationPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationPerformerList;
    function GetCurrent : TFhirImmunizationPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationPerformer read GetCurrent;
  end;

  TFhirImmunizationPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationPerformer;
    procedure SetItemN(index : Integer; value : TFhirImmunizationPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationPerformerList; overload;
    function Clone : TFhirImmunizationPerformerList; overload;
    function GetEnumerator : TFhirImmunizationPerformerListEnumerator;
    
    //  Add a FhirImmunizationPerformer to the end of the list.
    function Append : TFhirImmunizationPerformer;
    
    // Add an already existing FhirImmunizationPerformer to the end of the list.
    procedure AddItem(value : TFhirImmunizationPerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationPerformer) : Integer;
    
    // Insert FhirImmunizationPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationPerformer;
    
    // Insert an existing FhirImmunizationPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationPerformer);
    
    // Get the iIndexth FhirImmunizationPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationPerformers[index : Integer] : TFhirImmunizationPerformer read GetItemN write SetItemN; default;
  End;

  // Educational material presented to the patient (or guardian) at the time of vaccine administration.
  TFhirImmunizationEducation = class (TFhirBackboneElement)
  protected
    FDocumentType : TFhirString;
    FReference : TFhirUri;
    FPublicationDate : TFhirDateTime;
    FPresentationDate : TFhirDateTime;
    procedure SetDocumentType(value : TFhirString);
    function GetDocumentTypeST : String;
    procedure SetDocumentTypeST(value : String);
    procedure SetReference(value : TFhirUri);
    function GetReferenceST : String;
    procedure SetReferenceST(value : String);
    procedure SetPublicationDate(value : TFhirDateTime);
    function GetPublicationDateST : TFslDateTime;
    procedure SetPublicationDateST(value : TFslDateTime);
    procedure SetPresentationDate(value : TFhirDateTime);
    function GetPresentationDateST : TFslDateTime;
    procedure SetPresentationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationEducation; overload;
    function Clone : TFhirImmunizationEducation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier of the material presented to the patient.
    property documentType : String read GetDocumentTypeST write SetDocumentTypeST;
    // Identifier of the material presented to the patient.
    property documentTypeElement : TFhirString read FDocumentType write SetDocumentType;

    // Typed access to Reference pointer to the educational material given to the patient if the information was on line.
    property reference : String read GetReferenceST write SetReferenceST;
    // Reference pointer to the educational material given to the patient if the information was on line.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Typed access to Date the educational material was {$IFNDEF FPC}published{$ENDIF}.
    property publicationDate : TFslDateTime read GetPublicationDateST write SetPublicationDateST;
    // Date the educational material was {$IFNDEF FPC}published{$ENDIF}.
    property publicationDateElement : TFhirDateTime read FPublicationDate write SetPublicationDate;

    // Typed access to Date the educational material was given to the patient.
    property presentationDate : TFslDateTime read GetPresentationDateST write SetPresentationDateST;
    // Date the educational material was given to the patient.
    property presentationDateElement : TFhirDateTime read FPresentationDate write SetPresentationDate;

  end;

  TFhirImmunizationEducationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationEducationList;
    function GetCurrent : TFhirImmunizationEducation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationEducationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationEducation read GetCurrent;
  end;

  TFhirImmunizationEducationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationEducation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationEducation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationEducationList; overload;
    function Clone : TFhirImmunizationEducationList; overload;
    function GetEnumerator : TFhirImmunizationEducationListEnumerator;
    
    //  Add a FhirImmunizationEducation to the end of the list.
    function Append : TFhirImmunizationEducation;
    
    // Add an already existing FhirImmunizationEducation to the end of the list.
    procedure AddItem(value : TFhirImmunizationEducation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationEducation) : Integer;
    
    // Insert FhirImmunizationEducation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationEducation;
    
    // Insert an existing FhirImmunizationEducation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationEducation);
    
    // Get the iIndexth FhirImmunizationEducation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationEducation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationEducation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationEducations[index : Integer] : TFhirImmunizationEducation read GetItemN write SetItemN; default;
  End;

  // Categorical data indicating that an adverse event is associated in time to an immunization.
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FDetail : TFhirReference;
    FReported : TFhirBoolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetDetail(value : TFhirReference);
    procedure SetReported(value : TFhirBoolean);
    function GetReportedST : Boolean;
    procedure SetReportedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of reaction to the immunization.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of reaction to the immunization.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Details of the reaction. (defined for API consistency)
    property detail : TFhirReference read FDetail write SetDetail;
    // Details of the reaction.
    property detailElement : TFhirReference read FDetail write SetDetail;

    // Typed access to Self-reported indicator.
    property reported : Boolean read GetReportedST write SetReportedST;
    // Self-reported indicator.
    property reportedElement : TFhirBoolean read FReported write SetReported;

  end;

  TFhirImmunizationReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationReactionList;
    function GetCurrent : TFhirImmunizationReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationReaction read GetCurrent;
  end;

  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationReactionList; overload;
    function Clone : TFhirImmunizationReactionList; overload;
    function GetEnumerator : TFhirImmunizationReactionListEnumerator;
    
    //  Add a FhirImmunizationReaction to the end of the list.
    function Append : TFhirImmunizationReaction;
    
    // Add an already existing FhirImmunizationReaction to the end of the list.
    procedure AddItem(value : TFhirImmunizationReaction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationReaction) : Integer;
    
    // Insert FhirImmunizationReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationReaction;
    
    // Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);
    
    // Get the iIndexth FhirImmunizationReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationReaction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;

  // The protocol (set of recommendations) being followed by the provider who administered the dose.
  TFhirImmunizationProtocolApplied = class (TFhirBackboneElement)
  protected
    FSeries : TFhirString;
    FAuthority : TFhirReference;
    FtargetDiseaseList : TFhirCodeableConceptList;
    FDoseNumber : TFhirString;
    FSeriesDoses : TFhirString;
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetAuthority(value : TFhirReference);
    function GetTargetDiseaseList : TFhirCodeableConceptList;
    function GetHasTargetDiseaseList : Boolean;
    procedure SetDoseNumber(value : TFhirString);
    function GetDoseNumberST : String;
    procedure SetDoseNumberST(value : String);
    procedure SetSeriesDoses(value : TFhirString);
    function GetSeriesDosesST : String;
    procedure SetSeriesDosesST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationProtocolApplied; overload;
    function Clone : TFhirImmunizationProtocolApplied; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP) that is being followed. (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP) that is being followed.
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // The vaccine preventable disease the dose is being administered against.
    property targetDiseaseList : TFhirCodeableConceptList read GetTargetDiseaseList;
    property hasTargetDiseaseList : boolean read GetHasTargetDiseaseList;

    // Typed access to Nominal position in a series as intended by the practitioner administering the dose.
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    // Nominal position in a series as intended by the practitioner administering the dose.
    property doseNumberElement : TFhirString read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity as intended by the practitioner administering the dose.
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    // The recommended number of doses to achieve immunity as intended by the practitioner administering the dose.
    property seriesDosesElement : TFhirString read FSeriesDoses write SetSeriesDoses;

  end;

  TFhirImmunizationProtocolAppliedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationProtocolAppliedList;
    function GetCurrent : TFhirImmunizationProtocolApplied;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationProtocolAppliedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationProtocolApplied read GetCurrent;
  end;

  TFhirImmunizationProtocolAppliedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProtocolApplied;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProtocolApplied);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationProtocolAppliedList; overload;
    function Clone : TFhirImmunizationProtocolAppliedList; overload;
    function GetEnumerator : TFhirImmunizationProtocolAppliedListEnumerator;
    
    //  Add a FhirImmunizationProtocolApplied to the end of the list.
    function Append : TFhirImmunizationProtocolApplied;
    
    // Add an already existing FhirImmunizationProtocolApplied to the end of the list.
    procedure AddItem(value : TFhirImmunizationProtocolApplied); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationProtocolApplied) : Integer;
    
    // Insert FhirImmunizationProtocolApplied before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationProtocolApplied;
    
    // Insert an existing FhirImmunizationProtocolApplied before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationProtocolApplied);
    
    // Get the iIndexth FhirImmunizationProtocolApplied. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProtocolApplied);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationProtocolApplied;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationProtocolApplieds[index : Integer] : TFhirImmunizationProtocolApplied read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.
  TFhirImmunization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FVaccineCode : TFhirCodeableConcept;
    FManufacturer : TFhirReference;
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDate;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FRecorded : TFhirDateTime;
    FPrimarySource : TFhirBoolean;
    FInformationSource : TFhirDataType;
    FLocation : TFhirReference;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FperformerList : TFhirImmunizationPerformerList;
    FnoteList : TFhirAnnotationList;
    FreasonList : TFhirCodeableReferenceList;
    FIsSubpotent : TFhirBoolean;
    FsubpotentReasonList : TFhirCodeableConceptList;
    FeducationList : TFhirImmunizationEducationList;
    FprogramEligibilityList : TFhirCodeableConceptList;
    FFundingSource : TFhirCodeableConcept;
    FreactionList : TFhirImmunizationReactionList;
    FprotocolAppliedList : TFhirImmunizationProtocolAppliedList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImmunizationStatusCodesEnum;
    procedure SetStatusST(value : TFhirImmunizationStatusCodesEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetVaccineCode(value : TFhirCodeableConcept);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpirationDate(value : TFhirDate);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetRecorded(value : TFhirDateTime);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetPrimarySource(value : TFhirBoolean);
    function GetPrimarySourceST : Boolean;
    procedure SetPrimarySourceST(value : Boolean);
    procedure SetInformationSource(value : TFhirDataType);
    procedure SetLocation(value : TFhirReference);
    procedure SetSite(value : TFhirCodeableConcept);
    procedure SetRoute(value : TFhirCodeableConcept);
    procedure SetDoseQuantity(value : TFhirQuantity);
    function GetPerformerList : TFhirImmunizationPerformerList;
    function GetHasPerformerList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    procedure SetIsSubpotent(value : TFhirBoolean);
    function GetIsSubpotentST : Boolean;
    procedure SetIsSubpotentST(value : Boolean);
    function GetSubpotentReasonList : TFhirCodeableConceptList;
    function GetHasSubpotentReasonList : Boolean;
    function GetEducationList : TFhirImmunizationEducationList;
    function GetHasEducationList : Boolean;
    function GetProgramEligibilityList : TFhirCodeableConceptList;
    function GetHasProgramEligibilityList : Boolean;
    procedure SetFundingSource(value : TFhirCodeableConcept);
    function GetReactionList : TFhirImmunizationReactionList;
    function GetHasReactionList : Boolean;
    function GetProtocolAppliedList : TFhirImmunizationProtocolAppliedList;
    function GetHasProtocolAppliedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunization; overload;
    function Clone : TFhirImmunization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this immunization record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Immunization.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Immunization.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, order or recommendation fulfilled in whole or in part by this immunization.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Indicates the current status of the immunization event.
    property status : TFhirImmunizationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates the reason the immunization event was not performed. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Indicates the reason the immunization event was not performed.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Vaccine that was administered or was to be administered. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that was administered or was to be administered.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to Name of vaccine manufacturer. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Name of vaccine manufacturer.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Lot number of the  vaccine product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number of the  vaccine product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to Date vaccine batch expires.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // Date vaccine batch expires.
    property expirationDateElement : TFhirDate read FExpirationDate write SetExpirationDate;

    // Typed access to The patient who either received or did not receive the immunization. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who either received or did not receive the immunization.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The visit or admission or other contact between patient and health care provider the immunization was performed as part of. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Date vaccine administered or was to be administered. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // Date vaccine administered or was to be administered.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
    property recordedElement : TFhirDateTime read FRecorded write SetRecorded;

    // Typed access to Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.
    property primarySource : Boolean read GetPrimarySourceST write SetPrimarySourceST;
    // Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.
    property primarySourceElement : TFhirBoolean read FPrimarySource write SetPrimarySource;

    // Typed access to Typically the source of the data when the report of the immunization event is not based on information from the person who administered the vaccine. (defined for API consistency)
    property informationSource : TFhirDataType read FInformationSource write SetInformationSource;
    // Typically the source of the data when the report of the immunization event is not based on information from the person who administered the vaccine.
    property informationSourceElement : TFhirDataType read FInformationSource write SetInformationSource;

    // Typed access to The service delivery location where the vaccine administration occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The service delivery location where the vaccine administration occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to Body site where vaccine was administered. (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // Body site where vaccine was administered.
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to The path by which the vaccine product is taken into the body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // The path by which the vaccine product is taken into the body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to The quantity of vaccine product that was administered. (defined for API consistency)
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;
    // The quantity of vaccine product that was administered.
    property doseQuantityElement : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    // Indicates who performed the immunization event.
    property performerList : TFhirImmunizationPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Extra information about the immunization that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Describes why the immunization occurred in coded or textual form, or Indicates another resource (Condition, Observation or DiagnosticReport) whose existence justifies this immunization.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent.
    property isSubpotent : Boolean read GetIsSubpotentST write SetIsSubpotentST;
    // Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent.
    property isSubpotentElement : TFhirBoolean read FIsSubpotent write SetIsSubpotent;

    // Reason why a dose is considered to be subpotent.
    property subpotentReasonList : TFhirCodeableConceptList read GetSubpotentReasonList;
    property hasSubpotentReasonList : boolean read GetHasSubpotentReasonList;

    // Educational material presented to the patient (or guardian) at the time of vaccine administration.
    property educationList : TFhirImmunizationEducationList read GetEducationList;
    property hasEducationList : boolean read GetHasEducationList;

    // Indicates a patient's eligibility for a funding program.
    property programEligibilityList : TFhirCodeableConceptList read GetProgramEligibilityList;
    property hasProgramEligibilityList : boolean read GetHasProgramEligibilityList;

    // Typed access to Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered). (defined for API consistency)
    property fundingSource : TFhirCodeableConcept read FFundingSource write SetFundingSource;
    // Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).
    property fundingSourceElement : TFhirCodeableConcept read FFundingSource write SetFundingSource;

    // Categorical data indicating that an adverse event is associated in time to an immunization.
    property reactionList : TFhirImmunizationReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

    // The protocol (set of recommendations) being followed by the provider who administered the dose.
    property protocolAppliedList : TFhirImmunizationProtocolAppliedList read GetProtocolAppliedList;
    property hasProtocolAppliedList : boolean read GetHasProtocolAppliedList;

  end;

  TFhirImmunizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationList;
    function GetCurrent : TFhirImmunization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunization read GetCurrent;
  end;

  TFhirImmunizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunization;
    procedure SetItemN(index : Integer; value : TFhirImmunization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationList; overload;
    function Clone : TFhirImmunizationList; overload;
    function GetEnumerator : TFhirImmunizationListEnumerator;
    
    //  Add a FhirImmunization to the end of the list.
    function Append : TFhirImmunization;
    
    // Add an already existing FhirImmunization to the end of the list.
    procedure AddItem(value : TFhirImmunization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunization) : Integer;
    
    // Insert FhirImmunization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunization;
    
    // Insert an existing FhirImmunization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunization);
    
    // Get the iIndexth FhirImmunization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizations[index : Integer] : TFhirImmunization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  // Describes a comparison of an immunization event against {$IFNDEF FPC}published{$ENDIF} recommendations to determine if the administration is "valid" in relation to those  recommendations.
  TFhirImmunizationEvaluation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FAuthority : TFhirReference;
    FTargetDisease : TFhirCodeableConcept;
    FImmunizationEvent : TFhirReference;
    FDoseStatus : TFhirCodeableConcept;
    FdoseStatusReasonList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FSeries : TFhirString;
    FDoseNumber : TFhirString;
    FSeriesDoses : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImmunizationEvaluationStatusCodesEnum;
    procedure SetStatusST(value : TFhirImmunizationEvaluationStatusCodesEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthority(value : TFhirReference);
    procedure SetTargetDisease(value : TFhirCodeableConcept);
    procedure SetImmunizationEvent(value : TFhirReference);
    procedure SetDoseStatus(value : TFhirCodeableConcept);
    function GetDoseStatusReasonList : TFhirCodeableConceptList;
    function GetHasDoseStatusReasonList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetDoseNumber(value : TFhirString);
    function GetDoseNumberST : String;
    procedure SetDoseNumberST(value : String);
    procedure SetSeriesDoses(value : TFhirString);
    function GetSeriesDosesST : String;
    procedure SetSeriesDosesST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationEvaluation; overload;
    function Clone : TFhirImmunizationEvaluation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this immunization evaluation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current status of the evaluation of the vaccination administration event.
    property status : TFhirImmunizationEvaluationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The individual for whom the evaluation is being done. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The individual for whom the evaluation is being done.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date the evaluation of the vaccine administration event was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the evaluation of the vaccine administration event was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP). (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP).
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // Typed access to The vaccine preventable disease the dose is being evaluated against. (defined for API consistency)
    property targetDisease : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;
    // The vaccine preventable disease the dose is being evaluated against.
    property targetDiseaseElement : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;

    // Typed access to The vaccine administration event being evaluated. (defined for API consistency)
    property immunizationEvent : TFhirReference read FImmunizationEvent write SetImmunizationEvent;
    // The vaccine administration event being evaluated.
    property immunizationEventElement : TFhirReference read FImmunizationEvent write SetImmunizationEvent;

    // Typed access to Indicates if the dose is valid or not valid with respect to the {$IFNDEF FPC}published{$ENDIF} recommendations. (defined for API consistency)
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;
    // Indicates if the dose is valid or not valid with respect to the {$IFNDEF FPC}published{$ENDIF} recommendations.
    property doseStatusElement : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    // Provides an explanation as to why the vaccine administration event is valid or not relative to the {$IFNDEF FPC}published{$ENDIF} recommendations.
    property doseStatusReasonList : TFhirCodeableConceptList read GetDoseStatusReasonList;
    property hasDoseStatusReasonList : boolean read GetHasDoseStatusReasonList;

    // Typed access to Additional information about the evaluation.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Additional information about the evaluation.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Nominal position in a series as determined by the outcome of the evaluation process.
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    // Nominal position in a series as determined by the outcome of the evaluation process.
    property doseNumberElement : TFhirString read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity as determined by the outcome of the evaluation process.
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    // The recommended number of doses to achieve immunity as determined by the outcome of the evaluation process.
    property seriesDosesElement : TFhirString read FSeriesDoses write SetSeriesDoses;

  end;

  TFhirImmunizationEvaluationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationEvaluationList;
    function GetCurrent : TFhirImmunizationEvaluation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationEvaluationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationEvaluation read GetCurrent;
  end;

  TFhirImmunizationEvaluationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationEvaluation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationEvaluation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationEvaluationList; overload;
    function Clone : TFhirImmunizationEvaluationList; overload;
    function GetEnumerator : TFhirImmunizationEvaluationListEnumerator;
    
    //  Add a FhirImmunizationEvaluation to the end of the list.
    function Append : TFhirImmunizationEvaluation;
    
    // Add an already existing FhirImmunizationEvaluation to the end of the list.
    procedure AddItem(value : TFhirImmunizationEvaluation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationEvaluation) : Integer;
    
    // Insert FhirImmunizationEvaluation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationEvaluation;
    
    // Insert an existing FhirImmunizationEvaluation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationEvaluation);
    
    // Get the iIndexth FhirImmunizationEvaluation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationEvaluation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationEvaluation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationEvaluations[index : Integer] : TFhirImmunizationEvaluation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  // Vaccine administration recommendations.
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  protected
    FvaccineCodeList : TFhirCodeableConceptList;
    FtargetDiseaseList : TFhirCodeableConceptList;
    FcontraindicatedVaccineCodeList : TFhirCodeableConceptList;
    FForecastStatus : TFhirCodeableConcept;
    FforecastReasonList : TFhirCodeableConceptList;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FDescription : TFhirString;
    FSeries : TFhirString;
    FDoseNumber : TFhirString;
    FSeriesDoses : TFhirString;
    FsupportingImmunizationList : TFhirReferenceList;
    FsupportingPatientInformationList : TFhirReferenceList;
    function GetVaccineCodeList : TFhirCodeableConceptList;
    function GetHasVaccineCodeList : Boolean;
    function GetTargetDiseaseList : TFhirCodeableConceptList;
    function GetHasTargetDiseaseList : Boolean;
    function GetContraindicatedVaccineCodeList : TFhirCodeableConceptList;
    function GetHasContraindicatedVaccineCodeList : Boolean;
    procedure SetForecastStatus(value : TFhirCodeableConcept);
    function GetForecastReasonList : TFhirCodeableConceptList;
    function GetHasForecastReasonList : Boolean;
    function GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetHasDateCriterionList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetDoseNumber(value : TFhirString);
    function GetDoseNumberST : String;
    procedure SetDoseNumberST(value : String);
    procedure SetSeriesDoses(value : TFhirString);
    function GetSeriesDosesST : String;
    procedure SetSeriesDosesST(value : String);
    function GetSupportingImmunizationList : TFhirReferenceList;
    function GetHasSupportingImmunizationList : Boolean;
    function GetSupportingPatientInformationList : TFhirReferenceList;
    function GetHasSupportingPatientInformationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Vaccine(s) or vaccine group that pertain to the recommendation.
    property vaccineCodeList : TFhirCodeableConceptList read GetVaccineCodeList;
    property hasVaccineCodeList : boolean read GetHasVaccineCodeList;

    // The targeted disease for the recommendation.
    property targetDiseaseList : TFhirCodeableConceptList read GetTargetDiseaseList;
    property hasTargetDiseaseList : boolean read GetHasTargetDiseaseList;

    // Vaccine(s) which should not be used to fulfill the recommendation.
    property contraindicatedVaccineCodeList : TFhirCodeableConceptList read GetContraindicatedVaccineCodeList;
    property hasContraindicatedVaccineCodeList : boolean read GetHasContraindicatedVaccineCodeList;

    // Typed access to Indicates the patient status with respect to the path to immunity for the target disease. (defined for API consistency)
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;
    // Indicates the patient status with respect to the path to immunity for the target disease.
    property forecastStatusElement : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    // The reason for the assigned forecast status.
    property forecastReasonList : TFhirCodeableConceptList read GetForecastReasonList;
    property hasForecastReasonList : boolean read GetHasForecastReasonList;

    // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read GetDateCriterionList;
    property hasDateCriterionList : boolean read GetHasDateCriterionList;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Nominal position of the recommended dose in a series as determined by the evaluation and forecasting process (e.g. dose 2 is the next recommended dose).
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    // Nominal position of the recommended dose in a series as determined by the evaluation and forecasting process (e.g. dose 2 is the next recommended dose).
    property doseNumberElement : TFhirString read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity as determined by the evaluation and forecasting process.
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    // The recommended number of doses to achieve immunity as determined by the evaluation and forecasting process.
    property seriesDosesElement : TFhirString read FSeriesDoses write SetSeriesDoses;

    // Immunization event history and/or evaluation that supports the status and recommendation.
    property supportingImmunizationList : TFhirReferenceList read GetSupportingImmunizationList;
    property hasSupportingImmunizationList : boolean read GetHasSupportingImmunizationList;

    // Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    property supportingPatientInformationList : TFhirReferenceList read GetSupportingPatientInformationList;
    property hasSupportingPatientInformationList : boolean read GetHasSupportingPatientInformationList;

  end;

  TFhirImmunizationRecommendationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationRecommendationList; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
    
    //  Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendation;
    
    // Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;
    
    // Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    // Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    // Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;

  // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDateTime);
    function GetValueST : TFslDateTime;
    procedure SetValueST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date classification of recommendation.  For example, earliest date to give, latest date to give, etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Date classification of recommendation.  For example, earliest date to give, latest date to give, etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date whose meaning is specified by dateCriterion.code.
    property value : TFslDateTime read GetValueST write SetValueST;
    // The date whose meaning is specified by dateCriterion.code.
    property valueElement : TFhirDateTime read FValue write SetValue;

  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationDateCriterion read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
    
    //  Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;
    
    // Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    // Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;

  // A patient's point-in-time set of recommendations (i.e. forecasting) according to a {$IFNDEF FPC}published{$ENDIF} schedule with optional supporting justification.
  TFhirImmunizationRecommendation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FAuthority : TFhirReference;
    FrecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthority(value : TFhirReference);
    function GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetHasRecommendationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this particular recommendation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline or other definition that is adhered to in whole or in part by this ImmunizationRecommendation.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline or other definition that is adhered to in whole or in part by this ImmunizationRecommendation.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Typed access to The patient the recommendation(s) are for. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient the recommendation(s) are for.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date the immunization recommendation(s) were created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the immunization recommendation(s) were created.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP). (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}published{$ENDIF} the protocol (e.g. ACIP).
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // Vaccine administration recommendations.
    property recommendationList : TFhirImmunizationRecommendationRecommendationList read GetRecommendationList;
    property hasRecommendationList : boolean read GetHasRecommendationList;

  end;

  TFhirImmunizationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationList; overload;
    function Clone : TFhirImmunizationRecommendationList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
    
    //  Add a FhirImmunizationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendation;
    
    // Add an already existing FhirImmunizationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendation) : Integer;
    
    // Insert FhirImmunizationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendation;
    
    // Insert an existing FhirImmunizationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendation);
    
    // Get the iIndexth FhirImmunizationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendations[index : Integer] : TFhirImmunizationRecommendation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  // Indicates who or what performed the medication administration and how they were involved.
  TFhirMedicationAdministrationPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationPerformer; overload;
    function Clone : TFhirMedicationAdministrationPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the medication administration. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the medication administration.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what performed the medication administration. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what performed the medication administration.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirMedicationAdministrationPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationPerformerList;
    function GetCurrent : TFhirMedicationAdministrationPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationPerformer read GetCurrent;
  end;

  TFhirMedicationAdministrationPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationPerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationPerformerList; overload;
    function Clone : TFhirMedicationAdministrationPerformerList; overload;
    function GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;
    
    //  Add a FhirMedicationAdministrationPerformer to the end of the list.
    function Append : TFhirMedicationAdministrationPerformer;
    
    // Add an already existing FhirMedicationAdministrationPerformer to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministrationPerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationPerformer) : Integer;
    
    // Insert FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationPerformer;
    
    // Insert an existing FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationPerformer);
    
    // Get the iIndexth FhirMedicationAdministrationPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrationPerformers[index : Integer] : TFhirMedicationAdministrationPerformer read GetItemN write SetItemN; default;
  End;

  // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDose : TFhirQuantity;
    FRate : TFhirDataType;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetSite(value : TFhirCodeableConcept);
    procedure SetRoute(value : TFhirCodeableConcept);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetDose(value : TFhirQuantity);
    procedure SetRate(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property text : String read GetTextST write SetTextST;
    // Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm". (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm".
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection. (defined for API consistency)
    property dose : TFhirQuantity read FDose write SetDose;
    // The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    property doseElement : TFhirQuantity read FDose write SetDose;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirDataType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirDataType read FRate write SetRate;

  end;

  TFhirMedicationAdministrationDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationDosageList;
    function GetCurrent : TFhirMedicationAdministrationDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationDosage read GetCurrent;
  end;

  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationDosageList; overload;
    function Clone : TFhirMedicationAdministrationDosageList; overload;
    function GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
    
    //  Add a FhirMedicationAdministrationDosage to the end of the list.
    function Append : TFhirMedicationAdministrationDosage;
    
    // Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministrationDosage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;
    
    // Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;
    
    // Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    // Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
  TFhirMedicationAdministration = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FcategoryList : TFhirCodeableConceptList;
    FMedication : TFhirCodeableReference;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FOccurence : TFhirDataType;
    FRecorded : TFhirDateTime;
    FperformerList : TFhirMedicationAdministrationPerformerList;
    FreasonList : TFhirCodeableReferenceList;
    FRequest : TFhirReference;
    FdeviceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FDosage : TFhirMedicationAdministrationDosage;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationAdministrationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationAdministrationStatusCodesEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetMedication(value : TFhirCodeableReference);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetOccurence(value : TFhirDataType);
    procedure SetRecorded(value : TFhirDateTime);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    function GetPerformerList : TFhirMedicationAdministrationPerformerList;
    function GetHasPerformerList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    procedure SetRequest(value : TFhirReference);
    function GetDeviceList : TFhirReferenceList;
    function GetHasDeviceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetDosage(value : TFhirMedicationAdministrationDosage);
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministration; overload;
    function Clone : TFhirMedicationAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Administration that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset, or other definition that was adhered to in whole or in part by this event.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this MedicationAdministration.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan that is fulfilled in whole or in part by this MedicationAdministration.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Will generally be set to show that the administration has been completed.  For some long running administrations such as infusions, it is possible for an administration to be started but not completed or it may be paused while some other process is under way.
    property status : TFhirMedicationAdministrationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code indicating why the administration was not performed.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // The type of medication administration (for example, drug classification like ATC, where meds would be administered, legal category of the medication).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirCodeableReference read FMedication write SetMedication;
    // Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirCodeableReference read FMedication write SetMedication;

    // Typed access to The person or animal or group receiving the medication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person or animal or group receiving the medication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The visit, admission, or other contact between patient and health care provider during which the medication administration was performed. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The visit, admission, or other contact between patient and health care provider during which the medication administration was performed.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Additional information (for example, patient height and weight) that supports the administration of the medication.  This attribute can be used to provide documentation of specific characteristics of the patient present at the time of administration.  For example, if the dose says "give "x" if the heartrate exceeds "y"", then the heart rate can be included using this attribute.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to A specific date/time or interval of time during which the administration took place (or did not take place). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate. (defined for API consistency)
    property occurence : TFhirDataType read FOccurence write SetOccurence;
    // A specific date/time or interval of time during which the administration took place (or did not take place). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate.
    property occurenceElement : TFhirDataType read FOccurence write SetOccurence;

    // Typed access to The date the occurrence of the  MedicationAdministration was first captured in the record - potentially significantly after the occurrence of the event.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The date the occurrence of the  MedicationAdministration was first captured in the record - potentially significantly after the occurrence of the event.
    property recordedElement : TFhirDateTime read FRecorded write SetRecorded;

    // Indicates who or what performed the medication administration and how they were involved.
    property performerList : TFhirMedicationAdministrationPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // A code, Condition or observation that supports why the medication was administered.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to The original request, instruction or authority to perform the administration. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // The original request, instruction or authority to perform the administration.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The device used in administering the medication to the patient.  For example, a particular infusion pump.
    property deviceList : TFhirReferenceList read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Extra information about the medication administration that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Describes the medication dosage information details e.g. dose, rate, site, route, etc. (defined for API consistency)
    property dosage : TFhirMedicationAdministrationDosage read FDosage write SetDosage;
    // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
    property dosageElement : TFhirMedicationAdministrationDosage read FDosage write SetDosage;

    // A summary of the events of interest that have occurred, such as when the administration was verified.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationList;
    function GetCurrent : TFhirMedicationAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministration read GetCurrent;
  end;

  TFhirMedicationAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministration;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationList; overload;
    function Clone : TFhirMedicationAdministrationList; overload;
    function GetEnumerator : TFhirMedicationAdministrationListEnumerator;
    
    //  Add a FhirMedicationAdministration to the end of the list.
    function Append : TFhirMedicationAdministration;
    
    // Add an already existing FhirMedicationAdministration to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministration); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministration) : Integer;
    
    // Insert FhirMedicationAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministration;
    
    // Insert an existing FhirMedicationAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministration);
    
    // Get the iIndexth FhirMedicationAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrations[index : Integer] : TFhirMedicationAdministration read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  // Indicates who or what performed the event.
  TFhirMedicationDispensePerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispensePerformer; overload;
    function Clone : TFhirMedicationDispensePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of performer in the dispense.  For example, date enterer, packager, final checker. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of performer in the dispense.  For example, date enterer, packager, final checker.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirMedicationDispensePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispensePerformerList;
    function GetCurrent : TFhirMedicationDispensePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispensePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispensePerformer read GetCurrent;
  end;

  TFhirMedicationDispensePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispensePerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispensePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispensePerformerList; overload;
    function Clone : TFhirMedicationDispensePerformerList; overload;
    function GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;
    
    //  Add a FhirMedicationDispensePerformer to the end of the list.
    function Append : TFhirMedicationDispensePerformer;
    
    // Add an already existing FhirMedicationDispensePerformer to the end of the list.
    procedure AddItem(value : TFhirMedicationDispensePerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispensePerformer) : Integer;
    
    // Insert FhirMedicationDispensePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispensePerformer;
    
    // Insert an existing FhirMedicationDispensePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispensePerformer);
    
    // Get the iIndexth FhirMedicationDispensePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispensePerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispensePerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispensePerformers[index : Integer] : TFhirMedicationDispensePerformer read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  protected
    FWasSubstituted : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FResponsibleParty : TFhirReference;
    procedure SetWasSubstituted(value : TFhirBoolean);
    function GetWasSubstitutedST : Boolean;
    procedure SetWasSubstitutedST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    procedure SetResponsibleParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstituted : Boolean read GetWasSubstitutedST write SetWasSubstitutedST;
    // True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstitutedElement : TFhirBoolean read FWasSubstituted write SetWasSubstituted;

    // Typed access to A code signifying whether a different drug was dispensed from what was prescribed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code signifying whether a different drug was dispensed from what was prescribed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Indicates the reason for the substitution (or lack of substitution) from what was prescribed.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to The person or organization that has primary responsibility for the substitution. (defined for API consistency)
    property responsibleParty : TFhirReference read FResponsibleParty write SetResponsibleParty;
    // The person or organization that has primary responsibility for the substitution.
    property responsiblePartyElement : TFhirReference read FResponsibleParty write SetResponsibleParty;

  end;

  TFhirMedicationDispenseSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseSubstitutionList;
    function GetCurrent : TFhirMedicationDispenseSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseSubstitution read GetCurrent;
  end;

  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispenseSubstitutionList; overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; overload;
    function GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
    
    //  Add a FhirMedicationDispenseSubstitution to the end of the list.
    function Append : TFhirMedicationDispenseSubstitution;
    
    // Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationDispenseSubstitution); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;
    
    // Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    // Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    // Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;

  // Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
  TFhirMedicationDispense = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableReference;
    FcategoryList : TFhirCodeableConceptList;
    FMedication : TFhirCodeableReference;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FperformerList : TFhirMedicationDispensePerformerList;
    FLocation : TFhirReference;
    FauthorizingPrescriptionList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FDaysSupply : TFhirQuantity;
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirReference;
    FreceiverList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FRenderedDosageInstruction : TFhirString;
    FdosageInstructionList : TFhirDosageList;
    FSubstitution : TFhirMedicationDispenseSubstitution;
    FdetectedIssueList : TFhirReferenceList;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationDispenseStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationDispenseStatusCodesEnum);
    procedure SetStatusReason(value : TFhirCodeableReference);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetMedication(value : TFhirCodeableReference);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    function GetPerformerList : TFhirMedicationDispensePerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetAuthorizingPrescriptionList : TFhirReferenceList;
    function GetHasAuthorizingPrescriptionList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDaysSupply(value : TFhirQuantity);
    procedure SetWhenPrepared(value : TFhirDateTime);
    function GetWhenPreparedST : TFslDateTime;
    procedure SetWhenPreparedST(value : TFslDateTime);
    procedure SetWhenHandedOver(value : TFhirDateTime);
    function GetWhenHandedOverST : TFslDateTime;
    procedure SetWhenHandedOverST(value : TFslDateTime);
    procedure SetDestination(value : TFhirReference);
    function GetReceiverList : TFhirReferenceList;
    function GetHasReceiverList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetRenderedDosageInstruction(value : TFhirString);
    function GetRenderedDosageInstructionST : String;
    procedure SetRenderedDosageInstructionST(value : String);
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    procedure SetSubstitution(value : TFhirMedicationDispenseSubstitution);
    function GetDetectedIssueList : TFhirReferenceList;
    function GetHasDetectedIssueList : Boolean;
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispense; overload;
    function Clone : TFhirMedicationDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Dispense that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan that is fulfilled in whole or in part by this MedicationDispense.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The procedure or medication administration that triggered the dispense.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the set of dispense events.
    property status : TFhirMedicationDispenseStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates the reason why a dispense was not performed. (defined for API consistency)
    property statusReason : TFhirCodeableReference read FStatusReason write SetStatusReason;
    // Indicates the reason why a dispense was not performed.
    property statusReasonElement : TFhirCodeableReference read FStatusReason write SetStatusReason;

    // Indicates the type of medication dispense (for example, drug classification like ATC, where meds would be administered, legal category of the medication.).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirCodeableReference read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirCodeableReference read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or the group to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // A link to a resource representing the person or the group to whom the medication will be given.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that establishes the context for this event. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that establishes the context for this event.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Additional information that supports the medication being dispensed.  For example, there may be requirements that a specific lab test has been completed prior to dispensing or the patient's weight at the time of dispensing is documented.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Indicates who or what performed the event.
    property performerList : TFhirMedicationDispensePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The principal physical location where the dispense was performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The principal physical location where the dispense was performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Indicates the medication order that is being dispensed against.
    property authorizingPrescriptionList : TFhirReferenceList read GetAuthorizingPrescriptionList;
    property hasAuthorizingPrescriptionList : boolean read GetHasAuthorizingPrescriptionList;

    // Typed access to Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount of medication that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of medication that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount of medication expressed as a timing amount. (defined for API consistency)
    property daysSupply : TFhirQuantity read FDaysSupply write SetDaysSupply;
    // The amount of medication expressed as a timing amount.
    property daysSupplyElement : TFhirQuantity read FDaysSupply write SetDaysSupply;

    // Typed access to The time when the dispensed product was packaged and reviewed.
    property whenPrepared : TFslDateTime read GetWhenPreparedST write SetWhenPreparedST;
    // The time when the dispensed product was packaged and reviewed.
    property whenPreparedElement : TFhirDateTime read FWhenPrepared write SetWhenPrepared;

    // Typed access to The time the dispensed product was provided to the patient or their representative.
    property whenHandedOver : TFslDateTime read GetWhenHandedOverST write SetWhenHandedOverST;
    // The time the dispensed product was provided to the patient or their representative.
    property whenHandedOverElement : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;

    // Typed access to Identification of the facility/location where the medication was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Identifies the person who picked up the medication or the location of where the medication was delivered.  This will usually be a patient or their caregiver, but some cases exist where it can be a healthcare professional or a location.
    property receiverList : TFhirReferenceList read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

    // Extra information about the dispense that could not be conveyed in the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstruction : String read GetRenderedDosageInstructionST write SetRenderedDosageInstructionST;
    // The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstructionElement : TFhirString read FRenderedDosageInstruction write SetRenderedDosageInstruction;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done. (defined for API consistency)
    property substitution : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
    property substitutionElement : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // A summary of the events of interest that have occurred, such as when the dispense was verified.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseList;
    function GetCurrent : TFhirMedicationDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispense read GetCurrent;
  end;

  TFhirMedicationDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispenseList; overload;
    function Clone : TFhirMedicationDispenseList; overload;
    function GetEnumerator : TFhirMedicationDispenseListEnumerator;
    
    //  Add a FhirMedicationDispense to the end of the list.
    function Append : TFhirMedicationDispense;
    
    // Add an already existing FhirMedicationDispense to the end of the list.
    procedure AddItem(value : TFhirMedicationDispense); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispense) : Integer;
    
    // Insert FhirMedicationDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispense;
    
    // Insert an existing FhirMedicationDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispense);
    
    // Get the iIndexth FhirMedicationDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispense;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispenses[index : Integer] : TFhirMedicationDispense read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
  TFhirMedicationRequestDispenseRequest = class (TFhirBackboneElement)
  protected
    FInitialFill : TFhirMedicationRequestDispenseRequestInitialFill;
    FDispenseInterval : TFhirDuration;
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirUnsignedInt;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirDuration;
    FDispenser : TFhirReference;
    procedure SetInitialFill(value : TFhirMedicationRequestDispenseRequestInitialFill);
    procedure SetDispenseInterval(value : TFhirDuration);
    procedure SetValidityPeriod(value : TFhirPeriod);
    procedure SetNumberOfRepeatsAllowed(value : TFhirUnsignedInt);
    function GetNumberOfRepeatsAllowedST : String;
    procedure SetNumberOfRepeatsAllowedST(value : String);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetExpectedSupplyDuration(value : TFhirDuration);
    procedure SetDispenser(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestDispenseRequest; overload;
    function Clone : TFhirMedicationRequestDispenseRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the quantity or duration for the first dispense of the medication. (defined for API consistency)
    property initialFill : TFhirMedicationRequestDispenseRequestInitialFill read FInitialFill write SetInitialFill;
    // Indicates the quantity or duration for the first dispense of the medication.
    property initialFillElement : TFhirMedicationRequestDispenseRequestInitialFill read FInitialFill write SetInitialFill;

    // Typed access to The minimum period of time that must occur between dispenses of the medication. (defined for API consistency)
    property dispenseInterval : TFhirDuration read FDispenseInterval write SetDispenseInterval;
    // The minimum period of time that must occur between dispenses of the medication.
    property dispenseIntervalElement : TFhirDuration read FDispenseInterval write SetDispenseInterval;

    // Typed access to This indicates the validity period of a prescription (stale dating the Prescription). (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // This indicates the validity period of a prescription (stale dating the Prescription).
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.  A prescriber may explicitly say that zero refills are permitted after the initial dispense.
    property numberOfRepeatsAllowed : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;
    // An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.  A prescriber may explicitly say that zero refills are permitted after the initial dispense.
    property numberOfRepeatsAllowedElement : TFhirUnsignedInt read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;

    // Typed access to The amount that is to be dispensed for one fill. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is to be dispensed for one fill.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. (defined for API consistency)
    property expectedSupplyDuration : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;
    // Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last.
    property expectedSupplyDurationElement : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;

    // Typed access to Indicates the intended performing Organization that will dispense the medication as specified by the prescriber. (defined for API consistency)
    property dispenser : TFhirReference read FDispenser write SetDispenser;
    // Indicates the intended performing Organization that will dispense the medication as specified by the prescriber.
    property dispenserElement : TFhirReference read FDispenser write SetDispenser;

  end;

  TFhirMedicationRequestDispenseRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestDispenseRequestList;
    function GetCurrent : TFhirMedicationRequestDispenseRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestDispenseRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestDispenseRequest read GetCurrent;
  end;

  TFhirMedicationRequestDispenseRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestDispenseRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestDispenseRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestDispenseRequestList; overload;
    function Clone : TFhirMedicationRequestDispenseRequestList; overload;
    function GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;
    
    //  Add a FhirMedicationRequestDispenseRequest to the end of the list.
    function Append : TFhirMedicationRequestDispenseRequest;
    
    // Add an already existing FhirMedicationRequestDispenseRequest to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestDispenseRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestDispenseRequest) : Integer;
    
    // Insert FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestDispenseRequest;
    
    // Insert an existing FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestDispenseRequest);
    
    // Get the iIndexth FhirMedicationRequestDispenseRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestDispenseRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestDispenseRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestDispenseRequests[index : Integer] : TFhirMedicationRequestDispenseRequest read GetItemN write SetItemN; default;
  End;

  // Indicates the quantity or duration for the first dispense of the medication.
  TFhirMedicationRequestDispenseRequestInitialFill = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FDuration : TFhirDuration;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDuration(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestDispenseRequestInitialFill; overload;
    function Clone : TFhirMedicationRequestDispenseRequestInitialFill; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount or quantity to provide as part of the first dispense. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount or quantity to provide as part of the first dispense.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The length of time that the first dispense is expected to last. (defined for API consistency)
    property duration : TFhirDuration read FDuration write SetDuration;
    // The length of time that the first dispense is expected to last.
    property durationElement : TFhirDuration read FDuration write SetDuration;

  end;

  TFhirMedicationRequestDispenseRequestInitialFillListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestDispenseRequestInitialFillList;
    function GetCurrent : TFhirMedicationRequestDispenseRequestInitialFill;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestDispenseRequestInitialFillList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestDispenseRequestInitialFill read GetCurrent;
  end;

  TFhirMedicationRequestDispenseRequestInitialFillList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestDispenseRequestInitialFillList; overload;
    function Clone : TFhirMedicationRequestDispenseRequestInitialFillList; overload;
    function GetEnumerator : TFhirMedicationRequestDispenseRequestInitialFillListEnumerator;
    
    //  Add a FhirMedicationRequestDispenseRequestInitialFill to the end of the list.
    function Append : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // Add an already existing FhirMedicationRequestDispenseRequestInitialFill to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestDispenseRequestInitialFill); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestDispenseRequestInitialFill) : Integer;
    
    // Insert FhirMedicationRequestDispenseRequestInitialFill before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // Insert an existing FhirMedicationRequestDispenseRequestInitialFill before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
    
    // Get the iIndexth FhirMedicationRequestDispenseRequestInitialFill. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestDispenseRequestInitialFills[index : Integer] : TFhirMedicationRequestDispenseRequestInitialFill read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  TFhirMedicationRequestSubstitution = class (TFhirBackboneElement)
  protected
    FAllowed : TFhirDataType;
    FReason : TFhirCodeableConcept;
    procedure SetAllowed(value : TFhirDataType);
    procedure SetReason(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestSubstitution; overload;
    function Clone : TFhirMedicationRequestSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the prescriber allows a different drug to be dispensed from what was prescribed. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // True if the prescriber allows a different drug to be dispensed from what was prescribed.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to Indicates the reason for the substitution, or why substitution must or must not be performed. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Indicates the reason for the substitution, or why substitution must or must not be performed.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirMedicationRequestSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestSubstitutionList;
    function GetCurrent : TFhirMedicationRequestSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestSubstitution read GetCurrent;
  end;

  TFhirMedicationRequestSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestSubstitutionList; overload;
    function Clone : TFhirMedicationRequestSubstitutionList; overload;
    function GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;
    
    //  Add a FhirMedicationRequestSubstitution to the end of the list.
    function Append : TFhirMedicationRequestSubstitution;
    
    // Add an already existing FhirMedicationRequestSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestSubstitution); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestSubstitution) : Integer;
    
    // Insert FhirMedicationRequestSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestSubstitution;
    
    // Insert an existing FhirMedicationRequestSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestSubstitution);
    
    // Get the iIndexth FhirMedicationRequestSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestSubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestSubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestSubstitutions[index : Integer] : TFhirMedicationRequestSubstitution read GetItemN write SetItemN; default;
  End;

  // An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
  TFhirMedicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FReported : TFhirBoolean;
    FInformationSource : TFhirReference;
    FMedication : TFhirCodeableReference;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformer : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FRecorder : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FCourseOfTherapyType : TFhirCodeableConcept;
    FinsuranceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FRenderedDosageInstruction : TFhirString;
    FdosageInstructionList : TFhirDosageList;
    FDispenseRequest : TFhirMedicationRequestDispenseRequest;
    FSubstitution : TFhirMedicationRequestSubstitution;
    FPriorPrescription : TFhirReference;
    FdetectedIssueList : TFhirReferenceList;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationrequestStatusEnum;
    procedure SetStatusST(value : TFhirMedicationrequestStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirMedicationRequestIntentEnum;
    procedure SetIntentST(value : TFhirMedicationRequestIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetReported(value : TFhirBoolean);
    function GetReportedST : Boolean;
    procedure SetReportedST(value : Boolean);
    procedure SetInformationSource(value : TFhirReference);
    procedure SetMedication(value : TFhirCodeableReference);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    procedure SetRecorder(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetCourseOfTherapyType(value : TFhirCodeableConcept);
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetRenderedDosageInstruction(value : TFhirString);
    function GetRenderedDosageInstructionST : String;
    procedure SetRenderedDosageInstructionST(value : String);
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    procedure SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
    procedure SetSubstitution(value : TFhirMedicationRequestSubstitution);
    procedure SetPriorPrescription(value : TFhirReference);
    function GetDetectedIssueList : TFhirReferenceList;
    function GetHasDetectedIssueList : Boolean;
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequest; overload;
    function Clone : TFhirMedicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this medication request that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code specifying the current state of the order.  Generally, this will be active or completed state.
    property status : TFhirMedicationrequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the MedicationRequest. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the MedicationRequest.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Whether the request is a proposal, plan, or an original order.
    property intent : TFhirMedicationRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates the grouping or category of medication request (for example, drug classification like ATC, where meds would be administered, legal category of the medication.).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Indicates how quickly the Medication Request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to If true, indicates that the provider is asking for the patient to either stop taking or to not start taking the specified medication. For example, the patient is taking an existing medication and the provider is changing their medication. They want to create two seperate requests: one to stop using the current medication and another to start the new medication.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true, indicates that the provider is asking for the patient to either stop taking or to not start taking the specified medication. For example, the patient is taking an existing medication and the provider is changing their medication. They want to create two seperate requests: one to stop using the current medication and another to start the new medication.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report.
    property reported : Boolean read GetReportedST write SetReportedST;
    // Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report.
    property reportedElement : TFhirBoolean read FReported write SetReported;

    // Typed access to The person or organization who provided the information about this request, if the source is someone other than the requestor.  This is often used when the MedicationRequest is reported by another person. (defined for API consistency)
    property informationSource : TFhirReference read FInformationSource write SetInformationSource;
    // The person or organization who provided the information about this request, if the source is someone other than the requestor.  This is often used when the MedicationRequest is reported by another person.
    property informationSourceElement : TFhirReference read FInformationSource write SetInformationSource;

    // Typed access to Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirCodeableReference read FMedication write SetMedication;
    // Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirCodeableReference read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or set of individuals to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // A link to a resource representing the person or set of individuals to whom the medication will be given.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this [x] was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this [x] was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Include additional information (for example, patient height and weight, a MedicationUsage for the patient) that supports the ordering of the medication.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual, organization, or device that initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual, organization, or device that initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to The specified desired performer of the medication treatment (e.g. the performer of the medication administration). (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The specified desired performer of the medication treatment (e.g. the performer of the medication administration).
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Typed access to Indicates the type of performer of the administration of the medication. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Indicates the type of performer of the administration of the medication.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // The reason or the indication for ordering or not ordering the medication.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The URL pointing to a protocol, guideline, orderset, or other definition that is adhered to in whole or in part by this MedicationRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this MedicationRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan or request that is fulfilled in whole or in part by this medication request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Typed access to The description of the overall pattern of the administration of the medication to the patient. (defined for API consistency)
    property courseOfTherapyType : TFhirCodeableConcept read FCourseOfTherapyType write SetCourseOfTherapyType;
    // The description of the overall pattern of the administration of the medication to the patient.
    property courseOfTherapyTypeElement : TFhirCodeableConcept read FCourseOfTherapyType write SetCourseOfTherapyType;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be required for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Extra information about the prescription that could not be conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstruction : String read GetRenderedDosageInstructionST write SetRenderedDosageInstructionST;
    // The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstructionElement : TFhirString read FRenderedDosageInstruction write SetRenderedDosageInstruction;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department. (defined for API consistency)
    property dispenseRequest : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;
    // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
    property dispenseRequestElement : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;

    // Typed access to Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done. (defined for API consistency)
    property substitution : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
    property substitutionElement : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;

    // Typed access to A link to a resource representing an earlier order related order or prescription. (defined for API consistency)
    property priorPrescription : TFhirReference read FPriorPrescription write SetPriorPrescription;
    // A link to a resource representing an earlier order related order or prescription.
    property priorPrescriptionElement : TFhirReference read FPriorPrescription write SetPriorPrescription;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // Links to Provenance records for past versions of this resource or fulfilling request or event resources that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the resource.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestList;
    function GetCurrent : TFhirMedicationRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequest read GetCurrent;
  end;

  TFhirMedicationRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestList; overload;
    function Clone : TFhirMedicationRequestList; overload;
    function GetEnumerator : TFhirMedicationRequestListEnumerator;
    
    //  Add a FhirMedicationRequest to the end of the list.
    function Append : TFhirMedicationRequest;
    
    // Add an already existing FhirMedicationRequest to the end of the list.
    procedure AddItem(value : TFhirMedicationRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequest) : Integer;
    
    // Insert FhirMedicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequest;
    
    // Insert an existing FhirMedicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequest);
    
    // Get the iIndexth FhirMedicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequests[index : Integer] : TFhirMedicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
  // A record of a medication that is being consumed by a patient.   A MedicationUsage may indicate that the patient may be taking the medication now or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains.   The primary difference between a medicationusage and a medicationadministration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medicationusage is often, if not always, less
    //  specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the Medication Usage information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.
  TFhirMedicationUsage = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FcategoryList : TFhirCodeableConceptList;
    FMedication : TFhirCodeableReference;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FDateAsserted : TFhirDateTime;
    FInformationSource : TFhirReference;
    FderivedFromList : TFhirReferenceList;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    FRenderedDosageInstruction : TFhirString;
    FdosageList : TFhirDosageList;
    FTakenAsOrdered : TFhirBoolean;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationUsageStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationUsageStatusCodesEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetMedication(value : TFhirCodeableReference);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetDateAsserted(value : TFhirDateTime);
    function GetDateAssertedST : TFslDateTime;
    procedure SetDateAssertedST(value : TFslDateTime);
    procedure SetInformationSource(value : TFhirReference);
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetRenderedDosageInstruction(value : TFhirString);
    function GetRenderedDosageInstructionST : String;
    procedure SetRenderedDosageInstructionST(value : String);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
    procedure SetTakenAsOrdered(value : TFhirBoolean);
    function GetTakenAsOrderedST : Boolean;
    procedure SetTakenAsOrderedST(value : Boolean);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationUsage; overload;
    function Clone : TFhirMedicationUsage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Usage that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code representing the patient or other source's judgment about the state of the medication used that this usage is about.  Generally, this will be active or completed.
    property status : TFhirMedicationUsageStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Captures the reason for the current state of the MedicationUsage.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Type of medication usage (for example, drug classification like ATC, where meds would be administered, legal category of the medication.).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirCodeableReference read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirCodeableReference read FMedication write SetMedication;

    // Typed access to The person, animal or group who is/was taking the medication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person, animal or group who is/was taking the medication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that establishes the context for this MedicationUsage. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that establishes the context for this MedicationUsage.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The interval of time during which it is being asserted that the patient is/was/will be taking the medication (or was not taking, when the MedicationUsage.status element is NotTaken). (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The interval of time during which it is being asserted that the patient is/was/will be taking the medication (or was not taking, when the MedicationUsage.status element is NotTaken).
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date when the Medication Usage was asserted by the information source.
    property dateAsserted : TFslDateTime read GetDateAssertedST write SetDateAssertedST;
    // The date when the Medication Usage was asserted by the information source.
    property dateAssertedElement : TFhirDateTime read FDateAsserted write SetDateAsserted;

    // Typed access to The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationUsage is derived from other resources, e.g. Claim or MedicationRequest. (defined for API consistency)
    property informationSource : TFhirReference read FInformationSource write SetInformationSource;
    // The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationUsage is derived from other resources, e.g. Claim or MedicationRequest.
    property informationSourceElement : TFhirReference read FInformationSource write SetInformationSource;

    // Allows linking the MedicationUsage to the underlying MedicationRequest, or to other information that supports or is used to derive the MedicationUsage.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // A concept, Condition or observation that supports why the medication is being/was taken.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Provides extra information about the Medication Usage that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstruction : String read GetRenderedDosageInstructionST write SetRenderedDosageInstructionST;
    // The full representation of the dose of the medication included in all dosage instructions.  To be used when multiple dosage instructions are included to represent complex dosing such as increasing or tapering doses.
    property renderedDosageInstructionElement : TFhirString read FRenderedDosageInstruction write SetRenderedDosageInstruction;

    // Indicates how the medication is/was or should be taken by the patient.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Typed access to Indicates if the medication is being consumed or administered as prescribed.
    property takenAsOrdered : Boolean read GetTakenAsOrderedST write SetTakenAsOrderedST;
    // Indicates if the medication is being consumed or administered as prescribed.
    property takenAsOrderedElement : TFhirBoolean read FTakenAsOrdered write SetTakenAsOrdered;

  end;

  TFhirMedicationUsageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationUsageList;
    function GetCurrent : TFhirMedicationUsage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationUsageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationUsage read GetCurrent;
  end;

  TFhirMedicationUsageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationUsage;
    procedure SetItemN(index : Integer; value : TFhirMedicationUsage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationUsageList; overload;
    function Clone : TFhirMedicationUsageList; overload;
    function GetEnumerator : TFhirMedicationUsageListEnumerator;
    
    //  Add a FhirMedicationUsage to the end of the list.
    function Append : TFhirMedicationUsage;
    
    // Add an already existing FhirMedicationUsage to the end of the list.
    procedure AddItem(value : TFhirMedicationUsage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationUsage) : Integer;
    
    // Insert FhirMedicationUsage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationUsage;
    
    // Insert an existing FhirMedicationUsage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationUsage);
    
    // Get the iIndexth FhirMedicationUsage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationUsage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationUsage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationUsages[index : Integer] : TFhirMedicationUsage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
  TFhirMolecularSequenceReferenceSeq = class (TFhirBackboneElement)
  protected
    FChromosome : TFhirCodeableConcept;
    FGenomeBuild : TFhirString;
    FOrientation : TFhirEnum;
    FReferenceSeqId : TFhirCodeableConcept;
    FReferenceSeqPointer : TFhirReference;
    FReferenceSeqString : TFhirString;
    FStrand : TFhirEnum;
    FWindowStart : TFhirInteger;
    FWindowEnd : TFhirInteger;
    procedure SetChromosome(value : TFhirCodeableConcept);
    procedure SetGenomeBuild(value : TFhirString);
    function GetGenomeBuildST : String;
    procedure SetGenomeBuildST(value : String);
    procedure SetOrientation(value : TFhirEnum);
    function GetOrientationST : TFhirOrientationTypeEnum;
    procedure SetOrientationST(value : TFhirOrientationTypeEnum);
    procedure SetReferenceSeqId(value : TFhirCodeableConcept);
    procedure SetReferenceSeqPointer(value : TFhirReference);
    procedure SetReferenceSeqString(value : TFhirString);
    function GetReferenceSeqStringST : String;
    procedure SetReferenceSeqStringST(value : String);
    procedure SetStrand(value : TFhirEnum);
    function GetStrandST : TFhirStrandTypeEnum;
    procedure SetStrandST(value : TFhirStrandTypeEnum);
    procedure SetWindowStart(value : TFhirInteger);
    function GetWindowStartST : String;
    procedure SetWindowStartST(value : String);
    procedure SetWindowEnd(value : TFhirInteger);
    function GetWindowEndST : String;
    procedure SetWindowEndST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceReferenceSeq; overload;
    function Clone : TFhirMolecularSequenceReferenceSeq; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)). (defined for API consistency)
    property chromosome : TFhirCodeableConcept read FChromosome write SetChromosome;
    // Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
    property chromosomeElement : TFhirCodeableConcept read FChromosome write SetChromosome;

    // Typed access to The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuild : String read GetGenomeBuildST write SetGenomeBuildST;
    // The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuildElement : TFhirString read FGenomeBuild write SetGenomeBuild;

    // A relative reference to a DNA strand based on gene orientation. The strand that contains the open reading frame of the gene is the "sense" strand, and the opposite complementary strand is the "antisense" strand.
    property orientation : TFhirOrientationTypeEnum read GetOrientationST write SetOrientationST;
    property orientationElement : TFhirEnum read FOrientation write SetOrientation;

    // Typed access to Reference identifier of reference sequence submitted to NCBI. It must match the type in the MolecularSequence.type field. For example, the prefix, “NG_” identifies reference sequence for genes, “NM_” for messenger RNA transcripts, and “NP_” for amino acid sequences. (defined for API consistency)
    property referenceSeqId : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;
    // Reference identifier of reference sequence submitted to NCBI. It must match the type in the MolecularSequence.type field. For example, the prefix, “NG_” identifies reference sequence for genes, “NM_” for messenger RNA transcripts, and “NP_” for amino acid sequences.
    property referenceSeqIdElement : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;

    // Typed access to A pointer to another MolecularSequence entity as reference sequence. (defined for API consistency)
    property referenceSeqPointer : TFhirReference read FReferenceSeqPointer write SetReferenceSeqPointer;
    // A pointer to another MolecularSequence entity as reference sequence.
    property referenceSeqPointerElement : TFhirReference read FReferenceSeqPointer write SetReferenceSeqPointer;

    // Typed access to A string like "ACGT".
    property referenceSeqString : String read GetReferenceSeqStringST write SetReferenceSeqStringST;
    // A string like "ACGT".
    property referenceSeqStringElement : TFhirString read FReferenceSeqString write SetReferenceSeqString;

    // An absolute reference to a strand. The Watson strand is the strand whose 5'-end is on the short arm of the chromosome, and the Crick strand as the one whose 5'-end is on the long arm.
    property strand : TFhirStrandTypeEnum read GetStrandST write SetStrandST;
    property strandElement : TFhirEnum read FStrand write SetStrand;

    // Typed access to Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStart : String read GetWindowStartST write SetWindowStartST;
    // Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStartElement : TFhirInteger read FWindowStart write SetWindowStart;

    // Typed access to End position of the window on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEnd : String read GetWindowEndST write SetWindowEndST;
    // End position of the window on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEndElement : TFhirInteger read FWindowEnd write SetWindowEnd;

  end;

  TFhirMolecularSequenceReferenceSeqListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceReferenceSeqList;
    function GetCurrent : TFhirMolecularSequenceReferenceSeq;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceReferenceSeqList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceReferenceSeq read GetCurrent;
  end;

  TFhirMolecularSequenceReferenceSeqList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceReferenceSeqList; overload;
    function Clone : TFhirMolecularSequenceReferenceSeqList; overload;
    function GetEnumerator : TFhirMolecularSequenceReferenceSeqListEnumerator;
    
    //  Add a FhirMolecularSequenceReferenceSeq to the end of the list.
    function Append : TFhirMolecularSequenceReferenceSeq;
    
    // Add an already existing FhirMolecularSequenceReferenceSeq to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceReferenceSeq); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceReferenceSeq) : Integer;
    
    // Insert FhirMolecularSequenceReferenceSeq before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    
    // Insert an existing FhirMolecularSequenceReferenceSeq before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
    
    // Get the iIndexth FhirMolecularSequenceReferenceSeq. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceReferenceSeqs[index : Integer] : TFhirMolecularSequenceReferenceSeq read GetItemN write SetItemN; default;
  End;

  // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
  TFhirMolecularSequenceVariant = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FObservedAllele : TFhirString;
    FReferenceAllele : TFhirString;
    FCigar : TFhirString;
    FVariantPointer : TFhirReference;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
    procedure SetObservedAllele(value : TFhirString);
    function GetObservedAlleleST : String;
    procedure SetObservedAlleleST(value : String);
    procedure SetReferenceAllele(value : TFhirString);
    function GetReferenceAlleleST : String;
    procedure SetReferenceAlleleST(value : String);
    procedure SetCigar(value : TFhirString);
    function GetCigarST : String;
    procedure SetCigarST(value : String);
    procedure SetVariantPointer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceVariant; overload;
    function Clone : TFhirMolecularSequenceVariant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Start position of the variant on the  reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the variant on the  reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the variant on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the variant on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAllele : String read GetObservedAlleleST write SetObservedAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAlleleElement : TFhirString read FObservedAllele write SetObservedAllele;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAllele : String read GetReferenceAlleleST write SetReferenceAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAlleleElement : TFhirString read FReferenceAllele write SetReferenceAllele;

    // Typed access to Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigar : String read GetCigarST write SetCigarST;
    // Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigarElement : TFhirString read FCigar write SetCigar;

    // Typed access to A pointer to an Observation containing variant information. (defined for API consistency)
    property variantPointer : TFhirReference read FVariantPointer write SetVariantPointer;
    // A pointer to an Observation containing variant information.
    property variantPointerElement : TFhirReference read FVariantPointer write SetVariantPointer;

  end;

  TFhirMolecularSequenceVariantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceVariantList;
    function GetCurrent : TFhirMolecularSequenceVariant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceVariantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceVariant read GetCurrent;
  end;

  TFhirMolecularSequenceVariantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceVariant;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceVariant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceVariantList; overload;
    function Clone : TFhirMolecularSequenceVariantList; overload;
    function GetEnumerator : TFhirMolecularSequenceVariantListEnumerator;
    
    //  Add a FhirMolecularSequenceVariant to the end of the list.
    function Append : TFhirMolecularSequenceVariant;
    
    // Add an already existing FhirMolecularSequenceVariant to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceVariant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceVariant) : Integer;
    
    // Insert FhirMolecularSequenceVariant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceVariant;
    
    // Insert an existing FhirMolecularSequenceVariant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceVariant);
    
    // Get the iIndexth FhirMolecularSequenceVariant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceVariant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceVariant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceVariants[index : Integer] : TFhirMolecularSequenceVariant read GetItemN write SetItemN; default;
  End;

  // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
  TFhirMolecularSequenceQuality = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FStandardSequence : TFhirCodeableConcept;
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FScore : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FTruthTP : TFhirDecimal;
    FQueryTP : TFhirDecimal;
    FTruthFN : TFhirDecimal;
    FQueryFP : TFhirDecimal;
    FGtFP : TFhirDecimal;
    FPrecision : TFhirDecimal;
    FRecall : TFhirDecimal;
    FFScore_ : TFhirDecimal;
    FRoc : TFhirMolecularSequenceQualityRoc;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirQualityTypeEnum;
    procedure SetType_ST(value : TFhirQualityTypeEnum);
    procedure SetStandardSequence(value : TFhirCodeableConcept);
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
    procedure SetScore(value : TFhirQuantity);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetTruthTP(value : TFhirDecimal);
    function GetTruthTPST : String;
    procedure SetTruthTPST(value : String);
    procedure SetQueryTP(value : TFhirDecimal);
    function GetQueryTPST : String;
    procedure SetQueryTPST(value : String);
    procedure SetTruthFN(value : TFhirDecimal);
    function GetTruthFNST : String;
    procedure SetTruthFNST(value : String);
    procedure SetQueryFP(value : TFhirDecimal);
    function GetQueryFPST : String;
    procedure SetQueryFPST(value : String);
    procedure SetGtFP(value : TFhirDecimal);
    function GetGtFPST : String;
    procedure SetGtFPST(value : String);
    procedure SetPrecision(value : TFhirDecimal);
    function GetPrecisionST : String;
    procedure SetPrecisionST(value : String);
    procedure SetRecall(value : TFhirDecimal);
    function GetRecallST : String;
    procedure SetRecallST(value : String);
    procedure SetFScore_(value : TFhirDecimal);
    function GetFScore_ST : String;
    procedure SetFScore_ST(value : String);
    procedure SetRoc(value : TFhirMolecularSequenceQualityRoc);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceQuality; overload;
    function Clone : TFhirMolecularSequenceQuality; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // INDEL / SNP / Undefined variant.
    property type_ : TFhirQualityTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Gold standard sequence used for comparing against. (defined for API consistency)
    property standardSequence : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;
    // Gold standard sequence used for comparing against.
    property standardSequenceElement : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;

    // Typed access to Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)). (defined for API consistency)
    property score : TFhirQuantity read FScore write SetScore;
    // The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
    property scoreElement : TFhirQuantity read FScore write SetScore;

    // Typed access to Which method is used to get sequence quality. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Which method is used to get sequence quality.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTP : String read GetTruthTPST write SetTruthTPST;
    // True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTPElement : TFhirDecimal read FTruthTP write SetTruthTP;

    // Typed access to True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTP : String read GetQueryTPST write SetQueryTPST;
    // True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTPElement : TFhirDecimal read FQueryTP write SetQueryTP;

    // Typed access to False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFN : String read GetTruthFNST write SetTruthFNST;
    // False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFNElement : TFhirDecimal read FTruthFN write SetTruthFN;

    // Typed access to False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFP : String read GetQueryFPST write SetQueryFPST;
    // False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFPElement : TFhirDecimal read FQueryFP write SetQueryFP;

    // Typed access to The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFP : String read GetGtFPST write SetGtFPST;
    // The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFPElement : TFhirDecimal read FGtFP write SetGtFP;

    // Typed access to QUERY.TP / (QUERY.TP + QUERY.FP).
    property precision : String read GetPrecisionST write SetPrecisionST;
    // QUERY.TP / (QUERY.TP + QUERY.FP).
    property precisionElement : TFhirDecimal read FPrecision write SetPrecision;

    // Typed access to TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recall : String read GetRecallST write SetRecallST;
    // TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recallElement : TFhirDecimal read FRecall write SetRecall;

    // Typed access to Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_ : String read GetFScore_ST write SetFScore_ST;
    // Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_Element : TFhirDecimal read FFScore_ write SetFScore_;

    // Typed access to Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff. (defined for API consistency)
    property roc : TFhirMolecularSequenceQualityRoc read FRoc write SetRoc;
    // Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
    property rocElement : TFhirMolecularSequenceQualityRoc read FRoc write SetRoc;

  end;

  TFhirMolecularSequenceQualityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceQualityList;
    function GetCurrent : TFhirMolecularSequenceQuality;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceQualityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceQuality read GetCurrent;
  end;

  TFhirMolecularSequenceQualityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceQuality;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceQuality);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceQualityList; overload;
    function Clone : TFhirMolecularSequenceQualityList; overload;
    function GetEnumerator : TFhirMolecularSequenceQualityListEnumerator;
    
    //  Add a FhirMolecularSequenceQuality to the end of the list.
    function Append : TFhirMolecularSequenceQuality;
    
    // Add an already existing FhirMolecularSequenceQuality to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceQuality); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceQuality) : Integer;
    
    // Insert FhirMolecularSequenceQuality before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceQuality;
    
    // Insert an existing FhirMolecularSequenceQuality before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceQuality);
    
    // Get the iIndexth FhirMolecularSequenceQuality. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceQuality);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceQuality;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceQualities[index : Integer] : TFhirMolecularSequenceQuality read GetItemN write SetItemN; default;
  End;

  // Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
  TFhirMolecularSequenceQualityRoc = class (TFhirBackboneElement)
  protected
    FscoreList : TFhirIntegerList;
    FnumTPList : TFhirIntegerList;
    FnumFPList : TFhirIntegerList;
    FnumFNList : TFhirIntegerList;
    FprecisionList : TFhirDecimalList;
    FsensitivityList : TFhirDecimalList;
    FfMeasureList : TFhirDecimalList;
    function GetScoreList : TFhirIntegerList;
    function GetHasScoreList : Boolean;
    function GetNumTPList : TFhirIntegerList;
    function GetHasNumTPList : Boolean;
    function GetNumFPList : TFhirIntegerList;
    function GetHasNumFPList : Boolean;
    function GetNumFNList : TFhirIntegerList;
    function GetHasNumFNList : Boolean;
    function GetPrecisionList : TFhirDecimalList;
    function GetHasPrecisionList : Boolean;
    function GetSensitivityList : TFhirDecimalList;
    function GetHasSensitivityList : Boolean;
    function GetFMeasureList : TFhirDecimalList;
    function GetHasFMeasureList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceQualityRoc; overload;
    function Clone : TFhirMolecularSequenceQualityRoc; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Invidual data point representing the GQ (genotype quality) score threshold.
    property scoreList : TFhirIntegerList read GetScoreList;
    property hasScoreList : boolean read GetHasScoreList;

    // The number of true positives if the GQ score threshold was set to "score" field value.
    property numTPList : TFhirIntegerList read GetNumTPList;
    property hasNumTPList : boolean read GetHasNumTPList;

    // The number of false positives if the GQ score threshold was set to "score" field value.
    property numFPList : TFhirIntegerList read GetNumFPList;
    property hasNumFPList : boolean read GetHasNumFPList;

    // The number of false negatives if the GQ score threshold was set to "score" field value.
    property numFNList : TFhirIntegerList read GetNumFNList;
    property hasNumFNList : boolean read GetHasNumFNList;

    // Calculated precision if the GQ score threshold was set to "score" field value.
    property precisionList : TFhirDecimalList read GetPrecisionList;
    property hasPrecisionList : boolean read GetHasPrecisionList;

    // Calculated sensitivity if the GQ score threshold was set to "score" field value.
    property sensitivityList : TFhirDecimalList read GetSensitivityList;
    property hasSensitivityList : boolean read GetHasSensitivityList;

    // Calculated fScore if the GQ score threshold was set to "score" field value.
    property fMeasureList : TFhirDecimalList read GetFMeasureList;
    property hasFMeasureList : boolean read GetHasFMeasureList;

  end;

  TFhirMolecularSequenceQualityRocListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceQualityRocList;
    function GetCurrent : TFhirMolecularSequenceQualityRoc;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceQualityRocList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceQualityRoc read GetCurrent;
  end;

  TFhirMolecularSequenceQualityRocList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceQualityRoc;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceQualityRoc);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceQualityRocList; overload;
    function Clone : TFhirMolecularSequenceQualityRocList; overload;
    function GetEnumerator : TFhirMolecularSequenceQualityRocListEnumerator;
    
    //  Add a FhirMolecularSequenceQualityRoc to the end of the list.
    function Append : TFhirMolecularSequenceQualityRoc;
    
    // Add an already existing FhirMolecularSequenceQualityRoc to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceQualityRoc); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceQualityRoc) : Integer;
    
    // Insert FhirMolecularSequenceQualityRoc before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceQualityRoc;
    
    // Insert an existing FhirMolecularSequenceQualityRoc before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceQualityRoc);
    
    // Get the iIndexth FhirMolecularSequenceQualityRoc. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceQualityRoc);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceQualityRoc;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceQualityRocs[index : Integer] : TFhirMolecularSequenceQualityRoc read GetItemN write SetItemN; default;
  End;

  // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
  TFhirMolecularSequenceRepository = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUrl : TFhirUri;
    FName : TFhirString;
    FDatasetId : TFhirString;
    FVariantsetId : TFhirString;
    FReadsetId : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirRepositoryTypeEnum;
    procedure SetType_ST(value : TFhirRepositoryTypeEnum);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDatasetId(value : TFhirString);
    function GetDatasetIdST : String;
    procedure SetDatasetIdST(value : String);
    procedure SetVariantsetId(value : TFhirString);
    function GetVariantsetIdST : String;
    procedure SetVariantsetIdST(value : String);
    procedure SetReadsetId(value : TFhirString);
    function GetReadsetIdST : String;
    procedure SetReadsetIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceRepository; overload;
    function Clone : TFhirMolecularSequenceRepository; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Click and see / RESTful API / Need login to see / RESTful API with authentication / Other ways to see resource.
    property type_ : TFhirRepositoryTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property url : String read GetUrlST write SetUrlST;
    // URI of an external repository which contains further details about the genetics data.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property name : String read GetNameST write SetNameST;
    // URI of an external repository which contains further details about the genetics data.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetId : String read GetDatasetIdST write SetDatasetIdST;
    // Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetIdElement : TFhirString read FDatasetId write SetDatasetId;

    // Typed access to Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetId : String read GetVariantsetIdST write SetVariantsetIdST;
    // Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetIdElement : TFhirString read FVariantsetId write SetVariantsetId;

    // Typed access to Id of the read in this external repository.
    property readsetId : String read GetReadsetIdST write SetReadsetIdST;
    // Id of the read in this external repository.
    property readsetIdElement : TFhirString read FReadsetId write SetReadsetId;

  end;

  TFhirMolecularSequenceRepositoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceRepositoryList;
    function GetCurrent : TFhirMolecularSequenceRepository;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceRepositoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceRepository read GetCurrent;
  end;

  TFhirMolecularSequenceRepositoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceRepository;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceRepository);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceRepositoryList; overload;
    function Clone : TFhirMolecularSequenceRepositoryList; overload;
    function GetEnumerator : TFhirMolecularSequenceRepositoryListEnumerator;
    
    //  Add a FhirMolecularSequenceRepository to the end of the list.
    function Append : TFhirMolecularSequenceRepository;
    
    // Add an already existing FhirMolecularSequenceRepository to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceRepository); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceRepository) : Integer;
    
    // Insert FhirMolecularSequenceRepository before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceRepository;
    
    // Insert an existing FhirMolecularSequenceRepository before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceRepository);
    
    // Get the iIndexth FhirMolecularSequenceRepository. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceRepository);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceRepository;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceRepositories[index : Integer] : TFhirMolecularSequenceRepository read GetItemN write SetItemN; default;
  End;

  // Information about chromosome structure variation.
  TFhirMolecularSequenceStructureVariant = class (TFhirBackboneElement)
  protected
    FVariantType : TFhirCodeableConcept;
    FExact : TFhirBoolean;
    FLength : TFhirInteger;
    FOuter : TFhirMolecularSequenceStructureVariantOuter;
    FInner : TFhirMolecularSequenceStructureVariantInner;
    procedure SetVariantType(value : TFhirCodeableConcept);
    procedure SetExact(value : TFhirBoolean);
    function GetExactST : Boolean;
    procedure SetExactST(value : Boolean);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetOuter(value : TFhirMolecularSequenceStructureVariantOuter);
    procedure SetInner(value : TFhirMolecularSequenceStructureVariantInner);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariant; overload;
    function Clone : TFhirMolecularSequenceStructureVariant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Information about chromosome structure variation DNA change type. (defined for API consistency)
    property variantType : TFhirCodeableConcept read FVariantType write SetVariantType;
    // Information about chromosome structure variation DNA change type.
    property variantTypeElement : TFhirCodeableConcept read FVariantType write SetVariantType;

    // Typed access to Used to indicate if the outer and inner start-end values have the same meaning.
    property exact : Boolean read GetExactST write SetExactST;
    // Used to indicate if the outer and inner start-end values have the same meaning.
    property exactElement : TFhirBoolean read FExact write SetExact;

    // Typed access to Length of the variant chromosome.
    property length : String read GetLengthST write SetLengthST;
    // Length of the variant chromosome.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to Structural variant outer. (defined for API consistency)
    property outer : TFhirMolecularSequenceStructureVariantOuter read FOuter write SetOuter;
    // Structural variant outer.
    property outerElement : TFhirMolecularSequenceStructureVariantOuter read FOuter write SetOuter;

    // Typed access to Structural variant inner. (defined for API consistency)
    property inner : TFhirMolecularSequenceStructureVariantInner read FInner write SetInner;
    // Structural variant inner.
    property innerElement : TFhirMolecularSequenceStructureVariantInner read FInner write SetInner;

  end;

  TFhirMolecularSequenceStructureVariantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantList;
    function GetCurrent : TFhirMolecularSequenceStructureVariant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariant read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariant;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariant to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariant;
    
    // Add an already existing FhirMolecularSequenceStructureVariant to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceStructureVariant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariant) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariant;
    
    // Insert an existing FhirMolecularSequenceStructureVariant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariant);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariants[index : Integer] : TFhirMolecularSequenceStructureVariant read GetItemN write SetItemN; default;
  End;

  // Structural variant outer.
  TFhirMolecularSequenceStructureVariantOuter = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariantOuter; overload;
    function Clone : TFhirMolecularSequenceStructureVariantOuter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural variant outer start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Structural variant outer start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to Structural variant outer end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // Structural variant outer end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

  end;

  TFhirMolecularSequenceStructureVariantOuterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantOuterList;
    function GetCurrent : TFhirMolecularSequenceStructureVariantOuter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantOuterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariantOuter read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantOuterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantOuterList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantOuterList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantOuterListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariantOuter to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariantOuter;
    
    // Add an already existing FhirMolecularSequenceStructureVariantOuter to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceStructureVariantOuter); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariantOuter) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariantOuter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    
    // Insert an existing FhirMolecularSequenceStructureVariantOuter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariantOuter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariantOuters[index : Integer] : TFhirMolecularSequenceStructureVariantOuter read GetItemN write SetItemN; default;
  End;

  // Structural variant inner.
  TFhirMolecularSequenceStructureVariantInner = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariantInner; overload;
    function Clone : TFhirMolecularSequenceStructureVariantInner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural variant inner start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Structural variant inner start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to Structural variant inner end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // Structural variant inner end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

  end;

  TFhirMolecularSequenceStructureVariantInnerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantInnerList;
    function GetCurrent : TFhirMolecularSequenceStructureVariantInner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantInnerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariantInner read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantInnerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantInnerList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantInnerList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantInnerListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariantInner to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariantInner;
    
    // Add an already existing FhirMolecularSequenceStructureVariantInner to the end of the list.
    procedure AddItem(value : TFhirMolecularSequenceStructureVariantInner); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariantInner) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariantInner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    
    // Insert an existing FhirMolecularSequenceStructureVariantInner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariantInner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariantInners[index : Integer] : TFhirMolecularSequenceStructureVariantInner read GetItemN write SetItemN; default;
  End;

  // Raw data describing a biological sequence.
  TFhirMolecularSequence = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirEnum;
    FCoordinateSystem : TFhirInteger;
    FPatient : TFhirReference;
    FSpecimen : TFhirReference;
    FDevice : TFhirReference;
    FPerformer : TFhirReference;
    FQuantity : TFhirQuantity;
    FReferenceSeq : TFhirMolecularSequenceReferenceSeq;
    FvariantList : TFhirMolecularSequenceVariantList;
    FObservedSeq : TFhirString;
    FqualityList : TFhirMolecularSequenceQualityList;
    FReadCoverage : TFhirInteger;
    FrepositoryList : TFhirMolecularSequenceRepositoryList;
    FpointerList : TFhirReferenceList;
    FstructureVariantList : TFhirMolecularSequenceStructureVariantList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSequenceTypeEnum;
    procedure SetType_ST(value : TFhirSequenceTypeEnum);
    procedure SetCoordinateSystem(value : TFhirInteger);
    function GetCoordinateSystemST : String;
    procedure SetCoordinateSystemST(value : String);
    procedure SetPatient(value : TFhirReference);
    procedure SetSpecimen(value : TFhirReference);
    procedure SetDevice(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetReferenceSeq(value : TFhirMolecularSequenceReferenceSeq);
    function GetVariantList : TFhirMolecularSequenceVariantList;
    function GetHasVariantList : Boolean;
    procedure SetObservedSeq(value : TFhirString);
    function GetObservedSeqST : String;
    procedure SetObservedSeqST(value : String);
    function GetQualityList : TFhirMolecularSequenceQualityList;
    function GetHasQualityList : Boolean;
    procedure SetReadCoverage(value : TFhirInteger);
    function GetReadCoverageST : String;
    procedure SetReadCoverageST(value : String);
    function GetRepositoryList : TFhirMolecularSequenceRepositoryList;
    function GetHasRepositoryList : Boolean;
    function GetPointerList : TFhirReferenceList;
    function GetHasPointerList : Boolean;
    function GetStructureVariantList : TFhirMolecularSequenceStructureVariantList;
    function GetHasStructureVariantList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequence; overload;
    function Clone : TFhirMolecularSequence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier for this particular sequence instance. This is a FHIR-defined id.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Amino Acid Sequence/ DNA Sequence / RNA Sequence.
    property type_ : TFhirSequenceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystem : String read GetCoordinateSystemST write SetCoordinateSystemST;
    // Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystemElement : TFhirInteger read FCoordinateSystem write SetCoordinateSystem;

    // Typed access to The patient whose sequencing results are described by this resource. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient whose sequencing results are described by this resource.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to Specimen used for sequencing. (defined for API consistency)
    property specimen : TFhirReference read FSpecimen write SetSpecimen;
    // Specimen used for sequencing.
    property specimenElement : TFhirReference read FSpecimen write SetSpecimen;

    // Typed access to The method for sequencing, for example, chip information. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The method for sequencing, for example, chip information.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to The organization or lab that should be responsible for this result. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The organization or lab that should be responsible for this result.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Typed access to The number of copies of the sequence of interest. (RNASeq). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of copies of the sequence of interest. (RNASeq).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A sequence that is used as a reference to describe variants that are present in a sequence analyzed. (defined for API consistency)
    property referenceSeq : TFhirMolecularSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;
    // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
    property referenceSeqElement : TFhirMolecularSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;

    // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
    property variantList : TFhirMolecularSequenceVariantList read GetVariantList;
    property hasVariantList : boolean read GetHasVariantList;

    // Typed access to Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall start from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeq : String read GetObservedSeqST write SetObservedSeqST;
    // Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall start from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeqElement : TFhirString read FObservedSeq write SetObservedSeq;

    // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
    property qualityList : TFhirMolecularSequenceQualityList read GetQualityList;
    property hasQualityList : boolean read GetHasQualityList;

    // Typed access to Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverage : String read GetReadCoverageST write SetReadCoverageST;
    // Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverageElement : TFhirInteger read FReadCoverage write SetReadCoverage;

    // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
    property repositoryList : TFhirMolecularSequenceRepositoryList read GetRepositoryList;
    property hasRepositoryList : boolean read GetHasRepositoryList;

    // Pointer to next atomic sequence which at most contains one variant.
    property pointerList : TFhirReferenceList read GetPointerList;
    property hasPointerList : boolean read GetHasPointerList;

    // Information about chromosome structure variation.
    property structureVariantList : TFhirMolecularSequenceStructureVariantList read GetStructureVariantList;
    property hasStructureVariantList : boolean read GetHasStructureVariantList;

  end;

  TFhirMolecularSequenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceList;
    function GetCurrent : TFhirMolecularSequence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequence read GetCurrent;
  end;

  TFhirMolecularSequenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequence;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceList; overload;
    function Clone : TFhirMolecularSequenceList; overload;
    function GetEnumerator : TFhirMolecularSequenceListEnumerator;
    
    //  Add a FhirMolecularSequence to the end of the list.
    function Append : TFhirMolecularSequence;
    
    // Add an already existing FhirMolecularSequence to the end of the list.
    procedure AddItem(value : TFhirMolecularSequence); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequence) : Integer;
    
    // Insert FhirMolecularSequence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequence;
    
    // Insert an existing FhirMolecularSequence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequence);
    
    // Get the iIndexth FhirMolecularSequence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequences[index : Integer] : TFhirMolecularSequence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONINTAKE}
  // What food or fluid product or item was consumed.
  TFhirNutritionIntakeConsumedItem = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FNutritionProduct : TFhirCodeableReference;
    FSchedule : TFhirTiming;
    FAmount : TFhirQuantity;
    FRate : TFhirQuantity;
    FNotConsumed : TFhirBoolean;
    FNotConsumedReason : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetNutritionProduct(value : TFhirCodeableReference);
    procedure SetSchedule(value : TFhirTiming);
    procedure SetAmount(value : TFhirQuantity);
    procedure SetRate(value : TFhirQuantity);
    procedure SetNotConsumed(value : TFhirBoolean);
    function GetNotConsumedST : Boolean;
    procedure SetNotConsumedST(value : Boolean);
    procedure SetNotConsumedReason(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionIntakeConsumedItem; overload;
    function Clone : TFhirNutritionIntakeConsumedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates what a category of item that was consumed: eg., food, fluid, enteral, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates what a category of item that was consumed: eg., food, fluid, enteral, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Identifies the food or fluid product that was consumed. This is potentially a link to a resource representing the details of the food product (TBD) or a simple attribute carrying a code that identifies the food from a known list of foods. (defined for API consistency)
    property nutritionProduct : TFhirCodeableReference read FNutritionProduct write SetNutritionProduct;
    // Identifies the food or fluid product that was consumed. This is potentially a link to a resource representing the details of the food product (TBD) or a simple attribute carrying a code that identifies the food from a known list of foods.
    property nutritionProductElement : TFhirCodeableReference read FNutritionProduct write SetNutritionProduct;

    // Typed access to Scheduled frequency of consumption. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // Scheduled frequency of consumption.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

    // Typed access to Quantity of the specified food. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Quantity of the specified food.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Typed access to Rate at which enteral feeding was administered. (defined for API consistency)
    property rate : TFhirQuantity read FRate write SetRate;
    // Rate at which enteral feeding was administered.
    property rateElement : TFhirQuantity read FRate write SetRate;

    // Typed access to Indicator when a patient is in a setting where it is helpful to know if food was not consumed, such as it was refused, held (as in tube feedings), or otherwise not provided. If a consumption is being recorded from an app, such as MyFitnessPal, this indicator will likely not be used.
    property notConsumed : Boolean read GetNotConsumedST write SetNotConsumedST;
    // Indicator when a patient is in a setting where it is helpful to know if food was not consumed, such as it was refused, held (as in tube feedings), or otherwise not provided. If a consumption is being recorded from an app, such as MyFitnessPal, this indicator will likely not be used.
    property notConsumedElement : TFhirBoolean read FNotConsumed write SetNotConsumed;

    // Typed access to Document the reason the food or fluid was not consumed, such as refused, held, etc. (defined for API consistency)
    property notConsumedReason : TFhirCodeableConcept read FNotConsumedReason write SetNotConsumedReason;
    // Document the reason the food or fluid was not consumed, such as refused, held, etc.
    property notConsumedReasonElement : TFhirCodeableConcept read FNotConsumedReason write SetNotConsumedReason;

  end;

  TFhirNutritionIntakeConsumedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionIntakeConsumedItemList;
    function GetCurrent : TFhirNutritionIntakeConsumedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionIntakeConsumedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionIntakeConsumedItem read GetCurrent;
  end;

  TFhirNutritionIntakeConsumedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionIntakeConsumedItem;
    procedure SetItemN(index : Integer; value : TFhirNutritionIntakeConsumedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionIntakeConsumedItemList; overload;
    function Clone : TFhirNutritionIntakeConsumedItemList; overload;
    function GetEnumerator : TFhirNutritionIntakeConsumedItemListEnumerator;
    
    //  Add a FhirNutritionIntakeConsumedItem to the end of the list.
    function Append : TFhirNutritionIntakeConsumedItem;
    
    // Add an already existing FhirNutritionIntakeConsumedItem to the end of the list.
    procedure AddItem(value : TFhirNutritionIntakeConsumedItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionIntakeConsumedItem) : Integer;
    
    // Insert FhirNutritionIntakeConsumedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionIntakeConsumedItem;
    
    // Insert an existing FhirNutritionIntakeConsumedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionIntakeConsumedItem);
    
    // Get the iIndexth FhirNutritionIntakeConsumedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionIntakeConsumedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionIntakeConsumedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionIntakeConsumedItems[index : Integer] : TFhirNutritionIntakeConsumedItem read GetItemN write SetItemN; default;
  End;

  // Total nutrient amounts for the whole meal, product, serving, etc.
  TFhirNutritionIntakeIngredientLabel = class (TFhirBackboneElement)
  protected
    FNutrient : TFhirCodeableReference;
    FAmount : TFhirQuantity;
    procedure SetNutrient(value : TFhirCodeableReference);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionIntakeIngredientLabel; overload;
    function Clone : TFhirNutritionIntakeIngredientLabel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Total nutrient consumed. This could be a macronutrient (protein, fat, carbohydrate), or a vitamin and mineral. (defined for API consistency)
    property nutrient : TFhirCodeableReference read FNutrient write SetNutrient;
    // Total nutrient consumed. This could be a macronutrient (protein, fat, carbohydrate), or a vitamin and mineral.
    property nutrientElement : TFhirCodeableReference read FNutrient write SetNutrient;

    // Typed access to Total amount of nutrient consumed. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Total amount of nutrient consumed.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirNutritionIntakeIngredientLabelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionIntakeIngredientLabelList;
    function GetCurrent : TFhirNutritionIntakeIngredientLabel;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionIntakeIngredientLabelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionIntakeIngredientLabel read GetCurrent;
  end;

  TFhirNutritionIntakeIngredientLabelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionIntakeIngredientLabel;
    procedure SetItemN(index : Integer; value : TFhirNutritionIntakeIngredientLabel);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionIntakeIngredientLabelList; overload;
    function Clone : TFhirNutritionIntakeIngredientLabelList; overload;
    function GetEnumerator : TFhirNutritionIntakeIngredientLabelListEnumerator;
    
    //  Add a FhirNutritionIntakeIngredientLabel to the end of the list.
    function Append : TFhirNutritionIntakeIngredientLabel;
    
    // Add an already existing FhirNutritionIntakeIngredientLabel to the end of the list.
    procedure AddItem(value : TFhirNutritionIntakeIngredientLabel); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionIntakeIngredientLabel) : Integer;
    
    // Insert FhirNutritionIntakeIngredientLabel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionIntakeIngredientLabel;
    
    // Insert an existing FhirNutritionIntakeIngredientLabel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionIntakeIngredientLabel);
    
    // Get the iIndexth FhirNutritionIntakeIngredientLabel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionIntakeIngredientLabel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionIntakeIngredientLabel;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionIntakeIngredientLabels[index : Integer] : TFhirNutritionIntakeIngredientLabel read GetItemN write SetItemN; default;
  End;

  // Who performed the intake and how they were involved.
  TFhirNutritionIntakePerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionIntakePerformer; overload;
    function Clone : TFhirNutritionIntakePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of performer. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Type of performer.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Who performed the intake. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Who performed the intake.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirNutritionIntakePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionIntakePerformerList;
    function GetCurrent : TFhirNutritionIntakePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionIntakePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionIntakePerformer read GetCurrent;
  end;

  TFhirNutritionIntakePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionIntakePerformer;
    procedure SetItemN(index : Integer; value : TFhirNutritionIntakePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionIntakePerformerList; overload;
    function Clone : TFhirNutritionIntakePerformerList; overload;
    function GetEnumerator : TFhirNutritionIntakePerformerListEnumerator;
    
    //  Add a FhirNutritionIntakePerformer to the end of the list.
    function Append : TFhirNutritionIntakePerformer;
    
    // Add an already existing FhirNutritionIntakePerformer to the end of the list.
    procedure AddItem(value : TFhirNutritionIntakePerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionIntakePerformer) : Integer;
    
    // Insert FhirNutritionIntakePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionIntakePerformer;
    
    // Insert an existing FhirNutritionIntakePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionIntakePerformer);
    
    // Get the iIndexth FhirNutritionIntakePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionIntakePerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionIntakePerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionIntakePerformers[index : Integer] : TFhirNutritionIntakePerformer read GetItemN write SetItemN; default;
  End;

  // A record of food or fluid that is being consumed by a patient.   A NutritionIntake may indicate that the patient may be consuming the food or fluid now or has consumed the food or fluid in the past.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay or through an app that tracks food or fluids consumed.   The consumption information may come from sources such as the patient's memory, from a nutrition label,  or from a clinician documenting observed intake.
  TFhirNutritionIntake = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FRecorded : TFhirDateTime;
    FReported : TFhirDataType;
    FconsumedItemList : TFhirNutritionIntakeConsumedItemList;
    FingredientLabelList : TFhirNutritionIntakeIngredientLabelList;
    FperformerList : TFhirNutritionIntakePerformerList;
    FLocation : TFhirReference;
    FderivedFromList : TFhirReferenceList;
    FreasonList : TFhirCodeableReferenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetRecorded(value : TFhirDateTime);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetReported(value : TFhirDataType);
    function GetConsumedItemList : TFhirNutritionIntakeConsumedItemList;
    function GetHasConsumedItemList : Boolean;
    function GetIngredientLabelList : TFhirNutritionIntakeIngredientLabelList;
    function GetHasIngredientLabelList : Boolean;
    function GetPerformerList : TFhirNutritionIntakePerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionIntake; overload;
    function Clone : TFhirNutritionIntake; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Nutrition Intake that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Instantiates FHIR protocol or definition.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // Instantiates external protocol or definition.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code representing the patient or other source's judgment about the state of the intake that this assertion is about.  Generally, this will be active or completed.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Captures the reason for the current state of the NutritionIntake.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to Type of nutrition intake setting/reporting. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Type of nutrition intake setting/reporting.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The person, animal or group who is/was consuming the food or fluid. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person, animal or group who is/was consuming the food or fluid.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that establishes the context for this NutritionIntake. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that establishes the context for this NutritionIntake.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The interval of time during which it is being asserted that the patient is/was consuming the food or fluid. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The interval of time during which it is being asserted that the patient is/was consuming the food or fluid.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The date when the Nutrition Intake was asserted by the information source.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The date when the Nutrition Intake was asserted by the information source.
    property recordedElement : TFhirDateTime read FRecorded write SetRecorded;

    // Typed access to The person or organization that provided the information about the consumption of this food or fluid. Note: Use derivedFrom when a NutritionIntake is derived from other resources. (defined for API consistency)
    property reported : TFhirDataType read FReported write SetReported;
    // The person or organization that provided the information about the consumption of this food or fluid. Note: Use derivedFrom when a NutritionIntake is derived from other resources.
    property reportedElement : TFhirDataType read FReported write SetReported;

    // What food or fluid product or item was consumed.
    property consumedItemList : TFhirNutritionIntakeConsumedItemList read GetConsumedItemList;
    property hasConsumedItemList : boolean read GetHasConsumedItemList;

    // Total nutrient amounts for the whole meal, product, serving, etc.
    property ingredientLabelList : TFhirNutritionIntakeIngredientLabelList read GetIngredientLabelList;
    property hasIngredientLabelList : boolean read GetHasIngredientLabelList;

    // Who performed the intake and how they were involved.
    property performerList : TFhirNutritionIntakePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Where the intake occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Where the intake occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Allows linking the NutritionIntake to the underlying NutritionOrder, or to other information, such as AllergyIntolerance, that supports or is used to derive the NutritionIntake.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // A reason, Condition or observation for why the food or fluid is /was consumed.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Provides extra information about the Nutrition Intake that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionIntakeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionIntakeList;
    function GetCurrent : TFhirNutritionIntake;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionIntakeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionIntake read GetCurrent;
  end;

  TFhirNutritionIntakeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionIntake;
    procedure SetItemN(index : Integer; value : TFhirNutritionIntake);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionIntakeList; overload;
    function Clone : TFhirNutritionIntakeList; overload;
    function GetEnumerator : TFhirNutritionIntakeListEnumerator;
    
    //  Add a FhirNutritionIntake to the end of the list.
    function Append : TFhirNutritionIntake;
    
    // Add an already existing FhirNutritionIntake to the end of the list.
    procedure AddItem(value : TFhirNutritionIntake); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionIntake) : Integer;
    
    // Insert FhirNutritionIntake before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionIntake;
    
    // Insert an existing FhirNutritionIntake before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionIntake);
    
    // Get the iIndexth FhirNutritionIntake. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionIntake);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionIntake;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionIntakes[index : Integer] : TFhirNutritionIntake read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
  // Diet given orally in contrast to enteral (tube) feeding.
  TFhirNutritionOrderOralDiet = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FscheduleList : TFhirTimingList;
    FnutrientList : TFhirNutritionOrderOralDietNutrientList;
    FtextureList : TFhirNutritionOrderOralDietTextureList;
    FfluidConsistencyTypeList : TFhirCodeableConceptList;
    FInstruction : TFhirString;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    function GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
    function GetHasNutrientList : Boolean;
    function GetTextureList : TFhirNutritionOrderOralDietTextureList;
    function GetHasTextureList : Boolean;
    function GetFluidConsistencyTypeList : TFhirCodeableConceptList;
    function GetHasFluidConsistencyTypeList : Boolean;
    procedure SetInstruction(value : TFhirString);
    function GetInstructionST : String;
    procedure SetInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDiet; overload;
    function Clone : TFhirNutritionOrderOralDiet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The time period and frequency at which the diet should be given.  The diet should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
    property nutrientList : TFhirNutritionOrderOralDietNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
    property textureList : TFhirNutritionOrderOralDietTextureList read GetTextureList;
    property hasTextureList : boolean read GetHasTextureList;

    // The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
    property fluidConsistencyTypeList : TFhirCodeableConceptList read GetFluidConsistencyTypeList;
    property hasFluidConsistencyTypeList : boolean read GetHasFluidConsistencyTypeList;

    // Typed access to Free text or additional instructions or information pertaining to the oral diet.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral diet.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderOralDietListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietList;
    function GetCurrent : TFhirNutritionOrderOralDiet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDiet read GetCurrent;
  end;

  TFhirNutritionOrderOralDietList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDiet;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDiet);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietList; overload;
    function Clone : TFhirNutritionOrderOralDietList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
    
    //  Add a FhirNutritionOrderOralDiet to the end of the list.
    function Append : TFhirNutritionOrderOralDiet;
    
    // Add an already existing FhirNutritionOrderOralDiet to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDiet); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDiet) : Integer;
    
    // Insert FhirNutritionOrderOralDiet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDiet;
    
    // Insert an existing FhirNutritionOrderOralDiet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDiet);
    
    // Get the iIndexth FhirNutritionOrderOralDiet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDiet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDiet;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDiets[index : Integer] : TFhirNutritionOrderOralDiet read GetItemN write SetItemN; default;
  End;

  // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
  TFhirNutritionOrderOralDietNutrient = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    procedure SetModifier(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietNutrient; overload;
    function Clone : TFhirNutritionOrderOralDietNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The nutrient that is being modified such as carbohydrate or sodium. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // The nutrient that is being modified such as carbohydrate or sodium.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The quantity of the specified nutrient to include in diet. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The quantity of the specified nutrient to include in diet.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirNutritionOrderOralDietNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietNutrientList;
    function GetCurrent : TFhirNutritionOrderOralDietNutrient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietNutrient read GetCurrent;
  end;

  TFhirNutritionOrderOralDietNutrientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietNutrientList; overload;
    function Clone : TFhirNutritionOrderOralDietNutrientList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
    
    //  Add a FhirNutritionOrderOralDietNutrient to the end of the list.
    function Append : TFhirNutritionOrderOralDietNutrient;
    
    // Add an already existing FhirNutritionOrderOralDietNutrient to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietNutrient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietNutrient) : Integer;
    
    // Insert FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    
    // Insert an existing FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
    
    // Get the iIndexth FhirNutritionOrderOralDietNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDietNutrients[index : Integer] : TFhirNutritionOrderOralDietNutrient read GetItemN write SetItemN; default;
  End;

  // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
  TFhirNutritionOrderOralDietTexture = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FFoodType : TFhirCodeableConcept;
    procedure SetModifier(value : TFhirCodeableConcept);
    procedure SetFoodType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietTexture; overload;
    function Clone : TFhirNutritionOrderOralDietTexture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. (defined for API consistency)
    property foodType : TFhirCodeableConcept read FFoodType write SetFoodType;
    // The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types.
    property foodTypeElement : TFhirCodeableConcept read FFoodType write SetFoodType;

  end;

  TFhirNutritionOrderOralDietTextureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietTextureList;
    function GetCurrent : TFhirNutritionOrderOralDietTexture;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietTextureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietTexture read GetCurrent;
  end;

  TFhirNutritionOrderOralDietTextureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietTexture;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietTexture);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietTextureList; overload;
    function Clone : TFhirNutritionOrderOralDietTextureList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
    
    //  Add a FhirNutritionOrderOralDietTexture to the end of the list.
    function Append : TFhirNutritionOrderOralDietTexture;
    
    // Add an already existing FhirNutritionOrderOralDietTexture to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietTexture); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietTexture) : Integer;
    
    // Insert FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietTexture;
    
    // Insert an existing FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietTexture);
    
    // Get the iIndexth FhirNutritionOrderOralDietTexture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietTexture);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietTexture;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDietTextures[index : Integer] : TFhirNutritionOrderOralDietTexture read GetItemN write SetItemN; default;
  End;

  // Oral nutritional products given in order to add further nutritional value to the patient's diet.
  TFhirNutritionOrderSupplement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FProductName : TFhirString;
    FscheduleList : TFhirTimingList;
    FQuantity : TFhirQuantity;
    FInstruction : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetProductName(value : TFhirString);
    function GetProductNameST : String;
    procedure SetProductNameST(value : String);
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetInstruction(value : TFhirString);
    function GetInstructionST : String;
    procedure SetInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderSupplement; overload;
    function Clone : TFhirNutritionOrderSupplement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productName : String read GetProductNameST write SetProductNameST;
    // The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productNameElement : TFhirString read FProductName write SetProductName;

    // The time period and frequency at which the supplement(s) should be given.  The supplement should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The amount of the nutritional supplement to be given. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the nutritional supplement to be given.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Free text or additional instructions or information pertaining to the oral supplement.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral supplement.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderSupplementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderSupplementList;
    function GetCurrent : TFhirNutritionOrderSupplement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderSupplementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderSupplement read GetCurrent;
  end;

  TFhirNutritionOrderSupplementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderSupplement;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderSupplement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderSupplementList; overload;
    function Clone : TFhirNutritionOrderSupplementList; overload;
    function GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
    
    //  Add a FhirNutritionOrderSupplement to the end of the list.
    function Append : TFhirNutritionOrderSupplement;
    
    // Add an already existing FhirNutritionOrderSupplement to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderSupplement); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderSupplement) : Integer;
    
    // Insert FhirNutritionOrderSupplement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderSupplement;
    
    // Insert an existing FhirNutritionOrderSupplement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderSupplement);
    
    // Get the iIndexth FhirNutritionOrderSupplement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderSupplement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderSupplement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderSupplements[index : Integer] : TFhirNutritionOrderSupplement read GetItemN write SetItemN; default;
  End;

  // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
  TFhirNutritionOrderEnteralFormula = class (TFhirBackboneElement)
  protected
    FBaseFormulaType : TFhirCodeableConcept;
    FBaseFormulaProductName : TFhirString;
    FAdditiveType : TFhirCodeableConcept;
    FAdditiveProductName : TFhirString;
    FCaloricDensity : TFhirQuantity;
    FRouteofAdministration : TFhirCodeableConcept;
    FadministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    FMaxVolumeToDeliver : TFhirQuantity;
    FAdministrationInstruction : TFhirString;
    procedure SetBaseFormulaType(value : TFhirCodeableConcept);
    procedure SetBaseFormulaProductName(value : TFhirString);
    function GetBaseFormulaProductNameST : String;
    procedure SetBaseFormulaProductNameST(value : String);
    procedure SetAdditiveType(value : TFhirCodeableConcept);
    procedure SetAdditiveProductName(value : TFhirString);
    function GetAdditiveProductNameST : String;
    procedure SetAdditiveProductNameST(value : String);
    procedure SetCaloricDensity(value : TFhirQuantity);
    procedure SetRouteofAdministration(value : TFhirCodeableConcept);
    function GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetHasAdministrationList : Boolean;
    procedure SetMaxVolumeToDeliver(value : TFhirQuantity);
    procedure SetAdministrationInstruction(value : TFhirString);
    function GetAdministrationInstructionST : String;
    procedure SetAdministrationInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormula; overload;
    function Clone : TFhirNutritionOrderEnteralFormula; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. (defined for API consistency)
    property baseFormulaType : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;
    // The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
    property baseFormulaTypeElement : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;

    // Typed access to The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductName : String read GetBaseFormulaProductNameST write SetBaseFormulaProductNameST;
    // The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductNameElement : TFhirString read FBaseFormulaProductName write SetBaseFormulaProductName;

    // Typed access to Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula. (defined for API consistency)
    property additiveType : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;
    // Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
    property additiveTypeElement : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;

    // Typed access to The product or brand name of the type of modular component to be added to the formula.
    property additiveProductName : String read GetAdditiveProductNameST write SetAdditiveProductNameST;
    // The product or brand name of the type of modular component to be added to the formula.
    property additiveProductNameElement : TFhirString read FAdditiveProductName write SetAdditiveProductName;

    // Typed access to The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL. (defined for API consistency)
    property caloricDensity : TFhirQuantity read FCaloricDensity write SetCaloricDensity;
    // The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL.
    property caloricDensityElement : TFhirQuantity read FCaloricDensity write SetCaloricDensity;

    // Typed access to The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube. (defined for API consistency)
    property routeofAdministration : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;
    // The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube.
    property routeofAdministrationElement : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;

    // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
    property administrationList : TFhirNutritionOrderEnteralFormulaAdministrationList read GetAdministrationList;
    property hasAdministrationList : boolean read GetHasAdministrationList;

    // Typed access to The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours. (defined for API consistency)
    property maxVolumeToDeliver : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;
    // The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
    property maxVolumeToDeliverElement : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;

    // Typed access to Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstruction : String read GetAdministrationInstructionST write SetAdministrationInstructionST;
    // Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstructionElement : TFhirString read FAdministrationInstruction write SetAdministrationInstruction;

  end;

  TFhirNutritionOrderEnteralFormulaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaList;
    function GetCurrent : TFhirNutritionOrderEnteralFormula;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormula read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormula;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormula);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderEnteralFormulaList; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaList; overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
    
    //  Add a FhirNutritionOrderEnteralFormula to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormula;
    
    // Add an already existing FhirNutritionOrderEnteralFormula to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormula); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormula) : Integer;
    
    // Insert FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormula;
    
    // Insert an existing FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormula);
    
    // Get the iIndexth FhirNutritionOrderEnteralFormula. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormula);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormula;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderEnteralFormulas[index : Integer] : TFhirNutritionOrderEnteralFormula read GetItemN write SetItemN; default;
  End;

  // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
  TFhirNutritionOrderEnteralFormulaAdministration = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirTiming;
    FQuantity : TFhirQuantity;
    FRate : TFhirDataType;
    procedure SetSchedule(value : TFhirTiming);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetRate(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The time period and frequency at which the enteral formula should be delivered to the patient. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // The time period and frequency at which the enteral formula should be delivered to the patient.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

    // Typed access to The volume of formula to provide to the patient per the specified administration schedule. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The volume of formula to provide to the patient per the specified administration schedule.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. (defined for API consistency)
    property rate : TFhirDataType read FRate write SetRate;
    // The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule.
    property rateElement : TFhirDataType read FRate write SetRate;

  end;

  TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormulaAdministration read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderEnteralFormulaAdministrationList; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministrationList; overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
    
    //  Add a FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // Add an already existing FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormulaAdministration); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormulaAdministration) : Integer;
    
    // Insert FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // Insert an existing FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
    
    // Get the iIndexth FhirNutritionOrderEnteralFormulaAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderEnteralFormulaAdministrations[index : Integer] : TFhirNutritionOrderEnteralFormulaAdministration read GetItemN write SetItemN; default;
  End;

  // A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
  TFhirNutritionOrder = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FinstantiatesList : TFhirUriList;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FDateTime : TFhirDateTime;
    FOrderer : TFhirReference;
    FallergyIntoleranceList : TFhirReferenceList;
    FfoodPreferenceModifierList : TFhirCodeableConceptList;
    FexcludeFoodModifierList : TFhirCodeableConceptList;
    FOralDiet : TFhirNutritionOrderOralDiet;
    FsupplementList : TFhirNutritionOrderSupplementList;
    FEnteralFormula : TFhirNutritionOrderEnteralFormula;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetInstantiatesList : TFhirUriList;
    function GetHasInstantiatesList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDateTime(value : TFhirDateTime);
    function GetDateTimeST : TFslDateTime;
    procedure SetDateTimeST(value : TFslDateTime);
    procedure SetOrderer(value : TFhirReference);
    function GetAllergyIntoleranceList : TFhirReferenceList;
    function GetHasAllergyIntoleranceList : Boolean;
    function GetFoodPreferenceModifierList : TFhirCodeableConceptList;
    function GetHasFoodPreferenceModifierList : Boolean;
    function GetExcludeFoodModifierList : TFhirCodeableConceptList;
    function GetHasExcludeFoodModifierList : Boolean;
    procedure SetOralDiet(value : TFhirNutritionOrderOralDiet);
    function GetSupplementList : TFhirNutritionOrderSupplementList;
    function GetHasSupplementList : Boolean;
    procedure SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrder; overload;
    function Clone : TFhirNutritionOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the order sender or by the order receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // The URL pointing to a protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesList : TFhirUriList read GetInstantiatesList;
    property hasInstantiatesList : boolean read GetHasInstantiatesList;

    // The workflow status of the nutrition order/request.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the NutrionOrder and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Typed access to The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date and time that this nutrition order was requested.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The date and time that this nutrition order was requested.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Typed access to The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. (defined for API consistency)
    property orderer : TFhirReference read FOrderer write SetOrderer;
    // The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
    property ordererElement : TFhirReference read FOrderer write SetOrderer;

    // A link to a record of allergies or intolerances  which should be included in the nutrition order.
    property allergyIntoleranceList : TFhirReferenceList read GetAllergyIntoleranceList;
    property hasAllergyIntoleranceList : boolean read GetHasAllergyIntoleranceList;

    // This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property foodPreferenceModifierList : TFhirCodeableConceptList read GetFoodPreferenceModifierList;
    property hasFoodPreferenceModifierList : boolean read GetHasFoodPreferenceModifierList;

    // This modifier is used to convey Order-specific modifier about the type of oral food or oral fluids that should not be given. These can be derived from patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance information captured in the referenced AllergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be eliminated from the patient’s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property excludeFoodModifierList : TFhirCodeableConceptList read GetExcludeFoodModifierList;
    property hasExcludeFoodModifierList : boolean read GetHasExcludeFoodModifierList;

    // Typed access to Diet given orally in contrast to enteral (tube) feeding. (defined for API consistency)
    property oralDiet : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;
    // Diet given orally in contrast to enteral (tube) feeding.
    property oralDietElement : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;

    // Oral nutritional products given in order to add further nutritional value to the patient's diet.
    property supplementList : TFhirNutritionOrderSupplementList read GetSupplementList;
    property hasSupplementList : boolean read GetHasSupplementList;

    // Typed access to Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity. (defined for API consistency)
    property enteralFormula : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;
    // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
    property enteralFormulaElement : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;

    // Comments made about the {{title)))) by the requester, performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderList;
    function GetCurrent : TFhirNutritionOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrder read GetCurrent;
  end;

  TFhirNutritionOrderList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrder;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderList; overload;
    function Clone : TFhirNutritionOrderList; overload;
    function GetEnumerator : TFhirNutritionOrderListEnumerator;
    
    //  Add a FhirNutritionOrder to the end of the list.
    function Append : TFhirNutritionOrder;
    
    // Add an already existing FhirNutritionOrder to the end of the list.
    procedure AddItem(value : TFhirNutritionOrder); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrder) : Integer;
    
    // Insert FhirNutritionOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrder;
    
    // Insert an existing FhirNutritionOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrder);
    
    // Get the iIndexth FhirNutritionOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrder);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrder;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrders[index : Integer] : TFhirNutritionOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  // Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  protected
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FType_ : TFhirCodeableConcept;
    FappliesToList : TFhirCodeableConceptList;
    FAge : TFhirRange;
    FText : TFhirString;
    procedure SetLow(value : TFhirQuantity);
    procedure SetHigh(value : TFhirQuantity);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetAppliesToList : TFhirCodeableConceptList;
    function GetHasAppliesToList : Boolean;
    procedure SetAge(value : TFhirRange);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3). (defined for API consistency)
    property low : TFhirQuantity read FLow write SetLow;
    // The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
    property lowElement : TFhirQuantity read FLow write SetLow;

    // Typed access to The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3). (defined for API consistency)
    property high : TFhirQuantity read FHigh write SetHigh;
    // The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
    property highElement : TFhirQuantity read FHigh write SetHigh;

    // Typed access to Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Codes to indicate the target population this reference range applies to.  For example, a reference range may be based on the normal population or a particular sex or race.  Multiple `appliesTo`  are interpreted as an "AND" of the target populations.  For example, to represent a target population of African American females, both a code of female and a code for African American would be used.
    property appliesToList : TFhirCodeableConceptList read GetAppliesToList;
    property hasAppliesToList : boolean read GetHasAppliesToList;

    // Typed access to The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so. (defined for API consistency)
    property age : TFhirRange read FAge write SetAge;
    // The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    property ageElement : TFhirRange read FAge write SetAge;

    // Typed access to Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of "normals".
    property text : String read GetTextST write SetTextST;
    // Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of "normals".
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirObservationReferenceRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationReferenceRangeList;
    function GetCurrent : TFhirObservationReferenceRange;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationReferenceRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationReferenceRange read GetCurrent;
  end;

  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationReferenceRangeList; overload;
    function Clone : TFhirObservationReferenceRangeList; overload;
    function GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
    
    //  Add a FhirObservationReferenceRange to the end of the list.
    function Append : TFhirObservationReferenceRange;
    
    // Add an already existing FhirObservationReferenceRange to the end of the list.
    procedure AddItem(value : TFhirObservationReferenceRange); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;
    
    // Insert FhirObservationReferenceRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationReferenceRange;
    
    // Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);
    
    // Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationReferenceRange;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;

  // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
  TFhirObservationComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FDataAbsentReason : TFhirCodeableConcept;
    FinterpretationList : TFhirCodeableConceptList;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    function GetInterpretationList : TFhirCodeableConceptList;
    function GetHasInterpretationList : Boolean;
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationComponent; overload;
    function Clone : TFhirObservationComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes what was observed. Sometimes this is called the observation "code". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "code".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.component.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.component.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // A categorical assessment of an observation value.  For example, high, low, normal.
    property interpretationList : TFhirCodeableConceptList read GetInterpretationList;
    property hasInterpretationList : boolean read GetHasInterpretationList;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

  end;

  TFhirObservationComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationComponentList;
    function GetCurrent : TFhirObservationComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationComponent read GetCurrent;
  end;

  TFhirObservationComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationComponent;
    procedure SetItemN(index : Integer; value : TFhirObservationComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationComponentList; overload;
    function Clone : TFhirObservationComponentList; overload;
    function GetEnumerator : TFhirObservationComponentListEnumerator;
    
    //  Add a FhirObservationComponent to the end of the list.
    function Append : TFhirObservationComponent;
    
    // Add an already existing FhirObservationComponent to the end of the list.
    procedure AddItem(value : TFhirObservationComponent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationComponent) : Integer;
    
    // Insert FhirObservationComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationComponent;
    
    // Insert an existing FhirObservationComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationComponent);
    
    // Get the iIndexth FhirObservationComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationComponents[index : Integer] : TFhirObservationComponent read GetItemN write SetItemN; default;
  End;

  // Measurements and simple assertions made about a patient, device or other subject.
  TFhirObservation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FfocusList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList;
    FValue : TFhirDataType;
    FDataAbsentReason : TFhirCodeableConcept;
    FinterpretationList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FBodySite : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FSpecimen : TFhirReference;
    FDevice : TFhirReference;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    FhasMemberList : TFhirReferenceList;
    FderivedFromList : TFhirReferenceList;
    FcomponentList : TFhirObservationComponentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    function GetFocusList : TFhirReferenceList;
    function GetHasFocusList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetIssued(value : TFhirInstant);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    procedure SetValue(value : TFhirDataType);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    function GetInterpretationList : TFhirCodeableConceptList;
    function GetHasInterpretationList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetSpecimen(value : TFhirReference);
    procedure SetDevice(value : TFhirReference);
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
    function GetHasMemberList : TFhirReferenceList;
    function GetHasHasMemberList : Boolean;
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    function GetComponentList : TFhirObservationComponentList;
    function GetHasComponentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservation; overload;
    function Clone : TFhirObservation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this observation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.  For example, a MedicationRequest may require a patient to have laboratory test performed before  it is dispensed.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular Observation is a component or step.  For example,  an observation as part of a procedure.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The status of the result value.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of observation being made.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Describes what was observed. Sometimes this is called the observation "name". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "name".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, or group of patients, location, or device this observation is about and into whose record the observation is placed. If the actual focus of the observation is different from the subject (or a sample of, part, or region of the subject), the `focus` element or the `code` itself specifies the actual focus of the observation. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient, or group of patients, location, or device this observation is about and into whose record the observation is placed. If the actual focus of the observation is different from the subject (or a sample of, part, or region of the subject), the `focus` element or the `code` itself specifies the actual focus of the observation.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // The actual focus of an observation when it is not the patient of record representing something or someone associated with the patient such as a spouse, parent, fetus, or donor. For example, fetus observations in a mother's record.  The focus of an observation could also be an existing condition,  an intervention, the subject's diet,  another observation of the subject,  or a body structure such as tumor or implanted device.   An example use case would be using the Observation resource to capture whether the mother is trained to change her child's tracheostomy tube. In this example, the child is the patient of record and the mother is the focus.
    property focusList : TFhirReferenceList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date and time this version of the observation was made available to providers, typically after the results have been reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time this version of the observation was made available to providers, typically after the results have been reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Who was responsible for asserting the observed value as "true".
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // A categorical assessment of an observation value.  For example, high, low, normal.
    property interpretationList : TFhirCodeableConceptList read GetInterpretationList;
    property hasInterpretationList : boolean read GetHasInterpretationList;

    // Comments about the observation or the results.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Indicates the site on the subject's body where the observation was made (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the observation was made (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Indicates the mechanism used to perform the observation. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Indicates the mechanism used to perform the observation.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The specimen that was used when this observation was made. (defined for API consistency)
    property specimen : TFhirReference read FSpecimen write SetSpecimen;
    // The specimen that was used when this observation was made.
    property specimenElement : TFhirReference read FSpecimen write SetSpecimen;

    // Typed access to The device used to generate the observation data. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The device used to generate the observation data.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

    // This observation is a group observation (e.g. a battery, a panel of tests, a set of vital sign measurements) that includes the target as a member of the group.
    property hasMemberList : TFhirReferenceList read GetHasMemberList;
    property hasHasMemberList : boolean read GetHasHasMemberList;

    // The target resource that represents a measurement from which this observation value is derived. For example, a calculated anion gap or a fetal measurement based on an ultrasound image.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
    property componentList : TFhirObservationComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirObservationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationList;
    function GetCurrent : TFhirObservation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservation read GetCurrent;
  end;

  TFhirObservationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservation;
    procedure SetItemN(index : Integer; value : TFhirObservation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationList; overload;
    function Clone : TFhirObservationList; overload;
    function GetEnumerator : TFhirObservationListEnumerator;
    
    //  Add a FhirObservation to the end of the list.
    function Append : TFhirObservation;
    
    // Add an already existing FhirObservation to the end of the list.
    procedure AddItem(value : TFhirObservation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservation) : Integer;
    
    // Insert FhirObservation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservation;
    
    // Insert an existing FhirObservation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservation);
    
    // Get the iIndexth FhirObservation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservations[index : Integer] : TFhirObservation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  // Limited to "real" people rather than equipment.
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    FOnBehalfOf : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what performed the procedure. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what performed the procedure.
    property actorElement : TFhirReference read FActor write SetActor;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProcedurePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedurePerformerList;
    function GetCurrent : TFhirProcedurePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedurePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedurePerformer read GetCurrent;
  end;

  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedurePerformerList; overload;
    function Clone : TFhirProcedurePerformerList; overload;
    function GetEnumerator : TFhirProcedurePerformerListEnumerator;
    
    //  Add a FhirProcedurePerformer to the end of the list.
    function Append : TFhirProcedurePerformer;
    
    // Add an already existing FhirProcedurePerformer to the end of the list.
    procedure AddItem(value : TFhirProcedurePerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedurePerformer) : Integer;
    
    // Insert FhirProcedurePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedurePerformer;
    
    // Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);
    
    // Get the iIndexth FhirProcedurePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedurePerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;

  // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  TFhirProcedureFocalDevice = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FManipulated : TFhirReference;
    procedure SetAction(value : TFhirCodeableConcept);
    procedure SetManipulated(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureFocalDevice; overload;
    function Clone : TFhirProcedureFocalDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of change that happened to the device during the procedure. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // The kind of change that happened to the device during the procedure.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to The device that was manipulated (changed) during the procedure. (defined for API consistency)
    property manipulated : TFhirReference read FManipulated write SetManipulated;
    // The device that was manipulated (changed) during the procedure.
    property manipulatedElement : TFhirReference read FManipulated write SetManipulated;

  end;

  TFhirProcedureFocalDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureFocalDeviceList;
    function GetCurrent : TFhirProcedureFocalDevice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureFocalDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureFocalDevice read GetCurrent;
  end;

  TFhirProcedureFocalDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedureFocalDevice;
    procedure SetItemN(index : Integer; value : TFhirProcedureFocalDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedureFocalDeviceList; overload;
    function Clone : TFhirProcedureFocalDeviceList; overload;
    function GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
    
    //  Add a FhirProcedureFocalDevice to the end of the list.
    function Append : TFhirProcedureFocalDevice;
    
    // Add an already existing FhirProcedureFocalDevice to the end of the list.
    procedure AddItem(value : TFhirProcedureFocalDevice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureFocalDevice) : Integer;
    
    // Insert FhirProcedureFocalDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureFocalDevice;
    
    // Insert an existing FhirProcedureFocalDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureFocalDevice);
    
    // Get the iIndexth FhirProcedureFocalDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureFocalDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureFocalDevice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedureFocalDevices[index : Integer] : TFhirProcedureFocalDevice read GetItemN write SetItemN; default;
  End;

  // An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy.
  TFhirProcedure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FRecorded : TFhirDateTime;
    FRecorder : TFhirReference;
    FReported : TFhirDataType;
    FperformerList : TFhirProcedurePerformerList;
    FLocation : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FbodySiteList : TFhirCodeableConceptList;
    FOutcome : TFhirCodeableConcept;
    FreportList : TFhirReferenceList;
    FcomplicationList : TFhirCodeableConceptList;
    FcomplicationDetailList : TFhirReferenceList;
    FfollowUpList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FfocalDeviceList : TFhirProcedureFocalDeviceList;
    FusedList : TFhirCodeableReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetRecorded(value : TFhirDateTime);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetRecorder(value : TFhirReference);
    procedure SetReported(value : TFhirDataType);
    function GetPerformerList : TFhirProcedurePerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    procedure SetOutcome(value : TFhirCodeableConcept);
    function GetReportList : TFhirReferenceList;
    function GetHasReportList : Boolean;
    function GetComplicationList : TFhirCodeableConceptList;
    function GetHasComplicationList : Boolean;
    function GetComplicationDetailList : TFhirReferenceList;
    function GetHasComplicationDetailList : Boolean;
    function GetFollowUpList : TFhirCodeableConceptList;
    function GetHasFollowUpList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetFocalDeviceList : TFhirProcedureFocalDeviceList;
    function GetHasFocalDeviceList : Boolean;
    function GetUsedList : TFhirCodeableReferenceList;
    function GetHasUsedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedure; overload;
    function Clone : TFhirProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this procedure by the performer or other systems which remain constant as the resource is updated and is propagated from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A reference to a resource that contains details of the request for this procedure.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular procedure is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the procedure. Generally, this will be the in-progress or completed state.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the procedure. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the procedure.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy"). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The person, animal or group on which the procedure was performed. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person, animal or group on which the procedure was performed.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this Procedure was created or performed or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Procedure was created or performed or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date, date-time, period, or age when the procedure did occur or is occurring.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // Estimated or actual date, date-time, period, or age when the procedure did occur or is occurring.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The date the occurrence of the procedure was first captured in the record regardless of Procedure.status (potentially after the occurrence of the event).
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The date the occurrence of the procedure was first captured in the record regardless of Procedure.status (potentially after the occurrence of the event).
    property recordedElement : TFhirDateTime read FRecorded write SetRecorded;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report. (defined for API consistency)
    property reported : TFhirDataType read FReported write SetReported;
    // Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report.
    property reportedElement : TFhirDataType read FReported write SetReported;

    // Limited to "real" people rather than equipment.
    property performerList : TFhirProcedurePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The coded reason or reference why the procedure was performed. This may be a coded entity of some type, or may simply be present as text, or may be a reference to one of several resources that justify the procedure.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to The outcome of the procedure - did it resolve the reasons for the procedure being performed? (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // The outcome of the procedure - did it resolve the reasons for the procedure being performed?
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // This could be a histology result, pathology report, surgical report, etc.
    property reportList : TFhirReferenceList read GetReportList;
    property hasReportList : boolean read GetHasReportList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
    property complicationList : TFhirCodeableConceptList read GetComplicationList;
    property hasComplicationList : boolean read GetHasComplicationList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period.
    property complicationDetailList : TFhirReferenceList read GetComplicationDetailList;
    property hasComplicationDetailList : boolean read GetHasComplicationDetailList;

    // If the procedure required specific follow up - e.g. removal of sutures. The follow up may be represented as a simple note or could potentially be more complex, in which case the CarePlan resource can be used.
    property followUpList : TFhirCodeableConceptList read GetFollowUpList;
    property hasFollowUpList : boolean read GetHasFollowUpList;

    // Any other notes and comments about the procedure.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    property focalDeviceList : TFhirProcedureFocalDeviceList read GetFocalDeviceList;
    property hasFocalDeviceList : boolean read GetHasFocalDeviceList;

    // Identifies medications, devices and any other substance used as part of the procedure.
    property usedList : TFhirCodeableReferenceList read GetUsedList;
    property hasUsedList : boolean read GetHasUsedList;

  end;

  TFhirProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureList;
    function GetCurrent : TFhirProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedure read GetCurrent;
  end;

  TFhirProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedure;
    procedure SetItemN(index : Integer; value : TFhirProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedureList; overload;
    function Clone : TFhirProcedureList; overload;
    function GetEnumerator : TFhirProcedureListEnumerator;
    
    //  Add a FhirProcedure to the end of the list.
    function Append : TFhirProcedure;
    
    // Add an already existing FhirProcedure to the end of the list.
    procedure AddItem(value : TFhirProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedure) : Integer;
    
    // Insert FhirProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedure;
    
    // Insert an existing FhirProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedure);
    
    // Get the iIndexth FhirProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedures[index : Integer] : TFhirProcedure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
  // Describes the expected outcome for the subject.
  TFhirRiskAssessmentPrediction = class (TFhirBackboneElement)
  protected
    FOutcome : TFhirCodeableConcept;
    FProbability : TFhirDataType;
    FQualitativeRisk : TFhirCodeableConcept;
    FRelativeRisk : TFhirDecimal;
    FWhen : TFhirDataType;
    FRationale : TFhirString;
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetProbability(value : TFhirDataType);
    procedure SetQualitativeRisk(value : TFhirCodeableConcept);
    procedure SetRelativeRisk(value : TFhirDecimal);
    function GetRelativeRiskST : String;
    procedure SetRelativeRiskST(value : String);
    procedure SetWhen(value : TFhirDataType);
    procedure SetRationale(value : TFhirString);
    function GetRationaleST : String;
    procedure SetRationaleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessmentPrediction; overload;
    function Clone : TFhirRiskAssessmentPrediction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to One of the potential outcomes for the patient (e.g. remission, death,  a particular condition). (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Indicates how likely the outcome is (in the specified timeframe). (defined for API consistency)
    property probability : TFhirDataType read FProbability write SetProbability;
    // Indicates how likely the outcome is (in the specified timeframe).
    property probabilityElement : TFhirDataType read FProbability write SetProbability;

    // Typed access to Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high). (defined for API consistency)
    property qualitativeRisk : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;
    // Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high).
    property qualitativeRiskElement : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;

    // Typed access to Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRisk : String read GetRelativeRiskST write SetRelativeRiskST;
    // Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRiskElement : TFhirDecimal read FRelativeRisk write SetRelativeRisk;

    // Typed access to Indicates the period of time or age range of the subject to which the specified probability applies. (defined for API consistency)
    property when : TFhirDataType read FWhen write SetWhen;
    // Indicates the period of time or age range of the subject to which the specified probability applies.
    property whenElement : TFhirDataType read FWhen write SetWhen;

    // Typed access to Additional information explaining the basis for the prediction.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Additional information explaining the basis for the prediction.
    property rationaleElement : TFhirString read FRationale write SetRationale;

  end;

  TFhirRiskAssessmentPredictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentPredictionList;
    function GetCurrent : TFhirRiskAssessmentPrediction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentPredictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessmentPrediction read GetCurrent;
  end;

  TFhirRiskAssessmentPredictionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRiskAssessmentPrediction;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessmentPrediction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRiskAssessmentPredictionList; overload;
    function Clone : TFhirRiskAssessmentPredictionList; overload;
    function GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
    
    //  Add a FhirRiskAssessmentPrediction to the end of the list.
    function Append : TFhirRiskAssessmentPrediction;
    
    // Add an already existing FhirRiskAssessmentPrediction to the end of the list.
    procedure AddItem(value : TFhirRiskAssessmentPrediction); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessmentPrediction) : Integer;
    
    // Insert FhirRiskAssessmentPrediction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessmentPrediction;
    
    // Insert an existing FhirRiskAssessmentPrediction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessmentPrediction);
    
    // Get the iIndexth FhirRiskAssessmentPrediction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessmentPrediction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessmentPrediction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRiskAssessmentPredictions[index : Integer] : TFhirRiskAssessmentPrediction read GetItemN write SetItemN; default;
  End;

  // An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
  TFhirRiskAssessment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FBasedOn : TFhirReference;
    FParent : TFhirReference;
    FStatus : TFhirEnum;
    FMethod : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FCondition : TFhirReference;
    FPerformer : TFhirReference;
    FreasonList : TFhirCodeableReferenceList;
    FbasisList : TFhirReferenceList;
    FpredictionList : TFhirRiskAssessmentPredictionList;
    FMitigation : TFhirString;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetBasedOn(value : TFhirReference);
    procedure SetParent(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetCondition(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetBasisList : TFhirReferenceList;
    function GetHasBasisList : Boolean;
    function GetPredictionList : TFhirRiskAssessmentPredictionList;
    function GetHasPredictionList : Boolean;
    procedure SetMitigation(value : TFhirString);
    function GetMitigationST : String;
    procedure SetMitigationST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessment; overload;
    function Clone : TFhirRiskAssessment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier assigned to the risk assessment.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A reference to the request that is fulfilled by this risk assessment. (defined for API consistency)
    property basedOn : TFhirReference read FBasedOn write SetBasedOn;
    // A reference to the request that is fulfilled by this risk assessment.
    property basedOnElement : TFhirReference read FBasedOn write SetBasedOn;

    // Typed access to A reference to a resource that this risk assessment is part of, such as a Procedure. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // A reference to a resource that this risk assessment is part of, such as a Procedure.
    property parentElement : TFhirReference read FParent write SetParent;

    // The status of the RiskAssessment, using the same statuses as an Observation.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The algorithm, process or mechanism used to evaluate the risk. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The algorithm, process or mechanism used to evaluate the risk.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The type of the risk assessment performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the risk assessment performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient or group the risk assessment applies to. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group the risk assessment applies to.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter where the assessment was performed. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter where the assessment was performed.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and possibly time) the risk assessment was performed. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date (and possibly time) the risk assessment was performed.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to For assessments or prognosis specific to a particular condition, indicates the condition being assessed. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to The provider or software application that performed the assessment. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The provider or software application that performed the assessment.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // The reason the risk assessment was performed.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Indicates the source data considered as part of the assessment (for example, FamilyHistory, Observations, Procedures, Conditions, etc.).
    property basisList : TFhirReferenceList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Describes the expected outcome for the subject.
    property predictionList : TFhirRiskAssessmentPredictionList read GetPredictionList;
    property hasPredictionList : boolean read GetHasPredictionList;

    // Typed access to A description of the steps that might be taken to reduce the identified risk(s).
    property mitigation : String read GetMitigationST write SetMitigationST;
    // A description of the steps that might be taken to reduce the identified risk(s).
    property mitigationElement : TFhirString read FMitigation write SetMitigation;

    // Additional comments about the risk assessment.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirRiskAssessmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentList;
    function GetCurrent : TFhirRiskAssessment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessment read GetCurrent;
  end;

  TFhirRiskAssessmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRiskAssessment;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRiskAssessmentList; overload;
    function Clone : TFhirRiskAssessmentList; overload;
    function GetEnumerator : TFhirRiskAssessmentListEnumerator;
    
    //  Add a FhirRiskAssessment to the end of the list.
    function Append : TFhirRiskAssessment;
    
    // Add an already existing FhirRiskAssessment to the end of the list.
    procedure AddItem(value : TFhirRiskAssessment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessment) : Integer;
    
    // Insert FhirRiskAssessment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessment;
    
    // Insert an existing FhirRiskAssessment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessment);
    
    // Get the iIndexth FhirRiskAssessment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRiskAssessments[index : Integer] : TFhirRiskAssessment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
  // A record of a request for service such as diagnostic investigations, treatments, or operations to be performed.
  TFhirServiceRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FRequisition : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    ForderDetailList : TFhirCodeableConceptList;
    FQuantity : TFhirDataType;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FAsNeeded : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FperformerList : TFhirReferenceList;
    FlocationList : TFhirCodeableReferenceList;
    FreasonList : TFhirCodeableReferenceList;
    FinsuranceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FspecimenList : TFhirReferenceList;
    FbodySiteList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FPatientInstruction : TFhirString;
    FrelevantHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetRequisition(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetOrderDetailList : TFhirCodeableConceptList;
    function GetHasOrderDetailList : Boolean;
    procedure SetQuantity(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAsNeeded(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    function GetLocationList : TFhirCodeableReferenceList;
    function GetHasLocationList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetPatientInstruction(value : TFhirString);
    function GetPatientInstructionST : String;
    procedure SetPatientInstructionST(value : String);
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirServiceRequest; overload;
    function Clone : TFhirServiceRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order instance by the orderer and/or the receiver and/or order fulfiller.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this ServiceRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this ServiceRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all service requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier. (defined for API consistency)
    property requisition : TFhirIdentifier read FRequisition write SetRequisition;
    // A shared identifier common to all service requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier.
    property requisitionElement : TFhirIdentifier read FRequisition write SetRequisition;

    // The status of the order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // A code that classifies the service for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Indicates how quickly the ServiceRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Set this to true if the record is saying that the service/procedure should NOT be performed.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // Set this to true if the record is saying that the service/procedure should NOT be performed.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to A code that identifies a particular service (i.e., procedure, diagnostic investigation, or panel of investigations) that have been requested. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies a particular service (i.e., procedure, diagnostic investigation, or panel of investigations) that have been requested.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Additional details and instructions about the how the services are to be delivered.   For example, and order for a urinary catheter may have an order detail for an external or indwelling catheter, or an order for a bandage may require additional instructions specifying how the bandage should be applied.
    property orderDetailList : TFhirCodeableConceptList read GetOrderDetailList;
    property hasOrderDetailList : boolean read GetHasOrderDetailList;

    // Typed access to An amount of service being requested which can be a quantity ( for example $1,500 home modification), a ratio ( for example, 20 half day visits per month), or a range (2.0 to 1.8 Gy per fraction). (defined for API consistency)
    property quantity : TFhirDataType read FQuantity write SetQuantity;
    // An amount of service being requested which can be a quantity ( for example $1,500 home modification), a ratio ( for example, 20 half day visits per month), or a range (2.0 to 1.8 Gy per fraction).
    property quantityElement : TFhirDataType read FQuantity write SetQuantity;

    // Typed access to On whom or what the service is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // On whom or what the service is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date/time at which the requested service should occur. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date/time at which the requested service should occur.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc. (defined for API consistency)
    property asNeeded : TFhirDataType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc.
    property asNeededElement : TFhirDataType read FAsNeeded write SetAsNeeded;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the requested service. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the requested service.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // The desired performer for doing the requested service.  For example, the surgeon, dermatopathologist, endoscopist, etc.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The preferred location(s) where the procedure should actually happen in coded or free text form. E.g. at home or nursing day care center.
    property locationList : TFhirCodeableReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // An explanation or justification for why this service is being requested in coded or textual form.   This is often for billing purposes.  May relate to the resources referred to in `supportingInfo`.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be needed for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Additional clinical information about the patient or specimen that may influence the services or their interpretations.     This information includes diagnosis, clinical findings and other observations.  In laboratory ordering these are typically referred to as "ask at order entry questions (AOEs)".  This includes observations explicitly requested by the producer (filler) to provide context or supporting information needed to complete the order. For example,  reporting the amount of inspired oxygen for blood gas measurements.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // One or more specimens that the laboratory procedure will use.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Anatomic location where the procedure should be performed. This is the target site.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Any other notes and comments made about the service request. For example, internal billing notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Instructions in terms that are understood by the patient or consumer.
    property patientInstruction : String read GetPatientInstructionST write SetPatientInstructionST;
    // Instructions in terms that are understood by the patient or consumer.
    property patientInstructionElement : TFhirString read FPatientInstruction write SetPatientInstruction;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirServiceRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirServiceRequestList;
    function GetCurrent : TFhirServiceRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirServiceRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirServiceRequest read GetCurrent;
  end;

  TFhirServiceRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirServiceRequest;
    procedure SetItemN(index : Integer; value : TFhirServiceRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirServiceRequestList; overload;
    function Clone : TFhirServiceRequestList; overload;
    function GetEnumerator : TFhirServiceRequestListEnumerator;
    
    //  Add a FhirServiceRequest to the end of the list.
    function Append : TFhirServiceRequest;
    
    // Add an already existing FhirServiceRequest to the end of the list.
    procedure AddItem(value : TFhirServiceRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirServiceRequest) : Integer;
    
    // Insert FhirServiceRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirServiceRequest;
    
    // Insert an existing FhirServiceRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirServiceRequest);
    
    // Get the iIndexth FhirServiceRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirServiceRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirServiceRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirServiceRequests[index : Integer] : TFhirServiceRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
  // Details concerning the specimen collection.
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference;
    FCollected : TFhirDataType;
    FDuration : TFhirDuration;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FBodySite : TFhirCodeableConcept;
    FFastingStatus : TFhirDataType;
    procedure SetCollector(value : TFhirReference);
    procedure SetCollected(value : TFhirDataType);
    procedure SetDuration(value : TFhirDuration);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetBodySite(value : TFhirCodeableConcept);
    procedure SetFastingStatus(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Person who collected the specimen. (defined for API consistency)
    property collector : TFhirReference read FCollector write SetCollector;
    // Person who collected the specimen.
    property collectorElement : TFhirReference read FCollector write SetCollector;

    // Typed access to Time when specimen was collected from subject - the physiologically relevant time. (defined for API consistency)
    property collected : TFhirDataType read FCollected write SetCollected;
    // Time when specimen was collected from subject - the physiologically relevant time.
    property collectedElement : TFhirDataType read FCollected write SetCollected;

    // Typed access to The span of time over which the collection of a specimen occurred. (defined for API consistency)
    property duration : TFhirDuration read FDuration write SetDuration;
    // The span of time over which the collection of a specimen occurred.
    property durationElement : TFhirDuration read FDuration write SetDuration;

    // Typed access to The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A coded value specifying the technique that is used to perform the procedure. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value specifying the technique that is used to perform the procedure.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens. (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection. (defined for API consistency)
    property fastingStatus : TFhirDataType read FFastingStatus write SetFastingStatus;
    // Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection.
    property fastingStatusElement : TFhirDataType read FFastingStatus write SetFastingStatus;

  end;

  TFhirSpecimenCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenCollectionList;
    function GetCurrent : TFhirSpecimenCollection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenCollection read GetCurrent;
  end;

  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenCollectionList; overload;
    function Clone : TFhirSpecimenCollectionList; overload;
    function GetEnumerator : TFhirSpecimenCollectionListEnumerator;
    
    //  Add a FhirSpecimenCollection to the end of the list.
    function Append : TFhirSpecimenCollection;
    
    // Add an already existing FhirSpecimenCollection to the end of the list.
    procedure AddItem(value : TFhirSpecimenCollection); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenCollection) : Integer;
    
    // Insert FhirSpecimenCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenCollection;
    
    // Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);
    
    // Get the iIndexth FhirSpecimenCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenCollection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;

  // Details concerning processing and processing steps for the specimen.
  TFhirSpecimenProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirReferenceList;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetProcedure_(value : TFhirCodeableConcept);
    function GetAdditiveList : TFhirReferenceList;
    function GetHasAdditiveList : Boolean;
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenProcessing; overload;
    function Clone : TFhirSpecimenProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Textual description of procedure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of procedure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A coded value specifying the procedure used to process the specimen. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // A coded value specifying the procedure used to process the specimen.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Material used in the processing step.
    property additiveList : TFhirReferenceList read GetAdditiveList;
    property hasAdditiveList : boolean read GetHasAdditiveList;

    // Typed access to A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirSpecimenProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenProcessingList;
    function GetCurrent : TFhirSpecimenProcessing;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenProcessing read GetCurrent;
  end;

  TFhirSpecimenProcessingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenProcessing;
    procedure SetItemN(index : Integer; value : TFhirSpecimenProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenProcessingList; overload;
    function Clone : TFhirSpecimenProcessingList; overload;
    function GetEnumerator : TFhirSpecimenProcessingListEnumerator;
    
    //  Add a FhirSpecimenProcessing to the end of the list.
    function Append : TFhirSpecimenProcessing;
    
    // Add an already existing FhirSpecimenProcessing to the end of the list.
    procedure AddItem(value : TFhirSpecimenProcessing); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenProcessing) : Integer;
    
    // Insert FhirSpecimenProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenProcessing;
    
    // Insert an existing FhirSpecimenProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenProcessing);
    
    // Get the iIndexth FhirSpecimenProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenProcessing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenProcessing;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenProcessings[index : Integer] : TFhirSpecimenProcessing read GetItemN write SetItemN; default;
  End;

  // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirDataType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetCapacity(value : TFhirQuantity);
    procedure SetSpecimenQuantity(value : TFhirQuantity);
    procedure SetAdditive(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Textual description of the container.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the container.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The type of container associated with the specimen (e.g. slide, aliquot, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of container associated with the specimen (e.g. slide, aliquot, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The capacity (volume or other measure) the container may contain. (defined for API consistency)
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    // The capacity (volume or other measure) the container may contain.
    property capacityElement : TFhirQuantity read FCapacity write SetCapacity;

    // Typed access to The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type. (defined for API consistency)
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;
    // The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    property specimenQuantityElement : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    // Typed access to Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. (defined for API consistency)
    property additive : TFhirDataType read FAdditive write SetAdditive;
    // Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveElement : TFhirDataType read FAdditive write SetAdditive;

  end;

  TFhirSpecimenContainerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenContainerList;
    function GetCurrent : TFhirSpecimenContainer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenContainerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenContainer read GetCurrent;
  end;

  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenContainerList; overload;
    function Clone : TFhirSpecimenContainerList; overload;
    function GetEnumerator : TFhirSpecimenContainerListEnumerator;
    
    //  Add a FhirSpecimenContainer to the end of the list.
    function Append : TFhirSpecimenContainer;
    
    // Add an already existing FhirSpecimenContainer to the end of the list.
    procedure AddItem(value : TFhirSpecimenContainer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenContainer) : Integer;
    
    // Insert FhirSpecimenContainer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenContainer;
    
    // Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);
    
    // Get the iIndexth FhirSpecimenContainer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenContainer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;

  // A sample to be used for analysis.
  TFhirSpecimen = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAccessionIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FReceivedTime : TFhirDateTime;
    FparentList : TFhirReferenceList;
    FrequestList : TFhirReferenceList;
    FCollection : TFhirSpecimenCollection;
    FprocessingList : TFhirSpecimenProcessingList;
    FcontainerList : TFhirSpecimenContainerList;
    FconditionList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetAccessionIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSpecimenStatusEnum;
    procedure SetStatusST(value : TFhirSpecimenStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetReceivedTime(value : TFhirDateTime);
    function GetReceivedTimeST : TFslDateTime;
    procedure SetReceivedTimeST(value : TFslDateTime);
    function GetParentList : TFhirReferenceList;
    function GetHasParentList : Boolean;
    function GetRequestList : TFhirReferenceList;
    function GetHasRequestList : Boolean;
    procedure SetCollection(value : TFhirSpecimenCollection);
    function GetProcessingList : TFhirSpecimenProcessingList;
    function GetHasProcessingList : Boolean;
    function GetContainerList : TFhirSpecimenContainerList;
    function GetHasContainerList : Boolean;
    function GetConditionList : TFhirCodeableConceptList;
    function GetHasConditionList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimen; overload;
    function Clone : TFhirSpecimen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for specimen.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures. (defined for API consistency)
    property accessionIdentifier : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;
    // The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    property accessionIdentifierElement : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;

    // The availability of the specimen.
    property status : TFhirSpecimenStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The kind of material that forms the specimen. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of material that forms the specimen.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Time when specimen was received for processing or testing.
    property receivedTime : TFslDateTime read GetReceivedTimeST write SetReceivedTimeST;
    // Time when specimen was received for processing or testing.
    property receivedTimeElement : TFhirDateTime read FReceivedTime write SetReceivedTime;

    // Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
    property parentList : TFhirReferenceList read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Details concerning a service request that required a specimen to be collected.
    property requestList : TFhirReferenceList read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Details concerning the specimen collection. (defined for API consistency)
    property collection : TFhirSpecimenCollection read FCollection write SetCollection;
    // Details concerning the specimen collection.
    property collectionElement : TFhirSpecimenCollection read FCollection write SetCollection;

    // Details concerning processing and processing steps for the specimen.
    property processingList : TFhirSpecimenProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    property containerList : TFhirSpecimenContainerList read GetContainerList;
    property hasContainerList : boolean read GetHasContainerList;

    // A mode or state of being that describes the nature of the specimen.
    property conditionList : TFhirCodeableConceptList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirSpecimenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenList;
    function GetCurrent : TFhirSpecimen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimen read GetCurrent;
  end;

  TFhirSpecimenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimen;
    procedure SetItemN(index : Integer; value : TFhirSpecimen);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenList; overload;
    function Clone : TFhirSpecimenList; overload;
    function GetEnumerator : TFhirSpecimenListEnumerator;
    
    //  Add a FhirSpecimen to the end of the list.
    function Append : TFhirSpecimen;
    
    // Add an already existing FhirSpecimen to the end of the list.
    procedure AddItem(value : TFhirSpecimen); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimen) : Integer;
    
    // Insert FhirSpecimen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimen;
    
    // Insert an existing FhirSpecimen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimen);
    
    // Get the iIndexth FhirSpecimen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimen);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimen;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimen[index : Integer] : TFhirSpecimen read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  // The item that is being delivered or has been supplied.
  TFhirSupplyDeliverySuppliedItem = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FItem : TFhirDataType;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDeliverySuppliedItem; overload;
    function Clone : TFhirSupplyDeliverySuppliedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of supply that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of supply that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirSupplyDeliverySuppliedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliverySuppliedItemList;
    function GetCurrent : TFhirSupplyDeliverySuppliedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliverySuppliedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDeliverySuppliedItem read GetCurrent;
  end;

  TFhirSupplyDeliverySuppliedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    procedure SetItemN(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyDeliverySuppliedItemList; overload;
    function Clone : TFhirSupplyDeliverySuppliedItemList; overload;
    function GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;
    
    //  Add a FhirSupplyDeliverySuppliedItem to the end of the list.
    function Append : TFhirSupplyDeliverySuppliedItem;
    
    // Add an already existing FhirSupplyDeliverySuppliedItem to the end of the list.
    procedure AddItem(value : TFhirSupplyDeliverySuppliedItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDeliverySuppliedItem) : Integer;
    
    // Insert FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    
    // Insert an existing FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
    
    // Get the iIndexth FhirSupplyDeliverySuppliedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyDeliverySuppliedItems[index : Integer] : TFhirSupplyDeliverySuppliedItem read GetItemN write SetItemN; default;
  End;

  // Record of delivery of what is supplied.
  TFhirSupplyDelivery = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference;
    FType_ : TFhirCodeableConcept;
    FSuppliedItem : TFhirSupplyDeliverySuppliedItem;
    FOccurrence : TFhirDataType;
    FSupplier : TFhirReference;
    FDestination : TFhirReference;
    FreceiverList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSupplyDeliveryStatusEnum;
    procedure SetStatusST(value : TFhirSupplyDeliveryStatusEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetSupplier(value : TFhirReference);
    procedure SetDestination(value : TFhirReference);
    function GetReceiverList : TFhirReferenceList;
    function GetHasReceiverList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDelivery; overload;
    function Clone : TFhirSupplyDelivery; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the supply delivery event that is used to identify it across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the dispense event.
    property status : TFhirSupplyDeliveryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person whom the delivered item is for. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // A link to a resource representing the person whom the delivered item is for.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The item that is being delivered or has been supplied. (defined for API consistency)
    property suppliedItem : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;
    // The item that is being delivered or has been supplied.
    property suppliedItemElement : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;

    // Typed access to The date or time(s) the activity occurred. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date or time(s) the activity occurred.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The individual responsible for dispensing the medication, supplier or device. (defined for API consistency)
    property supplier : TFhirReference read FSupplier write SetSupplier;
    // The individual responsible for dispensing the medication, supplier or device.
    property supplierElement : TFhirReference read FSupplier write SetSupplier;

    // Typed access to Identification of the facility/location where the Supply was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Identifies the person who picked up the Supply.
    property receiverList : TFhirReferenceList read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

  end;

  TFhirSupplyDeliveryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliveryList;
    function GetCurrent : TFhirSupplyDelivery;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliveryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDelivery read GetCurrent;
  end;

  TFhirSupplyDeliveryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDelivery;
    procedure SetItemN(index : Integer; value : TFhirSupplyDelivery);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyDeliveryList; overload;
    function Clone : TFhirSupplyDeliveryList; overload;
    function GetEnumerator : TFhirSupplyDeliveryListEnumerator;
    
    //  Add a FhirSupplyDelivery to the end of the list.
    function Append : TFhirSupplyDelivery;
    
    // Add an already existing FhirSupplyDelivery to the end of the list.
    procedure AddItem(value : TFhirSupplyDelivery); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDelivery) : Integer;
    
    // Insert FhirSupplyDelivery before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDelivery;
    
    // Insert an existing FhirSupplyDelivery before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDelivery);
    
    // Get the iIndexth FhirSupplyDelivery. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDelivery);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDelivery;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyDeliveries[index : Integer] : TFhirSupplyDelivery read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  // Specific parameters for the ordered item.  For example, the size of the indicated item.
  TFhirSupplyRequestParameter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequestParameter; overload;
    function Clone : TFhirSupplyRequestParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or string that identifies the device detail being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or string that identifies the device detail being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the device detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the device detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirSupplyRequestParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestParameterList;
    function GetCurrent : TFhirSupplyRequestParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequestParameter read GetCurrent;
  end;

  TFhirSupplyRequestParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyRequestParameter;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequestParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyRequestParameterList; overload;
    function Clone : TFhirSupplyRequestParameterList; overload;
    function GetEnumerator : TFhirSupplyRequestParameterListEnumerator;
    
    //  Add a FhirSupplyRequestParameter to the end of the list.
    function Append : TFhirSupplyRequestParameter;
    
    // Add an already existing FhirSupplyRequestParameter to the end of the list.
    procedure AddItem(value : TFhirSupplyRequestParameter); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequestParameter) : Integer;
    
    // Insert FhirSupplyRequestParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequestParameter;
    
    // Insert an existing FhirSupplyRequestParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequestParameter);
    
    // Get the iIndexth FhirSupplyRequestParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequestParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequestParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyRequestParameters[index : Integer] : TFhirSupplyRequestParameter read GetItemN write SetItemN; default;
  End;

  // A record of a request for a medication, substance or device used in the healthcare setting.
  TFhirSupplyRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FItem : TFhirCodeableReference;
    FQuantity : TFhirQuantity;
    FparameterList : TFhirSupplyRequestParameterList;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FsupplierList : TFhirReferenceList;
    FreasonList : TFhirCodeableReferenceList;
    FDeliverFrom : TFhirReference;
    FDeliverTo : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSupplyRequestStatusEnum;
    procedure SetStatusST(value : TFhirSupplyRequestStatusEnum);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetQuantity(value : TFhirQuantity);
    function GetParameterList : TFhirSupplyRequestParameterList;
    function GetHasParameterList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetSupplierList : TFhirReferenceList;
    function GetHasSupplierList : Boolean;
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    procedure SetDeliverFrom(value : TFhirReference);
    procedure SetDeliverTo(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequest; overload;
    function Clone : TFhirSupplyRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this SupplyRequest by the author and/or other systems. These identifiers remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Status of the supply request.
    property status : TFhirSupplyRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates how quickly this SupplyRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to The amount that is being ordered of the indicated item. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is being ordered of the indicated item.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Specific parameters for the ordered item.  For example, the size of the indicated item.
    property parameterList : TFhirSupplyRequestParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Typed access to When the request should be fulfilled. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // When the request should be fulfilled.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to When the request was made.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request was made.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The device, practitioner, etc. who initiated the request.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Who is intended to fulfill the request.
    property supplierList : TFhirReferenceList read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // The reason why the supply item was requested.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to Where the supply is expected to come from. (defined for API consistency)
    property deliverFrom : TFhirReference read FDeliverFrom write SetDeliverFrom;
    // Where the supply is expected to come from.
    property deliverFromElement : TFhirReference read FDeliverFrom write SetDeliverFrom;

    // Typed access to Where the supply is destined to go. (defined for API consistency)
    property deliverTo : TFhirReference read FDeliverTo write SetDeliverTo;
    // Where the supply is destined to go.
    property deliverToElement : TFhirReference read FDeliverTo write SetDeliverTo;

  end;

  TFhirSupplyRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestList;
    function GetCurrent : TFhirSupplyRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequest read GetCurrent;
  end;

  TFhirSupplyRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyRequest;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyRequestList; overload;
    function Clone : TFhirSupplyRequestList; overload;
    function GetEnumerator : TFhirSupplyRequestListEnumerator;
    
    //  Add a FhirSupplyRequest to the end of the list.
    function Append : TFhirSupplyRequest;
    
    // Add an already existing FhirSupplyRequest to the end of the list.
    procedure AddItem(value : TFhirSupplyRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequest) : Integer;
    
    // Insert FhirSupplyRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequest;
    
    // Insert an existing FhirSupplyRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequest);
    
    // Get the iIndexth FhirSupplyRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyRequests[index : Integer] : TFhirSupplyRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  // Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
  TFhirVisionPrescriptionLensSpecification = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableConcept;
    FEye : TFhirEnum;
    FSphere : TFhirDecimal;
    FCylinder : TFhirDecimal;
    FAxis : TFhirInteger;
    FprismList : TFhirVisionPrescriptionLensSpecificationPrismList;
    FAdd : TFhirDecimal;
    FPower : TFhirDecimal;
    FBackCurve : TFhirDecimal;
    FDiameter : TFhirDecimal;
    FDuration : TFhirQuantity;
    FColor : TFhirString;
    FBrand : TFhirString;
    FnoteList : TFhirAnnotationList;
    procedure SetProduct(value : TFhirCodeableConcept);
    procedure SetEye(value : TFhirEnum);
    function GetEyeST : TFhirVisionEyesEnum;
    procedure SetEyeST(value : TFhirVisionEyesEnum);
    procedure SetSphere(value : TFhirDecimal);
    function GetSphereST : String;
    procedure SetSphereST(value : String);
    procedure SetCylinder(value : TFhirDecimal);
    function GetCylinderST : String;
    procedure SetCylinderST(value : String);
    procedure SetAxis(value : TFhirInteger);
    function GetAxisST : String;
    procedure SetAxisST(value : String);
    function GetPrismList : TFhirVisionPrescriptionLensSpecificationPrismList;
    function GetHasPrismList : Boolean;
    procedure SetAdd(value : TFhirDecimal);
    function GetAddST : String;
    procedure SetAddST(value : String);
    procedure SetPower(value : TFhirDecimal);
    function GetPowerST : String;
    procedure SetPowerST(value : String);
    procedure SetBackCurve(value : TFhirDecimal);
    function GetBackCurveST : String;
    procedure SetBackCurveST(value : String);
    procedure SetDiameter(value : TFhirDecimal);
    function GetDiameterST : String;
    procedure SetDiameterST(value : String);
    procedure SetDuration(value : TFhirQuantity);
    procedure SetColor(value : TFhirString);
    function GetColorST : String;
    procedure SetColorST(value : String);
    procedure SetBrand(value : TFhirString);
    function GetBrandST : String;
    procedure SetBrandST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionLensSpecification; overload;
    function Clone : TFhirVisionPrescriptionLensSpecification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the type of vision correction product which is required for the patient. (defined for API consistency)
    property product : TFhirCodeableConcept read FProduct write SetProduct;
    // Identifies the type of vision correction product which is required for the patient.
    property productElement : TFhirCodeableConcept read FProduct write SetProduct;

    // The eye for which the lens specification applies.
    property eye : TFhirVisionEyesEnum read GetEyeST write SetEyeST;
    property eyeElement : TFhirEnum read FEye write SetEye;

    // Typed access to Lens power measured in dioptres (0.25 units).
    property sphere : String read GetSphereST write SetSphereST;
    // Lens power measured in dioptres (0.25 units).
    property sphereElement : TFhirDecimal read FSphere write SetSphere;

    // Typed access to Power adjustment for astigmatism measured in dioptres (0.25 units).
    property cylinder : String read GetCylinderST write SetCylinderST;
    // Power adjustment for astigmatism measured in dioptres (0.25 units).
    property cylinderElement : TFhirDecimal read FCylinder write SetCylinder;

    // Typed access to Adjustment for astigmatism measured in integer degrees.
    property axis : String read GetAxisST write SetAxisST;
    // Adjustment for astigmatism measured in integer degrees.
    property axisElement : TFhirInteger read FAxis write SetAxis;

    // Allows for adjustment on two axis.
    property prismList : TFhirVisionPrescriptionLensSpecificationPrismList read GetPrismList;
    property hasPrismList : boolean read GetHasPrismList;

    // Typed access to Power adjustment for multifocal lenses measured in dioptres (0.25 units).
    property add : String read GetAddST write SetAddST;
    // Power adjustment for multifocal lenses measured in dioptres (0.25 units).
    property addElement : TFhirDecimal read FAdd write SetAdd;

    // Typed access to Contact lens power measured in dioptres (0.25 units).
    property power : String read GetPowerST write SetPowerST;
    // Contact lens power measured in dioptres (0.25 units).
    property powerElement : TFhirDecimal read FPower write SetPower;

    // Typed access to Back curvature measured in millimetres.
    property backCurve : String read GetBackCurveST write SetBackCurveST;
    // Back curvature measured in millimetres.
    property backCurveElement : TFhirDecimal read FBackCurve write SetBackCurve;

    // Typed access to Contact lens diameter measured in millimetres.
    property diameter : String read GetDiameterST write SetDiameterST;
    // Contact lens diameter measured in millimetres.
    property diameterElement : TFhirDecimal read FDiameter write SetDiameter;

    // Typed access to The recommended maximum wear period for the lens. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // The recommended maximum wear period for the lens.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // Typed access to Special color or pattern.
    property color : String read GetColorST write SetColorST;
    // Special color or pattern.
    property colorElement : TFhirString read FColor write SetColor;

    // Typed access to Brand recommendations or restrictions.
    property brand : String read GetBrandST write SetBrandST;
    // Brand recommendations or restrictions.
    property brandElement : TFhirString read FBrand write SetBrand;

    // Notes for special requirements such as coatings and lens materials.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirVisionPrescriptionLensSpecificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionLensSpecificationList;
    function GetCurrent : TFhirVisionPrescriptionLensSpecification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionLensSpecificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionLensSpecification read GetCurrent;
  end;

  TFhirVisionPrescriptionLensSpecificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionLensSpecificationList; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationList; overload;
    function GetEnumerator : TFhirVisionPrescriptionLensSpecificationListEnumerator;
    
    //  Add a FhirVisionPrescriptionLensSpecification to the end of the list.
    function Append : TFhirVisionPrescriptionLensSpecification;
    
    // Add an already existing FhirVisionPrescriptionLensSpecification to the end of the list.
    procedure AddItem(value : TFhirVisionPrescriptionLensSpecification); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionLensSpecification) : Integer;
    
    // Insert FhirVisionPrescriptionLensSpecification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    
    // Insert an existing FhirVisionPrescriptionLensSpecification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
    
    // Get the iIndexth FhirVisionPrescriptionLensSpecification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptionLensSpecifications[index : Integer] : TFhirVisionPrescriptionLensSpecification read GetItemN write SetItemN; default;
  End;

  // Allows for adjustment on two axis.
  TFhirVisionPrescriptionLensSpecificationPrism = class (TFhirBackboneElement)
  protected
    FAmount : TFhirDecimal;
    FBase : TFhirEnum;
    procedure SetAmount(value : TFhirDecimal);
    function GetAmountST : String;
    procedure SetAmountST(value : String);
    procedure SetBase(value : TFhirEnum);
    function GetBaseST : TFhirVisionBaseEnum;
    procedure SetBaseST(value : TFhirVisionBaseEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionLensSpecificationPrism; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationPrism; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Amount of prism to compensate for eye alignment in fractional units.
    property amount : String read GetAmountST write SetAmountST;
    // Amount of prism to compensate for eye alignment in fractional units.
    property amountElement : TFhirDecimal read FAmount write SetAmount;

    // The relative base, or reference lens edge, for the prism.
    property base : TFhirVisionBaseEnum read GetBaseST write SetBaseST;
    property baseElement : TFhirEnum read FBase write SetBase;

  end;

  TFhirVisionPrescriptionLensSpecificationPrismListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionLensSpecificationPrismList;
    function GetCurrent : TFhirVisionPrescriptionLensSpecificationPrism;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionLensSpecificationPrismList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionLensSpecificationPrism read GetCurrent;
  end;

  TFhirVisionPrescriptionLensSpecificationPrismList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionLensSpecificationPrismList; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationPrismList; overload;
    function GetEnumerator : TFhirVisionPrescriptionLensSpecificationPrismListEnumerator;
    
    //  Add a FhirVisionPrescriptionLensSpecificationPrism to the end of the list.
    function Append : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // Add an already existing FhirVisionPrescriptionLensSpecificationPrism to the end of the list.
    procedure AddItem(value : TFhirVisionPrescriptionLensSpecificationPrism); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionLensSpecificationPrism) : Integer;
    
    // Insert FhirVisionPrescriptionLensSpecificationPrism before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // Insert an existing FhirVisionPrescriptionLensSpecificationPrism before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
    
    // Get the iIndexth FhirVisionPrescriptionLensSpecificationPrism. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptionLensSpecificationPrisms[index : Integer] : TFhirVisionPrescriptionLensSpecificationPrism read GetItemN write SetItemN; default;
  End;

  // An authorization for the provision of glasses and/or contact lenses to a patient.
  TFhirVisionPrescription = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FDateWritten : TFhirDateTime;
    FPrescriber : TFhirReference;
    FlensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDateWritten(value : TFhirDateTime);
    function GetDateWrittenST : TFslDateTime;
    procedure SetDateWrittenST(value : TFslDateTime);
    procedure SetPrescriber(value : TFhirReference);
    function GetLensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
    function GetHasLensSpecificationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescription; overload;
    function Clone : TFhirVisionPrescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this vision prescription.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to A resource reference to the person to whom the vision prescription applies. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // A resource reference to the person to whom the vision prescription applies.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to A reference to a resource that identifies the particular occurrence of contact between patient and health care provider during which the prescription was issued. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // A reference to a resource that identifies the particular occurrence of contact between patient and health care provider during which the prescription was issued.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and perhaps time) when the prescription was written.
    property dateWritten : TFslDateTime read GetDateWrittenST write SetDateWrittenST;
    // The date (and perhaps time) when the prescription was written.
    property dateWrittenElement : TFhirDateTime read FDateWritten write SetDateWritten;

    // Typed access to The healthcare professional responsible for authorizing the prescription. (defined for API consistency)
    property prescriber : TFhirReference read FPrescriber write SetPrescriber;
    // The healthcare professional responsible for authorizing the prescription.
    property prescriberElement : TFhirReference read FPrescriber write SetPrescriber;

    // Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
    property lensSpecificationList : TFhirVisionPrescriptionLensSpecificationList read GetLensSpecificationList;
    property hasLensSpecificationList : boolean read GetHasLensSpecificationList;

  end;

  TFhirVisionPrescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionList;
    function GetCurrent : TFhirVisionPrescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescription read GetCurrent;
  end;

  TFhirVisionPrescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescription;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionList; overload;
    function Clone : TFhirVisionPrescriptionList; overload;
    function GetEnumerator : TFhirVisionPrescriptionListEnumerator;
    
    //  Add a FhirVisionPrescription to the end of the list.
    function Append : TFhirVisionPrescription;
    
    // Add an already existing FhirVisionPrescription to the end of the list.
    procedure AddItem(value : TFhirVisionPrescription); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescription) : Integer;
    
    // Insert FhirVisionPrescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescription;
    
    // Insert an existing FhirVisionPrescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescription);
    
    // Get the iIndexth FhirVisionPrescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptions[index : Integer] : TFhirVisionPrescription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VISIONPRESCRIPTION}

implementation

uses
  fhir5_utilities;

{$IFDEF FHIR_ADVERSEEVENT}
{ TFhirAdverseEventParticipant }

constructor TFhirAdverseEventParticipant.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventParticipant.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirAdverseEventParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirAdverseEventParticipant(oSource).function_.Clone;
  actor := TFhirAdverseEventParticipant(oSource).actor.Clone;
end;

procedure TFhirAdverseEventParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirAdverseEventParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirAdverseEventParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventParticipant.fhirType : string;
begin
  result := 'AdverseEvent.participant';
end;

function TFhirAdverseEventParticipant.Link : TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant(inherited Link);
end;

function TFhirAdverseEventParticipant.Clone : TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant(inherited Clone);
end;

function TFhirAdverseEventParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventParticipant)) then
    result := false
  else
  begin
    o := TFhirAdverseEventParticipant(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirAdverseEventParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirAdverseEventParticipant.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirAdverseEventParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirAdverseEventParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirAdverseEventParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirAdverseEventParticipantListEnumerator }

constructor TFhirAdverseEventParticipantListEnumerator.Create(list : TFhirAdverseEventParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventParticipantListEnumerator.GetCurrent : TFhirAdverseEventParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventParticipantList }

procedure TFhirAdverseEventParticipantList.AddItem(value: TFhirAdverseEventParticipant);
begin
  assert(value.ClassName = 'TFhirAdverseEventParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventParticipant');
  add(value);
end;

function TFhirAdverseEventParticipantList.Append: TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventParticipantList.GetEnumerator : TFhirAdverseEventParticipantListEnumerator;
begin
  result := TFhirAdverseEventParticipantListEnumerator.Create(self.link);
end;

function TFhirAdverseEventParticipantList.Clone: TFhirAdverseEventParticipantList;
begin
  result := TFhirAdverseEventParticipantList(inherited Clone);
end;

function TFhirAdverseEventParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventParticipantList.GetItemN(index: Integer): TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant(ObjectByIndex[index]);
end;

function TFhirAdverseEventParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventParticipant;
end;
function TFhirAdverseEventParticipantList.IndexOf(value: TFhirAdverseEventParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventParticipantList.Insert(index: Integer): TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventParticipantList.InsertItem(index: Integer; value: TFhirAdverseEventParticipant);
begin
  assert(value is TFhirAdverseEventParticipant);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventParticipantList.Item(index: Integer): TFhirAdverseEventParticipant;
begin
  result := TFhirAdverseEventParticipant(ObjectByIndex[index]);
end;

function TFhirAdverseEventParticipantList.Link: TFhirAdverseEventParticipantList;
begin
  result := TFhirAdverseEventParticipantList(inherited Link);
end;

procedure TFhirAdverseEventParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventParticipantList.SetItemByIndex(index: Integer; value: TFhirAdverseEventParticipant);
begin
  assert(value is TFhirAdverseEventParticipant);
  FhirAdverseEventParticipants[index] := value;
end;

procedure TFhirAdverseEventParticipantList.SetItemN(index: Integer; value: TFhirAdverseEventParticipant);
begin
  assert(value is TFhirAdverseEventParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventSuspectEntity }

constructor TFhirAdverseEventSuspectEntity.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSuspectEntity.Destroy;
begin
  FInstance.free;
  FCausality.free;
  inherited;
end;

procedure TFhirAdverseEventSuspectEntity.Assign(oSource : TFslObject);
begin
  inherited;
  instance := TFhirAdverseEventSuspectEntity(oSource).instance.Clone;
  causality := TFhirAdverseEventSuspectEntity(oSource).causality.Clone;
end;

procedure TFhirAdverseEventSuspectEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'instance[x]') or (child_name = 'instance') Then
     list.add(self.link, 'instance[x]', FInstance.Link);
  if (child_name = 'causality') Then
     list.add(self.link, 'causality', FCausality.Link);
end;

procedure TFhirAdverseEventSuspectEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'instance[x]', 'CodeableConcept|Reference', false, TFhirDataType, FInstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'causality', 'BackboneElement', false, TFhirAdverseEventSuspectEntityCausality, FCausality.Link)); {L1172}
end;

function TFhirAdverseEventSuspectEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'instance', ['CodeableConcept', 'Reference'])) then
  begin
    Instance := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'causality') then
  begin
    Causality := propValue as TFhirAdverseEventSuspectEntityCausality {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSuspectEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventSuspectEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'instance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Instance') {L1191}
  else if (propName = 'causality') then result := TFhirAdverseEventSuspectEntityCausality.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSuspectEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'instance[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'causality') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSuspectEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'instance', ['CodeableConcept', 'Reference'])) then InstanceElement := nil {L1189}
  else if (propName = 'causality') then CausalityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSuspectEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'instance', ['CodeableConcept', 'Reference'])) then InstanceElement := new as TFhirDataType {L1190}
  else if (propName = 'causality') then CausalityElement := new as TFhirAdverseEventSuspectEntityCausality {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSuspectEntity.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSuspectEntity.fhirType : string;
begin
  result := 'AdverseEvent.suspectEntity';
end;

function TFhirAdverseEventSuspectEntity.Link : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Link);
end;

function TFhirAdverseEventSuspectEntity.Clone : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Clone);
end;

function TFhirAdverseEventSuspectEntity.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventSuspectEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSuspectEntity)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSuspectEntity(other);
    result := compareDeep(instanceElement, o.instanceElement, true) and compareDeep(causalityElement, o.causalityElement, true);
  end;
end;

function TFhirAdverseEventSuspectEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInstance) and isEmptyProp(FCausality);
end;

procedure TFhirAdverseEventSuspectEntity.SetInstance(value : TFhirDataType);
begin
  FInstance.free;
  FInstance := value; {L1134}
end;

procedure TFhirAdverseEventSuspectEntity.SetCausality(value : TFhirAdverseEventSuspectEntityCausality);
begin
  FCausality.free;
  FCausality := value; {L1134}
end;

procedure TFhirAdverseEventSuspectEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('instance[x]');
  fields.add('causality');
end;

function TFhirAdverseEventSuspectEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FInstance.sizeInBytes);
  inc(result, FCausality.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityListEnumerator }

constructor TFhirAdverseEventSuspectEntityListEnumerator.Create(list : TFhirAdverseEventSuspectEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSuspectEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.GetCurrent : TFhirAdverseEventSuspectEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSuspectEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityList }

procedure TFhirAdverseEventSuspectEntityList.AddItem(value: TFhirAdverseEventSuspectEntity);
begin
  assert(value.ClassName = 'TFhirAdverseEventSuspectEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSuspectEntity');
  add(value);
end;

function TFhirAdverseEventSuspectEntityList.Append: TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSuspectEntityList.GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;
begin
  result := TFhirAdverseEventSuspectEntityListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSuspectEntityList.Clone: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSuspectEntityList.GetItemN(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSuspectEntity;
end;
function TFhirAdverseEventSuspectEntityList.IndexOf(value: TFhirAdverseEventSuspectEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSuspectEntityList.Insert(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.InsertItem(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSuspectEntityList.Item(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.Link: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Link);
end;

procedure TFhirAdverseEventSuspectEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  FhirAdverseEventSuspectEntities[index] := value;
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemN(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventSuspectEntityCausality }

constructor TFhirAdverseEventSuspectEntityCausality.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSuspectEntityCausality.Destroy;
begin
  FAssessmentMethod.free;
  FEntityRelatedness.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirAdverseEventSuspectEntityCausality.Assign(oSource : TFslObject);
begin
  inherited;
  assessmentMethod := TFhirAdverseEventSuspectEntityCausality(oSource).assessmentMethod.Clone;
  entityRelatedness := TFhirAdverseEventSuspectEntityCausality(oSource).entityRelatedness.Clone;
  author := TFhirAdverseEventSuspectEntityCausality(oSource).author.Clone;
end;

procedure TFhirAdverseEventSuspectEntityCausality.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'assessmentMethod') Then
     list.add(self.link, 'assessmentMethod', FAssessmentMethod.Link);
  if (child_name = 'entityRelatedness') Then
     list.add(self.link, 'entityRelatedness', FEntityRelatedness.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirAdverseEventSuspectEntityCausality.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'assessmentMethod', 'CodeableConcept', false, TFhirCodeableConcept, FAssessmentMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entityRelatedness', 'CodeableConcept', false, TFhirCodeableConcept, FEntityRelatedness.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
end;

function TFhirAdverseEventSuspectEntityCausality.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'assessmentMethod') then
  begin
    AssessmentMethod := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'entityRelatedness') then
  begin
    EntityRelatedness := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSuspectEntityCausality.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventSuspectEntityCausality.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'assessmentMethod') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'entityRelatedness') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSuspectEntityCausality.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'assessmentMethod') then result := 'CodeableConcept'
  else if (propName = 'entityRelatedness') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSuspectEntityCausality.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'assessmentMethod') then AssessmentMethodElement := nil
  else if (propName = 'entityRelatedness') then EntityRelatednessElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSuspectEntityCausality.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'assessmentMethod') then AssessmentMethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'entityRelatedness') then EntityRelatednessElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSuspectEntityCausality.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSuspectEntityCausality.fhirType : string;
begin
  result := 'AdverseEvent.suspectEntity.causality';
end;

function TFhirAdverseEventSuspectEntityCausality.Link : TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(inherited Link);
end;

function TFhirAdverseEventSuspectEntityCausality.Clone : TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityCausality.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventSuspectEntityCausality;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSuspectEntityCausality)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSuspectEntityCausality(other);
    result := compareDeep(assessmentMethodElement, o.assessmentMethodElement, true) and 
      compareDeep(entityRelatednessElement, o.entityRelatednessElement, true) and compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirAdverseEventSuspectEntityCausality.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAssessmentMethod) and isEmptyProp(FEntityRelatedness) and isEmptyProp(FAuthor);
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetAssessmentMethod(value : TFhirCodeableConcept);
begin
  FAssessmentMethod.free;
  FAssessmentMethod := value; {L1134}
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetEntityRelatedness(value : TFhirCodeableConcept);
begin
  FEntityRelatedness.free;
  FEntityRelatedness := value; {L1134}
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

procedure TFhirAdverseEventSuspectEntityCausality.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('assessmentMethod');
  fields.add('entityRelatedness');
  fields.add('author');
end;

function TFhirAdverseEventSuspectEntityCausality.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAssessmentMethod.sizeInBytes);
  inc(result, FEntityRelatedness.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityCausalityListEnumerator }

constructor TFhirAdverseEventSuspectEntityCausalityListEnumerator.Create(list : TFhirAdverseEventSuspectEntityCausalityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSuspectEntityCausalityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.GetCurrent : TFhirAdverseEventSuspectEntityCausality;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityCausalityList }

procedure TFhirAdverseEventSuspectEntityCausalityList.AddItem(value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value.ClassName = 'TFhirAdverseEventSuspectEntityCausality', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSuspectEntityCausality');
  add(value);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Append: TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSuspectEntityCausalityList.GetEnumerator : TFhirAdverseEventSuspectEntityCausalityListEnumerator;
begin
  result := TFhirAdverseEventSuspectEntityCausalityListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Clone: TFhirAdverseEventSuspectEntityCausalityList;
begin
  result := TFhirAdverseEventSuspectEntityCausalityList(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSuspectEntityCausalityList.GetItemN(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityCausalityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSuspectEntityCausality;
end;
function TFhirAdverseEventSuspectEntityCausalityList.IndexOf(value: TFhirAdverseEventSuspectEntityCausality): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Insert(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.InsertItem(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Item(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Link: TFhirAdverseEventSuspectEntityCausalityList;
begin
  result := TFhirAdverseEventSuspectEntityCausalityList(inherited Link);
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  FhirAdverseEventSuspectEntityCausalities[index] := value;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.SetItemN(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventContributingFactor }

constructor TFhirAdverseEventContributingFactor.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventContributingFactor.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirAdverseEventContributingFactor.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirAdverseEventContributingFactor(oSource).item.Clone;
end;

procedure TFhirAdverseEventContributingFactor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirAdverseEventContributingFactor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirAdverseEventContributingFactor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventContributingFactor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventContributingFactor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventContributingFactor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventContributingFactor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventContributingFactor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventContributingFactor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventContributingFactor.fhirType : string;
begin
  result := 'AdverseEvent.contributingFactor';
end;

function TFhirAdverseEventContributingFactor.Link : TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor(inherited Link);
end;

function TFhirAdverseEventContributingFactor.Clone : TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor(inherited Clone);
end;

function TFhirAdverseEventContributingFactor.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventContributingFactor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventContributingFactor)) then
    result := false
  else
  begin
    o := TFhirAdverseEventContributingFactor(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirAdverseEventContributingFactor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirAdverseEventContributingFactor.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirAdverseEventContributingFactor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirAdverseEventContributingFactor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirAdverseEventContributingFactorListEnumerator }

constructor TFhirAdverseEventContributingFactorListEnumerator.Create(list : TFhirAdverseEventContributingFactorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventContributingFactorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventContributingFactorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventContributingFactorListEnumerator.GetCurrent : TFhirAdverseEventContributingFactor;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventContributingFactorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventContributingFactorList }

procedure TFhirAdverseEventContributingFactorList.AddItem(value: TFhirAdverseEventContributingFactor);
begin
  assert(value.ClassName = 'TFhirAdverseEventContributingFactor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventContributingFactor');
  add(value);
end;

function TFhirAdverseEventContributingFactorList.Append: TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventContributingFactorList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventContributingFactorList.GetEnumerator : TFhirAdverseEventContributingFactorListEnumerator;
begin
  result := TFhirAdverseEventContributingFactorListEnumerator.Create(self.link);
end;

function TFhirAdverseEventContributingFactorList.Clone: TFhirAdverseEventContributingFactorList;
begin
  result := TFhirAdverseEventContributingFactorList(inherited Clone);
end;

function TFhirAdverseEventContributingFactorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventContributingFactorList.GetItemN(index: Integer): TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor(ObjectByIndex[index]);
end;

function TFhirAdverseEventContributingFactorList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventContributingFactor;
end;
function TFhirAdverseEventContributingFactorList.IndexOf(value: TFhirAdverseEventContributingFactor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventContributingFactorList.Insert(index: Integer): TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventContributingFactorList.InsertItem(index: Integer; value: TFhirAdverseEventContributingFactor);
begin
  assert(value is TFhirAdverseEventContributingFactor);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventContributingFactorList.Item(index: Integer): TFhirAdverseEventContributingFactor;
begin
  result := TFhirAdverseEventContributingFactor(ObjectByIndex[index]);
end;

function TFhirAdverseEventContributingFactorList.Link: TFhirAdverseEventContributingFactorList;
begin
  result := TFhirAdverseEventContributingFactorList(inherited Link);
end;

procedure TFhirAdverseEventContributingFactorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventContributingFactorList.SetItemByIndex(index: Integer; value: TFhirAdverseEventContributingFactor);
begin
  assert(value is TFhirAdverseEventContributingFactor);
  FhirAdverseEventContributingFactors[index] := value;
end;

procedure TFhirAdverseEventContributingFactorList.SetItemN(index: Integer; value: TFhirAdverseEventContributingFactor);
begin
  assert(value is TFhirAdverseEventContributingFactor);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventPreventiveAction }

constructor TFhirAdverseEventPreventiveAction.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventPreventiveAction.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirAdverseEventPreventiveAction.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirAdverseEventPreventiveAction(oSource).item.Clone;
end;

procedure TFhirAdverseEventPreventiveAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirAdverseEventPreventiveAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirAdverseEventPreventiveAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventPreventiveAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventPreventiveAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventPreventiveAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventPreventiveAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventPreventiveAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventPreventiveAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventPreventiveAction.fhirType : string;
begin
  result := 'AdverseEvent.preventiveAction';
end;

function TFhirAdverseEventPreventiveAction.Link : TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction(inherited Link);
end;

function TFhirAdverseEventPreventiveAction.Clone : TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction(inherited Clone);
end;

function TFhirAdverseEventPreventiveAction.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventPreventiveAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventPreventiveAction)) then
    result := false
  else
  begin
    o := TFhirAdverseEventPreventiveAction(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirAdverseEventPreventiveAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirAdverseEventPreventiveAction.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirAdverseEventPreventiveAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirAdverseEventPreventiveAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirAdverseEventPreventiveActionListEnumerator }

constructor TFhirAdverseEventPreventiveActionListEnumerator.Create(list : TFhirAdverseEventPreventiveActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventPreventiveActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventPreventiveActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventPreventiveActionListEnumerator.GetCurrent : TFhirAdverseEventPreventiveAction;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventPreventiveActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventPreventiveActionList }

procedure TFhirAdverseEventPreventiveActionList.AddItem(value: TFhirAdverseEventPreventiveAction);
begin
  assert(value.ClassName = 'TFhirAdverseEventPreventiveAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventPreventiveAction');
  add(value);
end;

function TFhirAdverseEventPreventiveActionList.Append: TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventPreventiveActionList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventPreventiveActionList.GetEnumerator : TFhirAdverseEventPreventiveActionListEnumerator;
begin
  result := TFhirAdverseEventPreventiveActionListEnumerator.Create(self.link);
end;

function TFhirAdverseEventPreventiveActionList.Clone: TFhirAdverseEventPreventiveActionList;
begin
  result := TFhirAdverseEventPreventiveActionList(inherited Clone);
end;

function TFhirAdverseEventPreventiveActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventPreventiveActionList.GetItemN(index: Integer): TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction(ObjectByIndex[index]);
end;

function TFhirAdverseEventPreventiveActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventPreventiveAction;
end;
function TFhirAdverseEventPreventiveActionList.IndexOf(value: TFhirAdverseEventPreventiveAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventPreventiveActionList.Insert(index: Integer): TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventPreventiveActionList.InsertItem(index: Integer; value: TFhirAdverseEventPreventiveAction);
begin
  assert(value is TFhirAdverseEventPreventiveAction);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventPreventiveActionList.Item(index: Integer): TFhirAdverseEventPreventiveAction;
begin
  result := TFhirAdverseEventPreventiveAction(ObjectByIndex[index]);
end;

function TFhirAdverseEventPreventiveActionList.Link: TFhirAdverseEventPreventiveActionList;
begin
  result := TFhirAdverseEventPreventiveActionList(inherited Link);
end;

procedure TFhirAdverseEventPreventiveActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventPreventiveActionList.SetItemByIndex(index: Integer; value: TFhirAdverseEventPreventiveAction);
begin
  assert(value is TFhirAdverseEventPreventiveAction);
  FhirAdverseEventPreventiveActions[index] := value;
end;

procedure TFhirAdverseEventPreventiveActionList.SetItemN(index: Integer; value: TFhirAdverseEventPreventiveAction);
begin
  assert(value is TFhirAdverseEventPreventiveAction);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventMitigatingAction }

constructor TFhirAdverseEventMitigatingAction.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventMitigatingAction.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirAdverseEventMitigatingAction.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirAdverseEventMitigatingAction(oSource).item.Clone;
end;

procedure TFhirAdverseEventMitigatingAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirAdverseEventMitigatingAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirAdverseEventMitigatingAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventMitigatingAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventMitigatingAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventMitigatingAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventMitigatingAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventMitigatingAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventMitigatingAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventMitigatingAction.fhirType : string;
begin
  result := 'AdverseEvent.mitigatingAction';
end;

function TFhirAdverseEventMitigatingAction.Link : TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction(inherited Link);
end;

function TFhirAdverseEventMitigatingAction.Clone : TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction(inherited Clone);
end;

function TFhirAdverseEventMitigatingAction.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventMitigatingAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventMitigatingAction)) then
    result := false
  else
  begin
    o := TFhirAdverseEventMitigatingAction(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirAdverseEventMitigatingAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirAdverseEventMitigatingAction.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirAdverseEventMitigatingAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirAdverseEventMitigatingAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirAdverseEventMitigatingActionListEnumerator }

constructor TFhirAdverseEventMitigatingActionListEnumerator.Create(list : TFhirAdverseEventMitigatingActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventMitigatingActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventMitigatingActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventMitigatingActionListEnumerator.GetCurrent : TFhirAdverseEventMitigatingAction;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventMitigatingActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventMitigatingActionList }

procedure TFhirAdverseEventMitigatingActionList.AddItem(value: TFhirAdverseEventMitigatingAction);
begin
  assert(value.ClassName = 'TFhirAdverseEventMitigatingAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventMitigatingAction');
  add(value);
end;

function TFhirAdverseEventMitigatingActionList.Append: TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventMitigatingActionList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventMitigatingActionList.GetEnumerator : TFhirAdverseEventMitigatingActionListEnumerator;
begin
  result := TFhirAdverseEventMitigatingActionListEnumerator.Create(self.link);
end;

function TFhirAdverseEventMitigatingActionList.Clone: TFhirAdverseEventMitigatingActionList;
begin
  result := TFhirAdverseEventMitigatingActionList(inherited Clone);
end;

function TFhirAdverseEventMitigatingActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventMitigatingActionList.GetItemN(index: Integer): TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction(ObjectByIndex[index]);
end;

function TFhirAdverseEventMitigatingActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventMitigatingAction;
end;
function TFhirAdverseEventMitigatingActionList.IndexOf(value: TFhirAdverseEventMitigatingAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventMitigatingActionList.Insert(index: Integer): TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventMitigatingActionList.InsertItem(index: Integer; value: TFhirAdverseEventMitigatingAction);
begin
  assert(value is TFhirAdverseEventMitigatingAction);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventMitigatingActionList.Item(index: Integer): TFhirAdverseEventMitigatingAction;
begin
  result := TFhirAdverseEventMitigatingAction(ObjectByIndex[index]);
end;

function TFhirAdverseEventMitigatingActionList.Link: TFhirAdverseEventMitigatingActionList;
begin
  result := TFhirAdverseEventMitigatingActionList(inherited Link);
end;

procedure TFhirAdverseEventMitigatingActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventMitigatingActionList.SetItemByIndex(index: Integer; value: TFhirAdverseEventMitigatingAction);
begin
  assert(value is TFhirAdverseEventMitigatingAction);
  FhirAdverseEventMitigatingActions[index] := value;
end;

procedure TFhirAdverseEventMitigatingActionList.SetItemN(index: Integer; value: TFhirAdverseEventMitigatingAction);
begin
  assert(value is TFhirAdverseEventMitigatingAction);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventSupportingInfo }

constructor TFhirAdverseEventSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSupportingInfo.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirAdverseEventSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirAdverseEventSupportingInfo(oSource).item.Clone;
end;

procedure TFhirAdverseEventSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirAdverseEventSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirAdverseEventSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSupportingInfo.fhirType : string;
begin
  result := 'AdverseEvent.supportingInfo';
end;

function TFhirAdverseEventSupportingInfo.Link : TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo(inherited Link);
end;

function TFhirAdverseEventSupportingInfo.Clone : TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo(inherited Clone);
end;

function TFhirAdverseEventSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSupportingInfo(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirAdverseEventSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirAdverseEventSupportingInfo.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirAdverseEventSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirAdverseEventSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirAdverseEventSupportingInfoListEnumerator }

constructor TFhirAdverseEventSupportingInfoListEnumerator.Create(list : TFhirAdverseEventSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSupportingInfoListEnumerator.GetCurrent : TFhirAdverseEventSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventSupportingInfoList }

procedure TFhirAdverseEventSupportingInfoList.AddItem(value: TFhirAdverseEventSupportingInfo);
begin
  assert(value.ClassName = 'TFhirAdverseEventSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSupportingInfo');
  add(value);
end;

function TFhirAdverseEventSupportingInfoList.Append: TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSupportingInfoList.GetEnumerator : TFhirAdverseEventSupportingInfoListEnumerator;
begin
  result := TFhirAdverseEventSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSupportingInfoList.Clone: TFhirAdverseEventSupportingInfoList;
begin
  result := TFhirAdverseEventSupportingInfoList(inherited Clone);
end;

function TFhirAdverseEventSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSupportingInfoList.GetItemN(index: Integer): TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo(ObjectByIndex[index]);
end;

function TFhirAdverseEventSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSupportingInfo;
end;
function TFhirAdverseEventSupportingInfoList.IndexOf(value: TFhirAdverseEventSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSupportingInfoList.Insert(index: Integer): TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSupportingInfoList.InsertItem(index: Integer; value: TFhirAdverseEventSupportingInfo);
begin
  assert(value is TFhirAdverseEventSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSupportingInfoList.Item(index: Integer): TFhirAdverseEventSupportingInfo;
begin
  result := TFhirAdverseEventSupportingInfo(ObjectByIndex[index]);
end;

function TFhirAdverseEventSupportingInfoList.Link: TFhirAdverseEventSupportingInfoList;
begin
  result := TFhirAdverseEventSupportingInfoList(inherited Link);
end;

procedure TFhirAdverseEventSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSupportingInfo);
begin
  assert(value is TFhirAdverseEventSupportingInfo);
  FhirAdverseEventSupportingInfos[index] := value;
end;

procedure TFhirAdverseEventSupportingInfoList.SetItemN(index: Integer; value: TFhirAdverseEventSupportingInfo);
begin
  assert(value is TFhirAdverseEventSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEvent }

constructor TFhirAdverseEvent.Create;
begin
  inherited;
end;

destructor TFhirAdverseEvent.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FActuality.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FDetected.free;
  FRecordedDate.free;
  FResultingConditionList.Free;
  FLocation.free;
  FSeriousness.free;
  FOutcome.free;
  FRecorder.free;
  FParticipantList.Free;
  FSuspectEntityList.Free;
  FContributingFactorList.Free;
  FPreventiveActionList.Free;
  FMitigatingActionList.Free;
  FSupportingInfoList.Free;
  FStudyList.Free;
  inherited;
end;

procedure TFhirAdverseEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAdverseEvent(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAdverseEvent(oSource).FIdentifierList);
  end;
  statusElement := TFhirAdverseEvent(oSource).statusElement.Clone;
  actualityElement := TFhirAdverseEvent(oSource).actualityElement.Clone;
  if (TFhirAdverseEvent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirAdverseEvent(oSource).FCategoryList);
  end;
  code := TFhirAdverseEvent(oSource).code.Clone;
  subject := TFhirAdverseEvent(oSource).subject.Clone;
  encounter := TFhirAdverseEvent(oSource).encounter.Clone;
  occurrence := TFhirAdverseEvent(oSource).occurrence.Clone;
  detectedElement := TFhirAdverseEvent(oSource).detectedElement.Clone;
  recordedDateElement := TFhirAdverseEvent(oSource).recordedDateElement.Clone;
  if (TFhirAdverseEvent(oSource).FResultingConditionList = nil) then
  begin
    FResultingConditionList.free;
    FResultingConditionList := nil;
  end
  else
  begin
    if FResultingConditionList = nil then
      FResultingConditionList := TFhirReferenceList.Create;
    FResultingConditionList.Assign(TFhirAdverseEvent(oSource).FResultingConditionList);
  end;
  location := TFhirAdverseEvent(oSource).location.Clone;
  seriousness := TFhirAdverseEvent(oSource).seriousness.Clone;
  outcome := TFhirAdverseEvent(oSource).outcome.Clone;
  recorder := TFhirAdverseEvent(oSource).recorder.Clone;
  if (TFhirAdverseEvent(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAdverseEventParticipantList.Create;
    FParticipantList.Assign(TFhirAdverseEvent(oSource).FParticipantList);
  end;
  if (TFhirAdverseEvent(oSource).FSuspectEntityList = nil) then
  begin
    FSuspectEntityList.free;
    FSuspectEntityList := nil;
  end
  else
  begin
    if FSuspectEntityList = nil then
      FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
    FSuspectEntityList.Assign(TFhirAdverseEvent(oSource).FSuspectEntityList);
  end;
  if (TFhirAdverseEvent(oSource).FContributingFactorList = nil) then
  begin
    FContributingFactorList.free;
    FContributingFactorList := nil;
  end
  else
  begin
    if FContributingFactorList = nil then
      FContributingFactorList := TFhirAdverseEventContributingFactorList.Create;
    FContributingFactorList.Assign(TFhirAdverseEvent(oSource).FContributingFactorList);
  end;
  if (TFhirAdverseEvent(oSource).FPreventiveActionList = nil) then
  begin
    FPreventiveActionList.free;
    FPreventiveActionList := nil;
  end
  else
  begin
    if FPreventiveActionList = nil then
      FPreventiveActionList := TFhirAdverseEventPreventiveActionList.Create;
    FPreventiveActionList.Assign(TFhirAdverseEvent(oSource).FPreventiveActionList);
  end;
  if (TFhirAdverseEvent(oSource).FMitigatingActionList = nil) then
  begin
    FMitigatingActionList.free;
    FMitigatingActionList := nil;
  end
  else
  begin
    if FMitigatingActionList = nil then
      FMitigatingActionList := TFhirAdverseEventMitigatingActionList.Create;
    FMitigatingActionList.Assign(TFhirAdverseEvent(oSource).FMitigatingActionList);
  end;
  if (TFhirAdverseEvent(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirAdverseEventSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirAdverseEvent(oSource).FSupportingInfoList);
  end;
  if (TFhirAdverseEvent(oSource).FStudyList = nil) then
  begin
    FStudyList.free;
    FStudyList := nil;
  end
  else
  begin
    if FStudyList = nil then
      FStudyList := TFhirReferenceList.Create;
    FStudyList.Assign(TFhirAdverseEvent(oSource).FStudyList);
  end;
end;

function TFhirAdverseEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAdverseEvent;
end;

procedure TFhirAdverseEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'actuality') Then
     list.add(self.link, 'actuality', FActuality.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'detected') Then
     list.add(self.link, 'detected', FDetected.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'resultingCondition') Then
    list.addAll(self, 'resultingCondition', FResultingConditionList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'seriousness') Then
     list.add(self.link, 'seriousness', FSeriousness.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'suspectEntity') Then
    list.addAll(self, 'suspectEntity', FSuspectEntityList);
  if (child_name = 'contributingFactor') Then
    list.addAll(self, 'contributingFactor', FContributingFactorList);
  if (child_name = 'preventiveAction') Then
    list.addAll(self, 'preventiveAction', FPreventiveActionList);
  if (child_name = 'mitigatingAction') Then
    list.addAll(self, 'mitigatingAction', FMitigatingActionList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'study') Then
    list.addAll(self, 'study', FStudyList);
end;

procedure TFhirAdverseEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'actuality', 'code', false, TFhirEnum, FActuality.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detected', 'dateTime', false, TFhirDateTime, FDetected.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'resultingCondition', 'Reference', true, TFhirReference, FResultingConditionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'seriousness', 'CodeableConcept', false, TFhirCodeableConcept, FSeriousness.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirAdverseEventParticipant, FParticipantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'suspectEntity', 'BackboneElement', true, TFhirAdverseEventSuspectEntity, FSuspectEntityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contributingFactor', 'BackboneElement', true, TFhirAdverseEventContributingFactor, FContributingFactorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'preventiveAction', 'BackboneElement', true, TFhirAdverseEventPreventiveAction, FPreventiveActionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'mitigatingAction', 'BackboneElement', true, TFhirAdverseEventMitigatingAction, FMitigatingActionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirAdverseEventSupportingInfo, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'study', 'Reference', true, TFhirReference, FStudyList.Link)) {L1039};
end;

function TFhirAdverseEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAdverseEventStatusEnum, CODES_TFhirAdverseEventStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'actuality') then
  begin
    ActualityElement := asEnum(SYSTEMS_TFhirAdverseEventActualityEnum, CODES_TFhirAdverseEventActualityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'detected') then
  begin
    DetectedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'resultingCondition') then
  begin
    ResultingConditionList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'seriousness') then
  begin
    Seriousness := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAdverseEventParticipant) {L1048};
    result := propValue;
  end
  else if (propName = 'suspectEntity') then
  begin
    SuspectEntityList.add(propValue as TFhirAdverseEventSuspectEntity) {L1048};
    result := propValue;
  end
  else if (propName = 'contributingFactor') then
  begin
    ContributingFactorList.add(propValue as TFhirAdverseEventContributingFactor) {L1048};
    result := propValue;
  end
  else if (propName = 'preventiveAction') then
  begin
    PreventiveActionList.add(propValue as TFhirAdverseEventPreventiveAction) {L1048};
    result := propValue;
  end
  else if (propName = 'mitigatingAction') then
  begin
    MitigatingActionList.add(propValue as TFhirAdverseEventMitigatingAction) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirAdverseEventSupportingInfo) {L1048};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    StudyList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'resultingCondition') then ResultingConditionList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAdverseEventParticipant) {L1049}
  else if (propName = 'suspectEntity') then SuspectEntityList.insertItem(index, propValue as TFhirAdverseEventSuspectEntity) {L1049}
  else if (propName = 'contributingFactor') then ContributingFactorList.insertItem(index, propValue as TFhirAdverseEventContributingFactor) {L1049}
  else if (propName = 'preventiveAction') then PreventiveActionList.insertItem(index, propValue as TFhirAdverseEventPreventiveAction) {L1049}
  else if (propName = 'mitigatingAction') then MitigatingActionList.insertItem(index, propValue as TFhirAdverseEventMitigatingAction) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirAdverseEventSupportingInfo) {L1049}
  else if (propName = 'study') then StudyList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirAdverseEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirAdverseEventStatusEnum[AdverseEventStatusNull], CODES_TFhirAdverseEventStatusEnum[AdverseEventStatusNull])  {L1211}
  else if (propName = 'actuality') then result := TFhirEnum.create(SYSTEMS_TFhirAdverseEventActualityEnum[AdverseEventActualityNull], CODES_TFhirAdverseEventActualityEnum[AdverseEventActualityNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'detected') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'recordedDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'resultingCondition') then result := ResultingConditionList.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'seriousness') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'recorder') then result := TFhirReference.create() {L1203}
  else if (propName = 'participant') then result := ParticipantList.new() {L1053}
  else if (propName = 'suspectEntity') then result := SuspectEntityList.new() {L1053}
  else if (propName = 'contributingFactor') then result := ContributingFactorList.new() {L1053}
  else if (propName = 'preventiveAction') then result := PreventiveActionList.new() {L1053}
  else if (propName = 'mitigatingAction') then result := MitigatingActionList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'study') then result := StudyList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'actuality') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'detected') then result := 'dateTime'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'resultingCondition') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'seriousness') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'suspectEntity') then result := 'BackboneElement'
  else if (propName = 'contributingFactor') then result := 'BackboneElement'
  else if (propName = 'preventiveAction') then result := 'BackboneElement'
  else if (propName = 'mitigatingAction') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'study') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'actuality') then ActualityElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'detected') then DetectedElement := nil
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'resultingCondition') then deletePropertyValue('resultingCondition', ResultingConditionList, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'seriousness') then SeriousnessElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {L1054}
  else if (propName = 'suspectEntity') then deletePropertyValue('suspectEntity', SuspectEntityList, value) {L1054}
  else if (propName = 'contributingFactor') then deletePropertyValue('contributingFactor', ContributingFactorList, value) {L1054}
  else if (propName = 'preventiveAction') then deletePropertyValue('preventiveAction', PreventiveActionList, value) {L1054}
  else if (propName = 'mitigatingAction') then deletePropertyValue('mitigatingAction', MitigatingActionList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'study') then deletePropertyValue('study', StudyList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAdverseEventStatusEnum, CODES_TFhirAdverseEventStatusEnum, new) {L1210}
  else if (propName = 'actuality') then ActualityElement := asEnum(SYSTEMS_TFhirAdverseEventActualityEnum, CODES_TFhirAdverseEventActualityEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'detected') then DetectedElement := asDateTime(new) {L1222}
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new) {L1222}
  else if (propName = 'resultingCondition') then replacePropertyValue('resultingCondition', ResultingConditionList, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'seriousness') then SeriousnessElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference {L1195}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {L1055}
  else if (propName = 'suspectEntity') then replacePropertyValue('suspectEntity', SuspectEntityList, existing, new) {L1055}
  else if (propName = 'contributingFactor') then replacePropertyValue('contributingFactor', ContributingFactorList, existing, new) {L1055}
  else if (propName = 'preventiveAction') then replacePropertyValue('preventiveAction', PreventiveActionList, existing, new) {L1055}
  else if (propName = 'mitigatingAction') then replacePropertyValue('mitigatingAction', MitigatingActionList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'study') then replacePropertyValue('study', StudyList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'resultingCondition') then ResultingConditionList.move(source, destination) {L1050}
  else if (propName = 'participant') then ParticipantList.move(source, destination) {L1050}
  else if (propName = 'suspectEntity') then SuspectEntityList.move(source, destination) {L1050}
  else if (propName = 'contributingFactor') then ContributingFactorList.move(source, destination) {L1050}
  else if (propName = 'preventiveAction') then PreventiveActionList.move(source, destination) {L1050}
  else if (propName = 'mitigatingAction') then MitigatingActionList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'study') then StudyList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEvent.fhirType : string;
begin
  result := 'AdverseEvent';
end;

function TFhirAdverseEvent.Link : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Link);
end;

function TFhirAdverseEvent.Clone : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Clone);
end;

function TFhirAdverseEvent.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEvent)) then
    result := false
  else
  begin
    o := TFhirAdverseEvent(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(actualityElement, o.actualityElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(detectedElement, o.detectedElement, true) and compareDeep(recordedDateElement, o.recordedDateElement, true) and 
      compareDeep(resultingConditionList, o.resultingConditionList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(seriousnessElement, o.seriousnessElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(suspectEntityList, o.suspectEntityList, true) and compareDeep(contributingFactorList, o.contributingFactorList, true) and 
      compareDeep(preventiveActionList, o.preventiveActionList, true) and compareDeep(mitigatingActionList, o.mitigatingActionList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(studyList, o.studyList, true);
  end;
end;

function TFhirAdverseEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FActuality) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FDetected) and isEmptyProp(FRecordedDate) and isEmptyProp(FresultingConditionList) and isEmptyProp(FLocation) and isEmptyProp(FSeriousness) and isEmptyProp(FOutcome) and isEmptyProp(FRecorder) and isEmptyProp(FparticipantList) and isEmptyProp(FsuspectEntityList) and isEmptyProp(FcontributingFactorList) and isEmptyProp(FpreventiveActionList) and isEmptyProp(FmitigatingActionList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FstudyList);
end;

function TFhirAdverseEvent.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAdverseEvent.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAdverseEvent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAdverseEvent.GetStatusST : TFhirAdverseEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAdverseEventStatusEnum(0)
  else
    result := TFhirAdverseEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAdverseEventStatusEnum, FStatus.value));
end;

procedure TFhirAdverseEvent.SetStatusST(value : TFhirAdverseEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAdverseEventStatusEnum[value], CODES_TFhirAdverseEventStatusEnum[value]);
end;

procedure TFhirAdverseEvent.SetActuality(value : TFhirEnum);
begin
  FActuality.free;
  FActuality := value;
end;

function TFhirAdverseEvent.GetActualityST : TFhirAdverseEventActualityEnum;
begin
  if FActuality = nil then
    result := TFhirAdverseEventActualityEnum(0)
  else
    result := TFhirAdverseEventActualityEnum(StringArrayIndexOfSensitive(CODES_TFhirAdverseEventActualityEnum, FActuality.value));
end;

procedure TFhirAdverseEvent.SetActualityST(value : TFhirAdverseEventActualityEnum);
begin
  if ord(value) = 0 then
    ActualityElement := nil
  else
    ActualityElement := TFhirEnum.create(SYSTEMS_TFhirAdverseEventActualityEnum[value], CODES_TFhirAdverseEventActualityEnum[value]);
end;

function TFhirAdverseEvent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirAdverseEvent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirAdverseEvent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirAdverseEvent.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirAdverseEvent.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirAdverseEvent.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirAdverseEvent.SetDetected(value : TFhirDateTime);
begin
  FDetected.free;
  FDetected := value; {L1134}
end;

function TFhirAdverseEvent.GetDetectedST : TFslDateTime;
begin
  if FDetected = nil then
    result := TFslDateTime.makeNull
  else
    result := FDetected.value;
end;

procedure TFhirAdverseEvent.SetDetectedST(value : TFslDateTime);
begin
  if FDetected = nil then
    FDetected := TFhirDateTime.create;
  FDetected.value := value
end;

procedure TFhirAdverseEvent.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value; {L1134}
end;

function TFhirAdverseEvent.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirAdverseEvent.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

function TFhirAdverseEvent.GetResultingConditionList : TFhirReferenceList;
begin
  if FResultingConditionList = nil then
    FResultingConditionList := TFhirReferenceList.Create;
  result := FResultingConditionList;
end;

function TFhirAdverseEvent.GetHasResultingConditionList : boolean;
begin
  result := (FResultingConditionList <> nil) and (FResultingConditionList.count > 0);
end;

procedure TFhirAdverseEvent.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirAdverseEvent.SetSeriousness(value : TFhirCodeableConcept);
begin
  FSeriousness.free;
  FSeriousness := value; {L1134}
end;

procedure TFhirAdverseEvent.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value; {L1134}
end;

procedure TFhirAdverseEvent.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value; {L1134}
end;

function TFhirAdverseEvent.GetParticipantList : TFhirAdverseEventParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAdverseEventParticipantList.Create;
  result := FParticipantList;
end;

function TFhirAdverseEvent.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirAdverseEvent.GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
begin
  if FSuspectEntityList = nil then
    FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
  result := FSuspectEntityList;
end;

function TFhirAdverseEvent.GetHasSuspectEntityList : boolean;
begin
  result := (FSuspectEntityList <> nil) and (FSuspectEntityList.count > 0);
end;

function TFhirAdverseEvent.GetContributingFactorList : TFhirAdverseEventContributingFactorList;
begin
  if FContributingFactorList = nil then
    FContributingFactorList := TFhirAdverseEventContributingFactorList.Create;
  result := FContributingFactorList;
end;

function TFhirAdverseEvent.GetHasContributingFactorList : boolean;
begin
  result := (FContributingFactorList <> nil) and (FContributingFactorList.count > 0);
end;

function TFhirAdverseEvent.GetPreventiveActionList : TFhirAdverseEventPreventiveActionList;
begin
  if FPreventiveActionList = nil then
    FPreventiveActionList := TFhirAdverseEventPreventiveActionList.Create;
  result := FPreventiveActionList;
end;

function TFhirAdverseEvent.GetHasPreventiveActionList : boolean;
begin
  result := (FPreventiveActionList <> nil) and (FPreventiveActionList.count > 0);
end;

function TFhirAdverseEvent.GetMitigatingActionList : TFhirAdverseEventMitigatingActionList;
begin
  if FMitigatingActionList = nil then
    FMitigatingActionList := TFhirAdverseEventMitigatingActionList.Create;
  result := FMitigatingActionList;
end;

function TFhirAdverseEvent.GetHasMitigatingActionList : boolean;
begin
  result := (FMitigatingActionList <> nil) and (FMitigatingActionList.count > 0);
end;

function TFhirAdverseEvent.GetSupportingInfoList : TFhirAdverseEventSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirAdverseEventSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirAdverseEvent.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirAdverseEvent.GetStudyList : TFhirReferenceList;
begin
  if FStudyList = nil then
    FStudyList := TFhirReferenceList.Create;
  result := FStudyList;
end;

function TFhirAdverseEvent.GetHasStudyList : boolean;
begin
  result := (FStudyList <> nil) and (FStudyList.count > 0);
end;

procedure TFhirAdverseEvent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('actuality');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('detected');
  fields.add('recordedDate');
  fields.add('resultingCondition');
  fields.add('location');
  fields.add('seriousness');
  fields.add('outcome');
  fields.add('recorder');
  fields.add('participant');
  fields.add('suspectEntity');
  fields.add('contributingFactor');
  fields.add('preventiveAction');
  fields.add('mitigatingAction');
  fields.add('supportingInfo');
  fields.add('study');
end;

function TFhirAdverseEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FActuality.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FDetected.sizeInBytes);
  inc(result, FRecordedDate.sizeInBytes);
  inc(result, FresultingConditionList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FSeriousness.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FsuspectEntityList.sizeInBytes);
  inc(result, FcontributingFactorList.sizeInBytes);
  inc(result, FpreventiveActionList.sizeInBytes);
  inc(result, FmitigatingActionList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FstudyList.sizeInBytes);
end;

{ TFhirAdverseEventListEnumerator }

constructor TFhirAdverseEventListEnumerator.Create(list : TFhirAdverseEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventListEnumerator.GetCurrent : TFhirAdverseEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventList }

procedure TFhirAdverseEventList.AddItem(value: TFhirAdverseEvent);
begin
  assert(value.ClassName = 'TFhirAdverseEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEvent');
  add(value);
end;

function TFhirAdverseEventList.Append: TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventList.GetEnumerator : TFhirAdverseEventListEnumerator;
begin
  result := TFhirAdverseEventListEnumerator.Create(self.link);
end;

function TFhirAdverseEventList.Clone: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Clone);
end;

function TFhirAdverseEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventList.GetItemN(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEvent;
end;
function TFhirAdverseEventList.IndexOf(value: TFhirAdverseEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventList.Insert(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.InsertItem(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventList.Item(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.Link: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Link);
end;

procedure TFhirAdverseEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventList.SetItemByIndex(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  FhirAdverseEvents[index] := value;
end;

procedure TFhirAdverseEventList.SetItemN(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
{ TFhirAllergyIntoleranceReaction }

constructor TFhirAllergyIntoleranceReaction.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntoleranceReaction.Destroy;
begin
  FSubstance.free;
  FManifestationList.Free;
  FDescription.free;
  FOnset.free;
  FSeverity.free;
  FExposureRoute.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirAllergyIntoleranceReaction.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirAllergyIntoleranceReaction(oSource).substance.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FManifestationList = nil) then
  begin
    FManifestationList.free;
    FManifestationList := nil;
  end
  else
  begin
    if FManifestationList = nil then
      FManifestationList := TFhirCodeableConceptList.Create;
    FManifestationList.Assign(TFhirAllergyIntoleranceReaction(oSource).FManifestationList);
  end;
  descriptionElement := TFhirAllergyIntoleranceReaction(oSource).descriptionElement.Clone;
  onsetElement := TFhirAllergyIntoleranceReaction(oSource).onsetElement.Clone;
  severityElement := TFhirAllergyIntoleranceReaction(oSource).severityElement.Clone;
  exposureRoute := TFhirAllergyIntoleranceReaction(oSource).exposureRoute.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntoleranceReaction(oSource).FNoteList);
  end;
end;

procedure TFhirAllergyIntoleranceReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'manifestation') Then
    list.addAll(self, 'manifestation', FManifestationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'onset') Then
     list.add(self.link, 'onset', FOnset.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'exposureRoute') Then
     list.add(self.link, 'exposureRoute', FExposureRoute.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirAllergyIntoleranceReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manifestation', 'CodeableConcept', true, TFhirCodeableConcept, FManifestationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onset', 'dateTime', false, TFhirDateTime, FOnset.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'exposureRoute', 'CodeableConcept', false, TFhirCodeableConcept, FExposureRoute.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirAllergyIntoleranceReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'manifestation') then
  begin
    ManifestationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'onset') then
  begin
    OnsetElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, CODES_TFhirAllergyIntoleranceSeverityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'exposureRoute') then
  begin
    ExposureRoute := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntoleranceReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manifestation') then ManifestationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirAllergyIntoleranceReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'manifestation') then result := ManifestationList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'onset') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum[AllergyIntoleranceSeverityNull], CODES_TFhirAllergyIntoleranceSeverityEnum[AllergyIntoleranceSeverityNull])  {L1211}
  else if (propName = 'exposureRoute') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntoleranceReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'manifestation') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'onset') then result := 'dateTime'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'exposureRoute') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntoleranceReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'manifestation') then deletePropertyValue('manifestation', ManifestationList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'onset') then OnsetElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'exposureRoute') then ExposureRouteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntoleranceReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'manifestation') then replacePropertyValue('manifestation', ManifestationList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'onset') then OnsetElement := asDateTime(new) {L1222}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, CODES_TFhirAllergyIntoleranceSeverityEnum, new) {L1210}
  else if (propName = 'exposureRoute') then ExposureRouteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntoleranceReaction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manifestation') then ManifestationList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntoleranceReaction.fhirType : string;
begin
  result := 'AllergyIntolerance.reaction';
end;

function TFhirAllergyIntoleranceReaction.Link : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Link);
end;

function TFhirAllergyIntoleranceReaction.Clone : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Clone);
end;

function TFhirAllergyIntoleranceReaction.equals(other : TObject) : boolean; 
var
  o : TFhirAllergyIntoleranceReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntoleranceReaction)) then
    result := false
  else
  begin
    o := TFhirAllergyIntoleranceReaction(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(manifestationList, o.manifestationList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(onsetElement, o.onsetElement, true) and 
      compareDeep(severityElement, o.severityElement, true) and compareDeep(exposureRouteElement, o.exposureRouteElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirAllergyIntoleranceReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FmanifestationList) and isEmptyProp(FDescription) and isEmptyProp(FOnset) and isEmptyProp(FSeverity) and isEmptyProp(FExposureRoute) and isEmptyProp(FnoteList);
end;

procedure TFhirAllergyIntoleranceReaction.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value; {L1134}
end;

function TFhirAllergyIntoleranceReaction.GetManifestationList : TFhirCodeableConceptList;
begin
  if FManifestationList = nil then
    FManifestationList := TFhirCodeableConceptList.Create;
  result := FManifestationList;
end;

function TFhirAllergyIntoleranceReaction.GetHasManifestationList : boolean;
begin
  result := (FManifestationList <> nil) and (FManifestationList.count > 0);
end;

procedure TFhirAllergyIntoleranceReaction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirAllergyIntoleranceReaction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAllergyIntoleranceReaction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirAllergyIntoleranceReaction.SetOnset(value : TFhirDateTime);
begin
  FOnset.free;
  FOnset := value; {L1134}
end;

function TFhirAllergyIntoleranceReaction.GetOnsetST : TFslDateTime;
begin
  if FOnset = nil then
    result := TFslDateTime.makeNull
  else
    result := FOnset.value;
end;

procedure TFhirAllergyIntoleranceReaction.SetOnsetST(value : TFslDateTime);
begin
  if FOnset = nil then
    FOnset := TFhirDateTime.create;
  FOnset.value := value
end;

procedure TFhirAllergyIntoleranceReaction.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirAllergyIntoleranceReaction.GetSeverityST : TFhirAllergyIntoleranceSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirAllergyIntoleranceSeverityEnum(0)
  else
    result := TFhirAllergyIntoleranceSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceSeverityEnum, FSeverity.value));
end;

procedure TFhirAllergyIntoleranceReaction.SetSeverityST(value : TFhirAllergyIntoleranceSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum[value], CODES_TFhirAllergyIntoleranceSeverityEnum[value]);
end;

procedure TFhirAllergyIntoleranceReaction.SetExposureRoute(value : TFhirCodeableConcept);
begin
  FExposureRoute.free;
  FExposureRoute := value; {L1134}
end;

function TFhirAllergyIntoleranceReaction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirAllergyIntoleranceReaction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirAllergyIntoleranceReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance');
  fields.add('manifestation');
  fields.add('description');
  fields.add('onset');
  fields.add('severity');
  fields.add('exposureRoute');
  fields.add('note');
end;

function TFhirAllergyIntoleranceReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FmanifestationList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FExposureRoute.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionListEnumerator }

constructor TFhirAllergyIntoleranceReactionListEnumerator.Create(list : TFhirAllergyIntoleranceReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.GetCurrent : TFhirAllergyIntoleranceReaction;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionList }

procedure TFhirAllergyIntoleranceReactionList.AddItem(value: TFhirAllergyIntoleranceReaction);
begin
  assert(value.ClassName = 'TFhirAllergyIntoleranceReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntoleranceReaction');
  add(value);
end;

function TFhirAllergyIntoleranceReactionList.Append: TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceReactionList.GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
begin
  result := TFhirAllergyIntoleranceReactionListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceReactionList.Clone: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Clone);
end;

function TFhirAllergyIntoleranceReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceReactionList.GetItemN(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntoleranceReaction;
end;
function TFhirAllergyIntoleranceReactionList.IndexOf(value: TFhirAllergyIntoleranceReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceReactionList.Insert(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.InsertItem(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceReactionList.Item(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.Link: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Link);
end;

procedure TFhirAllergyIntoleranceReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemByIndex(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  FhirAllergyIntoleranceReactions[index] := value;
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemN(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirAllergyIntolerance }

constructor TFhirAllergyIntolerance.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntolerance.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FType_.free;
  FCategory.Free;
  FCriticality.free;
  FCode.free;
  FPatient.free;
  FEncounter.free;
  FOnset.free;
  FRecordedDate.free;
  FRecorder.free;
  FAsserter.free;
  FLastOccurrence.free;
  FNoteList.Free;
  FReactionList.Free;
  inherited;
end;

procedure TFhirAllergyIntolerance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAllergyIntolerance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAllergyIntolerance(oSource).FIdentifierList);
  end;
  clinicalStatus := TFhirAllergyIntolerance(oSource).clinicalStatus.Clone;
  verificationStatus := TFhirAllergyIntolerance(oSource).verificationStatus.Clone;
  type_Element := TFhirAllergyIntolerance(oSource).type_Element.Clone;
  if (TFhirAllergyIntolerance(oSource).FCategory = nil) then
  begin
    FCategory.free;
    FCategory := nil;
  end
  else
  begin
    FCategory := TFhirEnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
    FCategory.Assign(TFhirAllergyIntolerance(oSource).FCategory);
  end;
  criticalityElement := TFhirAllergyIntolerance(oSource).criticalityElement.Clone;
  code := TFhirAllergyIntolerance(oSource).code.Clone;
  patient := TFhirAllergyIntolerance(oSource).patient.Clone;
  encounter := TFhirAllergyIntolerance(oSource).encounter.Clone;
  onset := TFhirAllergyIntolerance(oSource).onset.Clone;
  recordedDateElement := TFhirAllergyIntolerance(oSource).recordedDateElement.Clone;
  recorder := TFhirAllergyIntolerance(oSource).recorder.Clone;
  asserter := TFhirAllergyIntolerance(oSource).asserter.Clone;
  lastOccurrenceElement := TFhirAllergyIntolerance(oSource).lastOccurrenceElement.Clone;
  if (TFhirAllergyIntolerance(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntolerance(oSource).FNoteList);
  end;
  if (TFhirAllergyIntolerance(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirAllergyIntoleranceReactionList.Create;
    FReactionList.Assign(TFhirAllergyIntolerance(oSource).FReactionList);
  end;
end;

function TFhirAllergyIntolerance.GetResourceType : TFhirResourceType;
begin
  result := frtAllergyIntolerance;
end;

procedure TFhirAllergyIntolerance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
     list.addAll(self, 'category', FCategory);
  if (child_name = 'criticality') Then
     list.add(self.link, 'criticality', FCriticality.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'lastOccurrence') Then
     list.add(self.link, 'lastOccurrence', FLastOccurrence.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
end;

procedure TFhirAllergyIntolerance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FClinicalStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FVerificationStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'code', true, TFhirEnum, FCategory.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'criticality', 'code', false, TFhirEnum, FCriticality.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FOnset.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lastOccurrence', 'dateTime', false, TFhirDateTime, FLastOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reaction', 'BackboneElement', true, TFhirAllergyIntoleranceReaction, FReactionList.Link)) {L1039};
end;

function TFhirAllergyIntolerance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'criticality') then
  begin
    CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'lastOccurrence') then
  begin
    LastOccurrenceElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirAllergyIntoleranceReaction) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntolerance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then FCategory.insertItem(index, asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue)) {L995}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirAllergyIntoleranceReaction) {L1049}
  else inherited;
end;

function TFhirAllergyIntolerance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'clinicalStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'verificationStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[AllergyIntoleranceTypeNull], CODES_TFhirAllergyIntoleranceTypeEnum[AllergyIntoleranceTypeNull])  {L1211}
  else if (propName = 'criticality') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[AllergyIntoleranceCriticalityNull], CODES_TFhirAllergyIntoleranceCriticalityEnum[AllergyIntoleranceCriticalityNull])  {L1211}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset') {L1191}
  else if (propName = 'recordedDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'recorder') then result := TFhirReference.create() {L1203}
  else if (propName = 'asserter') then result := TFhirReference.create() {L1203}
  else if (propName = 'lastOccurrence') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'reaction') then result := ReactionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntolerance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'CodeableConcept'
  else if (propName = 'verificationStatus') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'criticality') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'lastOccurrence') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reaction') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntolerance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'criticality') then CriticalityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil {L1189}
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntolerance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'verificationStatus') then VerificationStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, new) {L1210}
  else if (propName = 'criticality') then CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, new) {L1210}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirDataType {L1190}
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new) {L1222}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference {L1195}
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference {L1195}
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := asDateTime(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntolerance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then FCategory.move(source, destination) {L996}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'reaction') then ReactionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntolerance.fhirType : string;
begin
  result := 'AllergyIntolerance';
end;

function TFhirAllergyIntolerance.Link : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Link);
end;

function TFhirAllergyIntolerance.Clone : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Clone);
end;

function TFhirAllergyIntolerance.equals(other : TObject) : boolean; 
var
  o : TFhirAllergyIntolerance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntolerance)) then
    result := false
  else
  begin
    o := TFhirAllergyIntolerance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and 
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(criticalityElement, o.criticalityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(recordedDateElement, o.recordedDateElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(asserterElement, o.asserterElement, true) and 
      compareDeep(lastOccurrenceElement, o.lastOccurrenceElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(reactionList, o.reactionList, true);
  end;
end;

function TFhirAllergyIntolerance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FType_) and isEmptyProp(FCategory) and isEmptyProp(FCriticality) and isEmptyProp(FCode) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FOnset) and isEmptyProp(FRecordedDate) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FLastOccurrence) and isEmptyProp(FnoteList) and isEmptyProp(FreactionList);
end;

function TFhirAllergyIntolerance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAllergyIntolerance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAllergyIntolerance.SetClinicalStatus(value : TFhirCodeableConcept);
begin
  FClinicalStatus.free;
  FClinicalStatus := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetVerificationStatus(value : TFhirCodeableConcept);
begin
  FVerificationStatus.free;
  FVerificationStatus := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAllergyIntolerance.GetType_ST : TFhirAllergyIntoleranceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAllergyIntoleranceTypeEnum(0)
  else
    result := TFhirAllergyIntoleranceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceTypeEnum, FType_.value));
end;

procedure TFhirAllergyIntolerance.SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[value], CODES_TFhirAllergyIntoleranceTypeEnum[value]);
end;

function TFhirAllergyIntolerance.GetCategory : TFhirEnumList;
begin
  if FCategory = nil then
    FCategory := TFhirEnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  result := FCategory;
end;

function TFhirAllergyIntolerance.GetHasCategory : boolean;
begin
  result := (FCategory <> nil) and (FCategory.count > 0);
end;

function TFhirAllergyIntolerance.GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
  var i : integer;
begin
  result := [];
  if Fcategory <> nil then
    for i := 0 to Fcategory.count - 1 do
      result := result + [TFhirAllergyIntoleranceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCategoryEnum, Fcategory[i].value))];
end;

procedure TFhirAllergyIntolerance.SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
var a : TFhirAllergyIntoleranceCategoryEnum;
begin
  if Fcategory = nil then
    Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  Fcategory.clear;
  for a := low(TFhirAllergyIntoleranceCategoryEnum) to high(TFhirAllergyIntoleranceCategoryEnum) do
    if a in value then
      begin
         if Fcategory = nil then
           Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
         Fcategory.add(TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum[a], CODES_TFhirAllergyIntoleranceCategoryEnum[a]));
      end;
end;

procedure TFhirAllergyIntolerance.SetCriticality(value : TFhirEnum);
begin
  FCriticality.free;
  FCriticality := value;
end;

function TFhirAllergyIntolerance.GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
begin
  if FCriticality = nil then
    result := TFhirAllergyIntoleranceCriticalityEnum(0)
  else
    result := TFhirAllergyIntoleranceCriticalityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCriticalityEnum, FCriticality.value));
end;

procedure TFhirAllergyIntolerance.SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
begin
  if ord(value) = 0 then
    CriticalityElement := nil
  else
    CriticalityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[value], CODES_TFhirAllergyIntoleranceCriticalityEnum[value]);
end;

procedure TFhirAllergyIntolerance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value; {L1134}
end;

function TFhirAllergyIntolerance.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirAllergyIntolerance.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

procedure TFhirAllergyIntolerance.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value; {L1134}
end;

procedure TFhirAllergyIntolerance.SetLastOccurrence(value : TFhirDateTime);
begin
  FLastOccurrence.free;
  FLastOccurrence := value; {L1134}
end;

function TFhirAllergyIntolerance.GetLastOccurrenceST : TFslDateTime;
begin
  if FLastOccurrence = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastOccurrence.value;
end;

procedure TFhirAllergyIntolerance.SetLastOccurrenceST(value : TFslDateTime);
begin
  if FLastOccurrence = nil then
    FLastOccurrence := TFhirDateTime.create;
  FLastOccurrence.value := value
end;

function TFhirAllergyIntolerance.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirAllergyIntolerance.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirAllergyIntolerance.GetReactionList : TFhirAllergyIntoleranceReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirAllergyIntoleranceReactionList.Create;
  result := FReactionList;
end;

function TFhirAllergyIntolerance.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

procedure TFhirAllergyIntolerance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('type');
  fields.add('category');
  fields.add('criticality');
  fields.add('code');
  fields.add('patient');
  fields.add('encounter');
  fields.add('onset[x]');
  fields.add('recordedDate');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('lastOccurrence');
  fields.add('note');
  fields.add('reaction');
end;

function TFhirAllergyIntolerance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FClinicalStatus.sizeInBytes);
  inc(result, FVerificationStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCriticality.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FRecordedDate.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FAsserter.sizeInBytes);
  inc(result, FLastOccurrence.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceListEnumerator }

constructor TFhirAllergyIntoleranceListEnumerator.Create(list : TFhirAllergyIntoleranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceListEnumerator.GetCurrent : TFhirAllergyIntolerance;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceList }

procedure TFhirAllergyIntoleranceList.AddItem(value: TFhirAllergyIntolerance);
begin
  assert(value.ClassName = 'TFhirAllergyIntolerance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntolerance');
  add(value);
end;

function TFhirAllergyIntoleranceList.Append: TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceList.GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
begin
  result := TFhirAllergyIntoleranceListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceList.Clone: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Clone);
end;

function TFhirAllergyIntoleranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceList.GetItemN(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntolerance;
end;
function TFhirAllergyIntoleranceList.IndexOf(value: TFhirAllergyIntolerance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceList.Insert(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.InsertItem(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceList.Item(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.Link: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Link);
end;

procedure TFhirAllergyIntoleranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceList.SetItemByIndex(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  FhirAllergyIntolerances[index] := value;
end;

procedure TFhirAllergyIntoleranceList.SetItemN(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
{ TFhirAppointmentParticipant }

constructor TFhirAppointmentParticipant.Create;
begin
  inherited;
end;

destructor TFhirAppointmentParticipant.Destroy;
begin
  FType_List.Free;
  FActor.free;
  FRequired.free;
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAppointmentParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirAppointmentParticipant(oSource).FType_List);
  end;
  actor := TFhirAppointmentParticipant(oSource).actor.Clone;
  requiredElement := TFhirAppointmentParticipant(oSource).requiredElement.Clone;
  statusElement := TFhirAppointmentParticipant(oSource).statusElement.Clone;
  period := TFhirAppointmentParticipant(oSource).period.Clone;
end;

procedure TFhirAppointmentParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAppointmentParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'required', 'code', false, TFhirEnum, FRequired.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirAppointmentParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asEnum(SYSTEMS_TFhirParticipantRequiredEnum, CODES_TFhirParticipantRequiredEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirAppointmentParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else if (propName = 'required') then result := TFhirEnum.create(SYSTEMS_TFhirParticipantRequiredEnum[ParticipantRequiredNull], CODES_TFhirParticipantRequiredEnum[ParticipantRequiredNull])  {L1211}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[ParticipationStatusNull], CODES_TFhirParticipationStatusEnum[ParticipationStatusNull])  {L1211}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'required') then result := 'code'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else if (propName = 'required') then RequiredElement := asEnum(SYSTEMS_TFhirParticipantRequiredEnum, CODES_TFhirParticipantRequiredEnum, new) {L1210}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, new) {L1210}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentParticipant.fhirType : string;
begin
  result := 'Appointment.participant';
end;

function TFhirAppointmentParticipant.Link : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Link);
end;

function TFhirAppointmentParticipant.Clone : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Clone);
end;

function TFhirAppointmentParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirAppointmentParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentParticipant)) then
    result := false
  else
  begin
    o := TFhirAppointmentParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAppointmentParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FActor) and isEmptyProp(FRequired) and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

function TFhirAppointmentParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirAppointmentParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirAppointmentParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirAppointmentParticipant.SetRequired(value : TFhirEnum);
begin
  FRequired.free;
  FRequired := value;
end;

function TFhirAppointmentParticipant.GetRequiredST : TFhirParticipantRequiredEnum;
begin
  if FRequired = nil then
    result := TFhirParticipantRequiredEnum(0)
  else
    result := TFhirParticipantRequiredEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipantRequiredEnum, FRequired.value));
end;

procedure TFhirAppointmentParticipant.SetRequiredST(value : TFhirParticipantRequiredEnum);
begin
  if ord(value) = 0 then
    RequiredElement := nil
  else
    RequiredElement := TFhirEnum.create(SYSTEMS_TFhirParticipantRequiredEnum[value], CODES_TFhirParticipantRequiredEnum[value]);
end;

procedure TFhirAppointmentParticipant.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAppointmentParticipant.GetStatusST : TFhirParticipationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirParticipationStatusEnum(0)
  else
    result := TFhirParticipationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationStatusEnum, FStatus.value));
end;

procedure TFhirAppointmentParticipant.SetStatusST(value : TFhirParticipationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[value], CODES_TFhirParticipationStatusEnum[value]);
end;

procedure TFhirAppointmentParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirAppointmentParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('actor');
  fields.add('required');
  fields.add('status');
  fields.add('period');
end;

function TFhirAppointmentParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirAppointmentParticipantListEnumerator }

constructor TFhirAppointmentParticipantListEnumerator.Create(list : TFhirAppointmentParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentParticipantListEnumerator.GetCurrent : TFhirAppointmentParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentParticipantList }

procedure TFhirAppointmentParticipantList.AddItem(value: TFhirAppointmentParticipant);
begin
  assert(value.ClassName = 'TFhirAppointmentParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentParticipant');
  add(value);
end;

function TFhirAppointmentParticipantList.Append: TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentParticipantList.GetEnumerator : TFhirAppointmentParticipantListEnumerator;
begin
  result := TFhirAppointmentParticipantListEnumerator.Create(self.link);
end;

function TFhirAppointmentParticipantList.Clone: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Clone);
end;

function TFhirAppointmentParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentParticipantList.GetItemN(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentParticipant;
end;
function TFhirAppointmentParticipantList.IndexOf(value: TFhirAppointmentParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentParticipantList.Insert(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.InsertItem(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  Inherited Insert(index, value);
end;

function TFhirAppointmentParticipantList.Item(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.Link: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Link);
end;

procedure TFhirAppointmentParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentParticipantList.SetItemByIndex(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  FhirAppointmentParticipants[index] := value;
end;

procedure TFhirAppointmentParticipantList.SetItemN(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAppointment }

constructor TFhirAppointment.Create;
begin
  inherited;
end;

destructor TFhirAppointment.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCancelationReason.free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FAppointmentType.free;
  FReasonList.Free;
  FPriority.free;
  FDescription.free;
  FSupportingInformationList.Free;
  FStart.free;
  FEnd_.free;
  FMinutesDuration.free;
  FSlotList.Free;
  FCreated.free;
  FComment.free;
  FPatientInstruction.free;
  FBasedOnList.Free;
  FParticipantList.Free;
  FRequestedPeriodList.Free;
  inherited;
end;

procedure TFhirAppointment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointment(oSource).FIdentifierList);
  end;
  statusElement := TFhirAppointment(oSource).statusElement.Clone;
  cancelationReason := TFhirAppointment(oSource).cancelationReason.Clone;
  if (TFhirAppointment(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirAppointment(oSource).FServiceCategoryList);
  end;
  if (TFhirAppointment(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirAppointment(oSource).FServiceTypeList);
  end;
  if (TFhirAppointment(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirAppointment(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirAppointment(oSource).appointmentType.Clone;
  if (TFhirAppointment(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirAppointment(oSource).FReasonList);
  end;
  priorityElement := TFhirAppointment(oSource).priorityElement.Clone;
  descriptionElement := TFhirAppointment(oSource).descriptionElement.Clone;
  if (TFhirAppointment(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirAppointment(oSource).FSupportingInformationList);
  end;
  startElement := TFhirAppointment(oSource).startElement.Clone;
  end_Element := TFhirAppointment(oSource).end_Element.Clone;
  minutesDurationElement := TFhirAppointment(oSource).minutesDurationElement.Clone;
  if (TFhirAppointment(oSource).FSlotList = nil) then
  begin
    FSlotList.free;
    FSlotList := nil;
  end
  else
  begin
    if FSlotList = nil then
      FSlotList := TFhirReferenceList.Create;
    FSlotList.Assign(TFhirAppointment(oSource).FSlotList);
  end;
  createdElement := TFhirAppointment(oSource).createdElement.Clone;
  commentElement := TFhirAppointment(oSource).commentElement.Clone;
  patientInstructionElement := TFhirAppointment(oSource).patientInstructionElement.Clone;
  if (TFhirAppointment(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirAppointment(oSource).FBasedOnList);
  end;
  if (TFhirAppointment(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAppointmentParticipantList.Create;
    FParticipantList.Assign(TFhirAppointment(oSource).FParticipantList);
  end;
  if (TFhirAppointment(oSource).FRequestedPeriodList = nil) then
  begin
    FRequestedPeriodList.free;
    FRequestedPeriodList := nil;
  end
  else
  begin
    if FRequestedPeriodList = nil then
      FRequestedPeriodList := TFhirPeriodList.Create;
    FRequestedPeriodList.Assign(TFhirAppointment(oSource).FRequestedPeriodList);
  end;
end;

function TFhirAppointment.GetResourceType : TFhirResourceType;
begin
  result := frtAppointment;
end;

procedure TFhirAppointment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'cancelationReason') Then
     list.add(self.link, 'cancelationReason', FCancelationReason.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'minutesDuration') Then
     list.add(self.link, 'minutesDuration', FMinutesDuration.Link);
  if (child_name = 'slot') Then
    list.addAll(self, 'slot', FSlotList);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'patientInstruction') Then
     list.add(self.link, 'patientInstruction', FPatientInstruction.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'requestedPeriod') Then
    list.addAll(self, 'requestedPeriod', FRequestedPeriodList);
end;

procedure TFhirAppointment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'cancelationReason', 'CodeableConcept', false, TFhirCodeableConcept, FCancelationReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priority', 'unsignedInt', false, TFhirUnsignedInt, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'minutesDuration', 'positiveInt', false, TFhirPositiveInt, FMinutesDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'slot', 'Reference', true, TFhirReference, FSlotList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patientInstruction', 'string', false, TFhirString, FPatientInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirAppointmentParticipant, FParticipantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'requestedPeriod', 'Period', true, TFhirPeriod, FRequestedPeriodList.Link)) {L1039};
end;

function TFhirAppointment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAppointmentStatusEnum, CODES_TFhirAppointmentStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'cancelationReason') then
  begin
    CancelationReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'minutesDuration') then
  begin
    MinutesDurationElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'slot') then
  begin
    SlotList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'patientInstruction') then
  begin
    PatientInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAppointmentParticipant) {L1048};
    result := propValue;
  end
  else if (propName = 'requestedPeriod') then
  begin
    RequestedPeriodList.add(propValue as TFhirPeriod) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'slot') then SlotList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAppointmentParticipant) {L1049}
  else if (propName = 'requestedPeriod') then RequestedPeriodList.insertItem(index, propValue as TFhirPeriod) {L1049}
  else inherited;
end;

function TFhirAppointment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirAppointmentStatusEnum[AppointmentStatusNull], CODES_TFhirAppointmentStatusEnum[AppointmentStatusNull])  {L1211}
  else if (propName = 'cancelationReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new() {L1053}
  else if (propName = 'serviceType') then result := ServiceTypeList.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'priority') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new() {L1053}
  else if (propName = 'start') then result := TFhirInstant.create() {L1223}
  else if (propName = 'end') then result := TFhirInstant.create() {L1223}
  else if (propName = 'minutesDuration') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'slot') then result := SlotList.new() {L1053}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else if (propName = 'patientInstruction') then result := TFhirString.create() {L1223}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'participant') then result := ParticipantList.new() {L1053}
  else if (propName = 'requestedPeriod') then result := RequestedPeriodList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'cancelationReason') then result := 'CodeableConcept'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'priority') then result := 'unsignedInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'minutesDuration') then result := 'positiveInt'
  else if (propName = 'slot') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'patientInstruction') then result := 'string'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'requestedPeriod') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'cancelationReason') then CancelationReasonElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value) {L1054}
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {L1054}
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'minutesDuration') then MinutesDurationElement := nil
  else if (propName = 'slot') then deletePropertyValue('slot', SlotList, value) {L1054}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'patientInstruction') then PatientInstructionElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {L1054}
  else if (propName = 'requestedPeriod') then deletePropertyValue('requestedPeriod', RequestedPeriodList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAppointmentStatusEnum, CODES_TFhirAppointmentStatusEnum, new) {L1210}
  else if (propName = 'cancelationReason') then CancelationReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new) {L1055}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'priority') then PriorityElement := asUnsignedInt(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {L1055}
  else if (propName = 'start') then StartElement := asInstant(new) {L1222}
  else if (propName = 'end') then End_Element := asInstant(new) {L1222}
  else if (propName = 'minutesDuration') then MinutesDurationElement := asPositiveInt(new) {L1222}
  else if (propName = 'slot') then replacePropertyValue('slot', SlotList, existing, new) {L1055}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else if (propName = 'patientInstruction') then PatientInstructionElement := asString(new) {L1222}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {L1055}
  else if (propName = 'requestedPeriod') then replacePropertyValue('requestedPeriod', RequestedPeriodList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination) {L1050}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination) {L1050}
  else if (propName = 'slot') then SlotList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'participant') then ParticipantList.move(source, destination) {L1050}
  else if (propName = 'requestedPeriod') then RequestedPeriodList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointment.fhirType : string;
begin
  result := 'Appointment';
end;

function TFhirAppointment.Link : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Link);
end;

function TFhirAppointment.Clone : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Clone);
end;

function TFhirAppointment.equals(other : TObject) : boolean; 
var
  o : TFhirAppointment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointment)) then
    result := false
  else
  begin
    o := TFhirAppointment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(cancelationReasonElement, o.cancelationReasonElement, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(minutesDurationElement, o.minutesDurationElement, true) and compareDeep(slotList, o.slotList, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(patientInstructionElement, o.patientInstructionElement, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(requestedPeriodList, o.requestedPeriodList, true);
  end;
end;

function TFhirAppointment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCancelationReason) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FreasonList) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FMinutesDuration) and isEmptyProp(FslotList) and isEmptyProp(FCreated) and isEmptyProp(FComment) and isEmptyProp(FPatientInstruction) and isEmptyProp(FbasedOnList) and isEmptyProp(FparticipantList) and isEmptyProp(FrequestedPeriodList);
end;

function TFhirAppointment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAppointment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAppointment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAppointment.GetStatusST : TFhirAppointmentStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAppointmentStatusEnum(0)
  else
    result := TFhirAppointmentStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAppointmentStatusEnum, FStatus.value));
end;

procedure TFhirAppointment.SetStatusST(value : TFhirAppointmentStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAppointmentStatusEnum[value], CODES_TFhirAppointmentStatusEnum[value]);
end;

procedure TFhirAppointment.SetCancelationReason(value : TFhirCodeableConcept);
begin
  FCancelationReason.free;
  FCancelationReason := value; {L1134}
end;

function TFhirAppointment.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirAppointment.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirAppointment.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirAppointment.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirAppointment.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirAppointment.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

procedure TFhirAppointment.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value; {L1134}
end;

function TFhirAppointment.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirAppointment.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirAppointment.SetPriority(value : TFhirUnsignedInt);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

function TFhirAppointment.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirAppointment.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirUnsignedInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

procedure TFhirAppointment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirAppointment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAppointment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirAppointment.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirAppointment.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirAppointment.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirAppointment.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirAppointment.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirAppointment.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirAppointment.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirAppointment.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirAppointment.SetMinutesDuration(value : TFhirPositiveInt);
begin
  FMinutesDuration.free;
  FMinutesDuration := value; {L1134}
end;

function TFhirAppointment.GetMinutesDurationST : String;
begin
  if FMinutesDuration = nil then
    result := ''
  else
    result := FMinutesDuration.value;
end;

procedure TFhirAppointment.SetMinutesDurationST(value : String);
begin
  if value <> '' then
  begin
    if FMinutesDuration = nil then
      FMinutesDuration := TFhirPositiveInt.create;
    FMinutesDuration.value := value
  end
  else if FMinutesDuration <> nil then
    FMinutesDuration.value := '';
end;

function TFhirAppointment.GetSlotList : TFhirReferenceList;
begin
  if FSlotList = nil then
    FSlotList := TFhirReferenceList.Create;
  result := FSlotList;
end;

function TFhirAppointment.GetHasSlotList : boolean;
begin
  result := (FSlotList <> nil) and (FSlotList.count > 0);
end;

procedure TFhirAppointment.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirAppointment.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirAppointment.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirAppointment.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirAppointment.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirAppointment.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirAppointment.SetPatientInstruction(value : TFhirString);
begin
  FPatientInstruction.free;
  FPatientInstruction := value; {L1134}
end;

function TFhirAppointment.GetPatientInstructionST : String;
begin
  if FPatientInstruction = nil then
    result := ''
  else
    result := FPatientInstruction.value;
end;

procedure TFhirAppointment.SetPatientInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPatientInstruction = nil then
      FPatientInstruction := TFhirString.create;
    FPatientInstruction.value := value
  end
  else if FPatientInstruction <> nil then
    FPatientInstruction.value := '';
end;

function TFhirAppointment.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirAppointment.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirAppointment.GetParticipantList : TFhirAppointmentParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAppointmentParticipantList.Create;
  result := FParticipantList;
end;

function TFhirAppointment.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirAppointment.GetRequestedPeriodList : TFhirPeriodList;
begin
  if FRequestedPeriodList = nil then
    FRequestedPeriodList := TFhirPeriodList.Create;
  result := FRequestedPeriodList;
end;

function TFhirAppointment.GetHasRequestedPeriodList : boolean;
begin
  result := (FRequestedPeriodList <> nil) and (FRequestedPeriodList.count > 0);
end;

procedure TFhirAppointment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('cancelationReason');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('reason');
  fields.add('priority');
  fields.add('description');
  fields.add('supportingInformation');
  fields.add('start');
  fields.add('end');
  fields.add('minutesDuration');
  fields.add('slot');
  fields.add('created');
  fields.add('comment');
  fields.add('patientInstruction');
  fields.add('basedOn');
  fields.add('participant');
  fields.add('requestedPeriod');
end;

function TFhirAppointment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCancelationReason.sizeInBytes);
  inc(result, FserviceCategoryList.sizeInBytes);
  inc(result, FserviceTypeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FAppointmentType.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FMinutesDuration.sizeInBytes);
  inc(result, FslotList.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FPatientInstruction.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FrequestedPeriodList.sizeInBytes);
end;

{ TFhirAppointmentListEnumerator }

constructor TFhirAppointmentListEnumerator.Create(list : TFhirAppointmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentListEnumerator.GetCurrent : TFhirAppointment;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentList }

procedure TFhirAppointmentList.AddItem(value: TFhirAppointment);
begin
  assert(value.ClassName = 'TFhirAppointment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointment');
  add(value);
end;

function TFhirAppointmentList.Append: TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentList.GetEnumerator : TFhirAppointmentListEnumerator;
begin
  result := TFhirAppointmentListEnumerator.Create(self.link);
end;

function TFhirAppointmentList.Clone: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Clone);
end;

function TFhirAppointmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentList.GetItemN(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointment;
end;
function TFhirAppointmentList.IndexOf(value: TFhirAppointment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentList.Insert(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.InsertItem(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  Inherited Insert(index, value);
end;

function TFhirAppointmentList.Item(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.Link: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Link);
end;

procedure TFhirAppointmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentList.SetItemByIndex(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  FhirAppointments[index] := value;
end;

procedure TFhirAppointmentList.SetItemN(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
{ TFhirAppointmentResponse }

constructor TFhirAppointmentResponse.Create;
begin
  inherited;
end;

destructor TFhirAppointmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FAppointment.free;
  FStart.free;
  FEnd_.free;
  FParticipantTypeList.Free;
  FActor.free;
  FParticipantStatus.free;
  FComment.free;
  inherited;
end;

procedure TFhirAppointmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointmentResponse(oSource).FIdentifierList);
  end;
  appointment := TFhirAppointmentResponse(oSource).appointment.Clone;
  startElement := TFhirAppointmentResponse(oSource).startElement.Clone;
  end_Element := TFhirAppointmentResponse(oSource).end_Element.Clone;
  if (TFhirAppointmentResponse(oSource).FParticipantTypeList = nil) then
  begin
    FParticipantTypeList.free;
    FParticipantTypeList := nil;
  end
  else
  begin
    if FParticipantTypeList = nil then
      FParticipantTypeList := TFhirCodeableConceptList.Create;
    FParticipantTypeList.Assign(TFhirAppointmentResponse(oSource).FParticipantTypeList);
  end;
  actor := TFhirAppointmentResponse(oSource).actor.Clone;
  participantStatusElement := TFhirAppointmentResponse(oSource).participantStatusElement.Clone;
  commentElement := TFhirAppointmentResponse(oSource).commentElement.Clone;
end;

function TFhirAppointmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtAppointmentResponse;
end;

procedure TFhirAppointmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'appointment') Then
     list.add(self.link, 'appointment', FAppointment.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'participantType') Then
    list.addAll(self, 'participantType', FParticipantTypeList);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'participantStatus') Then
     list.add(self.link, 'participantStatus', FParticipantStatus.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirAppointmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference', false, TFhirReference, FAppointment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participantType', 'CodeableConcept', true, TFhirCodeableConcept, FParticipantTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participantStatus', 'code', false, TFhirEnum, FParticipantStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
end;

function TFhirAppointmentResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    Appointment := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'participantType') then
  begin
    ParticipantTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'participantStatus') then
  begin
    ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'participantType') then ParticipantTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirAppointmentResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'appointment') then result := TFhirReference.create() {L1203}
  else if (propName = 'start') then result := TFhirInstant.create() {L1223}
  else if (propName = 'end') then result := TFhirInstant.create() {L1223}
  else if (propName = 'participantType') then result := ParticipantTypeList.new() {L1053}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else if (propName = 'participantStatus') then result := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[ParticipationStatusNull], CODES_TFhirParticipationStatusEnum[ParticipationStatusNull])  {L1211}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'participantType') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'participantStatus') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'appointment') then AppointmentElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'participantType') then deletePropertyValue('participantType', ParticipantTypeList, value) {L1054}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'participantStatus') then ParticipantStatusElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'appointment') then AppointmentElement := new as TFhirReference {L1195}
  else if (propName = 'start') then StartElement := asInstant(new) {L1222}
  else if (propName = 'end') then End_Element := asInstant(new) {L1222}
  else if (propName = 'participantType') then replacePropertyValue('participantType', ParticipantTypeList, existing, new) {L1055}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else if (propName = 'participantStatus') then ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, new) {L1210}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'participantType') then ParticipantTypeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentResponse.fhirType : string;
begin
  result := 'AppointmentResponse';
end;

function TFhirAppointmentResponse.Link : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Link);
end;

function TFhirAppointmentResponse.Clone : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Clone);
end;

function TFhirAppointmentResponse.equals(other : TObject) : boolean; 
var
  o : TFhirAppointmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentResponse)) then
    result := false
  else
  begin
    o := TFhirAppointmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(appointmentElement, o.appointmentElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(participantTypeList, o.participantTypeList, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(participantStatusElement, o.participantStatusElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirAppointmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAppointment) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FparticipantTypeList) and isEmptyProp(FActor) and isEmptyProp(FParticipantStatus) and isEmptyProp(FComment);
end;

function TFhirAppointmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAppointmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAppointmentResponse.SetAppointment(value : TFhirReference);
begin
  FAppointment.free;
  FAppointment := value; {L1134}
end;

procedure TFhirAppointmentResponse.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirAppointmentResponse.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirAppointmentResponse.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirAppointmentResponse.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirAppointmentResponse.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirAppointmentResponse.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

function TFhirAppointmentResponse.GetParticipantTypeList : TFhirCodeableConceptList;
begin
  if FParticipantTypeList = nil then
    FParticipantTypeList := TFhirCodeableConceptList.Create;
  result := FParticipantTypeList;
end;

function TFhirAppointmentResponse.GetHasParticipantTypeList : boolean;
begin
  result := (FParticipantTypeList <> nil) and (FParticipantTypeList.count > 0);
end;

procedure TFhirAppointmentResponse.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirAppointmentResponse.SetParticipantStatus(value : TFhirEnum);
begin
  FParticipantStatus.free;
  FParticipantStatus := value;
end;

function TFhirAppointmentResponse.GetParticipantStatusST : TFhirParticipationStatusEnum;
begin
  if FParticipantStatus = nil then
    result := TFhirParticipationStatusEnum(0)
  else
    result := TFhirParticipationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationStatusEnum, FParticipantStatus.value));
end;

procedure TFhirAppointmentResponse.SetParticipantStatusST(value : TFhirParticipationStatusEnum);
begin
  if ord(value) = 0 then
    ParticipantStatusElement := nil
  else
    ParticipantStatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[value], CODES_TFhirParticipationStatusEnum[value]);
end;

procedure TFhirAppointmentResponse.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirAppointmentResponse.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirAppointmentResponse.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirAppointmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('appointment');
  fields.add('start');
  fields.add('end');
  fields.add('participantType');
  fields.add('actor');
  fields.add('participantStatus');
  fields.add('comment');
end;

function TFhirAppointmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAppointment.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FparticipantTypeList.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FParticipantStatus.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirAppointmentResponseListEnumerator }

constructor TFhirAppointmentResponseListEnumerator.Create(list : TFhirAppointmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentResponseListEnumerator.GetCurrent : TFhirAppointmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentResponseList }

procedure TFhirAppointmentResponseList.AddItem(value: TFhirAppointmentResponse);
begin
  assert(value.ClassName = 'TFhirAppointmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentResponse');
  add(value);
end;

function TFhirAppointmentResponseList.Append: TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentResponseList.GetEnumerator : TFhirAppointmentResponseListEnumerator;
begin
  result := TFhirAppointmentResponseListEnumerator.Create(self.link);
end;

function TFhirAppointmentResponseList.Clone: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Clone);
end;

function TFhirAppointmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentResponseList.GetItemN(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentResponse;
end;
function TFhirAppointmentResponseList.IndexOf(value: TFhirAppointmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentResponseList.Insert(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.InsertItem(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  Inherited Insert(index, value);
end;

function TFhirAppointmentResponseList.Item(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.Link: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Link);
end;

procedure TFhirAppointmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentResponseList.SetItemByIndex(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  FhirAppointmentResponses[index] := value;
end;

procedure TFhirAppointmentResponseList.SetItemN(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
{ TFhirBasic }

constructor TFhirBasic.Create;
begin
  inherited;
end;

destructor TFhirBasic.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FSubject.free;
  FCreated.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirBasic.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBasic(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBasic(oSource).FIdentifierList);
  end;
  code := TFhirBasic(oSource).code.Clone;
  subject := TFhirBasic(oSource).subject.Clone;
  createdElement := TFhirBasic(oSource).createdElement.Clone;
  author := TFhirBasic(oSource).author.Clone;
end;

function TFhirBasic.GetResourceType : TFhirResourceType;
begin
  result := frtBasic;
end;

procedure TFhirBasic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirBasic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'date', false, TFhirDate, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
end;

function TFhirBasic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBasic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirBasic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'created') then result := TFhirDate.create() {L1223}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBasic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'date'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBasic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBasic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'created') then CreatedElement := asDate(new) {L1222}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBasic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBasic.fhirType : string;
begin
  result := 'Basic';
end;

function TFhirBasic.Link : TFhirBasic;
begin
  result := TFhirBasic(inherited Link);
end;

function TFhirBasic.Clone : TFhirBasic;
begin
  result := TFhirBasic(inherited Clone);
end;

function TFhirBasic.equals(other : TObject) : boolean; 
var
  o : TFhirBasic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBasic)) then
    result := false
  else
  begin
    o := TFhirBasic(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirBasic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FAuthor);
end;

function TFhirBasic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBasic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBasic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirBasic.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirBasic.SetCreated(value : TFhirDate);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirBasic.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirBasic.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDate.create;
  FCreated.value := value
end;

procedure TFhirBasic.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

procedure TFhirBasic.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
end;

function TFhirBasic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirBasicListEnumerator }

constructor TFhirBasicListEnumerator.Create(list : TFhirBasicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBasicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBasicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBasicListEnumerator.GetCurrent : TFhirBasic;
begin
  Result := FList[FIndex];
end;

function TFhirBasicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBasicList }

procedure TFhirBasicList.AddItem(value: TFhirBasic);
begin
  assert(value.ClassName = 'TFhirBasic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBasic');
  add(value);
end;

function TFhirBasicList.Append: TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.ClearItems;
begin
  Clear;
end;

function TFhirBasicList.GetEnumerator : TFhirBasicListEnumerator;
begin
  result := TFhirBasicListEnumerator.Create(self.link);
end;

function TFhirBasicList.Clone: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Clone);
end;

function TFhirBasicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBasicList.GetItemN(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.ItemClass: TFslObjectClass;
begin
  result := TFhirBasic;
end;
function TFhirBasicList.IndexOf(value: TFhirBasic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBasicList.Insert(index: Integer): TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.InsertItem(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  Inherited Insert(index, value);
end;

function TFhirBasicList.Item(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.Link: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Link);
end;

procedure TFhirBasicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBasicList.SetItemByIndex(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  FhirBasics[index] := value;
end;

procedure TFhirBasicList.SetItemN(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{ TFhirBiologicallyDerivedProductCollection }

constructor TFhirBiologicallyDerivedProductCollection.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductCollection.Destroy;
begin
  FCollector.free;
  FSource.free;
  FCollected.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirBiologicallyDerivedProductCollection(oSource).collector.Clone;
  source := TFhirBiologicallyDerivedProductCollection(oSource).source.Clone;
  collected := TFhirBiologicallyDerivedProductCollection(oSource).collected.Clone;
end;

procedure TFhirBiologicallyDerivedProductCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
end;

procedure TFhirBiologicallyDerivedProductCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference', false, TFhirReference, FCollector.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirDataType, FCollected.Link)); {L1172}
end;

function TFhirBiologicallyDerivedProductCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference.create() {L1203}
  else if (propName = 'source') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference {L1195}
  else if (propName = 'source') then SourceElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductCollection.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.collection';
end;

function TFhirBiologicallyDerivedProductCollection.Link : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Link);
end;

function TFhirBiologicallyDerivedProductCollection.Clone : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollection.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductCollection)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(collectedElement, o.collectedElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FSource) and isEmptyProp(FCollected);
end;

procedure TFhirBiologicallyDerivedProductCollection.SetCollector(value : TFhirReference);
begin
  FCollector.free;
  FCollector := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductCollection.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductCollection.SetCollected(value : TFhirDataType);
begin
  FCollected.free;
  FCollected := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductCollection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('collector');
  fields.add('source');
  fields.add('collected[x]');
end;

function TFhirBiologicallyDerivedProductCollection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCollector.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FCollected.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductCollectionListEnumerator }

constructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(list : TFhirBiologicallyDerivedProductCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductCollection;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductCollectionList }

procedure TFhirBiologicallyDerivedProductCollectionList.AddItem(value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductCollection');
  add(value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Append: TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductCollectionList.Clone: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductCollection;
end;
function TFhirBiologicallyDerivedProductCollectionList.IndexOf(value: TFhirBiologicallyDerivedProductCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Insert(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Item(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.Link: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  FhirBiologicallyDerivedProductCollections[index] := value;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductProcessing }

constructor TFhirBiologicallyDerivedProductProcessing.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditive.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirBiologicallyDerivedProductProcessing(oSource).procedure_.Clone;
  additive := TFhirBiologicallyDerivedProductProcessing(oSource).additive.Clone;
  time := TFhirBiologicallyDerivedProductProcessing(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
     list.add(self.link, 'additive', FAdditive.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference', false, TFhirReference, FAdditive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link)); {L1172}
end;

function TFhirBiologicallyDerivedProductProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    Additive := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'additive') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then AdditiveElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'additive') then AdditiveElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductProcessing.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.processing';
end;

function TFhirBiologicallyDerivedProductProcessing.Link : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Link);
end;

function TFhirBiologicallyDerivedProductProcessing.Clone : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessing.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductProcessing)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(additiveElement, o.additiveElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FAdditive) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirBiologicallyDerivedProductProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetAdditive(value : TFhirReference);
begin
  FAdditive.free;
  FAdditive := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductProcessing.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

function TFhirBiologicallyDerivedProductProcessing.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FAdditive.sizeInBytes);
  inc(result, FTime.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductProcessingListEnumerator }

constructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(list : TFhirBiologicallyDerivedProductProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductProcessingList }

procedure TFhirBiologicallyDerivedProductProcessingList.AddItem(value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductProcessing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductProcessing');
  add(value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Append: TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductProcessingList.Clone: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductProcessing;
end;
function TFhirBiologicallyDerivedProductProcessingList.IndexOf(value: TFhirBiologicallyDerivedProductProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Insert(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Item(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.Link: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  FhirBiologicallyDerivedProductProcessings[index] := value;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductManipulation }

constructor TFhirBiologicallyDerivedProductManipulation.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductManipulation.Destroy;
begin
  FDescription.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductManipulation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductManipulation(oSource).descriptionElement.Clone;
  time := TFhirBiologicallyDerivedProductManipulation(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductManipulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductManipulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link)); {L1172}
end;

function TFhirBiologicallyDerivedProductManipulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductManipulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductManipulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductManipulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductManipulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductManipulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductManipulation.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.manipulation';
end;

function TFhirBiologicallyDerivedProductManipulation.Link : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Link);
end;

function TFhirBiologicallyDerivedProductManipulation.Clone : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulation.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductManipulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductManipulation)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductManipulation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductManipulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirBiologicallyDerivedProductManipulation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductManipulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('time[x]');
end;

function TFhirBiologicallyDerivedProductManipulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FTime.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductManipulationListEnumerator }

constructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(list : TFhirBiologicallyDerivedProductManipulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductManipulation;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductManipulationList }

procedure TFhirBiologicallyDerivedProductManipulationList.AddItem(value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductManipulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductManipulation');
  add(value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Append: TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductManipulationList.Clone: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductManipulation;
end;
function TFhirBiologicallyDerivedProductManipulationList.IndexOf(value: TFhirBiologicallyDerivedProductManipulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Insert(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Item(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.Link: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  FhirBiologicallyDerivedProductManipulations[index] := value;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductStorage }

constructor TFhirBiologicallyDerivedProductStorage.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductStorage.Destroy;
begin
  FDescription.free;
  FTemperature.free;
  FScale.free;
  FDuration.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductStorage.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductStorage(oSource).descriptionElement.Clone;
  temperatureElement := TFhirBiologicallyDerivedProductStorage(oSource).temperatureElement.Clone;
  scaleElement := TFhirBiologicallyDerivedProductStorage(oSource).scaleElement.Clone;
  duration := TFhirBiologicallyDerivedProductStorage(oSource).duration.Clone;
end;

procedure TFhirBiologicallyDerivedProductStorage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'temperature') Then
     list.add(self.link, 'temperature', FTemperature.Link);
  if (child_name = 'scale') Then
     list.add(self.link, 'scale', FScale.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirBiologicallyDerivedProductStorage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'temperature', 'decimal', false, TFhirDecimal, FTemperature.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'scale', 'code', false, TFhirEnum, FScale.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'duration', 'Period', false, TFhirPeriod, FDuration.Link)); {L1172}
end;

function TFhirBiologicallyDerivedProductStorage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'temperature') then
  begin
    TemperatureElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'scale') then
  begin
    ScaleElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum, CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductStorage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductStorage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'temperature') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'scale') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum[BiologicallyDerivedProductStorageScaleNull], CODES_TFhirBiologicallyDerivedProductStorageScaleEnum[BiologicallyDerivedProductStorageScaleNull])  {L1211}
  else if (propName = 'duration') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductStorage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'temperature') then result := 'decimal'
  else if (propName = 'scale') then result := 'code'
  else if (propName = 'duration') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductStorage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'temperature') then TemperatureElement := nil
  else if (propName = 'scale') then ScaleElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductStorage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'temperature') then TemperatureElement := asDecimal(new) {L1222}
  else if (propName = 'scale') then ScaleElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum, CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, new) {L1210}
  else if (propName = 'duration') then DurationElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductStorage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductStorage.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.storage';
end;

function TFhirBiologicallyDerivedProductStorage.Link : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Link);
end;

function TFhirBiologicallyDerivedProductStorage.Clone : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorage.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductStorage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductStorage)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductStorage(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(temperatureElement, o.temperatureElement, true) and 
      compareDeep(scaleElement, o.scaleElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductStorage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTemperature) and isEmptyProp(FScale) and isEmptyProp(FDuration);
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirBiologicallyDerivedProductStorage.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductStorage.SetTemperature(value : TFhirDecimal);
begin
  FTemperature.free;
  FTemperature := value; {L1134}
end;

function TFhirBiologicallyDerivedProductStorage.GetTemperatureST : String;
begin
  if FTemperature = nil then
    result := ''
  else
    result := FTemperature.value;
end;

procedure TFhirBiologicallyDerivedProductStorage.SetTemperatureST(value : String);
begin
  if value <> '' then
  begin
    if FTemperature = nil then
      FTemperature := TFhirDecimal.create;
    FTemperature.value := value
  end
  else if FTemperature <> nil then
    FTemperature.value := '';
end;

procedure TFhirBiologicallyDerivedProductStorage.SetScale(value : TFhirEnum);
begin
  FScale.free;
  FScale := value;
end;

function TFhirBiologicallyDerivedProductStorage.GetScaleST : TFhirBiologicallyDerivedProductStorageScaleEnum;
begin
  if FScale = nil then
    result := TFhirBiologicallyDerivedProductStorageScaleEnum(0)
  else
    result := TFhirBiologicallyDerivedProductStorageScaleEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, FScale.value));
end;

procedure TFhirBiologicallyDerivedProductStorage.SetScaleST(value : TFhirBiologicallyDerivedProductStorageScaleEnum);
begin
  if ord(value) = 0 then
    ScaleElement := nil
  else
    ScaleElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum[value], CODES_TFhirBiologicallyDerivedProductStorageScaleEnum[value]);
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDuration(value : TFhirPeriod);
begin
  FDuration.free;
  FDuration := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProductStorage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('temperature');
  fields.add('scale');
  fields.add('duration');
end;

function TFhirBiologicallyDerivedProductStorage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FTemperature.sizeInBytes);
  inc(result, FScale.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductStorageListEnumerator }

constructor TFhirBiologicallyDerivedProductStorageListEnumerator.Create(list : TFhirBiologicallyDerivedProductStorageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductStorageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductStorage;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductStorageList }

procedure TFhirBiologicallyDerivedProductStorageList.AddItem(value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductStorage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductStorage');
  add(value);
end;

function TFhirBiologicallyDerivedProductStorageList.Append: TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductStorageList.GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductStorageListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductStorageList.Clone: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductStorageList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductStorage;
end;
function TFhirBiologicallyDerivedProductStorageList.IndexOf(value: TFhirBiologicallyDerivedProductStorage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductStorageList.Insert(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductStorageList.Item(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.Link: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductStorageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  FhirBiologicallyDerivedProductStorages[index] := value;
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProduct }

constructor TFhirBiologicallyDerivedProduct.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProduct.Destroy;
begin
  FIdentifierList.Free;
  FProductCategory.free;
  FProductCode.free;
  FStatus.free;
  FRequestList.Free;
  FQuantity.free;
  FParentList.Free;
  FCollection.free;
  FProcessingList.Free;
  FManipulation.free;
  FStorageList.Free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProduct.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBiologicallyDerivedProduct(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBiologicallyDerivedProduct(oSource).FIdentifierList);
  end;
  productCategoryElement := TFhirBiologicallyDerivedProduct(oSource).productCategoryElement.Clone;
  productCode := TFhirBiologicallyDerivedProduct(oSource).productCode.Clone;
  statusElement := TFhirBiologicallyDerivedProduct(oSource).statusElement.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList.Create;
    FRequestList.Assign(TFhirBiologicallyDerivedProduct(oSource).FRequestList);
  end;
  quantityElement := TFhirBiologicallyDerivedProduct(oSource).quantityElement.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList.Create;
    FParentList.Assign(TFhirBiologicallyDerivedProduct(oSource).FParentList);
  end;
  collection := TFhirBiologicallyDerivedProduct(oSource).collection.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
    FProcessingList.Assign(TFhirBiologicallyDerivedProduct(oSource).FProcessingList);
  end;
  manipulation := TFhirBiologicallyDerivedProduct(oSource).manipulation.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FStorageList = nil) then
  begin
    FStorageList.free;
    FStorageList := nil;
  end
  else
  begin
    if FStorageList = nil then
      FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
    FStorageList.Assign(TFhirBiologicallyDerivedProduct(oSource).FStorageList);
  end;
end;

function TFhirBiologicallyDerivedProduct.GetResourceType : TFhirResourceType;
begin
  result := frtBiologicallyDerivedProduct;
end;

procedure TFhirBiologicallyDerivedProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'productCategory') Then
     list.add(self.link, 'productCategory', FProductCategory.Link);
  if (child_name = 'productCode') Then
     list.add(self.link, 'productCode', FProductCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'manipulation') Then
     list.add(self.link, 'manipulation', FManipulation.Link);
  if (child_name = 'storage') Then
    list.addAll(self, 'storage', FStorageList);
end;

procedure TFhirBiologicallyDerivedProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'productCategory', 'code', false, TFhirEnum, FProductCategory.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'productCode', 'CodeableConcept', false, TFhirCodeableConcept, FProductCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', true, TFhirReference, FRequestList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', true, TFhirReference, FParentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'collection', 'BackboneElement', false, TFhirBiologicallyDerivedProductCollection, FCollection.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'processing', 'BackboneElement', true, TFhirBiologicallyDerivedProductProcessing, FProcessingList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manipulation', 'BackboneElement', false, TFhirBiologicallyDerivedProductManipulation, FManipulation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'storage', 'BackboneElement', true, TFhirBiologicallyDerivedProductStorage, FStorageList.Link)) {L1039};
end;

function TFhirBiologicallyDerivedProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'productCategory') then
  begin
    ProductCategoryElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum, CODES_TFhirBiologicallyDerivedProductCategoryEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'productCode') then
  begin
    ProductCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum, CODES_TFhirBiologicallyDerivedProductStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirBiologicallyDerivedProductCollection {L1199};
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirBiologicallyDerivedProductProcessing) {L1048};
    result := propValue;
  end
  else if (propName = 'manipulation') then
  begin
    Manipulation := propValue as TFhirBiologicallyDerivedProductManipulation {L1199};
    result := propValue;
  end
  else if (propName = 'storage') then
  begin
    StorageList.add(propValue as TFhirBiologicallyDerivedProductStorage) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirBiologicallyDerivedProductProcessing) {L1049}
  else if (propName = 'storage') then StorageList.insertItem(index, propValue as TFhirBiologicallyDerivedProductStorage) {L1049}
  else inherited;
end;

function TFhirBiologicallyDerivedProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'productCategory') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum[BiologicallyDerivedProductCategoryNull], CODES_TFhirBiologicallyDerivedProductCategoryEnum[BiologicallyDerivedProductCategoryNull])  {L1211}
  else if (propName = 'productCode') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum[BiologicallyDerivedProductStatusNull], CODES_TFhirBiologicallyDerivedProductStatusEnum[BiologicallyDerivedProductStatusNull])  {L1211}
  else if (propName = 'request') then result := RequestList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirInteger.create() {L1223}
  else if (propName = 'parent') then result := ParentList.new() {L1053}
  else if (propName = 'collection') then result := TFhirBiologicallyDerivedProductCollection.create() {L1203}
  else if (propName = 'processing') then result := ProcessingList.new() {L1053}
  else if (propName = 'manipulation') then result := TFhirBiologicallyDerivedProductManipulation.create() {L1203}
  else if (propName = 'storage') then result := StorageList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'productCategory') then result := 'code'
  else if (propName = 'productCode') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'collection') then result := 'BackboneElement'
  else if (propName = 'processing') then result := 'BackboneElement'
  else if (propName = 'manipulation') then result := 'BackboneElement'
  else if (propName = 'storage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'productCategory') then ProductCategoryElement := nil
  else if (propName = 'productCode') then ProductCodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {L1054}
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value) {L1054}
  else if (propName = 'manipulation') then ManipulationElement := nil
  else if (propName = 'storage') then deletePropertyValue('storage', StorageList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'productCategory') then ProductCategoryElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum, CODES_TFhirBiologicallyDerivedProductCategoryEnum, new) {L1210}
  else if (propName = 'productCode') then ProductCodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum, CODES_TFhirBiologicallyDerivedProductStatusEnum, new) {L1210}
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := asInteger(new) {L1222}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {L1055}
  else if (propName = 'collection') then CollectionElement := new as TFhirBiologicallyDerivedProductCollection {L1195}
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new) {L1055}
  else if (propName = 'manipulation') then ManipulationElement := new as TFhirBiologicallyDerivedProductManipulation {L1195}
  else if (propName = 'storage') then replacePropertyValue('storage', StorageList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'request') then RequestList.move(source, destination) {L1050}
  else if (propName = 'parent') then ParentList.move(source, destination) {L1050}
  else if (propName = 'processing') then ProcessingList.move(source, destination) {L1050}
  else if (propName = 'storage') then StorageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProduct.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct';
end;

function TFhirBiologicallyDerivedProduct.Link : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Link);
end;

function TFhirBiologicallyDerivedProduct.Clone : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Clone);
end;

function TFhirBiologicallyDerivedProduct.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProduct)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProduct(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(productCategoryElement, o.productCategoryElement, true) and 
      compareDeep(productCodeElement, o.productCodeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestList, o.requestList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parentList, o.parentList, true) and compareDeep(collectionElement, o.collectionElement, true) and 
      compareDeep(processingList, o.processingList, true) and compareDeep(manipulationElement, o.manipulationElement, true) and 
      compareDeep(storageList, o.storageList, true);
  end;
end;

function TFhirBiologicallyDerivedProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FProductCategory) and isEmptyProp(FProductCode) and isEmptyProp(FStatus) and isEmptyProp(FrequestList) and isEmptyProp(FQuantity) and isEmptyProp(FparentList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FManipulation) and isEmptyProp(FstorageList);
end;

function TFhirBiologicallyDerivedProduct.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBiologicallyDerivedProduct.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCategory(value : TFhirEnum);
begin
  FProductCategory.free;
  FProductCategory := value;
end;

function TFhirBiologicallyDerivedProduct.GetProductCategoryST : TFhirBiologicallyDerivedProductCategoryEnum;
begin
  if FProductCategory = nil then
    result := TFhirBiologicallyDerivedProductCategoryEnum(0)
  else
    result := TFhirBiologicallyDerivedProductCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductCategoryEnum, FProductCategory.value));
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCategoryST(value : TFhirBiologicallyDerivedProductCategoryEnum);
begin
  if ord(value) = 0 then
    ProductCategoryElement := nil
  else
    ProductCategoryElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum[value], CODES_TFhirBiologicallyDerivedProductCategoryEnum[value]);
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCode(value : TFhirCodeableConcept);
begin
  FProductCode.free;
  FProductCode := value; {L1134}
end;

procedure TFhirBiologicallyDerivedProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirBiologicallyDerivedProduct.GetStatusST : TFhirBiologicallyDerivedProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirBiologicallyDerivedProductStatusEnum(0)
  else
    result := TFhirBiologicallyDerivedProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductStatusEnum, FStatus.value));
end;

procedure TFhirBiologicallyDerivedProduct.SetStatusST(value : TFhirBiologicallyDerivedProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum[value], CODES_TFhirBiologicallyDerivedProductStatusEnum[value]);
end;

function TFhirBiologicallyDerivedProduct.GetRequestList : TFhirReferenceList;
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList.Create;
  result := FRequestList;
end;

function TFhirBiologicallyDerivedProduct.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirBiologicallyDerivedProduct.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirBiologicallyDerivedProduct.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

function TFhirBiologicallyDerivedProduct.GetParentList : TFhirReferenceList;
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList.Create;
  result := FParentList;
end;

function TFhirBiologicallyDerivedProduct.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetCollection(value : TFhirBiologicallyDerivedProductCollection);
begin
  FCollection.free;
  FCollection := value; {L1134}
end;

function TFhirBiologicallyDerivedProduct.GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
  result := FProcessingList;
end;

function TFhirBiologicallyDerivedProduct.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
begin
  FManipulation.free;
  FManipulation := value; {L1134}
end;

function TFhirBiologicallyDerivedProduct.GetStorageList : TFhirBiologicallyDerivedProductStorageList;
begin
  if FStorageList = nil then
    FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
  result := FStorageList;
end;

function TFhirBiologicallyDerivedProduct.GetHasStorageList : boolean;
begin
  result := (FStorageList <> nil) and (FStorageList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('productCategory');
  fields.add('productCode');
  fields.add('status');
  fields.add('request');
  fields.add('quantity');
  fields.add('parent');
  fields.add('collection');
  fields.add('processing');
  fields.add('manipulation');
  fields.add('storage');
end;

function TFhirBiologicallyDerivedProduct.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FProductCategory.sizeInBytes);
  inc(result, FProductCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FrequestList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FCollection.sizeInBytes);
  inc(result, FprocessingList.sizeInBytes);
  inc(result, FManipulation.sizeInBytes);
  inc(result, FstorageList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductListEnumerator }

constructor TFhirBiologicallyDerivedProductListEnumerator.Create(list : TFhirBiologicallyDerivedProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductListEnumerator.GetCurrent : TFhirBiologicallyDerivedProduct;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBiologicallyDerivedProductList }

procedure TFhirBiologicallyDerivedProductList.AddItem(value: TFhirBiologicallyDerivedProduct);
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProduct');
  add(value);
end;

function TFhirBiologicallyDerivedProductList.Append: TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductList.GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductList.Clone: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductList.GetItemN(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProduct;
end;
function TFhirBiologicallyDerivedProductList.IndexOf(value: TFhirBiologicallyDerivedProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductList.Insert(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductList.Item(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.Link: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  FhirBiologicallyDerivedProducts[index] := value;
end;

procedure TFhirBiologicallyDerivedProductList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
{ TFhirBodyStructure }

constructor TFhirBodyStructure.Create;
begin
  inherited;
end;

destructor TFhirBodyStructure.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FMorphology.free;
  FLocation.free;
  FLocationQualifierList.Free;
  FDescription.free;
  FImageList.Free;
  FPatient.free;
  inherited;
end;

procedure TFhirBodyStructure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBodyStructure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBodyStructure(oSource).FIdentifierList);
  end;
  activeElement := TFhirBodyStructure(oSource).activeElement.Clone;
  morphology := TFhirBodyStructure(oSource).morphology.Clone;
  location := TFhirBodyStructure(oSource).location.Clone;
  if (TFhirBodyStructure(oSource).FLocationQualifierList = nil) then
  begin
    FLocationQualifierList.free;
    FLocationQualifierList := nil;
  end
  else
  begin
    if FLocationQualifierList = nil then
      FLocationQualifierList := TFhirCodeableConceptList.Create;
    FLocationQualifierList.Assign(TFhirBodyStructure(oSource).FLocationQualifierList);
  end;
  descriptionElement := TFhirBodyStructure(oSource).descriptionElement.Clone;
  if (TFhirBodyStructure(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirBodyStructure(oSource).FImageList);
  end;
  patient := TFhirBodyStructure(oSource).patient.Clone;
end;

function TFhirBodyStructure.GetResourceType : TFhirResourceType;
begin
  result := frtBodyStructure;
end;

procedure TFhirBodyStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'morphology') Then
     list.add(self.link, 'morphology', FMorphology.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'locationQualifier') Then
    list.addAll(self, 'locationQualifier', FLocationQualifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
end;

procedure TFhirBodyStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'morphology', 'CodeableConcept', false, TFhirCodeableConcept, FMorphology.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableConcept', false, TFhirCodeableConcept, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'locationQualifier', 'CodeableConcept', true, TFhirCodeableConcept, FLocationQualifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
end;

function TFhirBodyStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'morphology') then
  begin
    Morphology := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'locationQualifier') then
  begin
    LocationQualifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment) {L1048};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBodyStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'locationQualifier') then LocationQualifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment) {L1049}
  else inherited;
end;

function TFhirBodyStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'morphology') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'location') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'locationQualifier') then result := LocationQualifierList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'image') then result := ImageList.new() {L1053}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBodyStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'morphology') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'CodeableConcept'
  else if (propName = 'locationQualifier') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'image') then result := 'Attachment'
  else if (propName = 'patient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBodyStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'morphology') then MorphologyElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'locationQualifier') then deletePropertyValue('locationQualifier', LocationQualifierList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {L1054}
  else if (propName = 'patient') then PatientElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBodyStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'morphology') then MorphologyElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'location') then LocationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'locationQualifier') then replacePropertyValue('locationQualifier', LocationQualifierList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {L1055}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBodyStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'locationQualifier') then LocationQualifierList.move(source, destination) {L1050}
  else if (propName = 'image') then ImageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBodyStructure.fhirType : string;
begin
  result := 'BodyStructure';
end;

function TFhirBodyStructure.Link : TFhirBodyStructure;
begin
  result := TFhirBodyStructure(inherited Link);
end;

function TFhirBodyStructure.Clone : TFhirBodyStructure;
begin
  result := TFhirBodyStructure(inherited Clone);
end;

function TFhirBodyStructure.equals(other : TObject) : boolean; 
var
  o : TFhirBodyStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBodyStructure)) then
    result := false
  else
  begin
    o := TFhirBodyStructure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(morphologyElement, o.morphologyElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(locationQualifierList, o.locationQualifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(imageList, o.imageList, true) and compareDeep(patientElement, o.patientElement, true);
  end;
end;

function TFhirBodyStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FMorphology) and isEmptyProp(FLocation) and isEmptyProp(FlocationQualifierList) and isEmptyProp(FDescription) and isEmptyProp(FimageList) and isEmptyProp(FPatient);
end;

function TFhirBodyStructure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBodyStructure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBodyStructure.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirBodyStructure.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirBodyStructure.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirBodyStructure.SetMorphology(value : TFhirCodeableConcept);
begin
  FMorphology.free;
  FMorphology := value; {L1134}
end;

procedure TFhirBodyStructure.SetLocation(value : TFhirCodeableConcept);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

function TFhirBodyStructure.GetLocationQualifierList : TFhirCodeableConceptList;
begin
  if FLocationQualifierList = nil then
    FLocationQualifierList := TFhirCodeableConceptList.Create;
  result := FLocationQualifierList;
end;

function TFhirBodyStructure.GetHasLocationQualifierList : boolean;
begin
  result := (FLocationQualifierList <> nil) and (FLocationQualifierList.count > 0);
end;

procedure TFhirBodyStructure.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirBodyStructure.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBodyStructure.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirBodyStructure.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

function TFhirBodyStructure.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

procedure TFhirBodyStructure.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirBodyStructure.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('morphology');
  fields.add('location');
  fields.add('locationQualifier');
  fields.add('description');
  fields.add('image');
  fields.add('patient');
end;

function TFhirBodyStructure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FMorphology.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FlocationQualifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
end;

{ TFhirBodyStructureListEnumerator }

constructor TFhirBodyStructureListEnumerator.Create(list : TFhirBodyStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBodyStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBodyStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBodyStructureListEnumerator.GetCurrent : TFhirBodyStructure;
begin
  Result := FList[FIndex];
end;

function TFhirBodyStructureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBodyStructureList }

procedure TFhirBodyStructureList.AddItem(value: TFhirBodyStructure);
begin
  assert(value.ClassName = 'TFhirBodyStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBodyStructure');
  add(value);
end;

function TFhirBodyStructureList.Append: TFhirBodyStructure;
begin
  result := TFhirBodyStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodyStructureList.ClearItems;
begin
  Clear;
end;

function TFhirBodyStructureList.GetEnumerator : TFhirBodyStructureListEnumerator;
begin
  result := TFhirBodyStructureListEnumerator.Create(self.link);
end;

function TFhirBodyStructureList.Clone: TFhirBodyStructureList;
begin
  result := TFhirBodyStructureList(inherited Clone);
end;

function TFhirBodyStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBodyStructureList.GetItemN(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure(ObjectByIndex[index]);
end;

function TFhirBodyStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirBodyStructure;
end;
function TFhirBodyStructureList.IndexOf(value: TFhirBodyStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBodyStructureList.Insert(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodyStructureList.InsertItem(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  Inherited Insert(index, value);
end;

function TFhirBodyStructureList.Item(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure(ObjectByIndex[index]);
end;

function TFhirBodyStructureList.Link: TFhirBodyStructureList;
begin
  result := TFhirBodyStructureList(inherited Link);
end;

procedure TFhirBodyStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBodyStructureList.SetItemByIndex(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  FhirBodyStructures[index] := value;
end;

procedure TFhirBodyStructureList.SetItemN(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FOutcomeList.Free;
  FProgressList.Free;
  FReference.free;
  FDetail.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlanActivity(oSource).FOutcomeList = nil) then
  begin
    FOutcomeList.free;
    FOutcomeList := nil;
  end
  else
  begin
    if FOutcomeList = nil then
      FOutcomeList := TFhirCodeableReferenceList.Create;
    FOutcomeList.Assign(TFhirCarePlanActivity(oSource).FOutcomeList);
  end;
  if (TFhirCarePlanActivity(oSource).FProgressList = nil) then
  begin
    FProgressList.free;
    FProgressList := nil;
  end
  else
  begin
    if FProgressList = nil then
      FProgressList := TFhirAnnotationList.Create;
    FProgressList.Assign(TFhirCarePlanActivity(oSource).FProgressList);
  end;
  reference := TFhirCarePlanActivity(oSource).reference.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcome') Then
    list.addAll(self, 'outcome', FOutcomeList);
  if (child_name = 'progress') Then
    list.addAll(self, 'progress', FProgressList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableReference', true, TFhirCodeableReference, FOutcomeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'progress', 'Annotation', true, TFhirAnnotation, FProgressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', false, TFhirCarePlanActivityDetail, FDetail.Link)); {L1172}
end;

function TFhirCarePlanActivity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcome') then
  begin
    OutcomeList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'progress') then
  begin
    ProgressList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirCarePlanActivityDetail {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'outcome') then OutcomeList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'progress') then ProgressList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCarePlanActivity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcome') then result := OutcomeList.new() {L1053}
  else if (propName = 'progress') then result := ProgressList.new() {L1053}
  else if (propName = 'reference') then result := TFhirReference.create() {L1203}
  else if (propName = 'detail') then result := TFhirCarePlanActivityDetail.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcome') then result := 'CodeableReference'
  else if (propName = 'progress') then result := 'Annotation'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcome') then deletePropertyValue('outcome', OutcomeList, value) {L1054}
  else if (propName = 'progress') then deletePropertyValue('progress', ProgressList, value) {L1054}
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcome') then replacePropertyValue('outcome', OutcomeList, existing, new) {L1055}
  else if (propName = 'progress') then replacePropertyValue('progress', ProgressList, existing, new) {L1055}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference {L1195}
  else if (propName = 'detail') then DetailElement := new as TFhirCarePlanActivityDetail {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'outcome') then OutcomeList.move(source, destination) {L1050}
  else if (propName = 'progress') then ProgressList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivity.fhirType : string;
begin
  result := 'CarePlan.activity';
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

function TFhirCarePlanActivity.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlanActivity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivity)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivity(other);
    result := compareDeep(outcomeList, o.outcomeList, true) and compareDeep(progressList, o.progressList, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirCarePlanActivity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FoutcomeList) and isEmptyProp(FprogressList) and isEmptyProp(FReference) and isEmptyProp(FDetail);
end;

function TFhirCarePlanActivity.GetOutcomeList : TFhirCodeableReferenceList;
begin
  if FOutcomeList = nil then
    FOutcomeList := TFhirCodeableReferenceList.Create;
  result := FOutcomeList;
end;

function TFhirCarePlanActivity.GetHasOutcomeList : boolean;
begin
  result := (FOutcomeList <> nil) and (FOutcomeList.count > 0);
end;

function TFhirCarePlanActivity.GetProgressList : TFhirAnnotationList;
begin
  if FProgressList = nil then
    FProgressList := TFhirAnnotationList.Create;
  result := FProgressList;
end;

function TFhirCarePlanActivity.GetHasProgressList : boolean;
begin
  result := (FProgressList <> nil) and (FProgressList.count > 0);
end;

procedure TFhirCarePlanActivity.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value; {L1134}
end;

procedure TFhirCarePlanActivity.SetDetail(value : TFhirCarePlanActivityDetail);
begin
  FDetail.free;
  FDetail := value; {L1134}
end;

procedure TFhirCarePlanActivity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outcome');
  fields.add('progress');
  fields.add('reference');
  fields.add('detail');
end;

function TFhirCarePlanActivity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FoutcomeList.sizeInBytes);
  inc(result, FprogressList.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirCarePlanActivityListEnumerator }

constructor TFhirCarePlanActivityListEnumerator.Create(list : TFhirCarePlanActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityListEnumerator.GetCurrent : TFhirCarePlanActivity;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityList }

procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;

function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.GetEnumerator : TFhirCarePlanActivityListEnumerator;
begin
  result := TFhirCarePlanActivityListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivity;
end;
function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivityDetail }

constructor TFhirCarePlanActivityDetail.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivityDetail.Destroy;
begin
  FKind.free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FCode.free;
  FReasonList.Free;
  FGoalList.Free;
  FStatus.free;
  FStatusReason.free;
  FDoNotPerform.free;
  FScheduled.free;
  FLocation.free;
  FReported.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDescription.free;
  inherited;
end;

procedure TFhirCarePlanActivityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirCarePlanActivityDetail(oSource).kindElement.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCarePlanActivityDetail(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCarePlanActivityDetail(oSource).FInstantiatesUriList);
  end;
  code := TFhirCarePlanActivityDetail(oSource).code.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirCarePlanActivityDetail(oSource).FGoalList);
  end;
  statusElement := TFhirCarePlanActivityDetail(oSource).statusElement.Clone;
  statusReason := TFhirCarePlanActivityDetail(oSource).statusReason.Clone;
  doNotPerformElement := TFhirCarePlanActivityDetail(oSource).doNotPerformElement.Clone;
  scheduled := TFhirCarePlanActivityDetail(oSource).scheduled.Clone;
  location := TFhirCarePlanActivityDetail(oSource).location.Clone;
  reported := TFhirCarePlanActivityDetail(oSource).reported.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirCarePlanActivityDetail(oSource).FPerformerList);
  end;
  product := TFhirCarePlanActivityDetail(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivityDetail(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivityDetail(oSource).quantity.Clone;
  descriptionElement := TFhirCarePlanActivityDetail(oSource).descriptionElement.Clone;
end;

procedure TFhirCarePlanActivityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reported[x]') or (child_name = 'reported') Then
     list.add(self.link, 'reported[x]', FReported.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'dailyAmount') Then
     list.add(self.link, 'dailyAmount', FDailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirCarePlanActivityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'Timing|Period|string', false, TFhirDataType, FScheduled.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', false, TFhirCodeableReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reported[x]', 'boolean|Reference', false, TFhirDataType, FReported.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProduct.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', false, TFhirQuantity, FDailyAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
end;

function TFhirCarePlanActivityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirCarePlanActivityKindEnum, CODES_TFhirCarePlanActivityKindEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then
  begin
    Scheduled := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then
  begin
    Reported := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then
  begin
    Product := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'dailyAmount') then
  begin
    DailyAmount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirCarePlanActivityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityKindEnum[CarePlanActivityKindNull], CODES_TFhirCarePlanActivityKindEnum[CarePlanActivityKindNull])  {L1211}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'goal') then result := GoalList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[CarePlanActivityStatusNull], CODES_TFhirCarePlanActivityStatusEnum[CarePlanActivityStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Scheduled') {L1191}
  else if (propName = 'location') then result := TFhirCodeableReference.create() {L1203}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then raise EFHIRException.create('Cannot make property Reported') {L1191}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Product') {L1191}
  else if (propName = 'dailyAmount') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'scheduled[x]') then result := 'Timing|Period|string'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'reported[x]') then result := 'boolean|Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dailyAmount') then result := 'Quantity'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := nil {L1189}
  else if (propName = 'location') then LocationElement := nil
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := nil {L1189}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := nil {L1189}
  else if (propName = 'dailyAmount') then DailyAmountElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirCarePlanActivityKindEnum, CODES_TFhirCarePlanActivityKindEnum, new) {L1210}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := new as TFhirDataType {L1190}
  else if (propName = 'location') then LocationElement := new as TFhirCodeableReference {L1195}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := new as TFhirDataType {L1190}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := new as TFhirDataType {L1190}
  else if (propName = 'dailyAmount') then DailyAmountElement := new as TFhirQuantity {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'goal') then GoalList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivityDetail.fhirType : string;
begin
  result := 'CarePlan.activity.detail';
end;

function TFhirCarePlanActivityDetail.Link : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Link);
end;

function TFhirCarePlanActivityDetail.Clone : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Clone);
end;

function TFhirCarePlanActivityDetail.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlanActivityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivityDetail)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivityDetail(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(goalList, o.goalList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(scheduledElement, o.scheduledElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reportedElement, o.reportedElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(productElement, o.productElement, true) and 
      compareDeep(dailyAmountElement, o.dailyAmountElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirCarePlanActivityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FCode) and isEmptyProp(FreasonList) and isEmptyProp(FgoalList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FDoNotPerform) and isEmptyProp(FScheduled) and isEmptyProp(FLocation) and isEmptyProp(FReported) and isEmptyProp(FperformerList) and isEmptyProp(FProduct) and isEmptyProp(FDailyAmount) and isEmptyProp(FQuantity) and isEmptyProp(FDescription);
end;

procedure TFhirCarePlanActivityDetail.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirCarePlanActivityDetail.GetKindST : TFhirCarePlanActivityKindEnum;
begin
  if FKind = nil then
    result := TFhirCarePlanActivityKindEnum(0)
  else
    result := TFhirCarePlanActivityKindEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityKindEnum, FKind.value));
end;

procedure TFhirCarePlanActivityDetail.SetKindST(value : TFhirCarePlanActivityKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityKindEnum[value], CODES_TFhirCarePlanActivityKindEnum[value]);
end;

function TFhirCarePlanActivityDetail.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCarePlanActivityDetail.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCarePlanActivityDetail.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCarePlanActivityDetail.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirCarePlanActivityDetail.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirCarePlanActivityDetail.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirCarePlanActivityDetail.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirCarePlanActivityDetail.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCarePlanActivityDetail.GetStatusST : TFhirCarePlanActivityStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatusEnum(0)
  else
    result := TFhirCarePlanActivityStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityStatusEnum, FStatus.value));
end;

procedure TFhirCarePlanActivityDetail.SetStatusST(value : TFhirCarePlanActivityStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[value], CODES_TFhirCarePlanActivityStatusEnum[value]);
end;

procedure TFhirCarePlanActivityDetail.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value; {L1134}
end;

function TFhirCarePlanActivityDetail.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirCarePlanActivityDetail.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirCarePlanActivityDetail.SetScheduled(value : TFhirDataType);
begin
  FScheduled.free;
  FScheduled := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetLocation(value : TFhirCodeableReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetReported(value : TFhirDataType);
begin
  FReported.free;
  FReported := value; {L1134}
end;

function TFhirCarePlanActivityDetail.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirCarePlanActivityDetail.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirCarePlanActivityDetail.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirCarePlanActivityDetail.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCarePlanActivityDetail.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCarePlanActivityDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kind');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('code');
  fields.add('reason');
  fields.add('goal');
  fields.add('status');
  fields.add('statusReason');
  fields.add('doNotPerform');
  fields.add('scheduled[x]');
  fields.add('location');
  fields.add('reported[x]');
  fields.add('performer');
  fields.add('product[x]');
  fields.add('dailyAmount');
  fields.add('quantity');
  fields.add('description');
end;

function TFhirCarePlanActivityDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FScheduled.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FReported.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FDailyAmount.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailListEnumerator }

constructor TFhirCarePlanActivityDetailListEnumerator.Create(list : TFhirCarePlanActivityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityDetailListEnumerator.GetCurrent : TFhirCarePlanActivityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailList }

procedure TFhirCarePlanActivityDetailList.AddItem(value: TFhirCarePlanActivityDetail);
begin
  assert(value.ClassName = 'TFhirCarePlanActivityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivityDetail');
  add(value);
end;

function TFhirCarePlanActivityDetailList.Append: TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityDetailList.GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
begin
  result := TFhirCarePlanActivityDetailListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityDetailList.Clone: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Clone);
end;

function TFhirCarePlanActivityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityDetailList.GetItemN(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivityDetail;
end;
function TFhirCarePlanActivityDetailList.IndexOf(value: TFhirCarePlanActivityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityDetailList.Insert(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.InsertItem(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityDetailList.Item(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.Link: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Link);
end;

procedure TFhirCarePlanActivityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityDetailList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  FhirCarePlanActivityDetails[index] := value;
end;

procedure TFhirCarePlanActivityDetailList.SetItemN(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlan }

constructor TFhirCarePlan.Create;
begin
  inherited;
end;

destructor TFhirCarePlan.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FPartOfList.Free;
  FStatus.free;
  FIntent.free;
  FCategoryList.Free;
  FTitle.free;
  FDescription.free;
  FSubject.free;
  FEncounter.free;
  FPeriod.free;
  FCreated.free;
  FAuthor.free;
  FContributorList.Free;
  FCareTeamList.Free;
  FAddressesList.Free;
  FSupportingInfoList.Free;
  FGoalList.Free;
  FActivityList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCarePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCarePlan(oSource).FIdentifierList);
  end;
  if (TFhirCarePlan(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCarePlan(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCarePlan(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCarePlan(oSource).FInstantiatesUriList);
  end;
  if (TFhirCarePlan(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCarePlan(oSource).FBasedOnList);
  end;
  if (TFhirCarePlan(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirCarePlan(oSource).FReplacesList);
  end;
  if (TFhirCarePlan(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirCarePlan(oSource).FPartOfList);
  end;
  statusElement := TFhirCarePlan(oSource).statusElement.Clone;
  intentElement := TFhirCarePlan(oSource).intentElement.Clone;
  if (TFhirCarePlan(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCarePlan(oSource).FCategoryList);
  end;
  titleElement := TFhirCarePlan(oSource).titleElement.Clone;
  descriptionElement := TFhirCarePlan(oSource).descriptionElement.Clone;
  subject := TFhirCarePlan(oSource).subject.Clone;
  encounter := TFhirCarePlan(oSource).encounter.Clone;
  period := TFhirCarePlan(oSource).period.Clone;
  createdElement := TFhirCarePlan(oSource).createdElement.Clone;
  author := TFhirCarePlan(oSource).author.Clone;
  if (TFhirCarePlan(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirReferenceList.Create;
    FContributorList.Assign(TFhirCarePlan(oSource).FContributorList);
  end;
  if (TFhirCarePlan(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirReferenceList.Create;
    FCareTeamList.Assign(TFhirCarePlan(oSource).FCareTeamList);
  end;
  if (TFhirCarePlan(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirCodeableReferenceList.Create;
    FAddressesList.Assign(TFhirCarePlan(oSource).FAddressesList);
  end;
  if (TFhirCarePlan(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirCarePlan(oSource).FSupportingInfoList);
  end;
  if (TFhirCarePlan(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirCarePlan(oSource).FGoalList);
  end;
  if (TFhirCarePlan(oSource).FActivityList = nil) then
  begin
    FActivityList.free;
    FActivityList := nil;
  end
  else
  begin
    if FActivityList = nil then
      FActivityList := TFhirCarePlanActivityList.Create;
    FActivityList.Assign(TFhirCarePlan(oSource).FActivityList);
  end;
  if (TFhirCarePlan(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCarePlan(oSource).FNoteList);
  end;
end;

function TFhirCarePlan.GetResourceType : TFhirResourceType;
begin
  result := frtCarePlan;
end;

procedure TFhirCarePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'activity') Then
    list.addAll(self, 'activity', FActivityList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCarePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contributor', 'Reference', true, TFhirReference, FContributorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'careTeam', 'Reference', true, TFhirReference, FCareTeamList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'addresses', 'CodeableReference', true, TFhirCodeableReference, FAddressesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'activity', 'BackboneElement', true, TFhirCarePlanActivity, FActivityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirCarePlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    ActivityList.add(propValue as TFhirCarePlanActivity) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'activity') then ActivityList.insertItem(index, propValue as TFhirCarePlanActivity) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCarePlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'replaces') then result := ReplacesList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull])  {L1211}
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanIntentEnum[CarePlanIntentNull], CODES_TFhirCarePlanIntentEnum[CarePlanIntentNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'title') then result := TFhirString.create() {L1223}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else if (propName = 'contributor') then result := ContributorList.new() {L1053}
  else if (propName = 'careTeam') then result := CareTeamList.new() {L1053}
  else if (propName = 'addresses') then result := AddressesList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'goal') then result := GoalList.new() {L1053}
  else if (propName = 'activity') then result := ActivityList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'contributor') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'Reference'
  else if (propName = 'addresses') then result := 'CodeableReference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'activity') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {L1054}
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {L1054}
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {L1054}
  else if (propName = 'activity') then deletePropertyValue('activity', ActivityList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new) {L1210}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'title') then TitleElement := asString(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {L1055}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {L1055}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {L1055}
  else if (propName = 'activity') then replacePropertyValue('activity', ActivityList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'replaces') then ReplacesList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'contributor') then ContributorList.move(source, destination) {L1050}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination) {L1050}
  else if (propName = 'addresses') then AddressesList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'goal') then GoalList.move(source, destination) {L1050}
  else if (propName = 'activity') then ActivityList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlan.fhirType : string;
begin
  result := 'CarePlan';
end;

function TFhirCarePlan.Link : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Link);
end;

function TFhirCarePlan.Clone : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Clone);
end;

function TFhirCarePlan.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlan)) then
    result := false
  else
  begin
    o := TFhirCarePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(contributorList, o.contributorList, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(addressesList, o.addressesList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(goalList, o.goalList, true) and compareDeep(activityList, o.activityList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCarePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FAuthor) and isEmptyProp(FcontributorList) and isEmptyProp(FcareTeamList) and isEmptyProp(FaddressesList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FgoalList) and isEmptyProp(FactivityList) and isEmptyProp(FnoteList);
end;

function TFhirCarePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCarePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCarePlan.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCarePlan.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCarePlan.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCarePlan.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirCarePlan.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCarePlan.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCarePlan.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirCarePlan.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

function TFhirCarePlan.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirCarePlan.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirCarePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCarePlan.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirCarePlan.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirCarePlan.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirCarePlan.GetIntentST : TFhirCarePlanIntentEnum;
begin
  if FIntent = nil then
    result := TFhirCarePlanIntentEnum(0)
  else
    result := TFhirCarePlanIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanIntentEnum, FIntent.value));
end;

procedure TFhirCarePlan.SetIntentST(value : TFhirCarePlanIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanIntentEnum[value], CODES_TFhirCarePlanIntentEnum[value]);
end;

function TFhirCarePlan.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCarePlan.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCarePlan.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirCarePlan.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCarePlan.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCarePlan.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirCarePlan.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCarePlan.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCarePlan.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirCarePlan.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirCarePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirCarePlan.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirCarePlan.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCarePlan.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCarePlan.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

function TFhirCarePlan.GetContributorList : TFhirReferenceList;
begin
  if FContributorList = nil then
    FContributorList := TFhirReferenceList.Create;
  result := FContributorList;
end;

function TFhirCarePlan.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

function TFhirCarePlan.GetCareTeamList : TFhirReferenceList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirReferenceList.Create;
  result := FCareTeamList;
end;

function TFhirCarePlan.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirCarePlan.GetAddressesList : TFhirCodeableReferenceList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirCodeableReferenceList.Create;
  result := FAddressesList;
end;

function TFhirCarePlan.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirCarePlan.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirCarePlan.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirCarePlan.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirCarePlan.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirCarePlan.GetActivityList : TFhirCarePlanActivityList;
begin
  if FActivityList = nil then
    FActivityList := TFhirCarePlanActivityList.Create;
  result := FActivityList;
end;

function TFhirCarePlan.GetHasActivityList : boolean;
begin
  result := (FActivityList <> nil) and (FActivityList.count > 0);
end;

function TFhirCarePlan.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCarePlan.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCarePlan.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('partOf');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('title');
  fields.add('description');
  fields.add('subject');
  fields.add('encounter');
  fields.add('period');
  fields.add('created');
  fields.add('author');
  fields.add('contributor');
  fields.add('careTeam');
  fields.add('addresses');
  fields.add('supportingInfo');
  fields.add('goal');
  fields.add('activity');
  fields.add('note');
end;

function TFhirCarePlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FactivityList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCarePlanListEnumerator }

constructor TFhirCarePlanListEnumerator.Create(list : TFhirCarePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanListEnumerator.GetCurrent : TFhirCarePlan;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanList }

procedure TFhirCarePlanList.AddItem(value: TFhirCarePlan);
begin
  assert(value.ClassName = 'TFhirCarePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlan');
  add(value);
end;

function TFhirCarePlanList.Append: TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanList.GetEnumerator : TFhirCarePlanListEnumerator;
begin
  result := TFhirCarePlanListEnumerator.Create(self.link);
end;

function TFhirCarePlanList.Clone: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Clone);
end;

function TFhirCarePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanList.GetItemN(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlan;
end;
function TFhirCarePlanList.IndexOf(value: TFhirCarePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanList.Insert(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.InsertItem(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  Inherited Insert(index, value);
end;

function TFhirCarePlanList.Item(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.Link: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Link);
end;

procedure TFhirCarePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanList.SetItemByIndex(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  FhirCarePlans[index] := value;
end;

procedure TFhirCarePlanList.SetItemN(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
{ TFhirCareTeamParticipant }

constructor TFhirCareTeamParticipant.Create;
begin
  inherited;
end;

destructor TFhirCareTeamParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  FOnBehalfOf.free;
  FCoverage.free;
  inherited;
end;

procedure TFhirCareTeamParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirCareTeamParticipant(oSource).role.Clone;
  member := TFhirCareTeamParticipant(oSource).member.Clone;
  onBehalfOf := TFhirCareTeamParticipant(oSource).onBehalfOf.Clone;
  coverage := TFhirCareTeamParticipant(oSource).coverage.Clone;
end;

procedure TFhirCareTeamParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'member') Then
     list.add(self.link, 'member', FMember.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'coverage[x]') or (child_name = 'coverage') Then
     list.add(self.link, 'coverage[x]', FCoverage.Link);
end;

procedure TFhirCareTeamParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'member', 'Reference', false, TFhirReference, FMember.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage[x]', 'Period|Timing', false, TFhirDataType, FCoverage.Link)); {L1172}
end;

function TFhirCareTeamParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    Member := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'coverage', ['Period', 'Timing'])) then
  begin
    Coverage := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCareTeamParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCareTeamParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'member') then result := TFhirReference.create() {L1203}
  else if (propName = 'onBehalfOf') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'coverage', ['Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Coverage') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeamParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'member') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'coverage[x]') then result := 'Period|Timing'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeamParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'member') then MemberElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (isMatchingName(propName, 'coverage', ['Period', 'Timing'])) then CoverageElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeamParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'member') then MemberElement := new as TFhirReference {L1195}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'coverage', ['Period', 'Timing'])) then CoverageElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeamParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeamParticipant.fhirType : string;
begin
  result := 'CareTeam.participant';
end;

function TFhirCareTeamParticipant.Link : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Link);
end;

function TFhirCareTeamParticipant.Clone : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Clone);
end;

function TFhirCareTeamParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirCareTeamParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeamParticipant)) then
    result := false
  else
  begin
    o := TFhirCareTeamParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(memberElement, o.memberElement, true) and 
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and compareDeep(coverageElement, o.coverageElement, true);
  end;
end;

function TFhirCareTeamParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FMember) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FCoverage);
end;

procedure TFhirCareTeamParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirCareTeamParticipant.SetMember(value : TFhirReference);
begin
  FMember.free;
  FMember := value; {L1134}
end;

procedure TFhirCareTeamParticipant.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value; {L1134}
end;

procedure TFhirCareTeamParticipant.SetCoverage(value : TFhirDataType);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirCareTeamParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('member');
  fields.add('onBehalfOf');
  fields.add('coverage[x]');
end;

function TFhirCareTeamParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FMember.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
end;

{ TFhirCareTeamParticipantListEnumerator }

constructor TFhirCareTeamParticipantListEnumerator.Create(list : TFhirCareTeamParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamParticipantListEnumerator.GetCurrent : TFhirCareTeamParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCareTeamParticipantList }

procedure TFhirCareTeamParticipantList.AddItem(value: TFhirCareTeamParticipant);
begin
  assert(value.ClassName = 'TFhirCareTeamParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeamParticipant');
  add(value);
end;

function TFhirCareTeamParticipantList.Append: TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamParticipantList.GetEnumerator : TFhirCareTeamParticipantListEnumerator;
begin
  result := TFhirCareTeamParticipantListEnumerator.Create(self.link);
end;

function TFhirCareTeamParticipantList.Clone: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Clone);
end;

function TFhirCareTeamParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamParticipantList.GetItemN(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeamParticipant;
end;
function TFhirCareTeamParticipantList.IndexOf(value: TFhirCareTeamParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamParticipantList.Insert(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.InsertItem(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  Inherited Insert(index, value);
end;

function TFhirCareTeamParticipantList.Item(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.Link: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Link);
end;

procedure TFhirCareTeamParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamParticipantList.SetItemByIndex(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  FhirCareTeamParticipants[index] := value;
end;

procedure TFhirCareTeamParticipantList.SetItemN(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCareTeam }

constructor TFhirCareTeam.Create;
begin
  inherited;
end;

destructor TFhirCareTeam.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FName.free;
  FSubject.free;
  FPeriod.free;
  FParticipantList.Free;
  FReasonList.Free;
  FManagingOrganizationList.Free;
  FTelecomList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCareTeam(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCareTeam(oSource).FIdentifierList);
  end;
  statusElement := TFhirCareTeam(oSource).statusElement.Clone;
  if (TFhirCareTeam(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCareTeam(oSource).FCategoryList);
  end;
  nameElement := TFhirCareTeam(oSource).nameElement.Clone;
  subject := TFhirCareTeam(oSource).subject.Clone;
  period := TFhirCareTeam(oSource).period.Clone;
  if (TFhirCareTeam(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirCareTeamParticipantList.Create;
    FParticipantList.Assign(TFhirCareTeam(oSource).FParticipantList);
  end;
  if (TFhirCareTeam(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirCareTeam(oSource).FReasonList);
  end;
  if (TFhirCareTeam(oSource).FManagingOrganizationList = nil) then
  begin
    FManagingOrganizationList.free;
    FManagingOrganizationList := nil;
  end
  else
  begin
    if FManagingOrganizationList = nil then
      FManagingOrganizationList := TFhirReferenceList.Create;
    FManagingOrganizationList.Assign(TFhirCareTeam(oSource).FManagingOrganizationList);
  end;
  if (TFhirCareTeam(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirCareTeam(oSource).FTelecomList);
  end;
  if (TFhirCareTeam(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCareTeam(oSource).FNoteList);
  end;
end;

function TFhirCareTeam.GetResourceType : TFhirResourceType;
begin
  result := frtCareTeam;
end;

procedure TFhirCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'managingOrganization') Then
    list.addAll(self, 'managingOrganization', FManagingOrganizationList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirCareTeamParticipant, FParticipantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', true, TFhirReference, FManagingOrganizationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirCareTeamParticipant) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganizationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirCareTeamParticipant) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'managingOrganization') then ManagingOrganizationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCareTeamStatusEnum[CareTeamStatusNull], CODES_TFhirCareTeamStatusEnum[CareTeamStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'participant') then result := ParticipantList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'managingOrganization') then result := ManagingOrganizationList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'managingOrganization') then deletePropertyValue('managingOrganization', ManagingOrganizationList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'managingOrganization') then replacePropertyValue('managingOrganization', ManagingOrganizationList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'participant') then ParticipantList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'managingOrganization') then ManagingOrganizationList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeam.fhirType : string;
begin
  result := 'CareTeam';
end;

function TFhirCareTeam.Link : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Link);
end;

function TFhirCareTeam.Clone : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Clone);
end;

function TFhirCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeam)) then
    result := false
  else
  begin
    o := TFhirCareTeam(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(managingOrganizationList, o.managingOrganizationList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FName) and isEmptyProp(FSubject) and isEmptyProp(FPeriod) and isEmptyProp(FparticipantList) and isEmptyProp(FreasonList) and isEmptyProp(FmanagingOrganizationList) and isEmptyProp(FtelecomList) and isEmptyProp(FnoteList);
end;

function TFhirCareTeam.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCareTeam.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCareTeam.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCareTeam.GetStatusST : TFhirCareTeamStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCareTeamStatusEnum(0)
  else
    result := TFhirCareTeamStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCareTeamStatusEnum, FStatus.value));
end;

procedure TFhirCareTeam.SetStatusST(value : TFhirCareTeamStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCareTeamStatusEnum[value], CODES_TFhirCareTeamStatusEnum[value]);
end;

function TFhirCareTeam.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCareTeam.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCareTeam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCareTeam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCareTeam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCareTeam.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirCareTeam.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirCareTeam.GetParticipantList : TFhirCareTeamParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirCareTeamParticipantList.Create;
  result := FParticipantList;
end;

function TFhirCareTeam.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirCareTeam.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirCareTeam.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirCareTeam.GetManagingOrganizationList : TFhirReferenceList;
begin
  if FManagingOrganizationList = nil then
    FManagingOrganizationList := TFhirReferenceList.Create;
  result := FManagingOrganizationList;
end;

function TFhirCareTeam.GetHasManagingOrganizationList : boolean;
begin
  result := (FManagingOrganizationList <> nil) and (FManagingOrganizationList.count > 0);
end;

function TFhirCareTeam.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirCareTeam.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirCareTeam.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCareTeam.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('name');
  fields.add('subject');
  fields.add('period');
  fields.add('participant');
  fields.add('reason');
  fields.add('managingOrganization');
  fields.add('telecom');
  fields.add('note');
end;

function TFhirCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FmanagingOrganizationList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCareTeamListEnumerator }

constructor TFhirCareTeamListEnumerator.Create(list : TFhirCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamListEnumerator.GetCurrent : TFhirCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCareTeamList }

procedure TFhirCareTeamList.AddItem(value: TFhirCareTeam);
begin
  assert(value.ClassName = 'TFhirCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeam');
  add(value);
end;

function TFhirCareTeamList.Append: TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamList.GetEnumerator : TFhirCareTeamListEnumerator;
begin
  result := TFhirCareTeamListEnumerator.Create(self.link);
end;

function TFhirCareTeamList.Clone: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Clone);
end;

function TFhirCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamList.GetItemN(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeam;
end;
function TFhirCareTeamList.IndexOf(value: TFhirCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamList.Insert(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.InsertItem(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  Inherited Insert(index, value);
end;

function TFhirCareTeamList.Item(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.Link: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Link);
end;

procedure TFhirCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamList.SetItemByIndex(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  FhirCareTeams[index] := value;
end;

procedure TFhirCareTeamList.SetItemN(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
{ TFhirClinicalImpressionFinding }

constructor TFhirClinicalImpressionFinding.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionFinding.Destroy;
begin
  FItem.free;
  FBasis.free;
  inherited;
end;

procedure TFhirClinicalImpressionFinding.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalImpressionFinding(oSource).item.Clone;
  basisElement := TFhirClinicalImpressionFinding(oSource).basisElement.Clone;
end;

procedure TFhirClinicalImpressionFinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'basis') Then
     list.add(self.link, 'basis', FBasis.Link);
end;

procedure TFhirClinicalImpressionFinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'basis', 'string', false, TFhirString, FBasis.Link)); {L1172}
end;

function TFhirClinicalImpressionFinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionFinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalImpressionFinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'basis') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionFinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'basis') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionFinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'basis') then BasisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionFinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'basis') then BasisElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionFinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionFinding.fhirType : string;
begin
  result := 'ClinicalImpression.finding';
end;

function TFhirClinicalImpressionFinding.Link : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Link);
end;

function TFhirClinicalImpressionFinding.Clone : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Clone);
end;

function TFhirClinicalImpressionFinding.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalImpressionFinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionFinding)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionFinding(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(basisElement, o.basisElement, true);
  end;
end;

function TFhirClinicalImpressionFinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FBasis);
end;

procedure TFhirClinicalImpressionFinding.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirClinicalImpressionFinding.SetBasis(value : TFhirString);
begin
  FBasis.free;
  FBasis := value; {L1134}
end;

function TFhirClinicalImpressionFinding.GetBasisST : String;
begin
  if FBasis = nil then
    result := ''
  else
    result := FBasis.value;
end;

procedure TFhirClinicalImpressionFinding.SetBasisST(value : String);
begin
  if value <> '' then
  begin
    if FBasis = nil then
      FBasis := TFhirString.create;
    FBasis.value := value
  end
  else if FBasis <> nil then
    FBasis.value := '';
end;

procedure TFhirClinicalImpressionFinding.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('basis');
end;

function TFhirClinicalImpressionFinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FBasis.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingListEnumerator }

constructor TFhirClinicalImpressionFindingListEnumerator.Create(list : TFhirClinicalImpressionFindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionFindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionFindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionFindingListEnumerator.GetCurrent : TFhirClinicalImpressionFinding;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionFindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingList }

procedure TFhirClinicalImpressionFindingList.AddItem(value: TFhirClinicalImpressionFinding);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionFinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionFinding');
  add(value);
end;

function TFhirClinicalImpressionFindingList.Append: TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionFindingList.GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
begin
  result := TFhirClinicalImpressionFindingListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionFindingList.Clone: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Clone);
end;

function TFhirClinicalImpressionFindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionFindingList.GetItemN(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionFinding;
end;
function TFhirClinicalImpressionFindingList.IndexOf(value: TFhirClinicalImpressionFinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionFindingList.Insert(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.InsertItem(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionFindingList.Item(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.Link: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Link);
end;

procedure TFhirClinicalImpressionFindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionFindingList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  FhirClinicalImpressionFindings[index] := value;
end;

procedure TFhirClinicalImpressionFindingList.SetItemN(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpression }

constructor TFhirClinicalImpression.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpression.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusReason.free;
  FDescription.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FDate.free;
  FPerformer.free;
  FPrevious.free;
  FProblemList.Free;
  FProtocolList.Free;
  FSummary.free;
  FFindingList.Free;
  FPrognosisCodeableConceptList.Free;
  FPrognosisReferenceList.Free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirClinicalImpression.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalImpression(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClinicalImpression(oSource).FIdentifierList);
  end;
  statusElement := TFhirClinicalImpression(oSource).statusElement.Clone;
  statusReason := TFhirClinicalImpression(oSource).statusReason.Clone;
  descriptionElement := TFhirClinicalImpression(oSource).descriptionElement.Clone;
  subject := TFhirClinicalImpression(oSource).subject.Clone;
  encounter := TFhirClinicalImpression(oSource).encounter.Clone;
  effective := TFhirClinicalImpression(oSource).effective.Clone;
  dateElement := TFhirClinicalImpression(oSource).dateElement.Clone;
  performer := TFhirClinicalImpression(oSource).performer.Clone;
  previous := TFhirClinicalImpression(oSource).previous.Clone;
  if (TFhirClinicalImpression(oSource).FProblemList = nil) then
  begin
    FProblemList.free;
    FProblemList := nil;
  end
  else
  begin
    if FProblemList = nil then
      FProblemList := TFhirReferenceList.Create;
    FProblemList.Assign(TFhirClinicalImpression(oSource).FProblemList);
  end;
  if (TFhirClinicalImpression(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirUriList.Create;
    FProtocolList.Assign(TFhirClinicalImpression(oSource).FProtocolList);
  end;
  summaryElement := TFhirClinicalImpression(oSource).summaryElement.Clone;
  if (TFhirClinicalImpression(oSource).FFindingList = nil) then
  begin
    FFindingList.free;
    FFindingList := nil;
  end
  else
  begin
    if FFindingList = nil then
      FFindingList := TFhirClinicalImpressionFindingList.Create;
    FFindingList.Assign(TFhirClinicalImpression(oSource).FFindingList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList = nil) then
  begin
    FPrognosisCodeableConceptList.free;
    FPrognosisCodeableConceptList := nil;
  end
  else
  begin
    if FPrognosisCodeableConceptList = nil then
      FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
    FPrognosisCodeableConceptList.Assign(TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisReferenceList = nil) then
  begin
    FPrognosisReferenceList.free;
    FPrognosisReferenceList := nil;
  end
  else
  begin
    if FPrognosisReferenceList = nil then
      FPrognosisReferenceList := TFhirReferenceList.Create;
    FPrognosisReferenceList.Assign(TFhirClinicalImpression(oSource).FPrognosisReferenceList);
  end;
  if (TFhirClinicalImpression(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirClinicalImpression(oSource).FSupportingInfoList);
  end;
  if (TFhirClinicalImpression(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirClinicalImpression(oSource).FNoteList);
  end;
end;

function TFhirClinicalImpression.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalImpression;
end;

procedure TFhirClinicalImpression.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'problem') Then
    list.addAll(self, 'problem', FProblemList);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'finding') Then
    list.addAll(self, 'finding', FFindingList);
  if (child_name = 'prognosisCodeableConcept') Then
    list.addAll(self, 'prognosisCodeableConcept', FPrognosisCodeableConceptList);
  if (child_name = 'prognosisReference') Then
    list.addAll(self, 'prognosisReference', FPrognosisReferenceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirClinicalImpression.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'previous', 'Reference', false, TFhirReference, FPrevious.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'problem', 'Reference', true, TFhirReference, FProblemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'protocol', 'uri', true, TFhirUri, FProtocolList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'summary', 'string', false, TFhirString, FSummary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'finding', 'BackboneElement', true, TFhirClinicalImpressionFinding, FFindingList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'prognosisCodeableConcept', 'CodeableConcept', true, TFhirCodeableConcept, FPrognosisCodeableConceptList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'prognosisReference', 'Reference', true, TFhirReference, FPrognosisReferenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirClinicalImpression.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'previous') then
  begin
    Previous := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'problem') then
  begin
    ProblemList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'summary') then
  begin
    SummaryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'finding') then
  begin
    FindingList.add(propValue as TFhirClinicalImpressionFinding) {L1048};
    result := propValue;
  end
  else if (propName = 'prognosisCodeableConcept') then
  begin
    PrognosisCodeableConceptList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'prognosisReference') then
  begin
    PrognosisReferenceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpression.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'problem') then ProblemList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'protocol') then ProtocolList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'finding') then FindingList.insertItem(index, propValue as TFhirClinicalImpressionFinding) {L1049}
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'prognosisReference') then PrognosisReferenceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirClinicalImpression.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective') {L1191}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'performer') then result := TFhirReference.create() {L1203}
  else if (propName = 'previous') then result := TFhirReference.create() {L1203}
  else if (propName = 'problem') then result := ProblemList.new() {L1053}
  else if (propName = 'protocol') then result := ProtocolList.new() {L1053}
  else if (propName = 'summary') then result := TFhirString.create() {L1223}
  else if (propName = 'finding') then result := FindingList.new() {L1053}
  else if (propName = 'prognosisCodeableConcept') then result := PrognosisCodeableConceptList.new() {L1053}
  else if (propName = 'prognosisReference') then result := PrognosisReferenceList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpression.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'previous') then result := 'Reference'
  else if (propName = 'problem') then result := 'Reference'
  else if (propName = 'protocol') then result := 'uri'
  else if (propName = 'summary') then result := 'string'
  else if (propName = 'finding') then result := 'BackboneElement'
  else if (propName = 'prognosisCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'prognosisReference') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpression.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil {L1189}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'problem') then deletePropertyValue('problem', ProblemList, value) {L1054}
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value) {L1054}
  else if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'finding') then deletePropertyValue('finding', FindingList, value) {L1054}
  else if (propName = 'prognosisCodeableConcept') then deletePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, value) {L1054}
  else if (propName = 'prognosisReference') then deletePropertyValue('prognosisReference', PrognosisReferenceList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpression.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType {L1190}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference {L1195}
  else if (propName = 'previous') then PreviousElement := new as TFhirReference {L1195}
  else if (propName = 'problem') then replacePropertyValue('problem', ProblemList, existing, new) {L1055}
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new) {L1055}
  else if (propName = 'summary') then SummaryElement := asString(new) {L1222}
  else if (propName = 'finding') then replacePropertyValue('finding', FindingList, existing, new) {L1055}
  else if (propName = 'prognosisCodeableConcept') then replacePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, existing, new) {L1055}
  else if (propName = 'prognosisReference') then replacePropertyValue('prognosisReference', PrognosisReferenceList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpression.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'problem') then ProblemList.move(source, destination) {L1050}
  else if (propName = 'protocol') then ProtocolList.move(source, destination) {L1046}
  else if (propName = 'finding') then FindingList.move(source, destination) {L1050}
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.move(source, destination) {L1050}
  else if (propName = 'prognosisReference') then PrognosisReferenceList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpression.fhirType : string;
begin
  result := 'ClinicalImpression';
end;

function TFhirClinicalImpression.Link : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Link);
end;

function TFhirClinicalImpression.Clone : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Clone);
end;

function TFhirClinicalImpression.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalImpression;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpression)) then
    result := false
  else
  begin
    o := TFhirClinicalImpression(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(previousElement, o.previousElement, true) and 
      compareDeep(problemList, o.problemList, true) and compareDeep(protocolList, o.protocolList, true) and 
      compareDeep(summaryElement, o.summaryElement, true) and compareDeep(findingList, o.findingList, true) and 
      compareDeep(prognosisCodeableConceptList, o.prognosisCodeableConceptList, true) and 
      compareDeep(prognosisReferenceList, o.prognosisReferenceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirClinicalImpression.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FDate) and isEmptyProp(FPerformer) and isEmptyProp(FPrevious) and isEmptyProp(FproblemList) and isEmptyProp(FprotocolList) and isEmptyProp(FSummary) and isEmptyProp(FfindingList) and isEmptyProp(FprognosisCodeableConceptList) and isEmptyProp(FprognosisReferenceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList);
end;

function TFhirClinicalImpression.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClinicalImpression.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClinicalImpression.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClinicalImpression.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirClinicalImpression.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirClinicalImpression.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

procedure TFhirClinicalImpression.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirClinicalImpression.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirClinicalImpression.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirClinicalImpression.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirClinicalImpression.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirClinicalImpression.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value; {L1134}
end;

procedure TFhirClinicalImpression.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirClinicalImpression.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClinicalImpression.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirClinicalImpression.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value; {L1134}
end;

procedure TFhirClinicalImpression.SetPrevious(value : TFhirReference);
begin
  FPrevious.free;
  FPrevious := value; {L1134}
end;

function TFhirClinicalImpression.GetProblemList : TFhirReferenceList;
begin
  if FProblemList = nil then
    FProblemList := TFhirReferenceList.Create;
  result := FProblemList;
end;

function TFhirClinicalImpression.GetHasProblemList : boolean;
begin
  result := (FProblemList <> nil) and (FProblemList.count > 0);
end;

function TFhirClinicalImpression.GetProtocolList : TFhirUriList;
begin
  if FProtocolList = nil then
    FProtocolList := TFhirUriList.Create;
  result := FProtocolList;
end;

function TFhirClinicalImpression.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

procedure TFhirClinicalImpression.SetSummary(value : TFhirString);
begin
  FSummary.free;
  FSummary := value; {L1134}
end;

function TFhirClinicalImpression.GetSummaryST : String;
begin
  if FSummary = nil then
    result := ''
  else
    result := FSummary.value;
end;

procedure TFhirClinicalImpression.SetSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FSummary = nil then
      FSummary := TFhirString.create;
    FSummary.value := value
  end
  else if FSummary <> nil then
    FSummary.value := '';
end;

function TFhirClinicalImpression.GetFindingList : TFhirClinicalImpressionFindingList;
begin
  if FFindingList = nil then
    FFindingList := TFhirClinicalImpressionFindingList.Create;
  result := FFindingList;
end;

function TFhirClinicalImpression.GetHasFindingList : boolean;
begin
  result := (FFindingList <> nil) and (FFindingList.count > 0);
end;

function TFhirClinicalImpression.GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
begin
  if FPrognosisCodeableConceptList = nil then
    FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
  result := FPrognosisCodeableConceptList;
end;

function TFhirClinicalImpression.GetHasPrognosisCodeableConceptList : boolean;
begin
  result := (FPrognosisCodeableConceptList <> nil) and (FPrognosisCodeableConceptList.count > 0);
end;

function TFhirClinicalImpression.GetPrognosisReferenceList : TFhirReferenceList;
begin
  if FPrognosisReferenceList = nil then
    FPrognosisReferenceList := TFhirReferenceList.Create;
  result := FPrognosisReferenceList;
end;

function TFhirClinicalImpression.GetHasPrognosisReferenceList : boolean;
begin
  result := (FPrognosisReferenceList <> nil) and (FPrognosisReferenceList.count > 0);
end;

function TFhirClinicalImpression.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirClinicalImpression.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirClinicalImpression.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirClinicalImpression.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirClinicalImpression.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('description');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('date');
  fields.add('performer');
  fields.add('previous');
  fields.add('problem');
  fields.add('protocol');
  fields.add('summary');
  fields.add('finding');
  fields.add('prognosisCodeableConcept');
  fields.add('prognosisReference');
  fields.add('supportingInfo');
  fields.add('note');
end;

function TFhirClinicalImpression.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FPrevious.sizeInBytes);
  inc(result, FproblemList.sizeInBytes);
  inc(result, FprotocolList.sizeInBytes);
  inc(result, FSummary.sizeInBytes);
  inc(result, FfindingList.sizeInBytes);
  inc(result, FprognosisCodeableConceptList.sizeInBytes);
  inc(result, FprognosisReferenceList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirClinicalImpressionListEnumerator }

constructor TFhirClinicalImpressionListEnumerator.Create(list : TFhirClinicalImpressionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionListEnumerator.GetCurrent : TFhirClinicalImpression;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionList }

procedure TFhirClinicalImpressionList.AddItem(value: TFhirClinicalImpression);
begin
  assert(value.ClassName = 'TFhirClinicalImpression', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpression');
  add(value);
end;

function TFhirClinicalImpressionList.Append: TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionList.GetEnumerator : TFhirClinicalImpressionListEnumerator;
begin
  result := TFhirClinicalImpressionListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionList.Clone: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Clone);
end;

function TFhirClinicalImpressionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionList.GetItemN(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpression;
end;
function TFhirClinicalImpressionList.IndexOf(value: TFhirClinicalImpression): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionList.Insert(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.InsertItem(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionList.Item(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.Link: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Link);
end;

procedure TFhirClinicalImpressionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionList.SetItemByIndex(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  FhirClinicalImpressions[index] := value;
end;

procedure TFhirClinicalImpressionList.SetItemN(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEISSUE}
{ TFhirClinicalUseIssueContraindication }

constructor TFhirClinicalUseIssueContraindication.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueContraindication.Destroy;
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FIndicationList.Free;
  FOtherTherapyList.Free;
  inherited;
end;

procedure TFhirClinicalUseIssueContraindication.Assign(oSource : TFslObject);
begin
  inherited;
  diseaseSymptomProcedure := TFhirClinicalUseIssueContraindication(oSource).diseaseSymptomProcedure.Clone;
  diseaseStatus := TFhirClinicalUseIssueContraindication(oSource).diseaseStatus.Clone;
  if (TFhirClinicalUseIssueContraindication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableConceptList.Create;
    FComorbidityList.Assign(TFhirClinicalUseIssueContraindication(oSource).FComorbidityList);
  end;
  if (TFhirClinicalUseIssueContraindication(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirReferenceList.Create;
    FIndicationList.Assign(TFhirClinicalUseIssueContraindication(oSource).FIndicationList);
  end;
  if (TFhirClinicalUseIssueContraindication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirClinicalUseIssueContraindicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirClinicalUseIssueContraindication(oSource).FOtherTherapyList);
  end;
end;

procedure TFhirClinicalUseIssueContraindication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diseaseSymptomProcedure') Then
     list.add(self.link, 'diseaseSymptomProcedure', FDiseaseSymptomProcedure.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
end;

procedure TFhirClinicalUseIssueContraindication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diseaseSymptomProcedure', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseSymptomProcedure.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableConcept', true, TFhirCodeableConcept, FComorbidityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'indication', 'Reference', true, TFhirReference, FIndicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'otherTherapy', 'BackboneElement', true, TFhirClinicalUseIssueContraindicationOtherTherapy, FOtherTherapyList.Link)) {L1039};
end;

function TFhirClinicalUseIssueContraindication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then
  begin
    DiseaseSymptomProcedure := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirClinicalUseIssueContraindicationOtherTherapy) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueContraindication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirClinicalUseIssueContraindicationOtherTherapy) {L1049}
  else inherited;
end;

function TFhirClinicalUseIssueContraindication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'diseaseStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'comorbidity') then result := ComorbidityList.new() {L1053}
  else if (propName = 'indication') then result := IndicationList.new() {L1053}
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueContraindication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diseaseSymptomProcedure') then result := 'CodeableConcept'
  else if (propName = 'diseaseStatus') then result := 'CodeableConcept'
  else if (propName = 'comorbidity') then result := 'CodeableConcept'
  else if (propName = 'indication') then result := 'Reference'
  else if (propName = 'otherTherapy') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueContraindication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value) {L1054}
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value) {L1054}
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueContraindication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new) {L1055}
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new) {L1055}
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueContraindication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.move(source, destination) {L1050}
  else if (propName = 'indication') then IndicationList.move(source, destination) {L1050}
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueContraindication.fhirType : string;
begin
  result := 'ClinicalUseIssue.contraindication';
end;

function TFhirClinicalUseIssueContraindication.Link : TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication(inherited Link);
end;

function TFhirClinicalUseIssueContraindication.Clone : TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication(inherited Clone);
end;

function TFhirClinicalUseIssueContraindication.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueContraindication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueContraindication)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueContraindication(other);
    result := compareDeep(diseaseSymptomProcedureElement, o.diseaseSymptomProcedureElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(indicationList, o.indicationList, true) and compareDeep(otherTherapyList, o.otherTherapyList, true);
  end;
end;

function TFhirClinicalUseIssueContraindication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiseaseSymptomProcedure) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FindicationList) and isEmptyProp(FotherTherapyList);
end;

procedure TFhirClinicalUseIssueContraindication.SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseSymptomProcedure := value; {L1134}
end;

procedure TFhirClinicalUseIssueContraindication.SetDiseaseStatus(value : TFhirCodeableConcept);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value; {L1134}
end;

function TFhirClinicalUseIssueContraindication.GetComorbidityList : TFhirCodeableConceptList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableConceptList.Create;
  result := FComorbidityList;
end;

function TFhirClinicalUseIssueContraindication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

function TFhirClinicalUseIssueContraindication.GetIndicationList : TFhirReferenceList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirReferenceList.Create;
  result := FIndicationList;
end;

function TFhirClinicalUseIssueContraindication.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

function TFhirClinicalUseIssueContraindication.GetOtherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirClinicalUseIssueContraindicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

function TFhirClinicalUseIssueContraindication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

procedure TFhirClinicalUseIssueContraindication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('diseaseSymptomProcedure');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('indication');
  fields.add('otherTherapy');
end;

function TFhirClinicalUseIssueContraindication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDiseaseSymptomProcedure.sizeInBytes);
  inc(result, FDiseaseStatus.sizeInBytes);
  inc(result, FcomorbidityList.sizeInBytes);
  inc(result, FindicationList.sizeInBytes);
  inc(result, FotherTherapyList.sizeInBytes);
end;

{ TFhirClinicalUseIssueContraindicationListEnumerator }

constructor TFhirClinicalUseIssueContraindicationListEnumerator.Create(list : TFhirClinicalUseIssueContraindicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueContraindicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueContraindicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueContraindicationListEnumerator.GetCurrent : TFhirClinicalUseIssueContraindication;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueContraindicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueContraindicationList }

procedure TFhirClinicalUseIssueContraindicationList.AddItem(value: TFhirClinicalUseIssueContraindication);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueContraindication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueContraindication');
  add(value);
end;

function TFhirClinicalUseIssueContraindicationList.Append: TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueContraindicationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueContraindicationList.GetEnumerator : TFhirClinicalUseIssueContraindicationListEnumerator;
begin
  result := TFhirClinicalUseIssueContraindicationListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueContraindicationList.Clone: TFhirClinicalUseIssueContraindicationList;
begin
  result := TFhirClinicalUseIssueContraindicationList(inherited Clone);
end;

function TFhirClinicalUseIssueContraindicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueContraindicationList.GetItemN(index: Integer): TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueContraindicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueContraindication;
end;
function TFhirClinicalUseIssueContraindicationList.IndexOf(value: TFhirClinicalUseIssueContraindication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueContraindicationList.Insert(index: Integer): TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueContraindicationList.InsertItem(index: Integer; value: TFhirClinicalUseIssueContraindication);
begin
  assert(value is TFhirClinicalUseIssueContraindication);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueContraindicationList.Item(index: Integer): TFhirClinicalUseIssueContraindication;
begin
  result := TFhirClinicalUseIssueContraindication(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueContraindicationList.Link: TFhirClinicalUseIssueContraindicationList;
begin
  result := TFhirClinicalUseIssueContraindicationList(inherited Link);
end;

procedure TFhirClinicalUseIssueContraindicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueContraindicationList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueContraindication);
begin
  assert(value is TFhirClinicalUseIssueContraindication);
  FhirClinicalUseIssueContraindications[index] := value;
end;

procedure TFhirClinicalUseIssueContraindicationList.SetItemN(index: Integer; value: TFhirClinicalUseIssueContraindication);
begin
  assert(value is TFhirClinicalUseIssueContraindication);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssueContraindicationOtherTherapy }

constructor TFhirClinicalUseIssueContraindicationOtherTherapy.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueContraindicationOtherTherapy.Destroy;
begin
  FTherapyRelationshipType.free;
  FMedication.free;
  inherited;
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.Assign(oSource : TFslObject);
begin
  inherited;
  therapyRelationshipType := TFhirClinicalUseIssueContraindicationOtherTherapy(oSource).therapyRelationshipType.Clone;
  medication := TFhirClinicalUseIssueContraindicationOtherTherapy(oSource).medication.Clone;
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'therapyRelationshipType') Then
     list.add(self.link, 'therapyRelationshipType', FTherapyRelationshipType.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'therapyRelationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FTherapyRelationshipType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FMedication.Link)); {L1172}
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then
  begin
    TherapyRelationshipType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'therapyRelationshipType') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.fhirType : string;
begin
  result := 'ClinicalUseIssue.contraindication.otherTherapy';
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.Link : TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy(inherited Link);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.Clone : TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy(inherited Clone);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueContraindicationOtherTherapy)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueContraindicationOtherTherapy(other);
    result := compareDeep(therapyRelationshipTypeElement, o.therapyRelationshipTypeElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true);
  end;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTherapyRelationshipType) and isEmptyProp(FMedication);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.SetTherapyRelationshipType(value : TFhirCodeableConcept);
begin
  FTherapyRelationshipType.free;
  FTherapyRelationshipType := value; {L1134}
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.SetMedication(value : TFhirDataType);
begin
  FMedication.free;
  FMedication := value; {L1134}
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('therapyRelationshipType');
  fields.add('medication[x]');
end;

function TFhirClinicalUseIssueContraindicationOtherTherapy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTherapyRelationshipType.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
end;

{ TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator }

constructor TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.Create(list : TFhirClinicalUseIssueContraindicationOtherTherapyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.GetCurrent : TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueContraindicationOtherTherapyList }

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.AddItem(value: TFhirClinicalUseIssueContraindicationOtherTherapy);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueContraindicationOtherTherapy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueContraindicationOtherTherapy');
  add(value);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Append: TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.GetEnumerator : TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapyListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Clone: TFhirClinicalUseIssueContraindicationOtherTherapyList;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapyList(inherited Clone);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.GetItemN(index: Integer): TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy;
end;
function TFhirClinicalUseIssueContraindicationOtherTherapyList.IndexOf(value: TFhirClinicalUseIssueContraindicationOtherTherapy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Insert(index: Integer): TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.InsertItem(index: Integer; value: TFhirClinicalUseIssueContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseIssueContraindicationOtherTherapy);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Item(index: Integer): TFhirClinicalUseIssueContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueContraindicationOtherTherapyList.Link: TFhirClinicalUseIssueContraindicationOtherTherapyList;
begin
  result := TFhirClinicalUseIssueContraindicationOtherTherapyList(inherited Link);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseIssueContraindicationOtherTherapy);
  FhirClinicalUseIssueContraindicationOtherTherapies[index] := value;
end;

procedure TFhirClinicalUseIssueContraindicationOtherTherapyList.SetItemN(index: Integer; value: TFhirClinicalUseIssueContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseIssueContraindicationOtherTherapy);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssueIndication }

constructor TFhirClinicalUseIssueIndication.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueIndication.Destroy;
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FIntendedEffect.free;
  FDuration.free;
  FUndesirableEffectList.Free;
  FOtherTherapyList.Free;
  inherited;
end;

procedure TFhirClinicalUseIssueIndication.Assign(oSource : TFslObject);
begin
  inherited;
  diseaseSymptomProcedure := TFhirClinicalUseIssueIndication(oSource).diseaseSymptomProcedure.Clone;
  diseaseStatus := TFhirClinicalUseIssueIndication(oSource).diseaseStatus.Clone;
  if (TFhirClinicalUseIssueIndication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableConceptList.Create;
    FComorbidityList.Assign(TFhirClinicalUseIssueIndication(oSource).FComorbidityList);
  end;
  intendedEffect := TFhirClinicalUseIssueIndication(oSource).intendedEffect.Clone;
  duration := TFhirClinicalUseIssueIndication(oSource).duration.Clone;
  if (TFhirClinicalUseIssueIndication(oSource).FUndesirableEffectList = nil) then
  begin
    FUndesirableEffectList.free;
    FUndesirableEffectList := nil;
  end
  else
  begin
    if FUndesirableEffectList = nil then
      FUndesirableEffectList := TFhirReferenceList.Create;
    FUndesirableEffectList.Assign(TFhirClinicalUseIssueIndication(oSource).FUndesirableEffectList);
  end;
  if (TFhirClinicalUseIssueIndication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirClinicalUseIssueContraindicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirClinicalUseIssueIndication(oSource).FOtherTherapyList);
  end;
end;

procedure TFhirClinicalUseIssueIndication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diseaseSymptomProcedure') Then
     list.add(self.link, 'diseaseSymptomProcedure', FDiseaseSymptomProcedure.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'intendedEffect') Then
     list.add(self.link, 'intendedEffect', FIntendedEffect.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'undesirableEffect') Then
    list.addAll(self, 'undesirableEffect', FUndesirableEffectList);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
end;

procedure TFhirClinicalUseIssueIndication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diseaseSymptomProcedure', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseSymptomProcedure.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableConcept', true, TFhirCodeableConcept, FComorbidityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'intendedEffect', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedEffect.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'undesirableEffect', 'Reference', true, TFhirReference, FUndesirableEffectList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'otherTherapy', '', true, TFhirClinicalUseIssueContraindicationOtherTherapy, FOtherTherapyList.Link)) {L1039};
end;

function TFhirClinicalUseIssueIndication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then
  begin
    DiseaseSymptomProcedure := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'intendedEffect') then
  begin
    IntendedEffect := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'undesirableEffect') then
  begin
    UndesirableEffectList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirClinicalUseIssueContraindicationOtherTherapy) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueIndication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'undesirableEffect') then UndesirableEffectList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirClinicalUseIssueContraindicationOtherTherapy) {L1049}
  else inherited;
end;

function TFhirClinicalUseIssueIndication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'diseaseStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'comorbidity') then result := ComorbidityList.new() {L1053}
  else if (propName = 'intendedEffect') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'duration') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'undesirableEffect') then result := UndesirableEffectList.new() {L1053}
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueIndication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diseaseSymptomProcedure') then result := 'CodeableConcept'
  else if (propName = 'diseaseStatus') then result := 'CodeableConcept'
  else if (propName = 'comorbidity') then result := 'CodeableConcept'
  else if (propName = 'intendedEffect') then result := 'CodeableConcept'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'undesirableEffect') then result := 'Reference'
  else if (propName = 'otherTherapy') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueIndication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value) {L1054}
  else if (propName = 'intendedEffect') then IntendedEffectElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'undesirableEffect') then deletePropertyValue('undesirableEffect', UndesirableEffectList, value) {L1054}
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueIndication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new) {L1055}
  else if (propName = 'intendedEffect') then IntendedEffectElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity {L1195}
  else if (propName = 'undesirableEffect') then replacePropertyValue('undesirableEffect', UndesirableEffectList, existing, new) {L1055}
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueIndication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.move(source, destination) {L1050}
  else if (propName = 'undesirableEffect') then UndesirableEffectList.move(source, destination) {L1050}
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueIndication.fhirType : string;
begin
  result := 'ClinicalUseIssue.indication';
end;

function TFhirClinicalUseIssueIndication.Link : TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication(inherited Link);
end;

function TFhirClinicalUseIssueIndication.Clone : TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication(inherited Clone);
end;

function TFhirClinicalUseIssueIndication.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueIndication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueIndication)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueIndication(other);
    result := compareDeep(diseaseSymptomProcedureElement, o.diseaseSymptomProcedureElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(intendedEffectElement, o.intendedEffectElement, true) and compareDeep(durationElement, o.durationElement, true) and 
      compareDeep(undesirableEffectList, o.undesirableEffectList, true) and compareDeep(otherTherapyList, o.otherTherapyList, true);
  end;
end;

function TFhirClinicalUseIssueIndication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiseaseSymptomProcedure) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FIntendedEffect) and isEmptyProp(FDuration) and isEmptyProp(FundesirableEffectList) and isEmptyProp(FotherTherapyList);
end;

procedure TFhirClinicalUseIssueIndication.SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseSymptomProcedure := value; {L1134}
end;

procedure TFhirClinicalUseIssueIndication.SetDiseaseStatus(value : TFhirCodeableConcept);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value; {L1134}
end;

function TFhirClinicalUseIssueIndication.GetComorbidityList : TFhirCodeableConceptList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableConceptList.Create;
  result := FComorbidityList;
end;

function TFhirClinicalUseIssueIndication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

procedure TFhirClinicalUseIssueIndication.SetIntendedEffect(value : TFhirCodeableConcept);
begin
  FIntendedEffect.free;
  FIntendedEffect := value; {L1134}
end;

procedure TFhirClinicalUseIssueIndication.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value; {L1134}
end;

function TFhirClinicalUseIssueIndication.GetUndesirableEffectList : TFhirReferenceList;
begin
  if FUndesirableEffectList = nil then
    FUndesirableEffectList := TFhirReferenceList.Create;
  result := FUndesirableEffectList;
end;

function TFhirClinicalUseIssueIndication.GetHasUndesirableEffectList : boolean;
begin
  result := (FUndesirableEffectList <> nil) and (FUndesirableEffectList.count > 0);
end;

function TFhirClinicalUseIssueIndication.GetOtherTherapyList : TFhirClinicalUseIssueContraindicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirClinicalUseIssueContraindicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

function TFhirClinicalUseIssueIndication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

procedure TFhirClinicalUseIssueIndication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('diseaseSymptomProcedure');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('intendedEffect');
  fields.add('duration');
  fields.add('undesirableEffect');
  fields.add('otherTherapy');
end;

function TFhirClinicalUseIssueIndication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDiseaseSymptomProcedure.sizeInBytes);
  inc(result, FDiseaseStatus.sizeInBytes);
  inc(result, FcomorbidityList.sizeInBytes);
  inc(result, FIntendedEffect.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FundesirableEffectList.sizeInBytes);
  inc(result, FotherTherapyList.sizeInBytes);
end;

{ TFhirClinicalUseIssueIndicationListEnumerator }

constructor TFhirClinicalUseIssueIndicationListEnumerator.Create(list : TFhirClinicalUseIssueIndicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueIndicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueIndicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueIndicationListEnumerator.GetCurrent : TFhirClinicalUseIssueIndication;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueIndicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueIndicationList }

procedure TFhirClinicalUseIssueIndicationList.AddItem(value: TFhirClinicalUseIssueIndication);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueIndication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueIndication');
  add(value);
end;

function TFhirClinicalUseIssueIndicationList.Append: TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueIndicationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueIndicationList.GetEnumerator : TFhirClinicalUseIssueIndicationListEnumerator;
begin
  result := TFhirClinicalUseIssueIndicationListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueIndicationList.Clone: TFhirClinicalUseIssueIndicationList;
begin
  result := TFhirClinicalUseIssueIndicationList(inherited Clone);
end;

function TFhirClinicalUseIssueIndicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueIndicationList.GetItemN(index: Integer): TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueIndicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueIndication;
end;
function TFhirClinicalUseIssueIndicationList.IndexOf(value: TFhirClinicalUseIssueIndication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueIndicationList.Insert(index: Integer): TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueIndicationList.InsertItem(index: Integer; value: TFhirClinicalUseIssueIndication);
begin
  assert(value is TFhirClinicalUseIssueIndication);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueIndicationList.Item(index: Integer): TFhirClinicalUseIssueIndication;
begin
  result := TFhirClinicalUseIssueIndication(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueIndicationList.Link: TFhirClinicalUseIssueIndicationList;
begin
  result := TFhirClinicalUseIssueIndicationList(inherited Link);
end;

procedure TFhirClinicalUseIssueIndicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueIndicationList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueIndication);
begin
  assert(value is TFhirClinicalUseIssueIndication);
  FhirClinicalUseIssueIndications[index] := value;
end;

procedure TFhirClinicalUseIssueIndicationList.SetItemN(index: Integer; value: TFhirClinicalUseIssueIndication);
begin
  assert(value is TFhirClinicalUseIssueIndication);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssueInteraction }

constructor TFhirClinicalUseIssueInteraction.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueInteraction.Destroy;
begin
  FInteractantList.Free;
  FType_.free;
  FEffect.free;
  FIncidence.free;
  FManagement.free;
  inherited;
end;

procedure TFhirClinicalUseIssueInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalUseIssueInteraction(oSource).FInteractantList = nil) then
  begin
    FInteractantList.free;
    FInteractantList := nil;
  end
  else
  begin
    if FInteractantList = nil then
      FInteractantList := TFhirClinicalUseIssueInteractionInteractantList.Create;
    FInteractantList.Assign(TFhirClinicalUseIssueInteraction(oSource).FInteractantList);
  end;
  type_ := TFhirClinicalUseIssueInteraction(oSource).type_.Clone;
  effect := TFhirClinicalUseIssueInteraction(oSource).effect.Clone;
  incidence := TFhirClinicalUseIssueInteraction(oSource).incidence.Clone;
  management := TFhirClinicalUseIssueInteraction(oSource).management.Clone;
end;

procedure TFhirClinicalUseIssueInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'interactant') Then
    list.addAll(self, 'interactant', FInteractantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effect') Then
     list.add(self.link, 'effect', FEffect.Link);
  if (child_name = 'incidence') Then
     list.add(self.link, 'incidence', FIncidence.Link);
  if (child_name = 'management') Then
     list.add(self.link, 'management', FManagement.Link);
end;

procedure TFhirClinicalUseIssueInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'interactant', 'BackboneElement', true, TFhirClinicalUseIssueInteractionInteractant, FInteractantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effect', 'CodeableConcept', false, TFhirCodeableConcept, FEffect.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'incidence', 'CodeableConcept', false, TFhirCodeableConcept, FIncidence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'management', 'CodeableConcept', false, TFhirCodeableConcept, FManagement.Link)); {L1172}
end;

function TFhirClinicalUseIssueInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'interactant') then
  begin
    InteractantList.add(propValue as TFhirClinicalUseIssueInteractionInteractant) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'effect') then
  begin
    Effect := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'incidence') then
  begin
    Incidence := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'management') then
  begin
    Management := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interactant') then InteractantList.insertItem(index, propValue as TFhirClinicalUseIssueInteractionInteractant) {L1049}
  else inherited;
end;

function TFhirClinicalUseIssueInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'interactant') then result := InteractantList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'effect') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'incidence') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'management') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'interactant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'effect') then result := 'CodeableConcept'
  else if (propName = 'incidence') then result := 'CodeableConcept'
  else if (propName = 'management') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'interactant') then deletePropertyValue('interactant', InteractantList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'effect') then EffectElement := nil
  else if (propName = 'incidence') then IncidenceElement := nil
  else if (propName = 'management') then ManagementElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'interactant') then replacePropertyValue('interactant', InteractantList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'effect') then EffectElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'incidence') then IncidenceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'management') then ManagementElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interactant') then InteractantList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueInteraction.fhirType : string;
begin
  result := 'ClinicalUseIssue.interaction';
end;

function TFhirClinicalUseIssueInteraction.Link : TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction(inherited Link);
end;

function TFhirClinicalUseIssueInteraction.Clone : TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction(inherited Clone);
end;

function TFhirClinicalUseIssueInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueInteraction)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueInteraction(other);
    result := compareDeep(interactantList, o.interactantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(effectElement, o.effectElement, true) and compareDeep(incidenceElement, o.incidenceElement, true) and 
      compareDeep(managementElement, o.managementElement, true);
  end;
end;

function TFhirClinicalUseIssueInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FinteractantList) and isEmptyProp(FType_) and isEmptyProp(FEffect) and isEmptyProp(FIncidence) and isEmptyProp(FManagement);
end;

function TFhirClinicalUseIssueInteraction.GetInteractantList : TFhirClinicalUseIssueInteractionInteractantList;
begin
  if FInteractantList = nil then
    FInteractantList := TFhirClinicalUseIssueInteractionInteractantList.Create;
  result := FInteractantList;
end;

function TFhirClinicalUseIssueInteraction.GetHasInteractantList : boolean;
begin
  result := (FInteractantList <> nil) and (FInteractantList.count > 0);
end;

procedure TFhirClinicalUseIssueInteraction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClinicalUseIssueInteraction.SetEffect(value : TFhirCodeableConcept);
begin
  FEffect.free;
  FEffect := value; {L1134}
end;

procedure TFhirClinicalUseIssueInteraction.SetIncidence(value : TFhirCodeableConcept);
begin
  FIncidence.free;
  FIncidence := value; {L1134}
end;

procedure TFhirClinicalUseIssueInteraction.SetManagement(value : TFhirCodeableConcept);
begin
  FManagement.free;
  FManagement := value; {L1134}
end;

procedure TFhirClinicalUseIssueInteraction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('interactant');
  fields.add('type');
  fields.add('effect');
  fields.add('incidence');
  fields.add('management');
end;

function TFhirClinicalUseIssueInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FinteractantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FEffect.sizeInBytes);
  inc(result, FIncidence.sizeInBytes);
  inc(result, FManagement.sizeInBytes);
end;

{ TFhirClinicalUseIssueInteractionListEnumerator }

constructor TFhirClinicalUseIssueInteractionListEnumerator.Create(list : TFhirClinicalUseIssueInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueInteractionListEnumerator.GetCurrent : TFhirClinicalUseIssueInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueInteractionList }

procedure TFhirClinicalUseIssueInteractionList.AddItem(value: TFhirClinicalUseIssueInteraction);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueInteraction');
  add(value);
end;

function TFhirClinicalUseIssueInteractionList.Append: TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueInteractionList.GetEnumerator : TFhirClinicalUseIssueInteractionListEnumerator;
begin
  result := TFhirClinicalUseIssueInteractionListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueInteractionList.Clone: TFhirClinicalUseIssueInteractionList;
begin
  result := TFhirClinicalUseIssueInteractionList(inherited Clone);
end;

function TFhirClinicalUseIssueInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueInteractionList.GetItemN(index: Integer): TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueInteraction;
end;
function TFhirClinicalUseIssueInteractionList.IndexOf(value: TFhirClinicalUseIssueInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueInteractionList.Insert(index: Integer): TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueInteractionList.InsertItem(index: Integer; value: TFhirClinicalUseIssueInteraction);
begin
  assert(value is TFhirClinicalUseIssueInteraction);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueInteractionList.Item(index: Integer): TFhirClinicalUseIssueInteraction;
begin
  result := TFhirClinicalUseIssueInteraction(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueInteractionList.Link: TFhirClinicalUseIssueInteractionList;
begin
  result := TFhirClinicalUseIssueInteractionList(inherited Link);
end;

procedure TFhirClinicalUseIssueInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueInteractionList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueInteraction);
begin
  assert(value is TFhirClinicalUseIssueInteraction);
  FhirClinicalUseIssueInteractions[index] := value;
end;

procedure TFhirClinicalUseIssueInteractionList.SetItemN(index: Integer; value: TFhirClinicalUseIssueInteraction);
begin
  assert(value is TFhirClinicalUseIssueInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssueInteractionInteractant }

constructor TFhirClinicalUseIssueInteractionInteractant.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueInteractionInteractant.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirClinicalUseIssueInteractionInteractant.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalUseIssueInteractionInteractant(oSource).item.Clone;
end;

procedure TFhirClinicalUseIssueInteractionInteractant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirClinicalUseIssueInteractionInteractant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseIssueInteractionInteractant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueInteractionInteractant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueInteractionInteractant.fhirType : string;
begin
  result := 'ClinicalUseIssue.interaction.interactant';
end;

function TFhirClinicalUseIssueInteractionInteractant.Link : TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant(inherited Link);
end;

function TFhirClinicalUseIssueInteractionInteractant.Clone : TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant(inherited Clone);
end;

function TFhirClinicalUseIssueInteractionInteractant.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueInteractionInteractant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueInteractionInteractant)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueInteractionInteractant(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirClinicalUseIssueInteractionInteractant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirClinicalUseIssueInteractionInteractant.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirClinicalUseIssueInteractionInteractant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirClinicalUseIssueInteractionInteractant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirClinicalUseIssueInteractionInteractantListEnumerator }

constructor TFhirClinicalUseIssueInteractionInteractantListEnumerator.Create(list : TFhirClinicalUseIssueInteractionInteractantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueInteractionInteractantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueInteractionInteractantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueInteractionInteractantListEnumerator.GetCurrent : TFhirClinicalUseIssueInteractionInteractant;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueInteractionInteractantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueInteractionInteractantList }

procedure TFhirClinicalUseIssueInteractionInteractantList.AddItem(value: TFhirClinicalUseIssueInteractionInteractant);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueInteractionInteractant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueInteractionInteractant');
  add(value);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Append: TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueInteractionInteractantList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueInteractionInteractantList.GetEnumerator : TFhirClinicalUseIssueInteractionInteractantListEnumerator;
begin
  result := TFhirClinicalUseIssueInteractionInteractantListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Clone: TFhirClinicalUseIssueInteractionInteractantList;
begin
  result := TFhirClinicalUseIssueInteractionInteractantList(inherited Clone);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueInteractionInteractantList.GetItemN(index: Integer): TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueInteractionInteractantList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueInteractionInteractant;
end;
function TFhirClinicalUseIssueInteractionInteractantList.IndexOf(value: TFhirClinicalUseIssueInteractionInteractant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Insert(index: Integer): TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueInteractionInteractantList.InsertItem(index: Integer; value: TFhirClinicalUseIssueInteractionInteractant);
begin
  assert(value is TFhirClinicalUseIssueInteractionInteractant);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Item(index: Integer): TFhirClinicalUseIssueInteractionInteractant;
begin
  result := TFhirClinicalUseIssueInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueInteractionInteractantList.Link: TFhirClinicalUseIssueInteractionInteractantList;
begin
  result := TFhirClinicalUseIssueInteractionInteractantList(inherited Link);
end;

procedure TFhirClinicalUseIssueInteractionInteractantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueInteractionInteractantList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueInteractionInteractant);
begin
  assert(value is TFhirClinicalUseIssueInteractionInteractant);
  FhirClinicalUseIssueInteractionInteractants[index] := value;
end;

procedure TFhirClinicalUseIssueInteractionInteractantList.SetItemN(index: Integer; value: TFhirClinicalUseIssueInteractionInteractant);
begin
  assert(value is TFhirClinicalUseIssueInteractionInteractant);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssueUndesirableEffect }

constructor TFhirClinicalUseIssueUndesirableEffect.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssueUndesirableEffect.Destroy;
begin
  FSymptomConditionEffect.free;
  FClassification.free;
  FFrequencyOfOccurrence.free;
  inherited;
end;

procedure TFhirClinicalUseIssueUndesirableEffect.Assign(oSource : TFslObject);
begin
  inherited;
  symptomConditionEffect := TFhirClinicalUseIssueUndesirableEffect(oSource).symptomConditionEffect.Clone;
  classification := TFhirClinicalUseIssueUndesirableEffect(oSource).classification.Clone;
  frequencyOfOccurrence := TFhirClinicalUseIssueUndesirableEffect(oSource).frequencyOfOccurrence.Clone;
end;

procedure TFhirClinicalUseIssueUndesirableEffect.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'symptomConditionEffect') Then
     list.add(self.link, 'symptomConditionEffect', FSymptomConditionEffect.Link);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'frequencyOfOccurrence') Then
     list.add(self.link, 'frequencyOfOccurrence', FFrequencyOfOccurrence.Link);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'symptomConditionEffect', 'CodeableConcept', false, TFhirCodeableConcept, FSymptomConditionEffect.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', false, TFhirCodeableConcept, FClassification.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'frequencyOfOccurrence', 'CodeableConcept', false, TFhirCodeableConcept, FFrequencyOfOccurrence.Link)); {L1172}
end;

function TFhirClinicalUseIssueUndesirableEffect.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'symptomConditionEffect') then
  begin
    SymptomConditionEffect := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'frequencyOfOccurrence') then
  begin
    FrequencyOfOccurrence := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseIssueUndesirableEffect.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'symptomConditionEffect') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'classification') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'frequencyOfOccurrence') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssueUndesirableEffect.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'symptomConditionEffect') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'frequencyOfOccurrence') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := nil
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'classification') then ClassificationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssueUndesirableEffect.fhirType : string;
begin
  result := 'ClinicalUseIssue.undesirableEffect';
end;

function TFhirClinicalUseIssueUndesirableEffect.Link : TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect(inherited Link);
end;

function TFhirClinicalUseIssueUndesirableEffect.Clone : TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect(inherited Clone);
end;

function TFhirClinicalUseIssueUndesirableEffect.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssueUndesirableEffect;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssueUndesirableEffect)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssueUndesirableEffect(other);
    result := compareDeep(symptomConditionEffectElement, o.symptomConditionEffectElement, true) and 
      compareDeep(classificationElement, o.classificationElement, true) and compareDeep(frequencyOfOccurrenceElement, o.frequencyOfOccurrenceElement, true);
  end;
end;

function TFhirClinicalUseIssueUndesirableEffect.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSymptomConditionEffect) and isEmptyProp(FClassification) and isEmptyProp(FFrequencyOfOccurrence);
end;

procedure TFhirClinicalUseIssueUndesirableEffect.SetSymptomConditionEffect(value : TFhirCodeableConcept);
begin
  FSymptomConditionEffect.free;
  FSymptomConditionEffect := value; {L1134}
end;

procedure TFhirClinicalUseIssueUndesirableEffect.SetClassification(value : TFhirCodeableConcept);
begin
  FClassification.free;
  FClassification := value; {L1134}
end;

procedure TFhirClinicalUseIssueUndesirableEffect.SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
begin
  FFrequencyOfOccurrence.free;
  FFrequencyOfOccurrence := value; {L1134}
end;

procedure TFhirClinicalUseIssueUndesirableEffect.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('symptomConditionEffect');
  fields.add('classification');
  fields.add('frequencyOfOccurrence');
end;

function TFhirClinicalUseIssueUndesirableEffect.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSymptomConditionEffect.sizeInBytes);
  inc(result, FClassification.sizeInBytes);
  inc(result, FFrequencyOfOccurrence.sizeInBytes);
end;

{ TFhirClinicalUseIssueUndesirableEffectListEnumerator }

constructor TFhirClinicalUseIssueUndesirableEffectListEnumerator.Create(list : TFhirClinicalUseIssueUndesirableEffectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueUndesirableEffectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueUndesirableEffectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueUndesirableEffectListEnumerator.GetCurrent : TFhirClinicalUseIssueUndesirableEffect;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueUndesirableEffectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueUndesirableEffectList }

procedure TFhirClinicalUseIssueUndesirableEffectList.AddItem(value: TFhirClinicalUseIssueUndesirableEffect);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssueUndesirableEffect', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssueUndesirableEffect');
  add(value);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Append: TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueUndesirableEffectList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueUndesirableEffectList.GetEnumerator : TFhirClinicalUseIssueUndesirableEffectListEnumerator;
begin
  result := TFhirClinicalUseIssueUndesirableEffectListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Clone: TFhirClinicalUseIssueUndesirableEffectList;
begin
  result := TFhirClinicalUseIssueUndesirableEffectList(inherited Clone);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueUndesirableEffectList.GetItemN(index: Integer): TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueUndesirableEffectList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssueUndesirableEffect;
end;
function TFhirClinicalUseIssueUndesirableEffectList.IndexOf(value: TFhirClinicalUseIssueUndesirableEffect): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Insert(index: Integer): TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueUndesirableEffectList.InsertItem(index: Integer; value: TFhirClinicalUseIssueUndesirableEffect);
begin
  assert(value is TFhirClinicalUseIssueUndesirableEffect);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Item(index: Integer): TFhirClinicalUseIssueUndesirableEffect;
begin
  result := TFhirClinicalUseIssueUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueUndesirableEffectList.Link: TFhirClinicalUseIssueUndesirableEffectList;
begin
  result := TFhirClinicalUseIssueUndesirableEffectList(inherited Link);
end;

procedure TFhirClinicalUseIssueUndesirableEffectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueUndesirableEffectList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssueUndesirableEffect);
begin
  assert(value is TFhirClinicalUseIssueUndesirableEffect);
  FhirClinicalUseIssueUndesirableEffects[index] := value;
end;

procedure TFhirClinicalUseIssueUndesirableEffectList.SetItemN(index: Integer; value: TFhirClinicalUseIssueUndesirableEffect);
begin
  assert(value is TFhirClinicalUseIssueUndesirableEffect);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseIssue }

constructor TFhirClinicalUseIssue.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseIssue.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCategory.free;
  FSubjectList.Free;
  FStatus.free;
  FDescription.free;
  FContraindication.free;
  FIndication.free;
  FInteraction.free;
  FPopulationList.Free;
  FUndesirableEffect.free;
  inherited;
end;

procedure TFhirClinicalUseIssue.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalUseIssue(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClinicalUseIssue(oSource).FIdentifierList);
  end;
  type_Element := TFhirClinicalUseIssue(oSource).type_Element.Clone;
  category := TFhirClinicalUseIssue(oSource).category.Clone;
  if (TFhirClinicalUseIssue(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirClinicalUseIssue(oSource).FSubjectList);
  end;
  status := TFhirClinicalUseIssue(oSource).status.Clone;
  descriptionElement := TFhirClinicalUseIssue(oSource).descriptionElement.Clone;
  contraindication := TFhirClinicalUseIssue(oSource).contraindication.Clone;
  indication := TFhirClinicalUseIssue(oSource).indication.Clone;
  interaction := TFhirClinicalUseIssue(oSource).interaction.Clone;
  if (TFhirClinicalUseIssue(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirPopulationList.Create;
    FPopulationList.Assign(TFhirClinicalUseIssue(oSource).FPopulationList);
  end;
  undesirableEffect := TFhirClinicalUseIssue(oSource).undesirableEffect.Clone;
end;

function TFhirClinicalUseIssue.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalUseIssue;
end;

procedure TFhirClinicalUseIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'contraindication') Then
     list.add(self.link, 'contraindication', FContraindication.Link);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'interaction') Then
     list.add(self.link, 'interaction', FInteraction.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'undesirableEffect') Then
     list.add(self.link, 'undesirableEffect', FUndesirableEffect.Link);
end;

procedure TFhirClinicalUseIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contraindication', 'BackboneElement', false, TFhirClinicalUseIssueContraindication, FContraindication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'indication', 'BackboneElement', false, TFhirClinicalUseIssueIndication, FIndication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'interaction', 'BackboneElement', false, TFhirClinicalUseIssueInteraction, FInteraction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'population', 'Population', true, TFhirPopulation, FPopulationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'undesirableEffect', 'BackboneElement', false, TFhirClinicalUseIssueUndesirableEffect, FUndesirableEffect.Link)); {L1172}
end;

function TFhirClinicalUseIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirClinicalUseIssueTypeEnum, CODES_TFhirClinicalUseIssueTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'contraindication') then
  begin
    Contraindication := propValue as TFhirClinicalUseIssueContraindication {L1199};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    Indication := propValue as TFhirClinicalUseIssueIndication {L1199};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    Interaction := propValue as TFhirClinicalUseIssueInteraction {L1199};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirPopulation) {L1048};
    result := propValue;
  end
  else if (propName = 'undesirableEffect') then
  begin
    UndesirableEffect := propValue as TFhirClinicalUseIssueUndesirableEffect {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirPopulation) {L1049}
  else inherited;
end;

function TFhirClinicalUseIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirClinicalUseIssueTypeEnum[ClinicalUseIssueTypeNull], CODES_TFhirClinicalUseIssueTypeEnum[ClinicalUseIssueTypeNull])  {L1211}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := SubjectList.new() {L1053}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'contraindication') then result := TFhirClinicalUseIssueContraindication.create() {L1203}
  else if (propName = 'indication') then result := TFhirClinicalUseIssueIndication.create() {L1203}
  else if (propName = 'interaction') then result := TFhirClinicalUseIssueInteraction.create() {L1203}
  else if (propName = 'population') then result := PopulationList.new() {L1053}
  else if (propName = 'undesirableEffect') then result := TFhirClinicalUseIssueUndesirableEffect.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'contraindication') then result := 'BackboneElement'
  else if (propName = 'indication') then result := 'BackboneElement'
  else if (propName = 'interaction') then result := 'BackboneElement'
  else if (propName = 'population') then result := 'Population'
  else if (propName = 'undesirableEffect') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'contraindication') then ContraindicationElement := nil
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'interaction') then InteractionElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {L1054}
  else if (propName = 'undesirableEffect') then UndesirableEffectElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirClinicalUseIssueTypeEnum, CODES_TFhirClinicalUseIssueTypeEnum, new) {L1210}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'contraindication') then ContraindicationElement := new as TFhirClinicalUseIssueContraindication {L1195}
  else if (propName = 'indication') then IndicationElement := new as TFhirClinicalUseIssueIndication {L1195}
  else if (propName = 'interaction') then InteractionElement := new as TFhirClinicalUseIssueInteraction {L1195}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {L1055}
  else if (propName = 'undesirableEffect') then UndesirableEffectElement := new as TFhirClinicalUseIssueUndesirableEffect {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'subject') then SubjectList.move(source, destination) {L1050}
  else if (propName = 'population') then PopulationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseIssue.fhirType : string;
begin
  result := 'ClinicalUseIssue';
end;

function TFhirClinicalUseIssue.Link : TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue(inherited Link);
end;

function TFhirClinicalUseIssue.Clone : TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue(inherited Clone);
end;

function TFhirClinicalUseIssue.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseIssue)) then
    result := false
  else
  begin
    o := TFhirClinicalUseIssue(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(contraindicationElement, o.contraindicationElement, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(interactionElement, o.interactionElement, true) and compareDeep(populationList, o.populationList, true) and 
      compareDeep(undesirableEffectElement, o.undesirableEffectElement, true);
  end;
end;

function TFhirClinicalUseIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FCategory) and isEmptyProp(FsubjectList) and isEmptyProp(FStatus) and isEmptyProp(FDescription) and isEmptyProp(FContraindication) and isEmptyProp(FIndication) and isEmptyProp(FInteraction) and isEmptyProp(FpopulationList) and isEmptyProp(FUndesirableEffect);
end;

function TFhirClinicalUseIssue.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClinicalUseIssue.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClinicalUseIssue.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirClinicalUseIssue.GetType_ST : TFhirClinicalUseIssueTypeEnum;
begin
  if FType_ = nil then
    result := TFhirClinicalUseIssueTypeEnum(0)
  else
    result := TFhirClinicalUseIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirClinicalUseIssueTypeEnum, FType_.value));
end;

procedure TFhirClinicalUseIssue.SetType_ST(value : TFhirClinicalUseIssueTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirClinicalUseIssueTypeEnum[value], CODES_TFhirClinicalUseIssueTypeEnum[value]);
end;

procedure TFhirClinicalUseIssue.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

function TFhirClinicalUseIssue.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirClinicalUseIssue.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirClinicalUseIssue.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirClinicalUseIssue.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirClinicalUseIssue.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirClinicalUseIssue.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirClinicalUseIssue.SetContraindication(value : TFhirClinicalUseIssueContraindication);
begin
  FContraindication.free;
  FContraindication := value; {L1134}
end;

procedure TFhirClinicalUseIssue.SetIndication(value : TFhirClinicalUseIssueIndication);
begin
  FIndication.free;
  FIndication := value; {L1134}
end;

procedure TFhirClinicalUseIssue.SetInteraction(value : TFhirClinicalUseIssueInteraction);
begin
  FInteraction.free;
  FInteraction := value; {L1134}
end;

function TFhirClinicalUseIssue.GetPopulationList : TFhirPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirPopulationList.Create;
  result := FPopulationList;
end;

function TFhirClinicalUseIssue.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirClinicalUseIssue.SetUndesirableEffect(value : TFhirClinicalUseIssueUndesirableEffect);
begin
  FUndesirableEffect.free;
  FUndesirableEffect := value; {L1134}
end;

procedure TFhirClinicalUseIssue.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('status');
  fields.add('description');
  fields.add('contraindication');
  fields.add('indication');
  fields.add('interaction');
  fields.add('population');
  fields.add('undesirableEffect');
end;

function TFhirClinicalUseIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FContraindication.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FInteraction.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FUndesirableEffect.sizeInBytes);
end;

{ TFhirClinicalUseIssueListEnumerator }

constructor TFhirClinicalUseIssueListEnumerator.Create(list : TFhirClinicalUseIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseIssueListEnumerator.GetCurrent : TFhirClinicalUseIssue;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalUseIssueList }

procedure TFhirClinicalUseIssueList.AddItem(value: TFhirClinicalUseIssue);
begin
  assert(value.ClassName = 'TFhirClinicalUseIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseIssue');
  add(value);
end;

function TFhirClinicalUseIssueList.Append: TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseIssueList.GetEnumerator : TFhirClinicalUseIssueListEnumerator;
begin
  result := TFhirClinicalUseIssueListEnumerator.Create(self.link);
end;

function TFhirClinicalUseIssueList.Clone: TFhirClinicalUseIssueList;
begin
  result := TFhirClinicalUseIssueList(inherited Clone);
end;

function TFhirClinicalUseIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseIssueList.GetItemN(index: Integer): TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseIssue;
end;
function TFhirClinicalUseIssueList.IndexOf(value: TFhirClinicalUseIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseIssueList.Insert(index: Integer): TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseIssueList.InsertItem(index: Integer; value: TFhirClinicalUseIssue);
begin
  assert(value is TFhirClinicalUseIssue);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseIssueList.Item(index: Integer): TFhirClinicalUseIssue;
begin
  result := TFhirClinicalUseIssue(ObjectByIndex[index]);
end;

function TFhirClinicalUseIssueList.Link: TFhirClinicalUseIssueList;
begin
  result := TFhirClinicalUseIssueList(inherited Link);
end;

procedure TFhirClinicalUseIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseIssueList.SetItemByIndex(index: Integer; value: TFhirClinicalUseIssue);
begin
  assert(value is TFhirClinicalUseIssue);
  FhirClinicalUseIssues[index] := value;
end;

procedure TFhirClinicalUseIssueList.SetItemN(index: Integer; value: TFhirClinicalUseIssue);
begin
  assert(value is TFhirClinicalUseIssue);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALUSEISSUE}
{$IFDEF FHIR_COMMUNICATION}
{ TFhirCommunicationPayload }

constructor TFhirCommunicationPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference|CodeableConcept', false, TFhirDataType, FContent.Link)); {L1172}
end;

function TFhirCommunicationPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then
  begin
    Content := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Content') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then ContentElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then ContentElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationPayload.fhirType : string;
begin
  result := 'Communication.payload';
end;

function TFhirCommunicationPayload.Link : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Link);
end;

function TFhirCommunicationPayload.Clone : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Clone);
end;

function TFhirCommunicationPayload.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationPayload.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value; {L1134}
end;

procedure TFhirCommunicationPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirCommunicationPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationPayloadListEnumerator }

constructor TFhirCommunicationPayloadListEnumerator.Create(list : TFhirCommunicationPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationPayloadListEnumerator.GetCurrent : TFhirCommunicationPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationPayloadList }

procedure TFhirCommunicationPayloadList.AddItem(value: TFhirCommunicationPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationPayload');
  add(value);
end;

function TFhirCommunicationPayloadList.Append: TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationPayloadList.GetEnumerator : TFhirCommunicationPayloadListEnumerator;
begin
  result := TFhirCommunicationPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationPayloadList.Clone: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Clone);
end;

function TFhirCommunicationPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationPayloadList.GetItemN(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationPayload;
end;
function TFhirCommunicationPayloadList.IndexOf(value: TFhirCommunicationPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationPayloadList.Insert(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.InsertItem(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationPayloadList.Item(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.Link: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Link);
end;

procedure TFhirCommunicationPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  FhirCommunicationPayloads[index] := value;
end;

procedure TFhirCommunicationPayloadList.SetItemN(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunication }

constructor TFhirCommunication.Create;
begin
  inherited;
end;

destructor TFhirCommunication.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FInResponseToList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FPriority.free;
  FMediumList.Free;
  FSubject.free;
  FTopic.free;
  FAboutList.Free;
  FEncounter.free;
  FSent.free;
  FReceived.free;
  FRecipientList.Free;
  FSender.free;
  FReasonList.Free;
  FPayloadList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunication(oSource).FIdentifierList);
  end;
  if (TFhirCommunication(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCommunication(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCommunication(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCommunication(oSource).FInstantiatesUriList);
  end;
  if (TFhirCommunication(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCommunication(oSource).FBasedOnList);
  end;
  if (TFhirCommunication(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirCommunication(oSource).FPartOfList);
  end;
  if (TFhirCommunication(oSource).FInResponseToList = nil) then
  begin
    FInResponseToList.free;
    FInResponseToList := nil;
  end
  else
  begin
    if FInResponseToList = nil then
      FInResponseToList := TFhirReferenceList.Create;
    FInResponseToList.Assign(TFhirCommunication(oSource).FInResponseToList);
  end;
  statusElement := TFhirCommunication(oSource).statusElement.Clone;
  statusReason := TFhirCommunication(oSource).statusReason.Clone;
  if (TFhirCommunication(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunication(oSource).FCategoryList);
  end;
  priorityElement := TFhirCommunication(oSource).priorityElement.Clone;
  if (TFhirCommunication(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunication(oSource).FMediumList);
  end;
  subject := TFhirCommunication(oSource).subject.Clone;
  topic := TFhirCommunication(oSource).topic.Clone;
  if (TFhirCommunication(oSource).FAboutList = nil) then
  begin
    FAboutList.free;
    FAboutList := nil;
  end
  else
  begin
    if FAboutList = nil then
      FAboutList := TFhirReferenceList.Create;
    FAboutList.Assign(TFhirCommunication(oSource).FAboutList);
  end;
  encounter := TFhirCommunication(oSource).encounter.Clone;
  sentElement := TFhirCommunication(oSource).sentElement.Clone;
  receivedElement := TFhirCommunication(oSource).receivedElement.Clone;
  if (TFhirCommunication(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirCommunication(oSource).FRecipientList);
  end;
  sender := TFhirCommunication(oSource).sender.Clone;
  if (TFhirCommunication(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirCommunication(oSource).FReasonList);
  end;
  if (TFhirCommunication(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationPayloadList.Create;
    FPayloadList.Assign(TFhirCommunication(oSource).FPayloadList);
  end;
  if (TFhirCommunication(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunication(oSource).FNoteList);
  end;
end;

function TFhirCommunication.GetResourceType : TFhirResourceType;
begin
  result := frtCommunication;
end;

procedure TFhirCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'inResponseTo') Then
    list.addAll(self, 'inResponseTo', FInResponseToList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'about') Then
    list.addAll(self, 'about', FAboutList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'sent') Then
     list.add(self.link, 'sent', FSent.Link);
  if (child_name = 'received') Then
     list.add(self.link, 'received', FReceived.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'inResponseTo', 'Reference', true, TFhirReference, FInResponseToList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', false, TFhirCodeableConcept, FTopic.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'about', 'Reference', true, TFhirReference, FAboutList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sent', 'dateTime', false, TFhirDateTime, FSent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'received', 'dateTime', false, TFhirDateTime, FReceived.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference', false, TFhirReference, FSender.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'payload', 'BackboneElement', true, TFhirCommunicationPayload, FPayloadList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'inResponseTo') then
  begin
    InResponseToList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    Topic := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'about') then
  begin
    AboutList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'sent') then
  begin
    SentElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'received') then
  begin
    ReceivedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationPayload) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'inResponseTo') then InResponseToList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'about') then AboutList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationPayload) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'inResponseTo') then result := InResponseToList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'medium') then result := MediumList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'topic') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'about') then result := AboutList.new() {L1053}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'sent') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'received') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'recipient') then result := RecipientList.new() {L1053}
  else if (propName = 'sender') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'payload') then result := PayloadList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'inResponseTo') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'about') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'sent') then result := 'dateTime'
  else if (propName = 'received') then result := 'dateTime'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'payload') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'inResponseTo') then deletePropertyValue('inResponseTo', InResponseToList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'about') then deletePropertyValue('about', AboutList, value) {L1054}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'sent') then SentElement := nil
  else if (propName = 'received') then ReceivedElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {L1054}
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'inResponseTo') then replacePropertyValue('inResponseTo', InResponseToList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'topic') then TopicElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'about') then replacePropertyValue('about', AboutList, existing, new) {L1055}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'sent') then SentElement := asDateTime(new) {L1222}
  else if (propName = 'received') then ReceivedElement := asDateTime(new) {L1222}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {L1055}
  else if (propName = 'sender') then SenderElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'inResponseTo') then InResponseToList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'medium') then MediumList.move(source, destination) {L1050}
  else if (propName = 'about') then AboutList.move(source, destination) {L1050}
  else if (propName = 'recipient') then RecipientList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'payload') then PayloadList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunication.fhirType : string;
begin
  result := 'Communication';
end;

function TFhirCommunication.Link : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Link);
end;

function TFhirCommunication.Clone : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Clone);
end;

function TFhirCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunication)) then
    result := false
  else
  begin
    o := TFhirCommunication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(inResponseToList, o.inResponseToList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(mediumList, o.mediumList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(aboutList, o.aboutList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(sentElement, o.sentElement, true) and 
      compareDeep(receivedElement, o.receivedElement, true) and compareDeep(recipientList, o.recipientList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(payloadList, o.payloadList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FinResponseToList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FTopic) and isEmptyProp(FaboutList) and isEmptyProp(FEncounter) and isEmptyProp(FSent) and isEmptyProp(FReceived) and isEmptyProp(FrecipientList) and isEmptyProp(FSender) and isEmptyProp(FreasonList) and isEmptyProp(FpayloadList) and isEmptyProp(FnoteList);
end;

function TFhirCommunication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCommunication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCommunication.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCommunication.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCommunication.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCommunication.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirCommunication.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCommunication.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCommunication.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirCommunication.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

function TFhirCommunication.GetInResponseToList : TFhirReferenceList;
begin
  if FInResponseToList = nil then
    FInResponseToList := TFhirReferenceList.Create;
  result := FInResponseToList;
end;

function TFhirCommunication.GetHasInResponseToList : boolean;
begin
  result := (FInResponseToList <> nil) and (FInResponseToList.count > 0);
end;

procedure TFhirCommunication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCommunication.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirCommunication.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirCommunication.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

function TFhirCommunication.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCommunication.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCommunication.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCommunication.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirCommunication.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

function TFhirCommunication.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

function TFhirCommunication.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

procedure TFhirCommunication.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirCommunication.SetTopic(value : TFhirCodeableConcept);
begin
  FTopic.free;
  FTopic := value; {L1134}
end;

function TFhirCommunication.GetAboutList : TFhirReferenceList;
begin
  if FAboutList = nil then
    FAboutList := TFhirReferenceList.Create;
  result := FAboutList;
end;

function TFhirCommunication.GetHasAboutList : boolean;
begin
  result := (FAboutList <> nil) and (FAboutList.count > 0);
end;

procedure TFhirCommunication.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirCommunication.SetSent(value : TFhirDateTime);
begin
  FSent.free;
  FSent := value; {L1134}
end;

function TFhirCommunication.GetSentST : TFslDateTime;
begin
  if FSent = nil then
    result := TFslDateTime.makeNull
  else
    result := FSent.value;
end;

procedure TFhirCommunication.SetSentST(value : TFslDateTime);
begin
  if FSent = nil then
    FSent := TFhirDateTime.create;
  FSent.value := value
end;

procedure TFhirCommunication.SetReceived(value : TFhirDateTime);
begin
  FReceived.free;
  FReceived := value; {L1134}
end;

function TFhirCommunication.GetReceivedST : TFslDateTime;
begin
  if FReceived = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceived.value;
end;

procedure TFhirCommunication.SetReceivedST(value : TFslDateTime);
begin
  if FReceived = nil then
    FReceived := TFhirDateTime.create;
  FReceived.value := value
end;

function TFhirCommunication.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirCommunication.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

procedure TFhirCommunication.SetSender(value : TFhirReference);
begin
  FSender.free;
  FSender := value; {L1134}
end;

function TFhirCommunication.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirCommunication.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirCommunication.GetPayloadList : TFhirCommunicationPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationPayloadList.Create;
  result := FPayloadList;
end;

function TFhirCommunication.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

function TFhirCommunication.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCommunication.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCommunication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('inResponseTo');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('priority');
  fields.add('medium');
  fields.add('subject');
  fields.add('topic');
  fields.add('about');
  fields.add('encounter');
  fields.add('sent');
  fields.add('received');
  fields.add('recipient');
  fields.add('sender');
  fields.add('reason');
  fields.add('payload');
  fields.add('note');
end;

function TFhirCommunication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FinResponseToList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FTopic.sizeInBytes);
  inc(result, FaboutList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FSent.sizeInBytes);
  inc(result, FReceived.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCommunicationListEnumerator }

constructor TFhirCommunicationListEnumerator.Create(list : TFhirCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationListEnumerator.GetCurrent : TFhirCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationList }

procedure TFhirCommunicationList.AddItem(value: TFhirCommunication);
begin
  assert(value.ClassName = 'TFhirCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunication');
  add(value);
end;

function TFhirCommunicationList.Append: TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationList.GetEnumerator : TFhirCommunicationListEnumerator;
begin
  result := TFhirCommunicationListEnumerator.Create(self.link);
end;

function TFhirCommunicationList.Clone: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Clone);
end;

function TFhirCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationList.GetItemN(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunication;
end;
function TFhirCommunicationList.IndexOf(value: TFhirCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationList.Insert(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.InsertItem(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  Inherited Insert(index, value);
end;

function TFhirCommunicationList.Item(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.Link: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Link);
end;

procedure TFhirCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationList.SetItemByIndex(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  FhirCommunications[index] := value;
end;

procedure TFhirCommunicationList.SetItemN(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
{ TFhirCommunicationRequestPayload }

constructor TFhirCommunicationRequestPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequestPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationRequestPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationRequestPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationRequestPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationRequestPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference|CodeableConcept', false, TFhirDataType, FContent.Link)); {L1172}
end;

function TFhirCommunicationRequestPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then
  begin
    Content := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequestPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationRequestPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Content') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequestPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequestPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then ContentElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequestPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference', 'CodeableConcept'])) then ContentElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequestPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequestPayload.fhirType : string;
begin
  result := 'CommunicationRequest.payload';
end;

function TFhirCommunicationRequestPayload.Link : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Link);
end;

function TFhirCommunicationRequestPayload.Clone : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Clone);
end;

function TFhirCommunicationRequestPayload.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationRequestPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequestPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequestPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationRequestPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationRequestPayload.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value; {L1134}
end;

procedure TFhirCommunicationRequestPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirCommunicationRequestPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadListEnumerator }

constructor TFhirCommunicationRequestPayloadListEnumerator.Create(list : TFhirCommunicationRequestPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestPayloadListEnumerator.GetCurrent : TFhirCommunicationRequestPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadList }

procedure TFhirCommunicationRequestPayloadList.AddItem(value: TFhirCommunicationRequestPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationRequestPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequestPayload');
  add(value);
end;

function TFhirCommunicationRequestPayloadList.Append: TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestPayloadList.GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
begin
  result := TFhirCommunicationRequestPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestPayloadList.Clone: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Clone);
end;

function TFhirCommunicationRequestPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestPayloadList.GetItemN(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequestPayload;
end;
function TFhirCommunicationRequestPayloadList.IndexOf(value: TFhirCommunicationRequestPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestPayloadList.Insert(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.InsertItem(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestPayloadList.Item(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.Link: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Link);
end;

procedure TFhirCommunicationRequestPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  FhirCommunicationRequestPayloads[index] := value;
end;

procedure TFhirCommunicationRequestPayloadList.SetItemN(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunicationRequest }

constructor TFhirCommunicationRequest.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FMediumList.Free;
  FSubject.free;
  FAboutList.Free;
  FEncounter.free;
  FPayloadList.Free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FRecipientList.Free;
  FInformationProviderList.Free;
  FReasonList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCommunicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunicationRequest(oSource).FIdentifierList);
  end;
  if (TFhirCommunicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCommunicationRequest(oSource).FBasedOnList);
  end;
  if (TFhirCommunicationRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirCommunicationRequest(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirCommunicationRequest(oSource).groupIdentifier.Clone;
  statusElement := TFhirCommunicationRequest(oSource).statusElement.Clone;
  statusReason := TFhirCommunicationRequest(oSource).statusReason.Clone;
  if (TFhirCommunicationRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunicationRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirCommunicationRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirCommunicationRequest(oSource).doNotPerformElement.Clone;
  if (TFhirCommunicationRequest(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunicationRequest(oSource).FMediumList);
  end;
  subject := TFhirCommunicationRequest(oSource).subject.Clone;
  if (TFhirCommunicationRequest(oSource).FAboutList = nil) then
  begin
    FAboutList.free;
    FAboutList := nil;
  end
  else
  begin
    if FAboutList = nil then
      FAboutList := TFhirReferenceList.Create;
    FAboutList.Assign(TFhirCommunicationRequest(oSource).FAboutList);
  end;
  encounter := TFhirCommunicationRequest(oSource).encounter.Clone;
  if (TFhirCommunicationRequest(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationRequestPayloadList.Create;
    FPayloadList.Assign(TFhirCommunicationRequest(oSource).FPayloadList);
  end;
  occurrence := TFhirCommunicationRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirCommunicationRequest(oSource).authoredOnElement.Clone;
  requester := TFhirCommunicationRequest(oSource).requester.Clone;
  if (TFhirCommunicationRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirCommunicationRequest(oSource).FRecipientList);
  end;
  if (TFhirCommunicationRequest(oSource).FInformationProviderList = nil) then
  begin
    FInformationProviderList.free;
    FInformationProviderList := nil;
  end
  else
  begin
    if FInformationProviderList = nil then
      FInformationProviderList := TFhirReferenceList.Create;
    FInformationProviderList.Assign(TFhirCommunicationRequest(oSource).FInformationProviderList);
  end;
  if (TFhirCommunicationRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirCommunicationRequest(oSource).FReasonList);
  end;
  if (TFhirCommunicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunicationRequest(oSource).FNoteList);
  end;
end;

function TFhirCommunicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCommunicationRequest;
end;

procedure TFhirCommunicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'about') Then
    list.addAll(self, 'about', FAboutList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'informationProvider') Then
    list.addAll(self, 'informationProvider', FInformationProviderList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'about', 'Reference', true, TFhirReference, FAboutList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payload', 'BackboneElement', true, TFhirCommunicationRequestPayload, FPayloadList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'informationProvider', 'Reference', true, TFhirReference, FInformationProviderList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirCommunicationRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'about') then
  begin
    AboutList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationRequestPayload) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'informationProvider') then
  begin
    InformationProviderList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'about') then AboutList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationRequestPayload) {L1049}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'informationProvider') then InformationProviderList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCommunicationRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'replaces') then result := ReplacesList.new() {L1053}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'medium') then result := MediumList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'about') then result := AboutList.new() {L1053}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'payload') then result := PayloadList.new() {L1053}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requester') then result := TFhirReference.create() {L1203}
  else if (propName = 'recipient') then result := RecipientList.new() {L1053}
  else if (propName = 'informationProvider') then result := InformationProviderList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'about') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'payload') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'informationProvider') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {L1054}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'about') then deletePropertyValue('about', AboutList, value) {L1054}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {L1054}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {L1054}
  else if (propName = 'informationProvider') then deletePropertyValue('informationProvider', InformationProviderList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {L1055}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new) {L1222}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'about') then replacePropertyValue('about', AboutList, existing, new) {L1055}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {L1055}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new) {L1222}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference {L1195}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {L1055}
  else if (propName = 'informationProvider') then replacePropertyValue('informationProvider', InformationProviderList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'replaces') then ReplacesList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'medium') then MediumList.move(source, destination) {L1050}
  else if (propName = 'about') then AboutList.move(source, destination) {L1050}
  else if (propName = 'payload') then PayloadList.move(source, destination) {L1050}
  else if (propName = 'recipient') then RecipientList.move(source, destination) {L1050}
  else if (propName = 'informationProvider') then InformationProviderList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequest.fhirType : string;
begin
  result := 'CommunicationRequest';
end;

function TFhirCommunicationRequest.Link : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Link);
end;

function TFhirCommunicationRequest.Clone : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Clone);
end;

function TFhirCommunicationRequest.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequest)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(mediumList, o.mediumList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(aboutList, o.aboutList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(payloadList, o.payloadList, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and 
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(recipientList, o.recipientList, true) and 
      compareDeep(informationProviderList, o.informationProviderList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FaboutList) and isEmptyProp(FEncounter) and isEmptyProp(FpayloadList) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FrecipientList) and isEmptyProp(FinformationProviderList) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList);
end;

function TFhirCommunicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCommunicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCommunicationRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCommunicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCommunicationRequest.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirCommunicationRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirCommunicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value; {L1134}
end;

procedure TFhirCommunicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCommunicationRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirCommunicationRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirCommunicationRequest.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

function TFhirCommunicationRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCommunicationRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCommunicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCommunicationRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirCommunicationRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirCommunicationRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value; {L1134}
end;

function TFhirCommunicationRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirCommunicationRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

function TFhirCommunicationRequest.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

function TFhirCommunicationRequest.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

procedure TFhirCommunicationRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

function TFhirCommunicationRequest.GetAboutList : TFhirReferenceList;
begin
  if FAboutList = nil then
    FAboutList := TFhirReferenceList.Create;
  result := FAboutList;
end;

function TFhirCommunicationRequest.GetHasAboutList : boolean;
begin
  result := (FAboutList <> nil) and (FAboutList.count > 0);
end;

procedure TFhirCommunicationRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

function TFhirCommunicationRequest.GetPayloadList : TFhirCommunicationRequestPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationRequestPayloadList.Create;
  result := FPayloadList;
end;

function TFhirCommunicationRequest.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

procedure TFhirCommunicationRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirCommunicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value; {L1134}
end;

function TFhirCommunicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirCommunicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirCommunicationRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value; {L1134}
end;

function TFhirCommunicationRequest.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirCommunicationRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

function TFhirCommunicationRequest.GetInformationProviderList : TFhirReferenceList;
begin
  if FInformationProviderList = nil then
    FInformationProviderList := TFhirReferenceList.Create;
  result := FInformationProviderList;
end;

function TFhirCommunicationRequest.GetHasInformationProviderList : boolean;
begin
  result := (FInformationProviderList <> nil) and (FInformationProviderList.count > 0);
end;

function TFhirCommunicationRequest.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirCommunicationRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirCommunicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCommunicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCommunicationRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('medium');
  fields.add('subject');
  fields.add('about');
  fields.add('encounter');
  fields.add('payload');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('recipient');
  fields.add('informationProvider');
  fields.add('reason');
  fields.add('note');
end;

function TFhirCommunicationRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FaboutList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FinformationProviderList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCommunicationRequestListEnumerator }

constructor TFhirCommunicationRequestListEnumerator.Create(list : TFhirCommunicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestListEnumerator.GetCurrent : TFhirCommunicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestList }

procedure TFhirCommunicationRequestList.AddItem(value: TFhirCommunicationRequest);
begin
  assert(value.ClassName = 'TFhirCommunicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequest');
  add(value);
end;

function TFhirCommunicationRequestList.Append: TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestList.GetEnumerator : TFhirCommunicationRequestListEnumerator;
begin
  result := TFhirCommunicationRequestListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestList.Clone: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Clone);
end;

function TFhirCommunicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestList.GetItemN(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequest;
end;
function TFhirCommunicationRequestList.IndexOf(value: TFhirCommunicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestList.Insert(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.InsertItem(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestList.Item(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.Link: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Link);
end;

procedure TFhirCommunicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  FhirCommunicationRequests[index] := value;
end;

procedure TFhirCommunicationRequestList.SetItemN(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirCompositionAttester(oSource).modeElement.Clone;
  timeElement := TFhirCompositionAttester(oSource).timeElement.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link)); {L1172}
end;

function TFhirCompositionAttester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionAttester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCompositionAttester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[CompositionAttestationModeNull], CODES_TFhirCompositionAttestationModeEnum[CompositionAttestationModeNull])  {L1211}
  else if (propName = 'time') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'party') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionAttester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionAttester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'time') then TimeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionAttester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, new) {L1210}
  else if (propName = 'time') then TimeElement := asDateTime(new) {L1222}
  else if (propName = 'party') then PartyElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionAttester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionAttester.fhirType : string;
begin
  result := 'Composition.attester';
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

function TFhirCompositionAttester.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionAttester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionAttester)) then
    result := false
  else
  begin
    o := TFhirCompositionAttester(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(timeElement, o.timeElement, true) and 
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirCompositionAttester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FTime) and isEmptyProp(FParty);
end;

procedure TFhirCompositionAttester.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeEnum;
begin
  if FMode = nil then
    result := TFhirCompositionAttestationModeEnum(0)
  else
    result := TFhirCompositionAttestationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionAttestationModeEnum, FMode.value));
end;

procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[value], CODES_TFhirCompositionAttestationModeEnum[value]);
end;

procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value; {L1134}
end;

function TFhirCompositionAttester.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirCompositionAttester.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

procedure TFhirCompositionAttester.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value; {L1134}
end;

procedure TFhirCompositionAttester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('time');
  fields.add('party');
end;

function TFhirCompositionAttester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirCompositionAttesterListEnumerator }

constructor TFhirCompositionAttesterListEnumerator.Create(list : TFhirCompositionAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionAttesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionAttesterListEnumerator.GetCurrent : TFhirCompositionAttester;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionAttesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionAttesterList }

procedure TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester);
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
end;

function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.GetEnumerator : TFhirCompositionAttesterListEnumerator;
begin
  result := TFhirCompositionAttesterListEnumerator.Create(self.link);
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionAttester;
end;
function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionRelatesTo }

constructor TFhirCompositionRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirCompositionRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirCompositionRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCompositionRelatesTo(oSource).codeElement.Clone;
  target := TFhirCompositionRelatesTo(oSource).target.Clone;
end;

procedure TFhirCompositionRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirCompositionRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'target[x]', 'Identifier|Reference', false, TFhirDataType, FTarget.Link)); {L1172}
end;

function TFhirCompositionRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then
  begin
    Target := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCompositionRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull], CODES_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull])  {L1211}
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then raise EFHIRException.create('Cannot make property Target') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target[x]') then result := 'Identifier|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new) {L1210}
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionRelatesTo.fhirType : string;
begin
  result := 'Composition.relatesTo';
end;

function TFhirCompositionRelatesTo.Link : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Link);
end;

function TFhirCompositionRelatesTo.Clone : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Clone);
end;

function TFhirCompositionRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionRelatesTo)) then
    result := false
  else
  begin
    o := TFhirCompositionRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCompositionRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirCompositionRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCompositionRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

procedure TFhirCompositionRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

procedure TFhirCompositionRelatesTo.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value; {L1134}
end;

procedure TFhirCompositionRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('target[x]');
end;

function TFhirCompositionRelatesTo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirCompositionRelatesToListEnumerator }

constructor TFhirCompositionRelatesToListEnumerator.Create(list : TFhirCompositionRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionRelatesToListEnumerator.GetCurrent : TFhirCompositionRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionRelatesToListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionRelatesToList }

procedure TFhirCompositionRelatesToList.AddItem(value: TFhirCompositionRelatesTo);
begin
  assert(value.ClassName = 'TFhirCompositionRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionRelatesTo');
  add(value);
end;

function TFhirCompositionRelatesToList.Append: TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionRelatesToList.GetEnumerator : TFhirCompositionRelatesToListEnumerator;
begin
  result := TFhirCompositionRelatesToListEnumerator.Create(self.link);
end;

function TFhirCompositionRelatesToList.Clone: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Clone);
end;

function TFhirCompositionRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionRelatesToList.GetItemN(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionRelatesTo;
end;
function TFhirCompositionRelatesToList.IndexOf(value: TFhirCompositionRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionRelatesToList.Insert(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.InsertItem(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirCompositionRelatesToList.Item(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.Link: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Link);
end;

procedure TFhirCompositionRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionRelatesToList.SetItemByIndex(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  FhirCompositionRelatesTos[index] := value;
end;

procedure TFhirCompositionRelatesToList.SetItemN(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionEvent(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  end;
  period := TFhirCompositionEvent(oSource).period.Clone;
  if (TFhirCompositionEvent(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
  end;
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link)) {L1039};
end;

function TFhirCompositionEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirCompositionEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionEvent.fhirType : string;
begin
  result := 'Composition.event';
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

function TFhirCompositionEvent.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionEvent)) then
    result := false
  else
  begin
    o := TFhirCompositionEvent(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCompositionEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FPeriod) and isEmptyProp(FdetailList);
end;

function TFhirCompositionEvent.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirCompositionEvent.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirCompositionEvent.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirCompositionEvent.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirCompositionEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('period');
  fields.add('detail');
end;

function TFhirCompositionEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirCompositionEventListEnumerator }

constructor TFhirCompositionEventListEnumerator.Create(list : TFhirCompositionEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionEventListEnumerator.GetCurrent : TFhirCompositionEvent;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionEventList }

procedure TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent);
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
end;

function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.GetEnumerator : TFhirCompositionEventListEnumerator;
begin
  result := TFhirCompositionEventListEnumerator.Create(self.link);
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionEvent;
end;
function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FAuthorList.Free;
  FFocus.free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirCompositionSection(oSource).titleElement.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  if (TFhirCompositionSection(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirCompositionSection(oSource).FAuthorList);
  end;
  focus := TFhirCompositionSection(oSource).focus.Clone;
  text := TFhirCompositionSection(oSource).text.Clone;
  modeElement := TFhirCompositionSection(oSource).modeElement.Clone;
  orderedBy := TFhirCompositionSection(oSource).orderedBy.Clone;
  if (TFhirCompositionSection(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirReferenceList.Create;
    FEntryList.Assign(TFhirCompositionSection(oSource).FEntryList);
  end;
  emptyReason := TFhirCompositionSection(oSource).emptyReason.Clone;
  if (TFhirCompositionSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
  end;
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entry', 'Reference', true, TFhirReference, FEntryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirCompositionSection, FSectionList.Link)) {L1039};
end;

function TFhirCompositionSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative {L1199};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection) {L1049}
  else inherited;
end;

function TFhirCompositionSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create() {L1223}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'author') then result := AuthorList.new() {L1053}
  else if (propName = 'focus') then result := TFhirReference.create() {L1203}
  else if (propName = 'text') then result := TFhirNarrative.create() {L1203}
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull])  {L1211}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'entry') then result := EntryList.new() {L1053}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'section') then result := SectionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entry') then result := 'Reference'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {L1054}
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {L1054}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new) {L1222}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {L1055}
  else if (propName = 'focus') then FocusElement := new as TFhirReference {L1195}
  else if (propName = 'text') then TextElement := new as TFhirNarrative {L1195}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new) {L1210}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {L1055}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination) {L1050}
  else if (propName = 'entry') then EntryList.move(source, destination) {L1050}
  else if (propName = 'section') then SectionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionSection.fhirType : string;
begin
  result := 'Composition.section';
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

function TFhirCompositionSection.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionSection)) then
    result := false
  else
  begin
    o := TFhirCompositionSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirCompositionSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FauthorList) and isEmptyProp(FFocus) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirCompositionSection.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirCompositionSection.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirCompositionSection.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value; {L1134}
end;

procedure TFhirCompositionSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value; {L1134}
end;

procedure TFhirCompositionSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCompositionSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirCompositionSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirCompositionSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value; {L1134}
end;

function TFhirCompositionSection.GetEntryList : TFhirReferenceList;
begin
  if FEntryList = nil then
    FEntryList := TFhirReferenceList.Create;
  result := FEntryList;
end;

function TFhirCompositionSection.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirCompositionSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value; {L1134}
end;

function TFhirCompositionSection.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

function TFhirCompositionSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

procedure TFhirCompositionSection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('title');
  fields.add('code');
  fields.add('author');
  fields.add('focus');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entry');
  fields.add('emptyReason');
  fields.add('section');
end;

function TFhirCompositionSection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FFocus.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionSectionListEnumerator }

constructor TFhirCompositionSectionListEnumerator.Create(list : TFhirCompositionSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionSectionListEnumerator.GetCurrent : TFhirCompositionSection;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionSectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionSectionList }

procedure TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection);
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
end;

function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.GetEnumerator : TFhirCompositionSectionListEnumerator;
begin
  result := TFhirCompositionSectionListEnumerator.Create(self.link);
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionSection;
end;
function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirComposition }

constructor TFhirComposition.Create;
begin
  inherited;
end;

destructor TFhirComposition.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FCategoryList.Free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FAuthorList.Free;
  FTitle.free;
  FConfidentiality.free;
  FAttesterList.Free;
  FCustodian.free;
  FRelatesToList.Free;
  FEventList.Free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirComposition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirComposition(oSource).identifier.Clone;
  statusElement := TFhirComposition(oSource).statusElement.Clone;
  type_ := TFhirComposition(oSource).type_.Clone;
  if (TFhirComposition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirComposition(oSource).FCategoryList);
  end;
  subject := TFhirComposition(oSource).subject.Clone;
  encounter := TFhirComposition(oSource).encounter.Clone;
  dateElement := TFhirComposition(oSource).dateElement.Clone;
  if (TFhirComposition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirComposition(oSource).FAuthorList);
  end;
  titleElement := TFhirComposition(oSource).titleElement.Clone;
  confidentialityElement := TFhirComposition(oSource).confidentialityElement.Clone;
  if (TFhirComposition(oSource).FAttesterList = nil) then
  begin
    FAttesterList.free;
    FAttesterList := nil;
  end
  else
  begin
    if FAttesterList = nil then
      FAttesterList := TFhirCompositionAttesterList.Create;
    FAttesterList.Assign(TFhirComposition(oSource).FAttesterList);
  end;
  custodian := TFhirComposition(oSource).custodian.Clone;
  if (TFhirComposition(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirCompositionRelatesToList.Create;
    FRelatesToList.Assign(TFhirComposition(oSource).FRelatesToList);
  end;
  if (TFhirComposition(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCompositionEventList.Create;
    FEventList.Assign(TFhirComposition(oSource).FEventList);
  end;
  if (TFhirComposition(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirComposition(oSource).FSectionList);
  end;
end;

function TFhirComposition.GetResourceType : TFhirResourceType;
begin
  result := frtComposition;
end;

procedure TFhirComposition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'attester') Then
    list.addAll(self, 'attester', FAttesterList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirComposition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'code', false, TFhirCode, FConfidentiality.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'attester', 'BackboneElement', true, TFhirCompositionAttester, FAttesterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference', false, TFhirReference, FCustodian.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirCompositionRelatesTo, FRelatesToList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'event', 'BackboneElement', true, TFhirCompositionEvent, FEventList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'section', 'BackboneElement', true, TFhirCompositionSection, FSectionList.Link)) {L1039};
end;

function TFhirComposition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'confidentiality') then
  begin
    ConfidentialityElement := asCode(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'attester') then
  begin
    AttesterList.add(propValue as TFhirCompositionAttester) {L1048};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirCompositionRelatesTo) {L1048};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCompositionEvent) {L1048};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirComposition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'attester') then AttesterList.insertItem(index, propValue as TFhirCompositionAttester) {L1049}
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirCompositionRelatesTo) {L1049}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCompositionEvent) {L1049}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection) {L1049}
  else inherited;
end;

function TFhirComposition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[CompositionStatusNull], CODES_TFhirCompositionStatusEnum[CompositionStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'author') then result := AuthorList.new() {L1053}
  else if (propName = 'title') then result := TFhirString.create() {L1223}
  else if (propName = 'confidentiality') then result := TFhirCode.create() {L1223}
  else if (propName = 'attester') then result := AttesterList.new() {L1053}
  else if (propName = 'custodian') then result := TFhirReference.create() {L1203}
  else if (propName = 'relatesTo') then result := RelatesToList.new() {L1053}
  else if (propName = 'event') then result := EventList.new() {L1053}
  else if (propName = 'section') then result := SectionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirComposition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'confidentiality') then result := 'code'
  else if (propName = 'attester') then result := 'BackboneElement'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'event') then result := 'BackboneElement'
  else if (propName = 'section') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirComposition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {L1054}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'attester') then deletePropertyValue('attester', AttesterList, value) {L1054}
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value) {L1054}
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {L1054}
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirComposition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {L1055}
  else if (propName = 'title') then TitleElement := asString(new) {L1222}
  else if (propName = 'confidentiality') then ConfidentialityElement := asCode(new) {L1222}
  else if (propName = 'attester') then replacePropertyValue('attester', AttesterList, existing, new) {L1055}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference {L1195}
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new) {L1055}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {L1055}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirComposition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'author') then AuthorList.move(source, destination) {L1050}
  else if (propName = 'attester') then AttesterList.move(source, destination) {L1050}
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination) {L1050}
  else if (propName = 'event') then EventList.move(source, destination) {L1050}
  else if (propName = 'section') then SectionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirComposition.fhirType : string;
begin
  result := 'Composition';
end;

function TFhirComposition.Link : TFhirComposition;
begin
  result := TFhirComposition(inherited Link);
end;

function TFhirComposition.Clone : TFhirComposition;
begin
  result := TFhirComposition(inherited Clone);
end;

function TFhirComposition.equals(other : TObject) : boolean; 
var
  o : TFhirComposition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirComposition)) then
    result := false
  else
  begin
    o := TFhirComposition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(confidentialityElement, o.confidentialityElement, true) and 
      compareDeep(attesterList, o.attesterList, true) and compareDeep(custodianElement, o.custodianElement, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(eventList, o.eventList, true) and 
      compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirComposition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FauthorList) and isEmptyProp(FTitle) and isEmptyProp(FConfidentiality) and isEmptyProp(FattesterList) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FeventList) and isEmptyProp(FsectionList);
end;

procedure TFhirComposition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirComposition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirComposition.GetStatusST : TFhirCompositionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FStatus.value));
end;

procedure TFhirComposition.SetStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

procedure TFhirComposition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirComposition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirComposition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirComposition.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirComposition.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirComposition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirComposition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirComposition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirComposition.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirComposition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirComposition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirComposition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirComposition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirComposition.SetConfidentiality(value : TFhirCode);
begin
  FConfidentiality.free;
  FConfidentiality := value; {L1134}
end;

function TFhirComposition.GetConfidentialityST : String;
begin
  if FConfidentiality = nil then
    result := ''
  else
    result := FConfidentiality.value;
end;

procedure TFhirComposition.SetConfidentialityST(value : String);
begin
  if value <> '' then
  begin
    if FConfidentiality = nil then
      FConfidentiality := TFhirCode.create;
    FConfidentiality.value := value
  end
  else if FConfidentiality <> nil then
    FConfidentiality.value := '';
end;

function TFhirComposition.GetAttesterList : TFhirCompositionAttesterList;
begin
  if FAttesterList = nil then
    FAttesterList := TFhirCompositionAttesterList.Create;
  result := FAttesterList;
end;

function TFhirComposition.GetHasAttesterList : boolean;
begin
  result := (FAttesterList <> nil) and (FAttesterList.count > 0);
end;

procedure TFhirComposition.SetCustodian(value : TFhirReference);
begin
  FCustodian.free;
  FCustodian := value; {L1134}
end;

function TFhirComposition.GetRelatesToList : TFhirCompositionRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirCompositionRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirComposition.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

function TFhirComposition.GetEventList : TFhirCompositionEventList;
begin
  if FEventList = nil then
    FEventList := TFhirCompositionEventList.Create;
  result := FEventList;
end;

function TFhirComposition.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

function TFhirComposition.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

function TFhirComposition.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

procedure TFhirComposition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('author');
  fields.add('title');
  fields.add('confidentiality');
  fields.add('attester');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('event');
  fields.add('section');
end;

function TFhirComposition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FConfidentiality.sizeInBytes);
  inc(result, FattesterList.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FrelatesToList.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionListEnumerator }

constructor TFhirCompositionListEnumerator.Create(list : TFhirCompositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionListEnumerator.GetCurrent : TFhirComposition;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionList }

procedure TFhirCompositionList.AddItem(value: TFhirComposition);
begin
  assert(value.ClassName = 'TFhirComposition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirComposition');
  add(value);
end;

function TFhirCompositionList.Append: TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionList.GetEnumerator : TFhirCompositionListEnumerator;
begin
  result := TFhirCompositionListEnumerator.Create(self.link);
end;

function TFhirCompositionList.Clone: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Clone);
end;

function TFhirCompositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionList.GetItemN(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirComposition;
end;
function TFhirCompositionList.IndexOf(value: TFhirComposition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionList.Insert(index: Integer): TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.InsertItem(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  Inherited Insert(index, value);
end;

function TFhirCompositionList.Item(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.Link: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Link);
end;

procedure TFhirCompositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionList.SetItemByIndex(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  FhirCompositions[index] := value;
end;

procedure TFhirCompositionList.SetItemN(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  FType_.free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TFslObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  if (TFhirConditionStage(oSource).FAssessmentList = nil) then
  begin
    FAssessmentList.free;
    FAssessmentList := nil;
  end
  else
  begin
    if FAssessmentList = nil then
      FAssessmentList := TFhirReferenceList.Create;
    FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
  end;
  type_ := TFhirConditionStage(oSource).type_.Clone;
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'assessment') Then
    list.addAll(self, 'assessment', FAssessmentList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', false, TFhirCodeableConcept, FSummary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Reference', true, TFhirReference, FAssessmentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
end;

function TFhirConditionStage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'summary') then
  begin
    Summary := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'assessment') then
  begin
    AssessmentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionStage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'assessment') then AssessmentList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirConditionStage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'summary') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'assessment') then result := AssessmentList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionStage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'summary') then result := 'CodeableConcept'
  else if (propName = 'assessment') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionStage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'assessment') then deletePropertyValue('assessment', AssessmentList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionStage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'assessment') then replacePropertyValue('assessment', AssessmentList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionStage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'assessment') then AssessmentList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionStage.fhirType : string;
begin
  result := 'Condition.stage';
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

function TFhirConditionStage.equals(other : TObject) : boolean; 
var
  o : TFhirConditionStage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionStage)) then
    result := false
  else
  begin
    o := TFhirConditionStage(other);
    result := compareDeep(summaryElement, o.summaryElement, true) and compareDeep(assessmentList, o.assessmentList, true) and 
      compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirConditionStage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSummary) and isEmptyProp(FassessmentList) and isEmptyProp(FType_);
end;

procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value; {L1134}
end;

function TFhirConditionStage.GetAssessmentList : TFhirReferenceList;
begin
  if FAssessmentList = nil then
    FAssessmentList := TFhirReferenceList.Create;
  result := FAssessmentList;
end;

function TFhirConditionStage.GetHasAssessmentList : boolean;
begin
  result := (FAssessmentList <> nil) and (FAssessmentList.count > 0);
end;

procedure TFhirConditionStage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirConditionStage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('summary');
  fields.add('assessment');
  fields.add('type');
end;

function TFhirConditionStage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSummary.sizeInBytes);
  inc(result, FassessmentList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirConditionStageListEnumerator }

constructor TFhirConditionStageListEnumerator.Create(list : TFhirConditionStageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionStageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionStageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionStageListEnumerator.GetCurrent : TFhirConditionStage;
begin
  Result := FList[FIndex];
end;

function TFhirConditionStageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionStageList }

procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;

function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.GetEnumerator : TFhirConditionStageListEnumerator;
begin
  result := TFhirConditionStageListEnumerator.Create(self.link);
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionStage;
end;
function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCodeList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConditionEvidence(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConditionEvidence(oSource).FCodeList);
  end;
  if (TFhirConditionEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link)) {L1039};
end;

function TFhirConditionEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirConditionEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionEvidence.fhirType : string;
begin
  result := 'Condition.evidence';
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

function TFhirConditionEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirConditionEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionEvidence)) then
    result := false
  else
  begin
    o := TFhirConditionEvidence(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirConditionEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FdetailList);
end;

function TFhirConditionEvidence.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirConditionEvidence.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirConditionEvidence.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirConditionEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirConditionEvidence.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

function TFhirConditionEvidence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirConditionEvidenceListEnumerator }

constructor TFhirConditionEvidenceListEnumerator.Create(list : TFhirConditionEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionEvidenceListEnumerator.GetCurrent : TFhirConditionEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirConditionEvidenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionEvidenceList }

procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;

function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.GetEnumerator : TFhirConditionEvidenceListEnumerator;
begin
  result := TFhirConditionEvidenceListEnumerator.Create(self.link);
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionEvidence;
end;
function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirCondition }

constructor TFhirCondition.Create;
begin
  inherited;
end;

destructor TFhirCondition.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FCategoryList.Free;
  FSeverity.free;
  FCode.free;
  FBodySiteList.Free;
  FSubject.free;
  FEncounter.free;
  FOnset.free;
  FAbatement.free;
  FRecordedDate.free;
  FRecorder.free;
  FAsserter.free;
  FStageList.Free;
  FEvidenceList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCondition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCondition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCondition(oSource).FIdentifierList);
  end;
  clinicalStatus := TFhirCondition(oSource).clinicalStatus.Clone;
  verificationStatus := TFhirCondition(oSource).verificationStatus.Clone;
  if (TFhirCondition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCondition(oSource).FCategoryList);
  end;
  severity := TFhirCondition(oSource).severity.Clone;
  code := TFhirCondition(oSource).code.Clone;
  if (TFhirCondition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirCondition(oSource).FBodySiteList);
  end;
  subject := TFhirCondition(oSource).subject.Clone;
  encounter := TFhirCondition(oSource).encounter.Clone;
  onset := TFhirCondition(oSource).onset.Clone;
  abatement := TFhirCondition(oSource).abatement.Clone;
  recordedDateElement := TFhirCondition(oSource).recordedDateElement.Clone;
  recorder := TFhirCondition(oSource).recorder.Clone;
  asserter := TFhirCondition(oSource).asserter.Clone;
  if (TFhirCondition(oSource).FStageList = nil) then
  begin
    FStageList.free;
    FStageList := nil;
  end
  else
  begin
    if FStageList = nil then
      FStageList := TFhirConditionStageList.Create;
    FStageList.Assign(TFhirCondition(oSource).FStageList);
  end;
  if (TFhirCondition(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirConditionEvidenceList.Create;
    FEvidenceList.Assign(TFhirCondition(oSource).FEvidenceList);
  end;
  if (TFhirCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCondition(oSource).FNoteList);
  end;
end;

function TFhirCondition.GetResourceType : TFhirResourceType;
begin
  result := frtCondition;
end;

procedure TFhirCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'abatement[x]') or (child_name = 'abatement') Then
     list.add(self.link, 'abatement[x]', FAbatement.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'stage') Then
    list.addAll(self, 'stage', FStageList);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FClinicalStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FVerificationStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'severity', 'CodeableConcept', false, TFhirCodeableConcept, FSeverity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FOnset.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'abatement[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FAbatement.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'stage', 'BackboneElement', true, TFhirConditionStage, FStageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'evidence', 'BackboneElement', true, TFhirConditionEvidence, FEvidenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    Severity := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Abatement := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'stage') then
  begin
    StageList.add(propValue as TFhirConditionStage) {L1048};
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirConditionEvidence) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'stage') then StageList.insertItem(index, propValue as TFhirConditionStage) {L1049}
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirConditionEvidence) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'clinicalStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'verificationStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'severity') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'bodySite') then result := BodySiteList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset') {L1191}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Abatement') {L1191}
  else if (propName = 'recordedDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'recorder') then result := TFhirReference.create() {L1203}
  else if (propName = 'asserter') then result := TFhirReference.create() {L1203}
  else if (propName = 'stage') then result := StageList.new() {L1053}
  else if (propName = 'evidence') then result := EvidenceList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'CodeableConcept'
  else if (propName = 'verificationStatus') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'abatement[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'stage') then result := 'BackboneElement'
  else if (propName = 'evidence') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil {L1189}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then AbatementElement := nil {L1189}
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'stage') then deletePropertyValue('stage', StageList, value) {L1054}
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'verificationStatus') then VerificationStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'severity') then SeverityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then AbatementElement := new as TFhirDataType {L1190}
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new) {L1222}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference {L1195}
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference {L1195}
  else if (propName = 'stage') then replacePropertyValue('stage', StageList, existing, new) {L1055}
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination) {L1050}
  else if (propName = 'stage') then StageList.move(source, destination) {L1050}
  else if (propName = 'evidence') then EvidenceList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCondition.fhirType : string;
begin
  result := 'Condition';
end;

function TFhirCondition.Link : TFhirCondition;
begin
  result := TFhirCondition(inherited Link);
end;

function TFhirCondition.Clone : TFhirCondition;
begin
  result := TFhirCondition(inherited Clone);
end;

function TFhirCondition.equals(other : TObject) : boolean; 
var
  o : TFhirCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCondition)) then
    result := false
  else
  begin
    o := TFhirCondition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and 
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(severityElement, o.severityElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(bodySiteList, o.bodySiteList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(abatementElement, o.abatementElement, true) and 
      compareDeep(recordedDateElement, o.recordedDateElement, true) and compareDeep(recorderElement, o.recorderElement, true) and 
      compareDeep(asserterElement, o.asserterElement, true) and compareDeep(stageList, o.stageList, true) and 
      compareDeep(evidenceList, o.evidenceList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FbodySiteList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOnset) and isEmptyProp(FAbatement) and isEmptyProp(FRecordedDate) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FstageList) and isEmptyProp(FevidenceList) and isEmptyProp(FnoteList);
end;

function TFhirCondition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCondition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCondition.SetClinicalStatus(value : TFhirCodeableConcept);
begin
  FClinicalStatus.free;
  FClinicalStatus := value; {L1134}
end;

procedure TFhirCondition.SetVerificationStatus(value : TFhirCodeableConcept);
begin
  FVerificationStatus.free;
  FVerificationStatus := value; {L1134}
end;

function TFhirCondition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCondition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCondition.SetSeverity(value : TFhirCodeableConcept);
begin
  FSeverity.free;
  FSeverity := value; {L1134}
end;

procedure TFhirCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirCondition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirCondition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

procedure TFhirCondition.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirCondition.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirCondition.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value; {L1134}
end;

procedure TFhirCondition.SetAbatement(value : TFhirDataType);
begin
  FAbatement.free;
  FAbatement := value; {L1134}
end;

procedure TFhirCondition.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value; {L1134}
end;

function TFhirCondition.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirCondition.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

procedure TFhirCondition.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value; {L1134}
end;

procedure TFhirCondition.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value; {L1134}
end;

function TFhirCondition.GetStageList : TFhirConditionStageList;
begin
  if FStageList = nil then
    FStageList := TFhirConditionStageList.Create;
  result := FStageList;
end;

function TFhirCondition.GetHasStageList : boolean;
begin
  result := (FStageList <> nil) and (FStageList.count > 0);
end;

function TFhirCondition.GetEvidenceList : TFhirConditionEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirConditionEvidenceList.Create;
  result := FEvidenceList;
end;

function TFhirCondition.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

function TFhirCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCondition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('category');
  fields.add('severity');
  fields.add('code');
  fields.add('bodySite');
  fields.add('subject');
  fields.add('encounter');
  fields.add('onset[x]');
  fields.add('abatement[x]');
  fields.add('recordedDate');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('stage');
  fields.add('evidence');
  fields.add('note');
end;

function TFhirCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FClinicalStatus.sizeInBytes);
  inc(result, FVerificationStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FAbatement.sizeInBytes);
  inc(result, FRecordedDate.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FAsserter.sizeInBytes);
  inc(result, FstageList.sizeInBytes);
  inc(result, FevidenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirConditionListEnumerator }

constructor TFhirConditionListEnumerator.Create(list : TFhirConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionListEnumerator.GetCurrent : TFhirCondition;
begin
  Result := FList[FIndex];
end;

function TFhirConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionList }

procedure TFhirConditionList.AddItem(value: TFhirCondition);
begin
  assert(value.ClassName = 'TFhirCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCondition');
  add(value);
end;

function TFhirConditionList.Append: TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.ClearItems;
begin
  Clear;
end;

function TFhirConditionList.GetEnumerator : TFhirConditionListEnumerator;
begin
  result := TFhirConditionListEnumerator.Create(self.link);
end;

function TFhirConditionList.Clone: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Clone);
end;

function TFhirConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionList.GetItemN(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCondition;
end;
function TFhirConditionList.IndexOf(value: TFhirCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionList.Insert(index: Integer): TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.InsertItem(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  Inherited Insert(index, value);
end;

function TFhirConditionList.Item(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.Link: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Link);
end;

procedure TFhirConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionList.SetItemByIndex(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  FhirConditions[index] := value;
end;

procedure TFhirConditionList.SetItemN(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
{ TFhirDetectedIssueEvidence }

constructor TFhirDetectedIssueEvidence.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueEvidence.Destroy;
begin
  FCodeList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirDetectedIssueEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDetectedIssueEvidence(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirDetectedIssueEvidence(oSource).FCodeList);
  end;
  if (TFhirDetectedIssueEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirDetectedIssueEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirDetectedIssueEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirDetectedIssueEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link)) {L1039};
end;

function TFhirDetectedIssueEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirDetectedIssueEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueEvidence.fhirType : string;
begin
  result := 'DetectedIssue.evidence';
end;

function TFhirDetectedIssueEvidence.Link : TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(inherited Link);
end;

function TFhirDetectedIssueEvidence.Clone : TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(inherited Clone);
end;

function TFhirDetectedIssueEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssueEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueEvidence)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueEvidence(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirDetectedIssueEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FdetailList);
end;

function TFhirDetectedIssueEvidence.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirDetectedIssueEvidence.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirDetectedIssueEvidence.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirDetectedIssueEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirDetectedIssueEvidence.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

function TFhirDetectedIssueEvidence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirDetectedIssueEvidenceListEnumerator }

constructor TFhirDetectedIssueEvidenceListEnumerator.Create(list : TFhirDetectedIssueEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueEvidenceListEnumerator.GetCurrent : TFhirDetectedIssueEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueEvidenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueEvidenceList }

procedure TFhirDetectedIssueEvidenceList.AddItem(value: TFhirDetectedIssueEvidence);
begin
  assert(value.ClassName = 'TFhirDetectedIssueEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueEvidence');
  add(value);
end;

function TFhirDetectedIssueEvidenceList.Append: TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueEvidenceList.GetEnumerator : TFhirDetectedIssueEvidenceListEnumerator;
begin
  result := TFhirDetectedIssueEvidenceListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueEvidenceList.Clone: TFhirDetectedIssueEvidenceList;
begin
  result := TFhirDetectedIssueEvidenceList(inherited Clone);
end;

function TFhirDetectedIssueEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueEvidenceList.GetItemN(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(ObjectByIndex[index]);
end;

function TFhirDetectedIssueEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueEvidence;
end;
function TFhirDetectedIssueEvidenceList.IndexOf(value: TFhirDetectedIssueEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueEvidenceList.Insert(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueEvidenceList.InsertItem(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueEvidenceList.Item(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(ObjectByIndex[index]);
end;

function TFhirDetectedIssueEvidenceList.Link: TFhirDetectedIssueEvidenceList;
begin
  result := TFhirDetectedIssueEvidenceList(inherited Link);
end;

procedure TFhirDetectedIssueEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueEvidenceList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  FhirDetectedIssueEvidences[index] := value;
end;

procedure TFhirDetectedIssueEvidenceList.SetItemN(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssueMitigation }

constructor TFhirDetectedIssueMitigation.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueMitigation.Destroy;
begin
  FAction.free;
  FDate.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirDetectedIssueMitigation.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirDetectedIssueMitigation(oSource).action.Clone;
  dateElement := TFhirDetectedIssueMitigation(oSource).dateElement.Clone;
  author := TFhirDetectedIssueMitigation(oSource).author.Clone;
end;

procedure TFhirDetectedIssueMitigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirDetectedIssueMitigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
end;

function TFhirDetectedIssueMitigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueMitigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDetectedIssueMitigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueMitigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueMitigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueMitigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueMitigation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueMitigation.fhirType : string;
begin
  result := 'DetectedIssue.mitigation';
end;

function TFhirDetectedIssueMitigation.Link : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Link);
end;

function TFhirDetectedIssueMitigation.Clone : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Clone);
end;

function TFhirDetectedIssueMitigation.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssueMitigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueMitigation)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueMitigation(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirDetectedIssueMitigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FDate) and isEmptyProp(FAuthor);
end;

procedure TFhirDetectedIssueMitigation.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value; {L1134}
end;

procedure TFhirDetectedIssueMitigation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirDetectedIssueMitigation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirDetectedIssueMitigation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirDetectedIssueMitigation.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

procedure TFhirDetectedIssueMitigation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('date');
  fields.add('author');
end;

function TFhirDetectedIssueMitigation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationListEnumerator }

constructor TFhirDetectedIssueMitigationListEnumerator.Create(list : TFhirDetectedIssueMitigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueMitigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueMitigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueMitigationListEnumerator.GetCurrent : TFhirDetectedIssueMitigation;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueMitigationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationList }

procedure TFhirDetectedIssueMitigationList.AddItem(value: TFhirDetectedIssueMitigation);
begin
  assert(value.ClassName = 'TFhirDetectedIssueMitigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueMitigation');
  add(value);
end;

function TFhirDetectedIssueMitigationList.Append: TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueMitigationList.GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
begin
  result := TFhirDetectedIssueMitigationListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueMitigationList.Clone: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Clone);
end;

function TFhirDetectedIssueMitigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueMitigationList.GetItemN(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueMitigation;
end;
function TFhirDetectedIssueMitigationList.IndexOf(value: TFhirDetectedIssueMitigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueMitigationList.Insert(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.InsertItem(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueMitigationList.Item(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.Link: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Link);
end;

procedure TFhirDetectedIssueMitigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueMitigationList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  FhirDetectedIssueMitigations[index] := value;
end;

procedure TFhirDetectedIssueMitigationList.SetItemN(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssue }

constructor TFhirDetectedIssue.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssue.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCode.free;
  FSeverity.free;
  FPatient.free;
  FIdentified.free;
  FAuthor.free;
  FImplicatedList.Free;
  FEvidenceList.Free;
  FDetail.free;
  FReference.free;
  FMitigationList.Free;
  inherited;
end;

procedure TFhirDetectedIssue.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDetectedIssue(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDetectedIssue(oSource).FIdentifierList);
  end;
  statusElement := TFhirDetectedIssue(oSource).statusElement.Clone;
  code := TFhirDetectedIssue(oSource).code.Clone;
  severityElement := TFhirDetectedIssue(oSource).severityElement.Clone;
  patient := TFhirDetectedIssue(oSource).patient.Clone;
  identified := TFhirDetectedIssue(oSource).identified.Clone;
  author := TFhirDetectedIssue(oSource).author.Clone;
  if (TFhirDetectedIssue(oSource).FImplicatedList = nil) then
  begin
    FImplicatedList.free;
    FImplicatedList := nil;
  end
  else
  begin
    if FImplicatedList = nil then
      FImplicatedList := TFhirReferenceList.Create;
    FImplicatedList.Assign(TFhirDetectedIssue(oSource).FImplicatedList);
  end;
  if (TFhirDetectedIssue(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirDetectedIssueEvidenceList.Create;
    FEvidenceList.Assign(TFhirDetectedIssue(oSource).FEvidenceList);
  end;
  detailElement := TFhirDetectedIssue(oSource).detailElement.Clone;
  referenceElement := TFhirDetectedIssue(oSource).referenceElement.Clone;
  if (TFhirDetectedIssue(oSource).FMitigationList = nil) then
  begin
    FMitigationList.free;
    FMitigationList := nil;
  end
  else
  begin
    if FMitigationList = nil then
      FMitigationList := TFhirDetectedIssueMitigationList.Create;
    FMitigationList.Assign(TFhirDetectedIssue(oSource).FMitigationList);
  end;
end;

function TFhirDetectedIssue.GetResourceType : TFhirResourceType;
begin
  result := frtDetectedIssue;
end;

procedure TFhirDetectedIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'identified[x]') or (child_name = 'identified') Then
     list.add(self.link, 'identified[x]', FIdentified.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'implicated') Then
    list.addAll(self, 'implicated', FImplicatedList);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'mitigation') Then
    list.addAll(self, 'mitigation', FMitigationList);
end;

procedure TFhirDetectedIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identified[x]', 'dateTime|Period', false, TFhirDataType, FIdentified.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'implicated', 'Reference', true, TFhirReference, FImplicatedList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'evidence', 'BackboneElement', true, TFhirDetectedIssueEvidence, FEvidenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'mitigation', 'BackboneElement', true, TFhirDetectedIssueMitigation, FMitigationList.Link)) {L1039};
end;

function TFhirDetectedIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirDetectedIssueSeverityEnum, CODES_TFhirDetectedIssueSeverityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then
  begin
    Identified := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'implicated') then
  begin
    ImplicatedList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirDetectedIssueEvidence) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationList.add(propValue as TFhirDetectedIssueMitigation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'implicated') then ImplicatedList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirDetectedIssueEvidence) {L1049}
  else if (propName = 'mitigation') then MitigationList.insertItem(index, propValue as TFhirDetectedIssueMitigation) {L1049}
  else inherited;
end;

function TFhirDetectedIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull])  {L1211}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirDetectedIssueSeverityEnum[DetectedIssueSeverityNull], CODES_TFhirDetectedIssueSeverityEnum[DetectedIssueSeverityNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Identified') {L1191}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else if (propName = 'implicated') then result := ImplicatedList.new() {L1053}
  else if (propName = 'evidence') then result := EvidenceList.new() {L1053}
  else if (propName = 'detail') then result := TFhirString.create() {L1223}
  else if (propName = 'reference') then result := TFhirUri.create() {L1223}
  else if (propName = 'mitigation') then result := MitigationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'identified[x]') then result := 'dateTime|Period'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'implicated') then result := 'Reference'
  else if (propName = 'evidence') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'mitigation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then IdentifiedElement := nil {L1189}
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'implicated') then deletePropertyValue('implicated', ImplicatedList, value) {L1054}
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value) {L1054}
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'mitigation') then deletePropertyValue('mitigation', MitigationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new) {L1210}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirDetectedIssueSeverityEnum, CODES_TFhirDetectedIssueSeverityEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then IdentifiedElement := new as TFhirDataType {L1190}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else if (propName = 'implicated') then replacePropertyValue('implicated', ImplicatedList, existing, new) {L1055}
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new) {L1055}
  else if (propName = 'detail') then DetailElement := asString(new) {L1222}
  else if (propName = 'reference') then ReferenceElement := asUri(new) {L1222}
  else if (propName = 'mitigation') then replacePropertyValue('mitigation', MitigationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'implicated') then ImplicatedList.move(source, destination) {L1050}
  else if (propName = 'evidence') then EvidenceList.move(source, destination) {L1050}
  else if (propName = 'mitigation') then MitigationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssue.fhirType : string;
begin
  result := 'DetectedIssue';
end;

function TFhirDetectedIssue.Link : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Link);
end;

function TFhirDetectedIssue.Clone : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Clone);
end;

function TFhirDetectedIssue.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssue)) then
    result := false
  else
  begin
    o := TFhirDetectedIssue(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(severityElement, o.severityElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(identifiedElement, o.identifiedElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(implicatedList, o.implicatedList, true) and 
      compareDeep(evidenceList, o.evidenceList, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(mitigationList, o.mitigationList, true);
  end;
end;

function TFhirDetectedIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCode) and isEmptyProp(FSeverity) and isEmptyProp(FPatient) and isEmptyProp(FIdentified) and isEmptyProp(FAuthor) and isEmptyProp(FimplicatedList) and isEmptyProp(FevidenceList) and isEmptyProp(FDetail) and isEmptyProp(FReference) and isEmptyProp(FmitigationList);
end;

function TFhirDetectedIssue.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDetectedIssue.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDetectedIssue.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDetectedIssue.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirDetectedIssue.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

procedure TFhirDetectedIssue.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirDetectedIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirDetectedIssue.GetSeverityST : TFhirDetectedIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirDetectedIssueSeverityEnum(0)
  else
    result := TFhirDetectedIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirDetectedIssueSeverityEnum, FSeverity.value));
end;

procedure TFhirDetectedIssue.SetSeverityST(value : TFhirDetectedIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirDetectedIssueSeverityEnum[value], CODES_TFhirDetectedIssueSeverityEnum[value]);
end;

procedure TFhirDetectedIssue.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirDetectedIssue.SetIdentified(value : TFhirDataType);
begin
  FIdentified.free;
  FIdentified := value; {L1134}
end;

procedure TFhirDetectedIssue.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

function TFhirDetectedIssue.GetImplicatedList : TFhirReferenceList;
begin
  if FImplicatedList = nil then
    FImplicatedList := TFhirReferenceList.Create;
  result := FImplicatedList;
end;

function TFhirDetectedIssue.GetHasImplicatedList : boolean;
begin
  result := (FImplicatedList <> nil) and (FImplicatedList.count > 0);
end;

function TFhirDetectedIssue.GetEvidenceList : TFhirDetectedIssueEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirDetectedIssueEvidenceList.Create;
  result := FEvidenceList;
end;

function TFhirDetectedIssue.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

procedure TFhirDetectedIssue.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value; {L1134}
end;

function TFhirDetectedIssue.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirDetectedIssue.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

procedure TFhirDetectedIssue.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value; {L1134}
end;

function TFhirDetectedIssue.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

procedure TFhirDetectedIssue.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

function TFhirDetectedIssue.GetMitigationList : TFhirDetectedIssueMitigationList;
begin
  if FMitigationList = nil then
    FMitigationList := TFhirDetectedIssueMitigationList.Create;
  result := FMitigationList;
end;

function TFhirDetectedIssue.GetHasMitigationList : boolean;
begin
  result := (FMitigationList <> nil) and (FMitigationList.count > 0);
end;

procedure TFhirDetectedIssue.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('code');
  fields.add('severity');
  fields.add('patient');
  fields.add('identified[x]');
  fields.add('author');
  fields.add('implicated');
  fields.add('evidence');
  fields.add('detail');
  fields.add('reference');
  fields.add('mitigation');
end;

function TFhirDetectedIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FIdentified.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FimplicatedList.sizeInBytes);
  inc(result, FevidenceList.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FmitigationList.sizeInBytes);
end;

{ TFhirDetectedIssueListEnumerator }

constructor TFhirDetectedIssueListEnumerator.Create(list : TFhirDetectedIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueListEnumerator.GetCurrent : TFhirDetectedIssue;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueList }

procedure TFhirDetectedIssueList.AddItem(value: TFhirDetectedIssue);
begin
  assert(value.ClassName = 'TFhirDetectedIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssue');
  add(value);
end;

function TFhirDetectedIssueList.Append: TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueList.GetEnumerator : TFhirDetectedIssueListEnumerator;
begin
  result := TFhirDetectedIssueListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueList.Clone: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Clone);
end;

function TFhirDetectedIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueList.GetItemN(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssue;
end;
function TFhirDetectedIssueList.IndexOf(value: TFhirDetectedIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueList.Insert(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.InsertItem(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueList.Item(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.Link: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Link);
end;

procedure TFhirDetectedIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueList.SetItemByIndex(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  FhirDetectedIssues[index] := value;
end;

procedure TFhirDetectedIssueList.SetItemN(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
{ TFhirDeviceRequestParameter }

constructor TFhirDeviceRequestParameter.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequestParameter.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceRequestParameter.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirDeviceRequestParameter(oSource).code.Clone;
  value := TFhirDeviceRequestParameter(oSource).value.Clone;
end;

procedure TFhirDeviceRequestParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirDeviceRequestParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range|boolean', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirDeviceRequestParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceRequestParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceRequestParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequestParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequestParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequestParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequestParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequestParameter.fhirType : string;
begin
  result := 'DeviceRequest.parameter';
end;

function TFhirDeviceRequestParameter.Link : TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(inherited Link);
end;

function TFhirDeviceRequestParameter.Clone : TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(inherited Clone);
end;

function TFhirDeviceRequestParameter.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceRequestParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequestParameter)) then
    result := false
  else
  begin
    o := TFhirDeviceRequestParameter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceRequestParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirDeviceRequestParameter.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirDeviceRequestParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirDeviceRequestParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirDeviceRequestParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirDeviceRequestParameterListEnumerator }

constructor TFhirDeviceRequestParameterListEnumerator.Create(list : TFhirDeviceRequestParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestParameterListEnumerator.GetCurrent : TFhirDeviceRequestParameter;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceRequestParameterList }

procedure TFhirDeviceRequestParameterList.AddItem(value: TFhirDeviceRequestParameter);
begin
  assert(value.ClassName = 'TFhirDeviceRequestParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequestParameter');
  add(value);
end;

function TFhirDeviceRequestParameterList.Append: TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestParameterList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestParameterList.GetEnumerator : TFhirDeviceRequestParameterListEnumerator;
begin
  result := TFhirDeviceRequestParameterListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestParameterList.Clone: TFhirDeviceRequestParameterList;
begin
  result := TFhirDeviceRequestParameterList(inherited Clone);
end;

function TFhirDeviceRequestParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestParameterList.GetItemN(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(ObjectByIndex[index]);
end;

function TFhirDeviceRequestParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequestParameter;
end;
function TFhirDeviceRequestParameterList.IndexOf(value: TFhirDeviceRequestParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestParameterList.Insert(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestParameterList.InsertItem(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestParameterList.Item(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(ObjectByIndex[index]);
end;

function TFhirDeviceRequestParameterList.Link: TFhirDeviceRequestParameterList;
begin
  result := TFhirDeviceRequestParameterList(inherited Link);
end;

procedure TFhirDeviceRequestParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestParameterList.SetItemByIndex(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  FhirDeviceRequestParameters[index] := value;
end;

procedure TFhirDeviceRequestParameterList.SetItemN(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceRequest }

constructor TFhirDeviceRequest.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequest.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPriorRequestList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FParameterList.Free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformer.free;
  FReasonList.Free;
  FInsuranceList.Free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  inherited;
end;

procedure TFhirDeviceRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceRequest(oSource).FIdentifierList);
  end;
  if (TFhirDeviceRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirDeviceRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirDeviceRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirDeviceRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirDeviceRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDeviceRequest(oSource).FBasedOnList);
  end;
  if (TFhirDeviceRequest(oSource).FPriorRequestList = nil) then
  begin
    FPriorRequestList.free;
    FPriorRequestList := nil;
  end
  else
  begin
    if FPriorRequestList = nil then
      FPriorRequestList := TFhirReferenceList.Create;
    FPriorRequestList.Assign(TFhirDeviceRequest(oSource).FPriorRequestList);
  end;
  groupIdentifier := TFhirDeviceRequest(oSource).groupIdentifier.Clone;
  statusElement := TFhirDeviceRequest(oSource).statusElement.Clone;
  intentElement := TFhirDeviceRequest(oSource).intentElement.Clone;
  priorityElement := TFhirDeviceRequest(oSource).priorityElement.Clone;
  code := TFhirDeviceRequest(oSource).code.Clone;
  if (TFhirDeviceRequest(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirDeviceRequestParameterList.Create;
    FParameterList.Assign(TFhirDeviceRequest(oSource).FParameterList);
  end;
  subject := TFhirDeviceRequest(oSource).subject.Clone;
  encounter := TFhirDeviceRequest(oSource).encounter.Clone;
  occurrence := TFhirDeviceRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirDeviceRequest(oSource).authoredOnElement.Clone;
  requester := TFhirDeviceRequest(oSource).requester.Clone;
  performerType := TFhirDeviceRequest(oSource).performerType.Clone;
  performer := TFhirDeviceRequest(oSource).performer.Clone;
  if (TFhirDeviceRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirDeviceRequest(oSource).FReasonList);
  end;
  if (TFhirDeviceRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirDeviceRequest(oSource).FInsuranceList);
  end;
  if (TFhirDeviceRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirDeviceRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirDeviceRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceRequest(oSource).FNoteList);
  end;
  if (TFhirDeviceRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirDeviceRequest(oSource).FRelevantHistoryList);
  end;
end;

function TFhirDeviceRequest.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceRequest;
end;

procedure TFhirDeviceRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'priorRequest') Then
    list.addAll(self, 'priorRequest', FPriorRequestList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirDeviceRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priorRequest', 'Reference', true, TFhirReference, FPriorRequestList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableReference', false, TFhirCodeableReference, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirDeviceRequestParameter, FParameterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link)) {L1039};
end;

function TFhirDeviceRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'priorRequest') then
  begin
    PriorRequestList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirDeviceRequestParameter) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'priorRequest') then PriorRequestList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirDeviceRequestParameter) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirDeviceRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'priorRequest') then result := PriorRequestList.new() {L1053}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull])  {L1211}
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull])  {L1211}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'code') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'parameter') then result := ParameterList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requester') then result := TFhirReference.create() {L1203}
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'performer') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'priorRequest') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableReference'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'priorRequest') then deletePropertyValue('priorRequest', PriorRequestList, value) {L1054}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'priorRequest') then replacePropertyValue('priorRequest', PriorRequestList, existing, new) {L1055}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new) {L1210}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new) {L1210}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new) {L1222}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference {L1195}
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'priorRequest') then PriorRequestList.move(source, destination) {L1050}
  else if (propName = 'parameter') then ParameterList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequest.fhirType : string;
begin
  result := 'DeviceRequest';
end;

function TFhirDeviceRequest.Link : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Link);
end;

function TFhirDeviceRequest.Clone : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Clone);
end;

function TFhirDeviceRequest.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequest)) then
    result := false
  else
  begin
    o := TFhirDeviceRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(priorRequestList, o.priorRequestList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeElement, o.performerTypeElement, true) and compareDeep(performerElement, o.performerElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirDeviceRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpriorRequestList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FparameterList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FPerformer) and isEmptyProp(FreasonList) and isEmptyProp(FinsuranceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList);
end;

function TFhirDeviceRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirDeviceRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirDeviceRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirDeviceRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirDeviceRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDeviceRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirDeviceRequest.GetPriorRequestList : TFhirReferenceList;
begin
  if FPriorRequestList = nil then
    FPriorRequestList := TFhirReferenceList.Create;
  result := FPriorRequestList;
end;

function TFhirDeviceRequest.GetHasPriorRequestList : boolean;
begin
  result := (FPriorRequestList <> nil) and (FPriorRequestList.count > 0);
end;

procedure TFhirDeviceRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value; {L1134}
end;

procedure TFhirDeviceRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirDeviceRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirDeviceRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirDeviceRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirDeviceRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirDeviceRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirDeviceRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirDeviceRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirDeviceRequest.SetCode(value : TFhirCodeableReference);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirDeviceRequest.GetParameterList : TFhirDeviceRequestParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirDeviceRequestParameterList.Create;
  result := FParameterList;
end;

function TFhirDeviceRequest.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

procedure TFhirDeviceRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirDeviceRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirDeviceRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirDeviceRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value; {L1134}
end;

function TFhirDeviceRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirDeviceRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirDeviceRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value; {L1134}
end;

procedure TFhirDeviceRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value; {L1134}
end;

procedure TFhirDeviceRequest.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value; {L1134}
end;

function TFhirDeviceRequest.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirDeviceRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirDeviceRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirDeviceRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirDeviceRequest.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirDeviceRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirDeviceRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDeviceRequest.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirDeviceRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

procedure TFhirDeviceRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('priorRequest');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('parameter');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('reason');
  fields.add('insurance');
  fields.add('supportingInfo');
  fields.add('note');
  fields.add('relevantHistory');
end;

function TFhirDeviceRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpriorRequestList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FPerformerType.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
end;

{ TFhirDeviceRequestListEnumerator }

constructor TFhirDeviceRequestListEnumerator.Create(list : TFhirDeviceRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestListEnumerator.GetCurrent : TFhirDeviceRequest;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceRequestList }

procedure TFhirDeviceRequestList.AddItem(value: TFhirDeviceRequest);
begin
  assert(value.ClassName = 'TFhirDeviceRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequest');
  add(value);
end;

function TFhirDeviceRequestList.Append: TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestList.GetEnumerator : TFhirDeviceRequestListEnumerator;
begin
  result := TFhirDeviceRequestListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestList.Clone: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Clone);
end;

function TFhirDeviceRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestList.GetItemN(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequest;
end;
function TFhirDeviceRequestList.IndexOf(value: TFhirDeviceRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestList.Insert(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.InsertItem(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestList.Item(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.Link: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Link);
end;

procedure TFhirDeviceRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestList.SetItemByIndex(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  FhirDeviceRequests[index] := value;
end;

procedure TFhirDeviceRequestList.SetItemN(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
{ TFhirDeviceUseStatement }

constructor TFhirDeviceUseStatement.Create;
begin
  inherited;
end;

destructor TFhirDeviceUseStatement.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FCategoryList.Free;
  FSubject.free;
  FDerivedFromList.Free;
  FContext.free;
  FTiming.free;
  FDateAsserted.free;
  FUsageStatus.free;
  FUsageReasonList.Free;
  FInformationSource.free;
  FDevice.free;
  FReasonList.Free;
  FBodySite.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirDeviceUseStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceUseStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceUseStatement(oSource).FIdentifierList);
  end;
  if (TFhirDeviceUseStatement(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDeviceUseStatement(oSource).FBasedOnList);
  end;
  statusElement := TFhirDeviceUseStatement(oSource).statusElement.Clone;
  if (TFhirDeviceUseStatement(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDeviceUseStatement(oSource).FCategoryList);
  end;
  subject := TFhirDeviceUseStatement(oSource).subject.Clone;
  if (TFhirDeviceUseStatement(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirDeviceUseStatement(oSource).FDerivedFromList);
  end;
  context := TFhirDeviceUseStatement(oSource).context.Clone;
  timing := TFhirDeviceUseStatement(oSource).timing.Clone;
  dateAssertedElement := TFhirDeviceUseStatement(oSource).dateAssertedElement.Clone;
  usageStatus := TFhirDeviceUseStatement(oSource).usageStatus.Clone;
  if (TFhirDeviceUseStatement(oSource).FUsageReasonList = nil) then
  begin
    FUsageReasonList.free;
    FUsageReasonList := nil;
  end
  else
  begin
    if FUsageReasonList = nil then
      FUsageReasonList := TFhirCodeableConceptList.Create;
    FUsageReasonList.Assign(TFhirDeviceUseStatement(oSource).FUsageReasonList);
  end;
  informationSource := TFhirDeviceUseStatement(oSource).informationSource.Clone;
  device := TFhirDeviceUseStatement(oSource).device.Clone;
  if (TFhirDeviceUseStatement(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirDeviceUseStatement(oSource).FReasonList);
  end;
  bodySite := TFhirDeviceUseStatement(oSource).bodySite.Clone;
  if (TFhirDeviceUseStatement(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceUseStatement(oSource).FNoteList);
  end;
end;

function TFhirDeviceUseStatement.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceUseStatement;
end;

procedure TFhirDeviceUseStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'dateAsserted') Then
     list.add(self.link, 'dateAsserted', FDateAsserted.Link);
  if (child_name = 'usageStatus') Then
     list.add(self.link, 'usageStatus', FUsageStatus.Link);
  if (child_name = 'usageReason') Then
    list.addAll(self, 'usageReason', FUsageReasonList);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirDeviceUseStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Period|dateTime', false, TFhirDataType, FTiming.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateAsserted', 'dateTime', false, TFhirDateTime, FDateAsserted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'usageStatus', 'CodeableConcept', false, TFhirCodeableConcept, FUsageStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'usageReason', 'CodeableConcept', true, TFhirCodeableConcept, FUsageReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', false, TFhirReference, FInformationSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'device', 'CodeableReference', false, TFhirCodeableReference, FDevice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableReference', false, TFhirCodeableReference, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirDeviceUseStatement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDeviceUseStatementStatusEnum, CODES_TFhirDeviceUseStatementStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then
  begin
    Timing := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'dateAsserted') then
  begin
    DateAssertedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'usageStatus') then
  begin
    UsageStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'usageReason') then
  begin
    UsageReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUseStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'usageReason') then UsageReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirDeviceUseStatement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceUseStatementStatusEnum[DeviceUseStatementStatusNull], CODES_TFhirDeviceUseStatementStatusEnum[DeviceUseStatementStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'derivedFrom') then result := DerivedFromList.new() {L1053}
  else if (propName = 'context') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing') {L1191}
  else if (propName = 'dateAsserted') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'usageStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'usageReason') then result := UsageReasonList.new() {L1053}
  else if (propName = 'informationSource') then result := TFhirReference.create() {L1203}
  else if (propName = 'device') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'bodySite') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUseStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'timing[x]') then result := 'Timing|Period|dateTime'
  else if (propName = 'dateAsserted') then result := 'dateTime'
  else if (propName = 'usageStatus') then result := 'CodeableConcept'
  else if (propName = 'usageReason') then result := 'CodeableConcept'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'device') then result := 'CodeableReference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'bodySite') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUseStatement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value) {L1054}
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := nil {L1189}
  else if (propName = 'dateAsserted') then DateAssertedElement := nil
  else if (propName = 'usageStatus') then UsageStatusElement := nil
  else if (propName = 'usageReason') then deletePropertyValue('usageReason', UsageReasonList, value) {L1054}
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUseStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDeviceUseStatementStatusEnum, CODES_TFhirDeviceUseStatementStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new) {L1055}
  else if (propName = 'context') then ContextElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := new as TFhirDataType {L1190}
  else if (propName = 'dateAsserted') then DateAssertedElement := asDateTime(new) {L1222}
  else if (propName = 'usageStatus') then UsageStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'usageReason') then replacePropertyValue('usageReason', UsageReasonList, existing, new) {L1055}
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference {L1195}
  else if (propName = 'device') then DeviceElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUseStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination) {L1050}
  else if (propName = 'usageReason') then UsageReasonList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUseStatement.fhirType : string;
begin
  result := 'DeviceUseStatement';
end;

function TFhirDeviceUseStatement.Link : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Link);
end;

function TFhirDeviceUseStatement.Clone : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Clone);
end;

function TFhirDeviceUseStatement.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUseStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUseStatement)) then
    result := false
  else
  begin
    o := TFhirDeviceUseStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(derivedFromList, o.derivedFromList, true) and 
      compareDeep(contextElement, o.contextElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(dateAssertedElement, o.dateAssertedElement, true) and compareDeep(usageStatusElement, o.usageStatusElement, true) and 
      compareDeep(usageReasonList, o.usageReasonList, true) and compareDeep(informationSourceElement, o.informationSourceElement, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirDeviceUseStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FderivedFromList) and isEmptyProp(FContext) and isEmptyProp(FTiming) and isEmptyProp(FDateAsserted) and isEmptyProp(FUsageStatus) and isEmptyProp(FusageReasonList) and isEmptyProp(FInformationSource) and isEmptyProp(FDevice) and isEmptyProp(FreasonList) and isEmptyProp(FBodySite) and isEmptyProp(FnoteList);
end;

function TFhirDeviceUseStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceUseStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceUseStatement.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDeviceUseStatement.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceUseStatement.GetStatusST : TFhirDeviceUseStatementStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDeviceUseStatementStatusEnum(0)
  else
    result := TFhirDeviceUseStatementStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceUseStatementStatusEnum, FStatus.value));
end;

procedure TFhirDeviceUseStatement.SetStatusST(value : TFhirDeviceUseStatementStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceUseStatementStatusEnum[value], CODES_TFhirDeviceUseStatementStatusEnum[value]);
end;

function TFhirDeviceUseStatement.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDeviceUseStatement.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

function TFhirDeviceUseStatement.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirDeviceUseStatement.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value; {L1134}
end;

procedure TFhirDeviceUseStatement.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value; {L1134}
end;

procedure TFhirDeviceUseStatement.SetDateAsserted(value : TFhirDateTime);
begin
  FDateAsserted.free;
  FDateAsserted := value; {L1134}
end;

function TFhirDeviceUseStatement.GetDateAssertedST : TFslDateTime;
begin
  if FDateAsserted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAsserted.value;
end;

procedure TFhirDeviceUseStatement.SetDateAssertedST(value : TFslDateTime);
begin
  if FDateAsserted = nil then
    FDateAsserted := TFhirDateTime.create;
  FDateAsserted.value := value
end;

procedure TFhirDeviceUseStatement.SetUsageStatus(value : TFhirCodeableConcept);
begin
  FUsageStatus.free;
  FUsageStatus := value; {L1134}
end;

function TFhirDeviceUseStatement.GetUsageReasonList : TFhirCodeableConceptList;
begin
  if FUsageReasonList = nil then
    FUsageReasonList := TFhirCodeableConceptList.Create;
  result := FUsageReasonList;
end;

function TFhirDeviceUseStatement.GetHasUsageReasonList : boolean;
begin
  result := (FUsageReasonList <> nil) and (FUsageReasonList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetInformationSource(value : TFhirReference);
begin
  FInformationSource.free;
  FInformationSource := value; {L1134}
end;

procedure TFhirDeviceUseStatement.SetDevice(value : TFhirCodeableReference);
begin
  FDevice.free;
  FDevice := value; {L1134}
end;

function TFhirDeviceUseStatement.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirDeviceUseStatement.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetBodySite(value : TFhirCodeableReference);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

function TFhirDeviceUseStatement.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceUseStatement.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirDeviceUseStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('category');
  fields.add('subject');
  fields.add('derivedFrom');
  fields.add('context');
  fields.add('timing[x]');
  fields.add('dateAsserted');
  fields.add('usageStatus');
  fields.add('usageReason');
  fields.add('informationSource');
  fields.add('device');
  fields.add('reason');
  fields.add('bodySite');
  fields.add('note');
end;

function TFhirDeviceUseStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FderivedFromList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FDateAsserted.sizeInBytes);
  inc(result, FUsageStatus.sizeInBytes);
  inc(result, FusageReasonList.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirDeviceUseStatementListEnumerator }

constructor TFhirDeviceUseStatementListEnumerator.Create(list : TFhirDeviceUseStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUseStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUseStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUseStatementListEnumerator.GetCurrent : TFhirDeviceUseStatement;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUseStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceUseStatementList }

procedure TFhirDeviceUseStatementList.AddItem(value: TFhirDeviceUseStatement);
begin
  assert(value.ClassName = 'TFhirDeviceUseStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUseStatement');
  add(value);
end;

function TFhirDeviceUseStatementList.Append: TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUseStatementList.GetEnumerator : TFhirDeviceUseStatementListEnumerator;
begin
  result := TFhirDeviceUseStatementListEnumerator.Create(self.link);
end;

function TFhirDeviceUseStatementList.Clone: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Clone);
end;

function TFhirDeviceUseStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUseStatementList.GetItemN(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUseStatement;
end;
function TFhirDeviceUseStatementList.IndexOf(value: TFhirDeviceUseStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUseStatementList.Insert(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.InsertItem(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  Inherited Insert(index, value);
end;

function TFhirDeviceUseStatementList.Item(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.Link: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Link);
end;

procedure TFhirDeviceUseStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUseStatementList.SetItemByIndex(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  FhirDeviceUseStatements[index] := value;
end;

procedure TFhirDeviceUseStatementList.SetItemN(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
{ TFhirDiagnosticReportMedia }

constructor TFhirDiagnosticReportMedia.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportMedia.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportMedia.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirDiagnosticReportMedia(oSource).commentElement.Clone;
  link_ := TFhirDiagnosticReportMedia(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportMedia.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'link') Then
     list.add(self.link, 'link', FLink_.Link);
end;

procedure TFhirDiagnosticReportMedia.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'link', 'Reference', false, TFhirReference, FLink_.Link)); {L1172}
end;

function TFhirDiagnosticReportMedia.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_ := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReportMedia.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticReportMedia.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create() {L1223}
  else if (propName = 'link') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReportMedia.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'link') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReportMedia.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'link') then Link_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReportMedia.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else if (propName = 'link') then Link_Element := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReportMedia.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReportMedia.fhirType : string;
begin
  result := 'DiagnosticReport.media';
end;

function TFhirDiagnosticReportMedia.Link : TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(inherited Link);
end;

function TFhirDiagnosticReportMedia.Clone : TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(inherited Clone);
end;

function TFhirDiagnosticReportMedia.equals(other : TObject) : boolean; 
var
  o : TFhirDiagnosticReportMedia;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReportMedia)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReportMedia(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(link_Element, o.link_Element, true);
  end;
end;

function TFhirDiagnosticReportMedia.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FLink_);
end;

procedure TFhirDiagnosticReportMedia.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirDiagnosticReportMedia.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirDiagnosticReportMedia.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirDiagnosticReportMedia.SetLink_(value : TFhirReference);
begin
  FLink_.free;
  FLink_ := value; {L1134}
end;

procedure TFhirDiagnosticReportMedia.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('comment');
  fields.add('link');
end;

function TFhirDiagnosticReportMedia.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComment.sizeInBytes);
  inc(result, FLink_.sizeInBytes);
end;

{ TFhirDiagnosticReportMediaListEnumerator }

constructor TFhirDiagnosticReportMediaListEnumerator.Create(list : TFhirDiagnosticReportMediaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportMediaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportMediaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportMediaListEnumerator.GetCurrent : TFhirDiagnosticReportMedia;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportMediaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportMediaList }

procedure TFhirDiagnosticReportMediaList.AddItem(value: TFhirDiagnosticReportMedia);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportMedia', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportMedia');
  add(value);
end;

function TFhirDiagnosticReportMediaList.Append: TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportMediaList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportMediaList.GetEnumerator : TFhirDiagnosticReportMediaListEnumerator;
begin
  result := TFhirDiagnosticReportMediaListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportMediaList.Clone: TFhirDiagnosticReportMediaList;
begin
  result := TFhirDiagnosticReportMediaList(inherited Clone);
end;

function TFhirDiagnosticReportMediaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportMediaList.GetItemN(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportMediaList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReportMedia;
end;
function TFhirDiagnosticReportMediaList.IndexOf(value: TFhirDiagnosticReportMedia): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportMediaList.Insert(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportMediaList.InsertItem(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportMediaList.Item(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportMediaList.Link: TFhirDiagnosticReportMediaList;
begin
  result := TFhirDiagnosticReportMediaList(inherited Link);
end;

procedure TFhirDiagnosticReportMediaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportMediaList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  FhirDiagnosticReportMedia[index] := value;
end;

procedure TFhirDiagnosticReportMediaList.SetItemN(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReport }

constructor TFhirDiagnosticReport.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReport.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FResultsInterpreterList.Free;
  FSpecimenList.Free;
  FResultList.Free;
  FImagingStudyList.Free;
  FMediaList.Free;
  FConclusion.free;
  FConclusionCodeList.Free;
  FPresentedFormList.Free;
  inherited;
end;

procedure TFhirDiagnosticReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDiagnosticReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDiagnosticReport(oSource).FIdentifierList);
  end;
  if (TFhirDiagnosticReport(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDiagnosticReport(oSource).FBasedOnList);
  end;
  statusElement := TFhirDiagnosticReport(oSource).statusElement.Clone;
  if (TFhirDiagnosticReport(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDiagnosticReport(oSource).FCategoryList);
  end;
  code := TFhirDiagnosticReport(oSource).code.Clone;
  subject := TFhirDiagnosticReport(oSource).subject.Clone;
  encounter := TFhirDiagnosticReport(oSource).encounter.Clone;
  effective := TFhirDiagnosticReport(oSource).effective.Clone;
  issuedElement := TFhirDiagnosticReport(oSource).issuedElement.Clone;
  if (TFhirDiagnosticReport(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirDiagnosticReport(oSource).FPerformerList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultsInterpreterList = nil) then
  begin
    FResultsInterpreterList.free;
    FResultsInterpreterList := nil;
  end
  else
  begin
    if FResultsInterpreterList = nil then
      FResultsInterpreterList := TFhirReferenceList.Create;
    FResultsInterpreterList.Assign(TFhirDiagnosticReport(oSource).FResultsInterpreterList);
  end;
  if (TFhirDiagnosticReport(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirDiagnosticReport(oSource).FSpecimenList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultList = nil) then
  begin
    FResultList.free;
    FResultList := nil;
  end
  else
  begin
    if FResultList = nil then
      FResultList := TFhirReferenceList.Create;
    FResultList.Assign(TFhirDiagnosticReport(oSource).FResultList);
  end;
  if (TFhirDiagnosticReport(oSource).FImagingStudyList = nil) then
  begin
    FImagingStudyList.free;
    FImagingStudyList := nil;
  end
  else
  begin
    if FImagingStudyList = nil then
      FImagingStudyList := TFhirReferenceList.Create;
    FImagingStudyList.Assign(TFhirDiagnosticReport(oSource).FImagingStudyList);
  end;
  if (TFhirDiagnosticReport(oSource).FMediaList = nil) then
  begin
    FMediaList.free;
    FMediaList := nil;
  end
  else
  begin
    if FMediaList = nil then
      FMediaList := TFhirDiagnosticReportMediaList.Create;
    FMediaList.Assign(TFhirDiagnosticReport(oSource).FMediaList);
  end;
  conclusionElement := TFhirDiagnosticReport(oSource).conclusionElement.Clone;
  if (TFhirDiagnosticReport(oSource).FConclusionCodeList = nil) then
  begin
    FConclusionCodeList.free;
    FConclusionCodeList := nil;
  end
  else
  begin
    if FConclusionCodeList = nil then
      FConclusionCodeList := TFhirCodeableConceptList.Create;
    FConclusionCodeList.Assign(TFhirDiagnosticReport(oSource).FConclusionCodeList);
  end;
  if (TFhirDiagnosticReport(oSource).FPresentedFormList = nil) then
  begin
    FPresentedFormList.free;
    FPresentedFormList := nil;
  end
  else
  begin
    if FPresentedFormList = nil then
      FPresentedFormList := TFhirAttachmentList.Create;
    FPresentedFormList.Assign(TFhirDiagnosticReport(oSource).FPresentedFormList);
  end;
end;

function TFhirDiagnosticReport.GetResourceType : TFhirResourceType;
begin
  result := frtDiagnosticReport;
end;

procedure TFhirDiagnosticReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'resultsInterpreter') Then
    list.addAll(self, 'resultsInterpreter', FResultsInterpreterList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'result') Then
    list.addAll(self, 'result', FResultList);
  if (child_name = 'imagingStudy') Then
    list.addAll(self, 'imagingStudy', FImagingStudyList);
  if (child_name = 'media') Then
    list.addAll(self, 'media', FMediaList);
  if (child_name = 'conclusion') Then
     list.add(self.link, 'conclusion', FConclusion.Link);
  if (child_name = 'conclusionCode') Then
    list.addAll(self, 'conclusionCode', FConclusionCodeList);
  if (child_name = 'presentedForm') Then
    list.addAll(self, 'presentedForm', FPresentedFormList);
end;

procedure TFhirDiagnosticReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'resultsInterpreter', 'Reference', true, TFhirReference, FResultsInterpreterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'result', 'Reference', true, TFhirReference, FResultList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference', true, TFhirReference, FImagingStudyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'media', 'BackboneElement', true, TFhirDiagnosticReportMedia, FMediaList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'conclusion', 'string', false, TFhirString, FConclusion.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'conclusionCode', 'CodeableConcept', true, TFhirCodeableConcept, FConclusionCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'presentedForm', 'Attachment', true, TFhirAttachment, FPresentedFormList.Link)) {L1039};
end;

function TFhirDiagnosticReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'resultsInterpreter') then
  begin
    ResultsInterpreterList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudyList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'media') then
  begin
    MediaList.add(propValue as TFhirDiagnosticReportMedia) {L1048};
    result := propValue;
  end
  else if (propName = 'conclusion') then
  begin
    ConclusionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'conclusionCode') then
  begin
    ConclusionCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'presentedForm') then
  begin
    PresentedFormList.add(propValue as TFhirAttachment) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'resultsInterpreter') then ResultsInterpreterList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'result') then ResultList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'imagingStudy') then ImagingStudyList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'media') then MediaList.insertItem(index, propValue as TFhirDiagnosticReportMedia) {L1049}
  else if (propName = 'conclusionCode') then ConclusionCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'presentedForm') then PresentedFormList.insertItem(index, propValue as TFhirAttachment) {L1049}
  else inherited;
end;

function TFhirDiagnosticReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[DiagnosticReportStatusNull], CODES_TFhirDiagnosticReportStatusEnum[DiagnosticReportStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective') {L1191}
  else if (propName = 'issued') then result := TFhirInstant.create() {L1223}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'resultsInterpreter') then result := ResultsInterpreterList.new() {L1053}
  else if (propName = 'specimen') then result := SpecimenList.new() {L1053}
  else if (propName = 'result') then result := ResultList.new() {L1053}
  else if (propName = 'imagingStudy') then result := ImagingStudyList.new() {L1053}
  else if (propName = 'media') then result := MediaList.new() {L1053}
  else if (propName = 'conclusion') then result := TFhirString.create() {L1223}
  else if (propName = 'conclusionCode') then result := ConclusionCodeList.new() {L1053}
  else if (propName = 'presentedForm') then result := PresentedFormList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'resultsInterpreter') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'media') then result := 'BackboneElement'
  else if (propName = 'conclusion') then result := 'string'
  else if (propName = 'conclusionCode') then result := 'CodeableConcept'
  else if (propName = 'presentedForm') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil {L1189}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'resultsInterpreter') then deletePropertyValue('resultsInterpreter', ResultsInterpreterList, value) {L1054}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {L1054}
  else if (propName = 'result') then deletePropertyValue('result', ResultList, value) {L1054}
  else if (propName = 'imagingStudy') then deletePropertyValue('imagingStudy', ImagingStudyList, value) {L1054}
  else if (propName = 'media') then deletePropertyValue('media', MediaList, value) {L1054}
  else if (propName = 'conclusion') then ConclusionElement := nil
  else if (propName = 'conclusionCode') then deletePropertyValue('conclusionCode', ConclusionCodeList, value) {L1054}
  else if (propName = 'presentedForm') then deletePropertyValue('presentedForm', PresentedFormList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType {L1190}
  else if (propName = 'issued') then IssuedElement := asInstant(new) {L1222}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'resultsInterpreter') then replacePropertyValue('resultsInterpreter', ResultsInterpreterList, existing, new) {L1055}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {L1055}
  else if (propName = 'result') then replacePropertyValue('result', ResultList, existing, new) {L1055}
  else if (propName = 'imagingStudy') then replacePropertyValue('imagingStudy', ImagingStudyList, existing, new) {L1055}
  else if (propName = 'media') then replacePropertyValue('media', MediaList, existing, new) {L1055}
  else if (propName = 'conclusion') then ConclusionElement := asString(new) {L1222}
  else if (propName = 'conclusionCode') then replacePropertyValue('conclusionCode', ConclusionCodeList, existing, new) {L1055}
  else if (propName = 'presentedForm') then replacePropertyValue('presentedForm', PresentedFormList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'resultsInterpreter') then ResultsInterpreterList.move(source, destination) {L1050}
  else if (propName = 'specimen') then SpecimenList.move(source, destination) {L1050}
  else if (propName = 'result') then ResultList.move(source, destination) {L1050}
  else if (propName = 'imagingStudy') then ImagingStudyList.move(source, destination) {L1050}
  else if (propName = 'media') then MediaList.move(source, destination) {L1050}
  else if (propName = 'conclusionCode') then ConclusionCodeList.move(source, destination) {L1050}
  else if (propName = 'presentedForm') then PresentedFormList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReport.fhirType : string;
begin
  result := 'DiagnosticReport';
end;

function TFhirDiagnosticReport.Link : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Link);
end;

function TFhirDiagnosticReport.Clone : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Clone);
end;

function TFhirDiagnosticReport.equals(other : TObject) : boolean; 
var
  o : TFhirDiagnosticReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReport)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(resultsInterpreterList, o.resultsInterpreterList, true) and compareDeep(specimenList, o.specimenList, true) and 
      compareDeep(resultList, o.resultList, true) and compareDeep(imagingStudyList, o.imagingStudyList, true) and 
      compareDeep(mediaList, o.mediaList, true) and compareDeep(conclusionElement, o.conclusionElement, true) and 
      compareDeep(conclusionCodeList, o.conclusionCodeList, true) and compareDeep(presentedFormList, o.presentedFormList, true);
  end;
end;

function TFhirDiagnosticReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FresultsInterpreterList) and isEmptyProp(FspecimenList) and isEmptyProp(FresultList) and isEmptyProp(FimagingStudyList) and isEmptyProp(FmediaList) and isEmptyProp(FConclusion) and isEmptyProp(FconclusionCodeList) and isEmptyProp(FpresentedFormList);
end;

function TFhirDiagnosticReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDiagnosticReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDiagnosticReport.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDiagnosticReport.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirDiagnosticReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDiagnosticReport.GetStatusST : TFhirDiagnosticReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticReportStatusEnum(0)
  else
    result := TFhirDiagnosticReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticReportStatusEnum, FStatus.value));
end;

procedure TFhirDiagnosticReport.SetStatusST(value : TFhirDiagnosticReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[value], CODES_TFhirDiagnosticReportStatusEnum[value]);
end;

function TFhirDiagnosticReport.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDiagnosticReport.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirDiagnosticReport.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirDiagnosticReport.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirDiagnosticReport.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirDiagnosticReport.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value; {L1134}
end;

procedure TFhirDiagnosticReport.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value; {L1134}
end;

function TFhirDiagnosticReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirDiagnosticReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

function TFhirDiagnosticReport.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirDiagnosticReport.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirDiagnosticReport.GetResultsInterpreterList : TFhirReferenceList;
begin
  if FResultsInterpreterList = nil then
    FResultsInterpreterList := TFhirReferenceList.Create;
  result := FResultsInterpreterList;
end;

function TFhirDiagnosticReport.GetHasResultsInterpreterList : boolean;
begin
  result := (FResultsInterpreterList <> nil) and (FResultsInterpreterList.count > 0);
end;

function TFhirDiagnosticReport.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirDiagnosticReport.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

function TFhirDiagnosticReport.GetResultList : TFhirReferenceList;
begin
  if FResultList = nil then
    FResultList := TFhirReferenceList.Create;
  result := FResultList;
end;

function TFhirDiagnosticReport.GetHasResultList : boolean;
begin
  result := (FResultList <> nil) and (FResultList.count > 0);
end;

function TFhirDiagnosticReport.GetImagingStudyList : TFhirReferenceList;
begin
  if FImagingStudyList = nil then
    FImagingStudyList := TFhirReferenceList.Create;
  result := FImagingStudyList;
end;

function TFhirDiagnosticReport.GetHasImagingStudyList : boolean;
begin
  result := (FImagingStudyList <> nil) and (FImagingStudyList.count > 0);
end;

function TFhirDiagnosticReport.GetMediaList : TFhirDiagnosticReportMediaList;
begin
  if FMediaList = nil then
    FMediaList := TFhirDiagnosticReportMediaList.Create;
  result := FMediaList;
end;

function TFhirDiagnosticReport.GetHasMediaList : boolean;
begin
  result := (FMediaList <> nil) and (FMediaList.count > 0);
end;

procedure TFhirDiagnosticReport.SetConclusion(value : TFhirString);
begin
  FConclusion.free;
  FConclusion := value; {L1134}
end;

function TFhirDiagnosticReport.GetConclusionST : String;
begin
  if FConclusion = nil then
    result := ''
  else
    result := FConclusion.value;
end;

procedure TFhirDiagnosticReport.SetConclusionST(value : String);
begin
  if value <> '' then
  begin
    if FConclusion = nil then
      FConclusion := TFhirString.create;
    FConclusion.value := value
  end
  else if FConclusion <> nil then
    FConclusion.value := '';
end;

function TFhirDiagnosticReport.GetConclusionCodeList : TFhirCodeableConceptList;
begin
  if FConclusionCodeList = nil then
    FConclusionCodeList := TFhirCodeableConceptList.Create;
  result := FConclusionCodeList;
end;

function TFhirDiagnosticReport.GetHasConclusionCodeList : boolean;
begin
  result := (FConclusionCodeList <> nil) and (FConclusionCodeList.count > 0);
end;

function TFhirDiagnosticReport.GetPresentedFormList : TFhirAttachmentList;
begin
  if FPresentedFormList = nil then
    FPresentedFormList := TFhirAttachmentList.Create;
  result := FPresentedFormList;
end;

function TFhirDiagnosticReport.GetHasPresentedFormList : boolean;
begin
  result := (FPresentedFormList <> nil) and (FPresentedFormList.count > 0);
end;

procedure TFhirDiagnosticReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('resultsInterpreter');
  fields.add('specimen');
  fields.add('result');
  fields.add('imagingStudy');
  fields.add('media');
  fields.add('conclusion');
  fields.add('conclusionCode');
  fields.add('presentedForm');
end;

function TFhirDiagnosticReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FresultsInterpreterList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FresultList.sizeInBytes);
  inc(result, FimagingStudyList.sizeInBytes);
  inc(result, FmediaList.sizeInBytes);
  inc(result, FConclusion.sizeInBytes);
  inc(result, FconclusionCodeList.sizeInBytes);
  inc(result, FpresentedFormList.sizeInBytes);
end;

{ TFhirDiagnosticReportListEnumerator }

constructor TFhirDiagnosticReportListEnumerator.Create(list : TFhirDiagnosticReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportListEnumerator.GetCurrent : TFhirDiagnosticReport;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportList }

procedure TFhirDiagnosticReportList.AddItem(value: TFhirDiagnosticReport);
begin
  assert(value.ClassName = 'TFhirDiagnosticReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReport');
  add(value);
end;

function TFhirDiagnosticReportList.Append: TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportList.GetEnumerator : TFhirDiagnosticReportListEnumerator;
begin
  result := TFhirDiagnosticReportListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportList.Clone: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Clone);
end;

function TFhirDiagnosticReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportList.GetItemN(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReport;
end;
function TFhirDiagnosticReportList.IndexOf(value: TFhirDiagnosticReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportList.Insert(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.InsertItem(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportList.Item(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.Link: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Link);
end;

procedure TFhirDiagnosticReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  FhirDiagnosticReports[index] := value;
end;

procedure TFhirDiagnosticReportList.SetItemN(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
{ TFhirDocumentManifestRelated }

constructor TFhirDocumentManifestRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentManifestRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentManifestRelated(oSource).identifier.Clone;
  ref := TFhirDocumentManifestRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentManifestRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentManifestRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference', false, TFhirReference, FRef.Link)); {L1172}
end;

function TFhirDocumentManifestRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'ref') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'ref') then RefElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestRelated.fhirType : string;
begin
  result := 'DocumentManifest.related';
end;

function TFhirDocumentManifestRelated.Link : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Link);
end;

function TFhirDocumentManifestRelated.Clone : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Clone);
end;

function TFhirDocumentManifestRelated.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentManifestRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentManifestRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentManifestRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirDocumentManifestRelated.SetRef(value : TFhirReference);
begin
  FRef.free;
  FRef := value; {L1134}
end;

procedure TFhirDocumentManifestRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

function TFhirDocumentManifestRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRef.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedListEnumerator }

constructor TFhirDocumentManifestRelatedListEnumerator.Create(list : TFhirDocumentManifestRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestRelatedListEnumerator.GetCurrent : TFhirDocumentManifestRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedList }

procedure TFhirDocumentManifestRelatedList.AddItem(value: TFhirDocumentManifestRelated);
begin
  assert(value.ClassName = 'TFhirDocumentManifestRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestRelated');
  add(value);
end;

function TFhirDocumentManifestRelatedList.Append: TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestRelatedList.GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
begin
  result := TFhirDocumentManifestRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestRelatedList.Clone: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Clone);
end;

function TFhirDocumentManifestRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestRelatedList.GetItemN(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestRelated;
end;
function TFhirDocumentManifestRelatedList.IndexOf(value: TFhirDocumentManifestRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestRelatedList.Insert(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.InsertItem(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestRelatedList.Item(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.Link: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Link);
end;

procedure TFhirDocumentManifestRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  FhirDocumentManifestRelateds[index] := value;
end;

procedure TFhirDocumentManifestRelatedList.SetItemN(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifest }

constructor TFhirDocumentManifest.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifest.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FCreated.free;
  FAuthorList.Free;
  FRecipientList.Free;
  FSource.free;
  FDescription.free;
  FContentList.Free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentManifest.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentManifest(oSource).masterIdentifier.Clone;
  if (TFhirDocumentManifest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentManifest(oSource).FIdentifierList);
  end;
  statusElement := TFhirDocumentManifest(oSource).statusElement.Clone;
  type_ := TFhirDocumentManifest(oSource).type_.Clone;
  subject := TFhirDocumentManifest(oSource).subject.Clone;
  createdElement := TFhirDocumentManifest(oSource).createdElement.Clone;
  if (TFhirDocumentManifest(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirDocumentManifest(oSource).FAuthorList);
  end;
  if (TFhirDocumentManifest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirDocumentManifest(oSource).FRecipientList);
  end;
  sourceElement := TFhirDocumentManifest(oSource).sourceElement.Clone;
  descriptionElement := TFhirDocumentManifest(oSource).descriptionElement.Clone;
  if (TFhirDocumentManifest(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirReferenceList.Create;
    FContentList.Assign(TFhirDocumentManifest(oSource).FContentList);
  end;
  if (TFhirDocumentManifest(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentManifestRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentManifest(oSource).FRelatedList);
  end;
end;

function TFhirDocumentManifest.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentManifest;
end;

procedure TFhirDocumentManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'content', 'Reference', true, TFhirReference, FContentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirDocumentManifestRelated, FRelatedList.Link)) {L1039};
end;

function TFhirDocumentManifest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentManifestRelated) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentManifestRelated) {L1049}
  else inherited;
end;

function TFhirDocumentManifest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull], CODES_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'author') then result := AuthorList.new() {L1053}
  else if (propName = 'recipient') then result := RecipientList.new() {L1053}
  else if (propName = 'source') then result := TFhirUri.create() {L1223}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'content') then result := ContentList.new() {L1053}
  else if (propName = 'related') then result := RelatedList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'source') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'content') then result := 'Reference'
  else if (propName = 'related') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {L1054}
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {L1054}
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {L1054}
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {L1055}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {L1055}
  else if (propName = 'source') then SourceElement := asUri(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {L1055}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'author') then AuthorList.move(source, destination) {L1050}
  else if (propName = 'recipient') then RecipientList.move(source, destination) {L1050}
  else if (propName = 'content') then ContentList.move(source, destination) {L1050}
  else if (propName = 'related') then RelatedList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifest.fhirType : string;
begin
  result := 'DocumentManifest';
end;

function TFhirDocumentManifest.Link : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Link);
end;

function TFhirDocumentManifest.Clone : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Clone);
end;

function TFhirDocumentManifest.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifest)) then
    result := false
  else
  begin
    o := TFhirDocumentManifest(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(recipientList, o.recipientList, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(contentList, o.contentList, true) and 
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FauthorList) and isEmptyProp(FrecipientList) and isEmptyProp(FSource) and isEmptyProp(FDescription) and isEmptyProp(FcontentList) and isEmptyProp(FrelatedList);
end;

procedure TFhirDocumentManifest.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value; {L1134}
end;

function TFhirDocumentManifest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDocumentManifest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDocumentManifest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDocumentManifest.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

procedure TFhirDocumentManifest.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

procedure TFhirDocumentManifest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirDocumentManifest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirDocumentManifest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirDocumentManifest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirDocumentManifest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

function TFhirDocumentManifest.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirDocumentManifest.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirDocumentManifest.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirDocumentManifest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

procedure TFhirDocumentManifest.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value; {L1134}
end;

function TFhirDocumentManifest.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirDocumentManifest.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirDocumentManifest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirDocumentManifest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirDocumentManifest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirDocumentManifest.GetContentList : TFhirReferenceList;
begin
  if FContentList = nil then
    FContentList := TFhirReferenceList.Create;
  result := FContentList;
end;

function TFhirDocumentManifest.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

function TFhirDocumentManifest.GetRelatedList : TFhirDocumentManifestRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentManifestRelatedList.Create;
  result := FRelatedList;
end;

function TFhirDocumentManifest.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirDocumentManifest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
  fields.add('recipient');
  fields.add('source');
  fields.add('description');
  fields.add('content');
  fields.add('related');
end;

function TFhirDocumentManifest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMasterIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentManifestListEnumerator }

constructor TFhirDocumentManifestListEnumerator.Create(list : TFhirDocumentManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestListEnumerator.GetCurrent : TFhirDocumentManifest;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestList }

procedure TFhirDocumentManifestList.AddItem(value: TFhirDocumentManifest);
begin
  assert(value.ClassName = 'TFhirDocumentManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifest');
  add(value);
end;

function TFhirDocumentManifestList.Append: TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestList.GetEnumerator : TFhirDocumentManifestListEnumerator;
begin
  result := TFhirDocumentManifestListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestList.Clone: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Clone);
end;

function TFhirDocumentManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestList.GetItemN(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifest;
end;
function TFhirDocumentManifestList.IndexOf(value: TFhirDocumentManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestList.Insert(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.InsertItem(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestList.Item(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.Link: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Link);
end;

procedure TFhirDocumentManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestList.SetItemByIndex(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  FhirDocumentManifests[index] := value;
end;

procedure TFhirDocumentManifestList.SetItemN(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
{ TFhirDocumentReferenceAttester }

constructor TFhirDocumentReferenceAttester.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceAttester.Destroy;
begin
  FMode.free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirDocumentReferenceAttester.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirDocumentReferenceAttester(oSource).modeElement.Clone;
  timeElement := TFhirDocumentReferenceAttester(oSource).timeElement.Clone;
  party := TFhirDocumentReferenceAttester(oSource).party.Clone;
end;

procedure TFhirDocumentReferenceAttester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirDocumentReferenceAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link)); {L1172}
end;

function TFhirDocumentReferenceAttester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirDocumentAttestationModeEnum, CODES_TFhirDocumentAttestationModeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceAttester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceAttester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentAttestationModeEnum[DocumentAttestationModeNull], CODES_TFhirDocumentAttestationModeEnum[DocumentAttestationModeNull])  {L1211}
  else if (propName = 'time') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'party') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceAttester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceAttester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'time') then TimeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceAttester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirDocumentAttestationModeEnum, CODES_TFhirDocumentAttestationModeEnum, new) {L1210}
  else if (propName = 'time') then TimeElement := asDateTime(new) {L1222}
  else if (propName = 'party') then PartyElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceAttester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceAttester.fhirType : string;
begin
  result := 'DocumentReference.attester';
end;

function TFhirDocumentReferenceAttester.Link : TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester(inherited Link);
end;

function TFhirDocumentReferenceAttester.Clone : TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester(inherited Clone);
end;

function TFhirDocumentReferenceAttester.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceAttester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceAttester)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceAttester(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(timeElement, o.timeElement, true) and 
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirDocumentReferenceAttester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FTime) and isEmptyProp(FParty);
end;

procedure TFhirDocumentReferenceAttester.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirDocumentReferenceAttester.GetModeST : TFhirDocumentAttestationModeEnum;
begin
  if FMode = nil then
    result := TFhirDocumentAttestationModeEnum(0)
  else
    result := TFhirDocumentAttestationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentAttestationModeEnum, FMode.value));
end;

procedure TFhirDocumentReferenceAttester.SetModeST(value : TFhirDocumentAttestationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentAttestationModeEnum[value], CODES_TFhirDocumentAttestationModeEnum[value]);
end;

procedure TFhirDocumentReferenceAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value; {L1134}
end;

function TFhirDocumentReferenceAttester.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirDocumentReferenceAttester.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

procedure TFhirDocumentReferenceAttester.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value; {L1134}
end;

procedure TFhirDocumentReferenceAttester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('time');
  fields.add('party');
end;

function TFhirDocumentReferenceAttester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirDocumentReferenceAttesterListEnumerator }

constructor TFhirDocumentReferenceAttesterListEnumerator.Create(list : TFhirDocumentReferenceAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceAttesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceAttesterListEnumerator.GetCurrent : TFhirDocumentReferenceAttester;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceAttesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceAttesterList }

procedure TFhirDocumentReferenceAttesterList.AddItem(value: TFhirDocumentReferenceAttester);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceAttester');
  add(value);
end;

function TFhirDocumentReferenceAttesterList.Append: TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceAttesterList.GetEnumerator : TFhirDocumentReferenceAttesterListEnumerator;
begin
  result := TFhirDocumentReferenceAttesterListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceAttesterList.Clone: TFhirDocumentReferenceAttesterList;
begin
  result := TFhirDocumentReferenceAttesterList(inherited Clone);
end;

function TFhirDocumentReferenceAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceAttesterList.GetItemN(index: Integer): TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceAttesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceAttester;
end;
function TFhirDocumentReferenceAttesterList.IndexOf(value: TFhirDocumentReferenceAttester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceAttesterList.Insert(index: Integer): TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceAttesterList.InsertItem(index: Integer; value: TFhirDocumentReferenceAttester);
begin
  assert(value is TFhirDocumentReferenceAttester);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceAttesterList.Item(index: Integer): TFhirDocumentReferenceAttester;
begin
  result := TFhirDocumentReferenceAttester(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceAttesterList.Link: TFhirDocumentReferenceAttesterList;
begin
  result := TFhirDocumentReferenceAttesterList(inherited Link);
end;

procedure TFhirDocumentReferenceAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceAttesterList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceAttester);
begin
  assert(value is TFhirDocumentReferenceAttester);
  FhirDocumentReferenceAttesters[index] := value;
end;

procedure TFhirDocumentReferenceAttesterList.SetItemN(index: Integer; value: TFhirDocumentReferenceAttester);
begin
  assert(value is TFhirDocumentReferenceAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirDocumentReferenceRelatesTo(oSource).codeElement.Clone;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link)); {L1172}
end;

function TFhirDocumentReferenceRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull], CODES_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull])  {L1211}
  else if (propName = 'target') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new) {L1210}
  else if (propName = 'target') then TargetElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceRelatesTo.fhirType : string;
begin
  result := 'DocumentReference.relatesTo';
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

function TFhirDocumentReferenceRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceRelatesTo)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirDocumentReferenceRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value; {L1134}
end;

procedure TFhirDocumentReferenceRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('target');
end;

function TFhirDocumentReferenceRelatesTo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToListEnumerator }

constructor TFhirDocumentReferenceRelatesToListEnumerator.Create(list : TFhirDocumentReferenceRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.GetCurrent : TFhirDocumentReferenceRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceRelatesToListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToList }

procedure TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
end;

function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
begin
  result := TFhirDocumentReferenceRelatesToListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceRelatesTo;
end;
function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContent }

constructor TFhirDocumentReferenceContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContent.Destroy;
begin
  FAttachment.free;
  FFormat.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirDocumentReferenceContent.Assign(oSource : TFslObject);
begin
  inherited;
  attachment := TFhirDocumentReferenceContent(oSource).attachment.Clone;
  format := TFhirDocumentReferenceContent(oSource).format.Clone;
  identifier := TFhirDocumentReferenceContent(oSource).identifier.Clone;
end;

procedure TFhirDocumentReferenceContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirDocumentReferenceContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'format', 'Coding', false, TFhirCoding, FFormat.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
end;

function TFhirDocumentReferenceContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'attachment') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'format') then result := TFhirCoding.create() {L1203}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'attachment') then result := 'Attachment'
  else if (propName = 'format') then result := 'Coding'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment {L1195}
  else if (propName = 'format') then FormatElement := new as TFhirCoding {L1195}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContent.fhirType : string;
begin
  result := 'DocumentReference.content';
end;

function TFhirDocumentReferenceContent.Link : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Link);
end;

function TFhirDocumentReferenceContent.Clone : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Clone);
end;

function TFhirDocumentReferenceContent.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContent)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContent(other);
    result := compareDeep(attachmentElement, o.attachmentElement, true) and compareDeep(formatElement, o.formatElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirDocumentReferenceContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAttachment) and isEmptyProp(FFormat) and isEmptyProp(FIdentifier);
end;

procedure TFhirDocumentReferenceContent.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value; {L1134}
end;

procedure TFhirDocumentReferenceContent.SetFormat(value : TFhirCoding);
begin
  FFormat.free;
  FFormat := value; {L1134}
end;

procedure TFhirDocumentReferenceContent.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirDocumentReferenceContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('attachment');
  fields.add('format');
  fields.add('identifier');
end;

function TFhirDocumentReferenceContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAttachment.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirDocumentReferenceContentListEnumerator }

constructor TFhirDocumentReferenceContentListEnumerator.Create(list : TFhirDocumentReferenceContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContentListEnumerator.GetCurrent : TFhirDocumentReferenceContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContentList }

procedure TFhirDocumentReferenceContentList.AddItem(value: TFhirDocumentReferenceContent);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContent');
  add(value);
end;

function TFhirDocumentReferenceContentList.Append: TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContentList.GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
begin
  result := TFhirDocumentReferenceContentListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContentList.Clone: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Clone);
end;

function TFhirDocumentReferenceContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContentList.GetItemN(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContent;
end;
function TFhirDocumentReferenceContentList.IndexOf(value: TFhirDocumentReferenceContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContentList.Insert(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.InsertItem(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContentList.Item(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.Link: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Link);
end;

procedure TFhirDocumentReferenceContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContentList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  FhirDocumentReferenceContents[index] := value;
end;

procedure TFhirDocumentReferenceContentList.SetItemN(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReference }

constructor TFhirDocumentReference.Create;
begin
  inherited;
end;

destructor TFhirDocumentReference.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FDocStatus.free;
  FType_.free;
  FCategoryList.Free;
  FSubject.free;
  FEncounterList.Free;
  FEventList.Free;
  FFacilityType.free;
  FPracticeSetting.free;
  FPeriod.free;
  FDate.free;
  FAuthorList.Free;
  FAttesterList.Free;
  FCustodian.free;
  FRelatesToList.Free;
  FDescription.free;
  FSecurityLabelList.Free;
  FContentList.Free;
  FSourcePatientInfo.free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentReference.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDocumentReference(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentReference(oSource).FIdentifierList);
  end;
  if (TFhirDocumentReference(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDocumentReference(oSource).FBasedOnList);
  end;
  statusElement := TFhirDocumentReference(oSource).statusElement.Clone;
  docStatusElement := TFhirDocumentReference(oSource).docStatusElement.Clone;
  type_ := TFhirDocumentReference(oSource).type_.Clone;
  if (TFhirDocumentReference(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDocumentReference(oSource).FCategoryList);
  end;
  subject := TFhirDocumentReference(oSource).subject.Clone;
  if (TFhirDocumentReference(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirDocumentReference(oSource).FEncounterList);
  end;
  if (TFhirDocumentReference(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCodeableConceptList.Create;
    FEventList.Assign(TFhirDocumentReference(oSource).FEventList);
  end;
  facilityType := TFhirDocumentReference(oSource).facilityType.Clone;
  practiceSetting := TFhirDocumentReference(oSource).practiceSetting.Clone;
  period := TFhirDocumentReference(oSource).period.Clone;
  dateElement := TFhirDocumentReference(oSource).dateElement.Clone;
  if (TFhirDocumentReference(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirDocumentReference(oSource).FAuthorList);
  end;
  if (TFhirDocumentReference(oSource).FAttesterList = nil) then
  begin
    FAttesterList.free;
    FAttesterList := nil;
  end
  else
  begin
    if FAttesterList = nil then
      FAttesterList := TFhirDocumentReferenceAttesterList.Create;
    FAttesterList.Assign(TFhirDocumentReference(oSource).FAttesterList);
  end;
  custodian := TFhirDocumentReference(oSource).custodian.Clone;
  if (TFhirDocumentReference(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
    FRelatesToList.Assign(TFhirDocumentReference(oSource).FRelatesToList);
  end;
  descriptionElement := TFhirDocumentReference(oSource).descriptionElement.Clone;
  if (TFhirDocumentReference(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodeableConceptList.Create;
    FSecurityLabelList.Assign(TFhirDocumentReference(oSource).FSecurityLabelList);
  end;
  if (TFhirDocumentReference(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentReferenceContentList.Create;
    FContentList.Assign(TFhirDocumentReference(oSource).FContentList);
  end;
  sourcePatientInfo := TFhirDocumentReference(oSource).sourcePatientInfo.Clone;
  if (TFhirDocumentReference(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirReferenceList.Create;
    FRelatedList.Assign(TFhirDocumentReference(oSource).FRelatedList);
  end;
end;

function TFhirDocumentReference.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentReference;
end;

procedure TFhirDocumentReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'docStatus') Then
     list.add(self.link, 'docStatus', FDocStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'facilityType') Then
     list.add(self.link, 'facilityType', FFacilityType.Link);
  if (child_name = 'practiceSetting') Then
     list.add(self.link, 'practiceSetting', FPracticeSetting.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'attester') Then
    list.addAll(self, 'attester', FAttesterList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'sourcePatientInfo') Then
     list.add(self.link, 'sourcePatientInfo', FSourcePatientInfo.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'docStatus', 'code', false, TFhirEnum, FDocStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', true, TFhirCodeableConcept, FEventList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', false, TFhirCodeableConcept, FFacilityType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'practiceSetting', 'CodeableConcept', false, TFhirCodeableConcept, FPracticeSetting.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'instant', false, TFhirInstant, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'attester', 'BackboneElement', true, TFhirDocumentReferenceAttester, FAttesterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference', false, TFhirReference, FCustodian.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirDocumentReferenceRelatesTo, FRelatesToList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'CodeableConcept', true, TFhirCodeableConcept, FSecurityLabelList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'content', 'BackboneElement', true, TFhirDocumentReferenceContent, FContentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'sourcePatientInfo', 'Reference', false, TFhirReference, FSourcePatientInfo.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'related', 'Reference', true, TFhirReference, FRelatedList.Link)) {L1039};
end;

function TFhirDocumentReference.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'docStatus') then
  begin
    DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'facilityType') then
  begin
    FacilityType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'practiceSetting') then
  begin
    PracticeSetting := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'attester') then
  begin
    AttesterList.add(propValue as TFhirDocumentReferenceAttester) {L1048};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirDocumentReferenceRelatesTo) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentReferenceContent) {L1048};
    result := propValue;
  end
  else if (propName = 'sourcePatientInfo') then
  begin
    SourcePatientInfo := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'attester') then AttesterList.insertItem(index, propValue as TFhirDocumentReferenceAttester) {L1049}
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirDocumentReferenceRelatesTo) {L1049}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentReferenceContent) {L1049}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirDocumentReference.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull], CODES_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull])  {L1211}
  else if (propName = 'docStatus') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[CompositionStatusNull], CODES_TFhirCompositionStatusEnum[CompositionStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := EncounterList.new() {L1053}
  else if (propName = 'event') then result := EventList.new() {L1053}
  else if (propName = 'facilityType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'practiceSetting') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'date') then result := TFhirInstant.create() {L1223}
  else if (propName = 'author') then result := AuthorList.new() {L1053}
  else if (propName = 'attester') then result := AttesterList.new() {L1053}
  else if (propName = 'custodian') then result := TFhirReference.create() {L1203}
  else if (propName = 'relatesTo') then result := RelatesToList.new() {L1053}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new() {L1053}
  else if (propName = 'content') then result := ContentList.new() {L1053}
  else if (propName = 'sourcePatientInfo') then result := TFhirReference.create() {L1203}
  else if (propName = 'related') then result := RelatedList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'docStatus') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'facilityType') then result := 'CodeableConcept'
  else if (propName = 'practiceSetting') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'date') then result := 'instant'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'attester') then result := 'BackboneElement'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'securityLabel') then result := 'CodeableConcept'
  else if (propName = 'content') then result := 'BackboneElement'
  else if (propName = 'sourcePatientInfo') then result := 'Reference'
  else if (propName = 'related') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReference.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'docStatus') then DocStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {L1054}
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {L1054}
  else if (propName = 'facilityType') then FacilityTypeElement := nil
  else if (propName = 'practiceSetting') then PracticeSettingElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {L1054}
  else if (propName = 'attester') then deletePropertyValue('attester', AttesterList, value) {L1054}
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {L1054}
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {L1054}
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new) {L1210}
  else if (propName = 'docStatus') then DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {L1055}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {L1055}
  else if (propName = 'facilityType') then FacilityTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'practiceSetting') then PracticeSettingElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'date') then DateElement := asInstant(new) {L1222}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {L1055}
  else if (propName = 'attester') then replacePropertyValue('attester', AttesterList, existing, new) {L1055}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference {L1195}
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {L1055}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {L1055}
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := new as TFhirReference {L1195}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReference.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'encounter') then EncounterList.move(source, destination) {L1050}
  else if (propName = 'event') then EventList.move(source, destination) {L1050}
  else if (propName = 'author') then AuthorList.move(source, destination) {L1050}
  else if (propName = 'attester') then AttesterList.move(source, destination) {L1050}
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination) {L1050}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination) {L1050}
  else if (propName = 'content') then ContentList.move(source, destination) {L1050}
  else if (propName = 'related') then RelatedList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReference.fhirType : string;
begin
  result := 'DocumentReference';
end;

function TFhirDocumentReference.Link : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Link);
end;

function TFhirDocumentReference.Clone : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Clone);
end;

function TFhirDocumentReference.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReference)) then
    result := false
  else
  begin
    o := TFhirDocumentReference(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(docStatusElement, o.docStatusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(eventList, o.eventList, true) and compareDeep(facilityTypeElement, o.facilityTypeElement, true) and 
      compareDeep(practiceSettingElement, o.practiceSettingElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(attesterList, o.attesterList, true) and compareDeep(custodianElement, o.custodianElement, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(contentList, o.contentList, true) and 
      compareDeep(sourcePatientInfoElement, o.sourcePatientInfoElement, true) and compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FDocStatus) and isEmptyProp(FType_) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FencounterList) and isEmptyProp(FeventList) and isEmptyProp(FFacilityType) and isEmptyProp(FPracticeSetting) and isEmptyProp(FPeriod) and isEmptyProp(FDate) and isEmptyProp(FauthorList) and isEmptyProp(FattesterList) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FDescription) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FcontentList) and isEmptyProp(FSourcePatientInfo) and isEmptyProp(FrelatedList);
end;

function TFhirDocumentReference.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDocumentReference.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDocumentReference.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDocumentReference.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirDocumentReference.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDocumentReference.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

procedure TFhirDocumentReference.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

procedure TFhirDocumentReference.SetDocStatus(value : TFhirEnum);
begin
  FDocStatus.free;
  FDocStatus := value;
end;

function TFhirDocumentReference.GetDocStatusST : TFhirCompositionStatusEnum;
begin
  if FDocStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FDocStatus.value));
end;

procedure TFhirDocumentReference.SetDocStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    DocStatusElement := nil
  else
    DocStatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

procedure TFhirDocumentReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirDocumentReference.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDocumentReference.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirDocumentReference.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

function TFhirDocumentReference.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirDocumentReference.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirDocumentReference.GetEventList : TFhirCodeableConceptList;
begin
  if FEventList = nil then
    FEventList := TFhirCodeableConceptList.Create;
  result := FEventList;
end;

function TFhirDocumentReference.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

procedure TFhirDocumentReference.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value; {L1134}
end;

procedure TFhirDocumentReference.SetPracticeSetting(value : TFhirCodeableConcept);
begin
  FPracticeSetting.free;
  FPracticeSetting := value; {L1134}
end;

procedure TFhirDocumentReference.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirDocumentReference.SetDate(value : TFhirInstant);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirDocumentReference.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirDocumentReference.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirInstant.create;
  FDate.value := value
end;

function TFhirDocumentReference.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirDocumentReference.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirDocumentReference.GetAttesterList : TFhirDocumentReferenceAttesterList;
begin
  if FAttesterList = nil then
    FAttesterList := TFhirDocumentReferenceAttesterList.Create;
  result := FAttesterList;
end;

function TFhirDocumentReference.GetHasAttesterList : boolean;
begin
  result := (FAttesterList <> nil) and (FAttesterList.count > 0);
end;

procedure TFhirDocumentReference.SetCustodian(value : TFhirReference);
begin
  FCustodian.free;
  FCustodian := value; {L1134}
end;

function TFhirDocumentReference.GetRelatesToList : TFhirDocumentReferenceRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirDocumentReference.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

procedure TFhirDocumentReference.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirDocumentReference.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirDocumentReference.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirDocumentReference.GetSecurityLabelList : TFhirCodeableConceptList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodeableConceptList.Create;
  result := FSecurityLabelList;
end;

function TFhirDocumentReference.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

function TFhirDocumentReference.GetContentList : TFhirDocumentReferenceContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentReferenceContentList.Create;
  result := FContentList;
end;

function TFhirDocumentReference.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

procedure TFhirDocumentReference.SetSourcePatientInfo(value : TFhirReference);
begin
  FSourcePatientInfo.free;
  FSourcePatientInfo := value; {L1134}
end;

function TFhirDocumentReference.GetRelatedList : TFhirReferenceList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirReferenceList.Create;
  result := FRelatedList;
end;

function TFhirDocumentReference.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirDocumentReference.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('docStatus');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('encounter');
  fields.add('event');
  fields.add('facilityType');
  fields.add('practiceSetting');
  fields.add('period');
  fields.add('date');
  fields.add('author');
  fields.add('attester');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('description');
  fields.add('securityLabel');
  fields.add('content');
  fields.add('sourcePatientInfo');
  fields.add('related');
end;

function TFhirDocumentReference.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDocStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FFacilityType.sizeInBytes);
  inc(result, FPracticeSetting.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FattesterList.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FrelatesToList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FSourcePatientInfo.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentReferenceListEnumerator }

constructor TFhirDocumentReferenceListEnumerator.Create(list : TFhirDocumentReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceListEnumerator.GetCurrent : TFhirDocumentReference;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceList }

procedure TFhirDocumentReferenceList.AddItem(value: TFhirDocumentReference);
begin
  assert(value.ClassName = 'TFhirDocumentReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReference');
  add(value);
end;

function TFhirDocumentReferenceList.Append: TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceList.GetEnumerator : TFhirDocumentReferenceListEnumerator;
begin
  result := TFhirDocumentReferenceListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceList.Clone: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Clone);
end;

function TFhirDocumentReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceList.GetItemN(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReference;
end;
function TFhirDocumentReferenceList.IndexOf(value: TFhirDocumentReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceList.Insert(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.InsertItem(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceList.Item(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.Link: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Link);
end;

procedure TFhirDocumentReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceList.SetItemByIndex(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  FhirDocumentReferences[index] := value;
end;

procedure TFhirDocumentReferenceList.SetItemN(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
{ TFhirEpisodeOfCareStatusHistory }

constructor TFhirEpisodeOfCareStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEpisodeOfCareStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirEpisodeOfCareStatusHistory(oSource).statusElement.Clone;
  period := TFhirEpisodeOfCareStatusHistory(oSource).period.Clone;
end;

procedure TFhirEpisodeOfCareStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEpisodeOfCareStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirEpisodeOfCareStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull], CODES_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull])  {L1211}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new) {L1210}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareStatusHistory.fhirType : string;
begin
  result := 'EpisodeOfCare.statusHistory';
end;

function TFhirEpisodeOfCareStatusHistory.Link : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Link);
end;

function TFhirEpisodeOfCareStatusHistory.Clone : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEpisodeOfCareStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEpisodeOfCareStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEpisodeOfCareStatusHistory.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

procedure TFhirEpisodeOfCareStatusHistory.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

procedure TFhirEpisodeOfCareStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEpisodeOfCareStatusHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

function TFhirEpisodeOfCareStatusHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirEpisodeOfCareStatusHistoryListEnumerator }

constructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(list : TFhirEpisodeOfCareStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.GetCurrent : TFhirEpisodeOfCareStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEpisodeOfCareStatusHistoryList }

procedure TFhirEpisodeOfCareStatusHistoryList.AddItem(value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value.ClassName = 'TFhirEpisodeOfCareStatusHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCareStatusHistory');
  add(value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Append: TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
begin
  result := TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareStatusHistoryList.Clone: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetItemN(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareStatusHistory;
end;
function TFhirEpisodeOfCareStatusHistoryList.IndexOf(value: TFhirEpisodeOfCareStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Insert(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.InsertItem(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Item(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.Link: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Link);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  FhirEpisodeOfCareStatusHistories[index] := value;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemN(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCareDiagnosis }

constructor TFhirEpisodeOfCareDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareDiagnosis.Destroy;
begin
  FCondition.free;
  FRole.free;
  FRank.free;
  inherited;
end;

procedure TFhirEpisodeOfCareDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEpisodeOfCareDiagnosis(oSource).condition.Clone;
  role := TFhirEpisodeOfCareDiagnosis(oSource).role.Clone;
  rankElement := TFhirEpisodeOfCareDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEpisodeOfCareDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEpisodeOfCareDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link)); {L1172}
end;

function TFhirEpisodeOfCareDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference.create() {L1203}
  else if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'rank') then result := TFhirPositiveInt.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference {L1195}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'rank') then RankElement := asPositiveInt(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareDiagnosis.fhirType : string;
begin
  result := 'EpisodeOfCare.diagnosis';
end;

function TFhirEpisodeOfCareDiagnosis.Link : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Link);
end;

function TFhirEpisodeOfCareDiagnosis.Clone : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEpisodeOfCareDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FRole) and isEmptyProp(FRank);
end;

procedure TFhirEpisodeOfCareDiagnosis.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value; {L1134}
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value; {L1134}
end;

function TFhirEpisodeOfCareDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

procedure TFhirEpisodeOfCareDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('condition');
  fields.add('role');
  fields.add('rank');
end;

function TFhirEpisodeOfCareDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCondition.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FRank.sizeInBytes);
end;

{ TFhirEpisodeOfCareDiagnosisListEnumerator }

constructor TFhirEpisodeOfCareDiagnosisListEnumerator.Create(list : TFhirEpisodeOfCareDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.GetCurrent : TFhirEpisodeOfCareDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEpisodeOfCareDiagnosisList }

procedure TFhirEpisodeOfCareDiagnosisList.AddItem(value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value.ClassName = 'TFhirEpisodeOfCareDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCareDiagnosis');
  add(value);
end;

function TFhirEpisodeOfCareDiagnosisList.Append: TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareDiagnosisList.GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
begin
  result := TFhirEpisodeOfCareDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareDiagnosisList.Clone: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareDiagnosisList.GetItemN(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareDiagnosis;
end;
function TFhirEpisodeOfCareDiagnosisList.IndexOf(value: TFhirEpisodeOfCareDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareDiagnosisList.Insert(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.InsertItem(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareDiagnosisList.Item(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.Link: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Link);
end;

procedure TFhirEpisodeOfCareDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  FhirEpisodeOfCareDiagnoses[index] := value;
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemN(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCare }

constructor TFhirEpisodeOfCare.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCare.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusHistoryList.Free;
  FType_List.Free;
  FDiagnosisList.Free;
  FPatient.free;
  FManagingOrganization.free;
  FPeriod.free;
  FReferralRequestList.Free;
  FCareManager.free;
  FTeamList.Free;
  FAccountList.Free;
  inherited;
end;

procedure TFhirEpisodeOfCare.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEpisodeOfCare(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEpisodeOfCare(oSource).FIdentifierList);
  end;
  statusElement := TFhirEpisodeOfCare(oSource).statusElement.Clone;
  if (TFhirEpisodeOfCare(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEpisodeOfCare(oSource).FStatusHistoryList);
  end;
  if (TFhirEpisodeOfCare(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEpisodeOfCare(oSource).FType_List);
  end;
  if (TFhirEpisodeOfCare(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEpisodeOfCare(oSource).FDiagnosisList);
  end;
  patient := TFhirEpisodeOfCare(oSource).patient.Clone;
  managingOrganization := TFhirEpisodeOfCare(oSource).managingOrganization.Clone;
  period := TFhirEpisodeOfCare(oSource).period.Clone;
  if (TFhirEpisodeOfCare(oSource).FReferralRequestList = nil) then
  begin
    FReferralRequestList.free;
    FReferralRequestList := nil;
  end
  else
  begin
    if FReferralRequestList = nil then
      FReferralRequestList := TFhirReferenceList.Create;
    FReferralRequestList.Assign(TFhirEpisodeOfCare(oSource).FReferralRequestList);
  end;
  careManager := TFhirEpisodeOfCare(oSource).careManager.Clone;
  if (TFhirEpisodeOfCare(oSource).FTeamList = nil) then
  begin
    FTeamList.free;
    FTeamList := nil;
  end
  else
  begin
    if FTeamList = nil then
      FTeamList := TFhirReferenceList.Create;
    FTeamList.Assign(TFhirEpisodeOfCare(oSource).FTeamList);
  end;
  if (TFhirEpisodeOfCare(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirEpisodeOfCare(oSource).FAccountList);
  end;
end;

function TFhirEpisodeOfCare.GetResourceType : TFhirResourceType;
begin
  result := frtEpisodeOfCare;
end;

procedure TFhirEpisodeOfCare.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'referralRequest') Then
    list.addAll(self, 'referralRequest', FReferralRequestList);
  if (child_name = 'careManager') Then
     list.add(self.link, 'careManager', FCareManager.Link);
  if (child_name = 'team') Then
    list.addAll(self, 'team', FTeamList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
end;

procedure TFhirEpisodeOfCare.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusHistory', 'BackboneElement', true, TFhirEpisodeOfCareStatusHistory, FStatusHistoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirEpisodeOfCareDiagnosis, FDiagnosisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referralRequest', 'Reference', true, TFhirReference, FReferralRequestList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'careManager', 'Reference', false, TFhirReference, FCareManager.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'team', 'Reference', true, TFhirReference, FTeamList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link)) {L1039};
end;

function TFhirEpisodeOfCare.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEpisodeOfCareStatusHistory) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEpisodeOfCareDiagnosis) {L1048};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'referralRequest') then
  begin
    ReferralRequestList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'careManager') then
  begin
    CareManager := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'team') then
  begin
    TeamList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCare.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEpisodeOfCareStatusHistory) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEpisodeOfCareDiagnosis) {L1049}
  else if (propName = 'referralRequest') then ReferralRequestList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'team') then TeamList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirEpisodeOfCare.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull], CODES_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull])  {L1211}
  else if (propName = 'statusHistory') then result := StatusHistoryList.new() {L1053}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'diagnosis') then result := DiagnosisList.new() {L1053}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'managingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'referralRequest') then result := ReferralRequestList.new() {L1053}
  else if (propName = 'careManager') then result := TFhirReference.create() {L1203}
  else if (propName = 'team') then result := TeamList.new() {L1053}
  else if (propName = 'account') then result := AccountList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCare.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'referralRequest') then result := 'Reference'
  else if (propName = 'careManager') then result := 'Reference'
  else if (propName = 'team') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCare.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value) {L1054}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {L1054}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'referralRequest') then deletePropertyValue('referralRequest', ReferralRequestList, value) {L1054}
  else if (propName = 'careManager') then CareManagerElement := nil
  else if (propName = 'team') then deletePropertyValue('team', TeamList, value) {L1054}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCare.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new) {L1210}
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new) {L1055}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {L1055}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'referralRequest') then replacePropertyValue('referralRequest', ReferralRequestList, existing, new) {L1055}
  else if (propName = 'careManager') then CareManagerElement := new as TFhirReference {L1195}
  else if (propName = 'team') then replacePropertyValue('team', TeamList, existing, new) {L1055}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCare.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination) {L1050}
  else if (propName = 'referralRequest') then ReferralRequestList.move(source, destination) {L1050}
  else if (propName = 'team') then TeamList.move(source, destination) {L1050}
  else if (propName = 'account') then AccountList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCare.fhirType : string;
begin
  result := 'EpisodeOfCare';
end;

function TFhirEpisodeOfCare.Link : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Link);
end;

function TFhirEpisodeOfCare.Clone : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Clone);
end;

function TFhirEpisodeOfCare.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCare;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCare)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCare(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(diagnosisList, o.diagnosisList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(referralRequestList, o.referralRequestList, true) and 
      compareDeep(careManagerElement, o.careManagerElement, true) and compareDeep(teamList, o.teamList, true) and 
      compareDeep(accountList, o.accountList, true);
  end;
end;

function TFhirEpisodeOfCare.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FdiagnosisList) and isEmptyProp(FPatient) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPeriod) and isEmptyProp(FreferralRequestList) and isEmptyProp(FCareManager) and isEmptyProp(FteamList) and isEmptyProp(FaccountList);
end;

function TFhirEpisodeOfCare.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEpisodeOfCare.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEpisodeOfCare.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

procedure TFhirEpisodeOfCare.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

function TFhirEpisodeOfCare.GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

function TFhirEpisodeOfCare.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

function TFhirEpisodeOfCare.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEpisodeOfCare.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirEpisodeOfCare.GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirEpisodeOfCare.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirEpisodeOfCare.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value; {L1134}
end;

procedure TFhirEpisodeOfCare.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirEpisodeOfCare.GetReferralRequestList : TFhirReferenceList;
begin
  if FReferralRequestList = nil then
    FReferralRequestList := TFhirReferenceList.Create;
  result := FReferralRequestList;
end;

function TFhirEpisodeOfCare.GetHasReferralRequestList : boolean;
begin
  result := (FReferralRequestList <> nil) and (FReferralRequestList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetCareManager(value : TFhirReference);
begin
  FCareManager.free;
  FCareManager := value; {L1134}
end;

function TFhirEpisodeOfCare.GetTeamList : TFhirReferenceList;
begin
  if FTeamList = nil then
    FTeamList := TFhirReferenceList.Create;
  result := FTeamList;
end;

function TFhirEpisodeOfCare.GetHasTeamList : boolean;
begin
  result := (FTeamList <> nil) and (FTeamList.count > 0);
end;

function TFhirEpisodeOfCare.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirEpisodeOfCare.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

procedure TFhirEpisodeOfCare.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('type');
  fields.add('diagnosis');
  fields.add('patient');
  fields.add('managingOrganization');
  fields.add('period');
  fields.add('referralRequest');
  fields.add('careManager');
  fields.add('team');
  fields.add('account');
end;

function TFhirEpisodeOfCare.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusHistoryList.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FManagingOrganization.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FreferralRequestList.sizeInBytes);
  inc(result, FCareManager.sizeInBytes);
  inc(result, FteamList.sizeInBytes);
  inc(result, FaccountList.sizeInBytes);
end;

{ TFhirEpisodeOfCareListEnumerator }

constructor TFhirEpisodeOfCareListEnumerator.Create(list : TFhirEpisodeOfCareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareListEnumerator.GetCurrent : TFhirEpisodeOfCare;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEpisodeOfCareList }

procedure TFhirEpisodeOfCareList.AddItem(value: TFhirEpisodeOfCare);
begin
  assert(value.ClassName = 'TFhirEpisodeOfCare', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCare');
  add(value);
end;

function TFhirEpisodeOfCareList.Append: TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareList.GetEnumerator : TFhirEpisodeOfCareListEnumerator;
begin
  result := TFhirEpisodeOfCareListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareList.Clone: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Clone);
end;

function TFhirEpisodeOfCareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareList.GetItemN(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCare;
end;
function TFhirEpisodeOfCareList.IndexOf(value: TFhirEpisodeOfCare): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareList.Insert(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.InsertItem(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareList.Item(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.Link: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Link);
end;

procedure TFhirEpisodeOfCareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  FhirEpisodeOfCares[index] := value;
end;

procedure TFhirEpisodeOfCareList.SetItemN(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
{ TFhirFamilyMemberHistoryCondition }

constructor TFhirFamilyMemberHistoryCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistoryCondition.Destroy;
begin
  FCode.free;
  FOutcome.free;
  FContributedToDeath.free;
  FOnset.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistoryCondition.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirFamilyMemberHistoryCondition(oSource).code.Clone;
  outcome := TFhirFamilyMemberHistoryCondition(oSource).outcome.Clone;
  contributedToDeathElement := TFhirFamilyMemberHistoryCondition(oSource).contributedToDeathElement.Clone;
  onset := TFhirFamilyMemberHistoryCondition(oSource).onset.Clone;
  if (TFhirFamilyMemberHistoryCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistoryCondition(oSource).FNoteList);
  end;
end;

procedure TFhirFamilyMemberHistoryCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'contributedToDeath') Then
     list.add(self.link, 'contributedToDeath', FContributedToDeath.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contributedToDeath', 'boolean', false, TFhirBoolean, FContributedToDeath.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|Period|string', false, TFhirDataType, FOnset.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirFamilyMemberHistoryCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'contributedToDeath') then
  begin
    ContributedToDeathElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then
  begin
    Onset := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistoryCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirFamilyMemberHistoryCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'contributedToDeath') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Onset') {L1191}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistoryCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'contributedToDeath') then result := 'boolean'
  else if (propName = 'onset[x]') then result := 'Age|Range|Period|string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistoryCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := nil
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := nil {L1189}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistoryCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := new as TFhirDataType {L1190}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistoryCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistoryCondition.fhirType : string;
begin
  result := 'FamilyMemberHistory.condition';
end;

function TFhirFamilyMemberHistoryCondition.Link : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Link);
end;

function TFhirFamilyMemberHistoryCondition.Clone : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Clone);
end;

function TFhirFamilyMemberHistoryCondition.equals(other : TObject) : boolean; 
var
  o : TFhirFamilyMemberHistoryCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistoryCondition)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistoryCondition(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(contributedToDeathElement, o.contributedToDeathElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirFamilyMemberHistoryCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FOutcome) and isEmptyProp(FContributedToDeath) and isEmptyProp(FOnset) and isEmptyProp(FnoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirFamilyMemberHistoryCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value; {L1134}
end;

procedure TFhirFamilyMemberHistoryCondition.SetContributedToDeath(value : TFhirBoolean);
begin
  FContributedToDeath.free;
  FContributedToDeath := value; {L1134}
end;

function TFhirFamilyMemberHistoryCondition.GetContributedToDeathST : Boolean;
begin
  if FContributedToDeath = nil then
    result := false
  else
    result := FContributedToDeath.value;
end;

procedure TFhirFamilyMemberHistoryCondition.SetContributedToDeathST(value : Boolean);
begin
  if FContributedToDeath = nil then
    FContributedToDeath := TFhirBoolean.create;
  FContributedToDeath.value := value
end;

procedure TFhirFamilyMemberHistoryCondition.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value; {L1134}
end;

function TFhirFamilyMemberHistoryCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirFamilyMemberHistoryCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirFamilyMemberHistoryCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('outcome');
  fields.add('contributedToDeath');
  fields.add('onset[x]');
  fields.add('note');
end;

function TFhirFamilyMemberHistoryCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FContributedToDeath.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionListEnumerator }

constructor TFhirFamilyMemberHistoryConditionListEnumerator.Create(list : TFhirFamilyMemberHistoryConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.GetCurrent : TFhirFamilyMemberHistoryCondition;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionList }

procedure TFhirFamilyMemberHistoryConditionList.AddItem(value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistoryCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistoryCondition');
  add(value);
end;

function TFhirFamilyMemberHistoryConditionList.Append: TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryConditionList.GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
begin
  result := TFhirFamilyMemberHistoryConditionListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryConditionList.Clone: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Clone);
end;

function TFhirFamilyMemberHistoryConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryConditionList.GetItemN(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistoryCondition;
end;
function TFhirFamilyMemberHistoryConditionList.IndexOf(value: TFhirFamilyMemberHistoryCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryConditionList.Insert(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.InsertItem(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryConditionList.Item(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.Link: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  FhirFamilyMemberHistoryConditions[index] := value;
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemN(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyMemberHistoryProcedure }

constructor TFhirFamilyMemberHistoryProcedure.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistoryProcedure.Destroy;
begin
  FCode.free;
  FOutcome.free;
  FContributedToDeath.free;
  FPerformed.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistoryProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirFamilyMemberHistoryProcedure(oSource).code.Clone;
  outcome := TFhirFamilyMemberHistoryProcedure(oSource).outcome.Clone;
  contributedToDeathElement := TFhirFamilyMemberHistoryProcedure(oSource).contributedToDeathElement.Clone;
  performed := TFhirFamilyMemberHistoryProcedure(oSource).performed.Clone;
  if (TFhirFamilyMemberHistoryProcedure(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistoryProcedure(oSource).FNoteList);
  end;
end;

procedure TFhirFamilyMemberHistoryProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'contributedToDeath') Then
     list.add(self.link, 'contributedToDeath', FContributedToDeath.Link);
  if (child_name = 'performed[x]') or (child_name = 'performed') Then
     list.add(self.link, 'performed[x]', FPerformed.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirFamilyMemberHistoryProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contributedToDeath', 'boolean', false, TFhirBoolean, FContributedToDeath.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performed[x]', 'Age|Range|Period|string|dateTime', false, TFhirDataType, FPerformed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirFamilyMemberHistoryProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'contributedToDeath') then
  begin
    ContributedToDeathElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'performed', ['Age', 'Range', 'Period', 'String', 'DateTime'])) then
  begin
    Performed := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistoryProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirFamilyMemberHistoryProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'contributedToDeath') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'performed', ['Age', 'Range', 'Period', 'String', 'DateTime'])) then raise EFHIRException.create('Cannot make property Performed') {L1191}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistoryProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'contributedToDeath') then result := 'boolean'
  else if (propName = 'performed[x]') then result := 'Age|Range|Period|string|dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistoryProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := nil
  else if (isMatchingName(propName, 'performed', ['Age', 'Range', 'Period', 'String', 'DateTime'])) then PerformedElement := nil {L1189}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistoryProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'performed', ['Age', 'Range', 'Period', 'String', 'DateTime'])) then PerformedElement := new as TFhirDataType {L1190}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistoryProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistoryProcedure.fhirType : string;
begin
  result := 'FamilyMemberHistory.procedure';
end;

function TFhirFamilyMemberHistoryProcedure.Link : TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure(inherited Link);
end;

function TFhirFamilyMemberHistoryProcedure.Clone : TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure(inherited Clone);
end;

function TFhirFamilyMemberHistoryProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirFamilyMemberHistoryProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistoryProcedure)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistoryProcedure(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(contributedToDeathElement, o.contributedToDeathElement, true) and 
      compareDeep(performedElement, o.performedElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirFamilyMemberHistoryProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FOutcome) and isEmptyProp(FContributedToDeath) and isEmptyProp(FPerformed) and isEmptyProp(FnoteList);
end;

procedure TFhirFamilyMemberHistoryProcedure.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirFamilyMemberHistoryProcedure.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value; {L1134}
end;

procedure TFhirFamilyMemberHistoryProcedure.SetContributedToDeath(value : TFhirBoolean);
begin
  FContributedToDeath.free;
  FContributedToDeath := value; {L1134}
end;

function TFhirFamilyMemberHistoryProcedure.GetContributedToDeathST : Boolean;
begin
  if FContributedToDeath = nil then
    result := false
  else
    result := FContributedToDeath.value;
end;

procedure TFhirFamilyMemberHistoryProcedure.SetContributedToDeathST(value : Boolean);
begin
  if FContributedToDeath = nil then
    FContributedToDeath := TFhirBoolean.create;
  FContributedToDeath.value := value
end;

procedure TFhirFamilyMemberHistoryProcedure.SetPerformed(value : TFhirDataType);
begin
  FPerformed.free;
  FPerformed := value; {L1134}
end;

function TFhirFamilyMemberHistoryProcedure.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirFamilyMemberHistoryProcedure.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirFamilyMemberHistoryProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('outcome');
  fields.add('contributedToDeath');
  fields.add('performed[x]');
  fields.add('note');
end;

function TFhirFamilyMemberHistoryProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FContributedToDeath.sizeInBytes);
  inc(result, FPerformed.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryProcedureListEnumerator }

constructor TFhirFamilyMemberHistoryProcedureListEnumerator.Create(list : TFhirFamilyMemberHistoryProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryProcedureListEnumerator.GetCurrent : TFhirFamilyMemberHistoryProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryProcedureList }

procedure TFhirFamilyMemberHistoryProcedureList.AddItem(value: TFhirFamilyMemberHistoryProcedure);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistoryProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistoryProcedure');
  add(value);
end;

function TFhirFamilyMemberHistoryProcedureList.Append: TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryProcedureList.GetEnumerator : TFhirFamilyMemberHistoryProcedureListEnumerator;
begin
  result := TFhirFamilyMemberHistoryProcedureListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryProcedureList.Clone: TFhirFamilyMemberHistoryProcedureList;
begin
  result := TFhirFamilyMemberHistoryProcedureList(inherited Clone);
end;

function TFhirFamilyMemberHistoryProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryProcedureList.GetItemN(index: Integer): TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistoryProcedure;
end;
function TFhirFamilyMemberHistoryProcedureList.IndexOf(value: TFhirFamilyMemberHistoryProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryProcedureList.Insert(index: Integer): TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryProcedureList.InsertItem(index: Integer; value: TFhirFamilyMemberHistoryProcedure);
begin
  assert(value is TFhirFamilyMemberHistoryProcedure);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryProcedureList.Item(index: Integer): TFhirFamilyMemberHistoryProcedure;
begin
  result := TFhirFamilyMemberHistoryProcedure(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryProcedureList.Link: TFhirFamilyMemberHistoryProcedureList;
begin
  result := TFhirFamilyMemberHistoryProcedureList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryProcedureList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistoryProcedure);
begin
  assert(value is TFhirFamilyMemberHistoryProcedure);
  FhirFamilyMemberHistoryProcedures[index] := value;
end;

procedure TFhirFamilyMemberHistoryProcedureList.SetItemN(index: Integer; value: TFhirFamilyMemberHistoryProcedure);
begin
  assert(value is TFhirFamilyMemberHistoryProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyMemberHistory }

constructor TFhirFamilyMemberHistory.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistory.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FStatus.free;
  FDataAbsentReason.free;
  FPatient.free;
  FDate.free;
  FName.free;
  FRelationship.free;
  FSex.free;
  FBorn.free;
  FAge.free;
  FEstimatedAge.free;
  FDeceased.free;
  FReasonList.Free;
  FNoteList.Free;
  FConditionList.Free;
  FProcedure_List.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistory.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFamilyMemberHistory(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFamilyMemberHistory(oSource).FIdentifierList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirFamilyMemberHistory(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirFamilyMemberHistory(oSource).FInstantiatesUriList);
  end;
  statusElement := TFhirFamilyMemberHistory(oSource).statusElement.Clone;
  dataAbsentReason := TFhirFamilyMemberHistory(oSource).dataAbsentReason.Clone;
  patient := TFhirFamilyMemberHistory(oSource).patient.Clone;
  dateElement := TFhirFamilyMemberHistory(oSource).dateElement.Clone;
  nameElement := TFhirFamilyMemberHistory(oSource).nameElement.Clone;
  relationship := TFhirFamilyMemberHistory(oSource).relationship.Clone;
  sex := TFhirFamilyMemberHistory(oSource).sex.Clone;
  born := TFhirFamilyMemberHistory(oSource).born.Clone;
  age := TFhirFamilyMemberHistory(oSource).age.Clone;
  estimatedAgeElement := TFhirFamilyMemberHistory(oSource).estimatedAgeElement.Clone;
  deceased := TFhirFamilyMemberHistory(oSource).deceased.Clone;
  if (TFhirFamilyMemberHistory(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirFamilyMemberHistory(oSource).FReasonList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistory(oSource).FNoteList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
    FConditionList.Assign(TFhirFamilyMemberHistory(oSource).FConditionList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirFamilyMemberHistoryProcedureList.Create;
    FProcedure_List.Assign(TFhirFamilyMemberHistory(oSource).FProcedure_List);
  end;
end;

function TFhirFamilyMemberHistory.GetResourceType : TFhirResourceType;
begin
  result := frtFamilyMemberHistory;
end;

procedure TFhirFamilyMemberHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'sex') Then
     list.add(self.link, 'sex', FSex.Link);
  if (child_name = 'born[x]') or (child_name = 'born') Then
     list.add(self.link, 'born[x]', FBorn.Link);
  if (child_name = 'age[x]') or (child_name = 'age') Then
     list.add(self.link, 'age[x]', FAge.Link);
  if (child_name = 'estimatedAge') Then
     list.add(self.link, 'estimatedAge', FEstimatedAge.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
end;

procedure TFhirFamilyMemberHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sex', 'CodeableConcept', false, TFhirCodeableConcept, FSex.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', false, TFhirDataType, FBorn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'age[x]', 'Age|Range|string', false, TFhirDataType, FAge.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'estimatedAge', 'boolean', false, TFhirBoolean, FEstimatedAge.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|date|string', false, TFhirDataType, FDeceased.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirFamilyMemberHistoryCondition, FConditionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirFamilyMemberHistoryProcedure, FProcedure_List.Link)) {L1039};
end;

function TFhirFamilyMemberHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFamilyHistoryStatusEnum, CODES_TFhirFamilyHistoryStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'sex') then
  begin
    Sex := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then
  begin
    Born := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then
  begin
    Age := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'estimatedAge') then
  begin
    EstimatedAgeElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then
  begin
    Deceased := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirFamilyMemberHistoryCondition) {L1048};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirFamilyMemberHistoryProcedure) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirFamilyMemberHistoryCondition) {L1049}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirFamilyMemberHistoryProcedure) {L1049}
  else inherited;
end;

function TFhirFamilyMemberHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFamilyHistoryStatusEnum[FamilyHistoryStatusNull], CODES_TFhirFamilyHistoryStatusEnum[FamilyHistoryStatusNull])  {L1211}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'sex') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Born') {L1191}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Age') {L1191}
  else if (propName = 'estimatedAge') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Deceased') {L1191}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'condition') then result := ConditionList.new() {L1053}
  else if (propName = 'procedure') then result := Procedure_List.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'sex') then result := 'CodeableConcept'
  else if (propName = 'born[x]') then result := 'Period|date|string'
  else if (propName = 'age[x]') then result := 'Age|Range|string'
  else if (propName = 'estimatedAge') then result := 'boolean'
  else if (propName = 'deceased[x]') then result := 'boolean|Age|Range|date|string'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'sex') then SexElement := nil
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := nil {L1189}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := nil {L1189}
  else if (propName = 'estimatedAge') then EstimatedAgeElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := nil {L1189}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {L1054}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFamilyHistoryStatusEnum, CODES_TFhirFamilyHistoryStatusEnum, new) {L1210}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'sex') then SexElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := new as TFhirDataType {L1190}
  else if (propName = 'estimatedAge') then EstimatedAgeElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := new as TFhirDataType {L1190}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {L1055}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'condition') then ConditionList.move(source, destination) {L1050}
  else if (propName = 'procedure') then Procedure_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistory.fhirType : string;
begin
  result := 'FamilyMemberHistory';
end;

function TFhirFamilyMemberHistory.Link : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Link);
end;

function TFhirFamilyMemberHistory.Clone : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Clone);
end;

function TFhirFamilyMemberHistory.equals(other : TObject) : boolean; 
var
  o : TFhirFamilyMemberHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistory)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistory(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(sexElement, o.sexElement, true) and 
      compareDeep(bornElement, o.bornElement, true) and compareDeep(ageElement, o.ageElement, true) and 
      compareDeep(estimatedAgeElement, o.estimatedAgeElement, true) and compareDeep(deceasedElement, o.deceasedElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(conditionList, o.conditionList, true) and compareDeep(procedure_List, o.procedure_List, true);
  end;
end;

function TFhirFamilyMemberHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FStatus) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FName) and isEmptyProp(FRelationship) and isEmptyProp(FSex) and isEmptyProp(FBorn) and isEmptyProp(FAge) and isEmptyProp(FEstimatedAge) and isEmptyProp(FDeceased) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList) and isEmptyProp(FconditionList) and isEmptyProp(Fprocedure_List);
end;

function TFhirFamilyMemberHistory.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirFamilyMemberHistory.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirFamilyMemberHistory.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirFamilyMemberHistory.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirFamilyMemberHistory.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirFamilyMemberHistory.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

procedure TFhirFamilyMemberHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirFamilyMemberHistory.GetStatusST : TFhirFamilyHistoryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFamilyHistoryStatusEnum(0)
  else
    result := TFhirFamilyHistoryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFamilyHistoryStatusEnum, FStatus.value));
end;

procedure TFhirFamilyMemberHistory.SetStatusST(value : TFhirFamilyHistoryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFamilyHistoryStatusEnum[value], CODES_TFhirFamilyHistoryStatusEnum[value]);
end;

procedure TFhirFamilyMemberHistory.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirFamilyMemberHistory.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirFamilyMemberHistory.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirFamilyMemberHistory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirFamilyMemberHistory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirFamilyMemberHistory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirFamilyMemberHistory.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetSex(value : TFhirCodeableConcept);
begin
  FSex.free;
  FSex := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetBorn(value : TFhirDataType);
begin
  FBorn.free;
  FBorn := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetAge(value : TFhirDataType);
begin
  FAge.free;
  FAge := value; {L1134}
end;

procedure TFhirFamilyMemberHistory.SetEstimatedAge(value : TFhirBoolean);
begin
  FEstimatedAge.free;
  FEstimatedAge := value; {L1134}
end;

function TFhirFamilyMemberHistory.GetEstimatedAgeST : Boolean;
begin
  if FEstimatedAge = nil then
    result := false
  else
    result := FEstimatedAge.value;
end;

procedure TFhirFamilyMemberHistory.SetEstimatedAgeST(value : Boolean);
begin
  if FEstimatedAge = nil then
    FEstimatedAge := TFhirBoolean.create;
  FEstimatedAge.value := value
end;

procedure TFhirFamilyMemberHistory.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value; {L1134}
end;

function TFhirFamilyMemberHistory.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirFamilyMemberHistory.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirFamilyMemberHistory.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirFamilyMemberHistory.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirFamilyMemberHistory.GetConditionList : TFhirFamilyMemberHistoryConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
  result := FConditionList;
end;

function TFhirFamilyMemberHistory.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirFamilyMemberHistory.GetProcedure_List : TFhirFamilyMemberHistoryProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirFamilyMemberHistoryProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirFamilyMemberHistory.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

procedure TFhirFamilyMemberHistory.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('status');
  fields.add('dataAbsentReason');
  fields.add('patient');
  fields.add('date');
  fields.add('name');
  fields.add('relationship');
  fields.add('sex');
  fields.add('born[x]');
  fields.add('age[x]');
  fields.add('estimatedAge');
  fields.add('deceased[x]');
  fields.add('reason');
  fields.add('note');
  fields.add('condition');
  fields.add('procedure');
end;

function TFhirFamilyMemberHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FSex.sizeInBytes);
  inc(result, FBorn.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FEstimatedAge.sizeInBytes);
  inc(result, FDeceased.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryListEnumerator }

constructor TFhirFamilyMemberHistoryListEnumerator.Create(list : TFhirFamilyMemberHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryListEnumerator.GetCurrent : TFhirFamilyMemberHistory;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryList }

procedure TFhirFamilyMemberHistoryList.AddItem(value: TFhirFamilyMemberHistory);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistory');
  add(value);
end;

function TFhirFamilyMemberHistoryList.Append: TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryList.GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
begin
  result := TFhirFamilyMemberHistoryListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryList.Clone: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Clone);
end;

function TFhirFamilyMemberHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryList.GetItemN(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistory;
end;
function TFhirFamilyMemberHistoryList.IndexOf(value: TFhirFamilyMemberHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryList.Insert(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.InsertItem(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryList.Item(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.Link: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  FhirFamilyMemberHistories[index] := value;
end;

procedure TFhirFamilyMemberHistoryList.SetItemN(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
{ TFhirFlag }

constructor TFhirFlag.Create;
begin
  inherited;
end;

destructor TFhirFlag.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FPeriod.free;
  FEncounter.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirFlag.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFlag(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFlag(oSource).FIdentifierList);
  end;
  statusElement := TFhirFlag(oSource).statusElement.Clone;
  if (TFhirFlag(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirFlag(oSource).FCategoryList);
  end;
  code := TFhirFlag(oSource).code.Clone;
  subject := TFhirFlag(oSource).subject.Clone;
  period := TFhirFlag(oSource).period.Clone;
  encounter := TFhirFlag(oSource).encounter.Clone;
  author := TFhirFlag(oSource).author.Clone;
end;

function TFhirFlag.GetResourceType : TFhirResourceType;
begin
  result := frtFlag;
end;

procedure TFhirFlag.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirFlag.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
end;

function TFhirFlag.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFlag.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirFlag.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[FlagStatusNull], CODES_TFhirFlagStatusEnum[FlagStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFlag.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFlag.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFlag.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFlag.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFlag.fhirType : string;
begin
  result := 'Flag';
end;

function TFhirFlag.Link : TFhirFlag;
begin
  result := TFhirFlag(inherited Link);
end;

function TFhirFlag.Clone : TFhirFlag;
begin
  result := TFhirFlag(inherited Clone);
end;

function TFhirFlag.equals(other : TObject) : boolean; 
var
  o : TFhirFlag;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFlag)) then
    result := false
  else
  begin
    o := TFhirFlag(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirFlag.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FPeriod) and isEmptyProp(FEncounter) and isEmptyProp(FAuthor);
end;

function TFhirFlag.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirFlag.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirFlag.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirFlag.GetStatusST : TFhirFlagStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFlagStatusEnum(0)
  else
    result := TFhirFlagStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFlagStatusEnum, FStatus.value));
end;

procedure TFhirFlag.SetStatusST(value : TFhirFlagStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[value], CODES_TFhirFlagStatusEnum[value]);
end;

function TFhirFlag.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirFlag.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirFlag.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirFlag.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirFlag.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirFlag.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirFlag.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

procedure TFhirFlag.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('period');
  fields.add('encounter');
  fields.add('author');
end;

function TFhirFlag.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirFlagListEnumerator }

constructor TFhirFlagListEnumerator.Create(list : TFhirFlagList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFlagListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFlagListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFlagListEnumerator.GetCurrent : TFhirFlag;
begin
  Result := FList[FIndex];
end;

function TFhirFlagListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFlagList }

procedure TFhirFlagList.AddItem(value: TFhirFlag);
begin
  assert(value.ClassName = 'TFhirFlag', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFlag');
  add(value);
end;

function TFhirFlagList.Append: TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.ClearItems;
begin
  Clear;
end;

function TFhirFlagList.GetEnumerator : TFhirFlagListEnumerator;
begin
  result := TFhirFlagListEnumerator.Create(self.link);
end;

function TFhirFlagList.Clone: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Clone);
end;

function TFhirFlagList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFlagList.GetItemN(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.ItemClass: TFslObjectClass;
begin
  result := TFhirFlag;
end;
function TFhirFlagList.IndexOf(value: TFhirFlag): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFlagList.Insert(index: Integer): TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.InsertItem(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  Inherited Insert(index, value);
end;

function TFhirFlagList.Item(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.Link: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Link);
end;

procedure TFhirFlagList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFlagList.SetItemByIndex(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  FhirFlags[index] := value;
end;

procedure TFhirFlagList.SetItemN(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
{ TFhirGoalTarget }

constructor TFhirGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirGoalTarget(oSource).measure.Clone;
  detail := TFhirGoalTarget(oSource).detail.Clone;
  due := TFhirGoalTarget(oSource).due.Clone;
end;

procedure TFhirGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due[x]') or (child_name = 'due') Then
     list.add(self.link, 'due[x]', FDue.Link);
end;

procedure TFhirGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio', false, TFhirDataType, FDetail.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'due[x]', 'date|Duration', false, TFhirDataType, FDue.Link)); {L1172}
end;

function TFhirGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then
  begin
    Detail := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then
  begin
    Due := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then raise EFHIRException.create('Cannot make property Detail') {L1191}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then raise EFHIRException.create('Cannot make property Due') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio'
  else if (propName = 'due[x]') then result := 'date|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := nil {L1189}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGoalTarget.fhirType : string;
begin
  result := 'Goal.target';
end;

function TFhirGoalTarget.Link : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Link);
end;

function TFhirGoalTarget.Clone : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Clone);
end;

function TFhirGoalTarget.equals(other : TObject) : boolean; 
var
  o : TFhirGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoalTarget)) then
    result := false
  else
  begin
    o := TFhirGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value; {L1134}
end;

procedure TFhirGoalTarget.SetDetail(value : TFhirDataType);
begin
  FDetail.free;
  FDetail := value; {L1134}
end;

procedure TFhirGoalTarget.SetDue(value : TFhirDataType);
begin
  FDue.free;
  FDue := value; {L1134}
end;

procedure TFhirGoalTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due[x]');
end;

function TFhirGoalTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeasure.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FDue.sizeInBytes);
end;

{ TFhirGoalTargetListEnumerator }

constructor TFhirGoalTargetListEnumerator.Create(list : TFhirGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalTargetListEnumerator.GetCurrent : TFhirGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirGoalTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalTargetList }

procedure TFhirGoalTargetList.AddItem(value: TFhirGoalTarget);
begin
  assert(value.ClassName = 'TFhirGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoalTarget');
  add(value);
end;

function TFhirGoalTargetList.Append: TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirGoalTargetList.GetEnumerator : TFhirGoalTargetListEnumerator;
begin
  result := TFhirGoalTargetListEnumerator.Create(self.link);
end;

function TFhirGoalTargetList.Clone: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Clone);
end;

function TFhirGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalTargetList.GetItemN(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoalTarget;
end;
function TFhirGoalTargetList.IndexOf(value: TFhirGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalTargetList.Insert(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.InsertItem(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirGoalTargetList.Item(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.Link: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Link);
end;

procedure TFhirGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalTargetList.SetItemByIndex(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  FhirGoalTargets[index] := value;
end;

procedure TFhirGoalTargetList.SetItemN(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirGoal }

constructor TFhirGoal.Create;
begin
  inherited;
end;

destructor TFhirGoal.Destroy;
begin
  FIdentifierList.Free;
  FLifecycleStatus.free;
  FAchievementStatus.free;
  FCategoryList.Free;
  FContinuous.free;
  FPriority.free;
  FDescription.free;
  FSubject.free;
  FStart.free;
  FTargetList.Free;
  FStatusDate.free;
  FStatusReason.free;
  FExpressedBy.free;
  FAddressesList.Free;
  FNoteList.Free;
  FOutcomeList.Free;
  inherited;
end;

procedure TFhirGoal.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGoal(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGoal(oSource).FIdentifierList);
  end;
  lifecycleStatusElement := TFhirGoal(oSource).lifecycleStatusElement.Clone;
  achievementStatus := TFhirGoal(oSource).achievementStatus.Clone;
  if (TFhirGoal(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirGoal(oSource).FCategoryList);
  end;
  continuousElement := TFhirGoal(oSource).continuousElement.Clone;
  priority := TFhirGoal(oSource).priority.Clone;
  description := TFhirGoal(oSource).description.Clone;
  subject := TFhirGoal(oSource).subject.Clone;
  start := TFhirGoal(oSource).start.Clone;
  if (TFhirGoal(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirGoalTargetList.Create;
    FTargetList.Assign(TFhirGoal(oSource).FTargetList);
  end;
  statusDateElement := TFhirGoal(oSource).statusDateElement.Clone;
  statusReasonElement := TFhirGoal(oSource).statusReasonElement.Clone;
  expressedBy := TFhirGoal(oSource).expressedBy.Clone;
  if (TFhirGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList.Create;
    FAddressesList.Assign(TFhirGoal(oSource).FAddressesList);
  end;
  if (TFhirGoal(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGoal(oSource).FNoteList);
  end;
  if (TFhirGoal(oSource).FOutcomeList = nil) then
  begin
    FOutcomeList.free;
    FOutcomeList := nil;
  end
  else
  begin
    if FOutcomeList = nil then
      FOutcomeList := TFhirCodeableReferenceList.Create;
    FOutcomeList.Assign(TFhirGoal(oSource).FOutcomeList);
  end;
end;

function TFhirGoal.GetResourceType : TFhirResourceType;
begin
  result := frtGoal;
end;

procedure TFhirGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'lifecycleStatus') Then
     list.add(self.link, 'lifecycleStatus', FLifecycleStatus.Link);
  if (child_name = 'achievementStatus') Then
     list.add(self.link, 'achievementStatus', FAchievementStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'continuous') Then
     list.add(self.link, 'continuous', FContinuous.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'start[x]') or (child_name = 'start') Then
     list.add(self.link, 'start[x]', FStart.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'expressedBy') Then
     list.add(self.link, 'expressedBy', FExpressedBy.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'outcome') Then
    list.addAll(self, 'outcome', FOutcomeList);
end;

procedure TFhirGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'lifecycleStatus', 'code', false, TFhirEnum, FLifecycleStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'achievementStatus', 'CodeableConcept', false, TFhirCodeableConcept, FAchievementStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'continuous', 'boolean', false, TFhirBoolean, FContinuous.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'start[x]', 'date|CodeableConcept', false, TFhirDataType, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirGoalTarget, FTargetList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'statusDate', 'date', false, TFhirDate, FStatusDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'string', false, TFhirString, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expressedBy', 'Reference', false, TFhirReference, FExpressedBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference', true, TFhirReference, FAddressesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableReference', true, TFhirCodeableReference, FOutcomeList.Link)) {L1039};
end;

function TFhirGoal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'lifecycleStatus') then
  begin
    LifecycleStatusElement := asEnum(SYSTEMS_TFhirGoalLifecycleStatusEnum, CODES_TFhirGoalLifecycleStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'achievementStatus') then
  begin
    AchievementStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'continuous') then
  begin
    ContinuousElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then
  begin
    Start := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirGoalTarget) {L1048};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expressedBy') then
  begin
    ExpressedBy := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirGoalTarget) {L1049}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'outcome') then OutcomeList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else inherited;
end;

function TFhirGoal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'lifecycleStatus') then result := TFhirEnum.create(SYSTEMS_TFhirGoalLifecycleStatusEnum[GoalLifecycleStatusNull], CODES_TFhirGoalLifecycleStatusEnum[GoalLifecycleStatusNull])  {L1211}
  else if (propName = 'achievementStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'continuous') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Start') {L1191}
  else if (propName = 'target') then result := TargetList.new() {L1053}
  else if (propName = 'statusDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'statusReason') then result := TFhirString.create() {L1223}
  else if (propName = 'expressedBy') then result := TFhirReference.create() {L1203}
  else if (propName = 'addresses') then result := AddressesList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'outcome') then result := OutcomeList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'lifecycleStatus') then result := 'code'
  else if (propName = 'achievementStatus') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'continuous') then result := 'boolean'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'start[x]') then result := 'date|CodeableConcept'
  else if (propName = 'target') then result := 'BackboneElement'
  else if (propName = 'statusDate') then result := 'date'
  else if (propName = 'statusReason') then result := 'string'
  else if (propName = 'expressedBy') then result := 'Reference'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'outcome') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'lifecycleStatus') then LifecycleStatusElement := nil
  else if (propName = 'achievementStatus') then AchievementStatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'continuous') then ContinuousElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := nil {L1189}
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {L1054}
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'expressedBy') then ExpressedByElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'outcome') then deletePropertyValue('outcome', OutcomeList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'lifecycleStatus') then LifecycleStatusElement := asEnum(SYSTEMS_TFhirGoalLifecycleStatusEnum, CODES_TFhirGoalLifecycleStatusEnum, new) {L1210}
  else if (propName = 'achievementStatus') then AchievementStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'continuous') then ContinuousElement := asBoolean(new) {L1222}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := new as TFhirDataType {L1190}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {L1055}
  else if (propName = 'statusDate') then StatusDateElement := asDate(new) {L1222}
  else if (propName = 'statusReason') then StatusReasonElement := asString(new) {L1222}
  else if (propName = 'expressedBy') then ExpressedByElement := new as TFhirReference {L1195}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'outcome') then replacePropertyValue('outcome', OutcomeList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'target') then TargetList.move(source, destination) {L1050}
  else if (propName = 'addresses') then AddressesList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'outcome') then OutcomeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGoal.fhirType : string;
begin
  result := 'Goal';
end;

function TFhirGoal.Link : TFhirGoal;
begin
  result := TFhirGoal(inherited Link);
end;

function TFhirGoal.Clone : TFhirGoal;
begin
  result := TFhirGoal(inherited Clone);
end;

function TFhirGoal.equals(other : TObject) : boolean; 
var
  o : TFhirGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoal)) then
    result := false
  else
  begin
    o := TFhirGoal(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(lifecycleStatusElement, o.lifecycleStatusElement, true) and 
      compareDeep(achievementStatusElement, o.achievementStatusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(continuousElement, o.continuousElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(targetList, o.targetList, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(expressedByElement, o.expressedByElement, true) and compareDeep(addressesList, o.addressesList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(outcomeList, o.outcomeList, true);
  end;
end;

function TFhirGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FLifecycleStatus) and isEmptyProp(FAchievementStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FContinuous) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FStart) and isEmptyProp(FtargetList) and isEmptyProp(FStatusDate) and isEmptyProp(FStatusReason) and isEmptyProp(FExpressedBy) and isEmptyProp(FaddressesList) and isEmptyProp(FnoteList) and isEmptyProp(FoutcomeList);
end;

function TFhirGoal.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGoal.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGoal.SetLifecycleStatus(value : TFhirEnum);
begin
  FLifecycleStatus.free;
  FLifecycleStatus := value;
end;

function TFhirGoal.GetLifecycleStatusST : TFhirGoalLifecycleStatusEnum;
begin
  if FLifecycleStatus = nil then
    result := TFhirGoalLifecycleStatusEnum(0)
  else
    result := TFhirGoalLifecycleStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGoalLifecycleStatusEnum, FLifecycleStatus.value));
end;

procedure TFhirGoal.SetLifecycleStatusST(value : TFhirGoalLifecycleStatusEnum);
begin
  if ord(value) = 0 then
    LifecycleStatusElement := nil
  else
    LifecycleStatusElement := TFhirEnum.create(SYSTEMS_TFhirGoalLifecycleStatusEnum[value], CODES_TFhirGoalLifecycleStatusEnum[value]);
end;

procedure TFhirGoal.SetAchievementStatus(value : TFhirCodeableConcept);
begin
  FAchievementStatus.free;
  FAchievementStatus := value; {L1134}
end;

function TFhirGoal.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirGoal.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirGoal.SetContinuous(value : TFhirBoolean);
begin
  FContinuous.free;
  FContinuous := value; {L1134}
end;

function TFhirGoal.GetContinuousST : Boolean;
begin
  if FContinuous = nil then
    result := false
  else
    result := FContinuous.value;
end;

procedure TFhirGoal.SetContinuousST(value : Boolean);
begin
  if FContinuous = nil then
    FContinuous := TFhirBoolean.create;
  FContinuous.value := value
end;

procedure TFhirGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

procedure TFhirGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

procedure TFhirGoal.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirGoal.SetStart(value : TFhirDataType);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirGoal.GetTargetList : TFhirGoalTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirGoalTargetList.Create;
  result := FTargetList;
end;

function TFhirGoal.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

procedure TFhirGoal.SetStatusDate(value : TFhirDate);
begin
  FStatusDate.free;
  FStatusDate := value; {L1134}
end;

function TFhirGoal.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirGoal.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDate.create;
  FStatusDate.value := value
end;

procedure TFhirGoal.SetStatusReason(value : TFhirString);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

function TFhirGoal.GetStatusReasonST : String;
begin
  if FStatusReason = nil then
    result := ''
  else
    result := FStatusReason.value;
end;

procedure TFhirGoal.SetStatusReasonST(value : String);
begin
  if value <> '' then
  begin
    if FStatusReason = nil then
      FStatusReason := TFhirString.create;
    FStatusReason.value := value
  end
  else if FStatusReason <> nil then
    FStatusReason.value := '';
end;

procedure TFhirGoal.SetExpressedBy(value : TFhirReference);
begin
  FExpressedBy.free;
  FExpressedBy := value; {L1134}
end;

function TFhirGoal.GetAddressesList : TFhirReferenceList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList.Create;
  result := FAddressesList;
end;

function TFhirGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirGoal.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirGoal.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirGoal.GetOutcomeList : TFhirCodeableReferenceList;
begin
  if FOutcomeList = nil then
    FOutcomeList := TFhirCodeableReferenceList.Create;
  result := FOutcomeList;
end;

function TFhirGoal.GetHasOutcomeList : boolean;
begin
  result := (FOutcomeList <> nil) and (FOutcomeList.count > 0);
end;

procedure TFhirGoal.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('lifecycleStatus');
  fields.add('achievementStatus');
  fields.add('category');
  fields.add('continuous');
  fields.add('priority');
  fields.add('description');
  fields.add('subject');
  fields.add('start[x]');
  fields.add('target');
  fields.add('statusDate');
  fields.add('statusReason');
  fields.add('expressedBy');
  fields.add('addresses');
  fields.add('note');
  fields.add('outcome');
end;

function TFhirGoal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FLifecycleStatus.sizeInBytes);
  inc(result, FAchievementStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FContinuous.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FExpressedBy.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FoutcomeList.sizeInBytes);
end;

{ TFhirGoalListEnumerator }

constructor TFhirGoalListEnumerator.Create(list : TFhirGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalListEnumerator.GetCurrent : TFhirGoal;
begin
  Result := FList[FIndex];
end;

function TFhirGoalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalList }

procedure TFhirGoalList.AddItem(value: TFhirGoal);
begin
  assert(value.ClassName = 'TFhirGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoal');
  add(value);
end;

function TFhirGoalList.Append: TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.ClearItems;
begin
  Clear;
end;

function TFhirGoalList.GetEnumerator : TFhirGoalListEnumerator;
begin
  result := TFhirGoalListEnumerator.Create(self.link);
end;

function TFhirGoalList.Clone: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Clone);
end;

function TFhirGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalList.GetItemN(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoal;
end;
function TFhirGoalList.IndexOf(value: TFhirGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalList.Insert(index: Integer): TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.InsertItem(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  Inherited Insert(index, value);
end;

function TFhirGoalList.Item(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.Link: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Link);
end;

procedure TFhirGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalList.SetItemByIndex(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  FhirGoals[index] := value;
end;

procedure TFhirGoalList.SetItemN(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
{ TFhirImagingStudyProcedure }

constructor TFhirImagingStudyProcedure.Create;
begin
  inherited;
end;

destructor TFhirImagingStudyProcedure.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirImagingStudyProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirImagingStudyProcedure(oSource).value.Clone;
end;

procedure TFhirImagingStudyProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirImagingStudyProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Reference|CodeableConcept', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirImagingStudyProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudyProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudyProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudyProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudyProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudyProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudyProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudyProcedure.fhirType : string;
begin
  result := 'ImagingStudy.procedure';
end;

function TFhirImagingStudyProcedure.Link : TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure(inherited Link);
end;

function TFhirImagingStudyProcedure.Clone : TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure(inherited Clone);
end;

function TFhirImagingStudyProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudyProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudyProcedure)) then
    result := false
  else
  begin
    o := TFhirImagingStudyProcedure(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImagingStudyProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirImagingStudyProcedure.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirImagingStudyProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
end;

function TFhirImagingStudyProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
end;

{ TFhirImagingStudyProcedureListEnumerator }

constructor TFhirImagingStudyProcedureListEnumerator.Create(list : TFhirImagingStudyProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudyProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudyProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudyProcedureListEnumerator.GetCurrent : TFhirImagingStudyProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudyProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudyProcedureList }

procedure TFhirImagingStudyProcedureList.AddItem(value: TFhirImagingStudyProcedure);
begin
  assert(value.ClassName = 'TFhirImagingStudyProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudyProcedure');
  add(value);
end;

function TFhirImagingStudyProcedureList.Append: TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudyProcedureList.GetEnumerator : TFhirImagingStudyProcedureListEnumerator;
begin
  result := TFhirImagingStudyProcedureListEnumerator.Create(self.link);
end;

function TFhirImagingStudyProcedureList.Clone: TFhirImagingStudyProcedureList;
begin
  result := TFhirImagingStudyProcedureList(inherited Clone);
end;

function TFhirImagingStudyProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudyProcedureList.GetItemN(index: Integer): TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure(ObjectByIndex[index]);
end;

function TFhirImagingStudyProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudyProcedure;
end;
function TFhirImagingStudyProcedureList.IndexOf(value: TFhirImagingStudyProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudyProcedureList.Insert(index: Integer): TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyProcedureList.InsertItem(index: Integer; value: TFhirImagingStudyProcedure);
begin
  assert(value is TFhirImagingStudyProcedure);
  Inherited Insert(index, value);
end;

function TFhirImagingStudyProcedureList.Item(index: Integer): TFhirImagingStudyProcedure;
begin
  result := TFhirImagingStudyProcedure(ObjectByIndex[index]);
end;

function TFhirImagingStudyProcedureList.Link: TFhirImagingStudyProcedureList;
begin
  result := TFhirImagingStudyProcedureList(inherited Link);
end;

procedure TFhirImagingStudyProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudyProcedureList.SetItemByIndex(index: Integer; value: TFhirImagingStudyProcedure);
begin
  assert(value is TFhirImagingStudyProcedure);
  FhirImagingStudyProcedures[index] := value;
end;

procedure TFhirImagingStudyProcedureList.SetItemN(index: Integer; value: TFhirImagingStudyProcedure);
begin
  assert(value is TFhirImagingStudyProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FUid.free;
  FNumber.free;
  FModality.free;
  FDescription.free;
  FNumberOfInstances.free;
  FEndpointList.Free;
  FBodySite.free;
  FLaterality.free;
  FSpecimenList.Free;
  FStarted.free;
  FPerformerList.Free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeries(oSource).uidElement.Clone;
  numberElement := TFhirImagingStudySeries(oSource).numberElement.Clone;
  modality := TFhirImagingStudySeries(oSource).modality.Clone;
  descriptionElement := TFhirImagingStudySeries(oSource).descriptionElement.Clone;
  numberOfInstancesElement := TFhirImagingStudySeries(oSource).numberOfInstancesElement.Clone;
  if (TFhirImagingStudySeries(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirImagingStudySeries(oSource).FEndpointList);
  end;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  laterality := TFhirImagingStudySeries(oSource).laterality.Clone;
  if (TFhirImagingStudySeries(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirImagingStudySeries(oSource).FSpecimenList);
  end;
  startedElement := TFhirImagingStudySeries(oSource).startedElement.Clone;
  if (TFhirImagingStudySeries(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirImagingStudySeriesPerformerList.Create;
    FPerformerList.Assign(TFhirImagingStudySeries(oSource).FPerformerList);
  end;
  if (TFhirImagingStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'modality') Then
     list.add(self.link, 'modality', FModality.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'laterality') Then
     list.add(self.link, 'laterality', FLaterality.Link);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'id', false, TFhirId, FUid.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', false, TFhirCoding, FModality.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', false, TFhirCoding, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'laterality', 'Coding', false, TFhirCoding, FLaterality.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirImagingStudySeriesPerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirImagingStudySeriesInstance, FInstanceList.Link)) {L1039};
end;

function TFhirImagingStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asId(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    Modality := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'laterality') then
  begin
    Laterality := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirImagingStudySeriesPerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingStudySeriesInstance) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirImagingStudySeriesPerformer) {L1049}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingStudySeriesInstance) {L1049}
  else inherited;
end;

function TFhirImagingStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirId.create() {L1223}
  else if (propName = 'number') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'modality') then result := TFhirCoding.create() {L1203}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else if (propName = 'bodySite') then result := TFhirCoding.create() {L1203}
  else if (propName = 'laterality') then result := TFhirCoding.create() {L1203}
  else if (propName = 'specimen') then result := SpecimenList.new() {L1053}
  else if (propName = 'started') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'instance') then result := InstanceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'id'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'Coding'
  else if (propName = 'laterality') then result := 'Coding'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'modality') then ModalityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'laterality') then LateralityElement := nil
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {L1054}
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asId(new) {L1222}
  else if (propName = 'number') then NumberElement := asUnsignedInt(new) {L1222}
  else if (propName = 'modality') then ModalityElement := new as TFhirCoding {L1195}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new) {L1222}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCoding {L1195}
  else if (propName = 'laterality') then LateralityElement := new as TFhirCoding {L1195}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {L1055}
  else if (propName = 'started') then StartedElement := asDateTime(new) {L1222}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else if (propName = 'specimen') then SpecimenList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'instance') then InstanceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeries.fhirType : string;
begin
  result := 'ImagingStudy.series';
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

function TFhirImagingStudySeries.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeries(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(numberElement, o.numberElement, true) and 
      compareDeep(modalityElement, o.modalityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and compareDeep(endpointList, o.endpointList, true) and 
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(lateralityElement, o.lateralityElement, true) and 
      compareDeep(specimenList, o.specimenList, true) and compareDeep(startedElement, o.startedElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FNumber) and isEmptyProp(FModality) and isEmptyProp(FDescription) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FendpointList) and isEmptyProp(FBodySite) and isEmptyProp(FLaterality) and isEmptyProp(FspecimenList) and isEmptyProp(FStarted) and isEmptyProp(FperformerList) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingStudySeries.SetUid(value : TFhirId);
begin
  FUid.free;
  FUid := value; {L1134}
end;

function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirId.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

procedure TFhirImagingStudySeries.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value; {L1134}
end;

function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirImagingStudySeries.SetModality(value : TFhirCoding);
begin
  FModality.free;
  FModality := value; {L1134}
end;

procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value; {L1134}
end;

function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

function TFhirImagingStudySeries.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirImagingStudySeries.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

procedure TFhirImagingStudySeries.SetLaterality(value : TFhirCoding);
begin
  FLaterality.free;
  FLaterality := value; {L1134}
end;

function TFhirImagingStudySeries.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirImagingStudySeries.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

procedure TFhirImagingStudySeries.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value; {L1134}
end;

function TFhirImagingStudySeries.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

procedure TFhirImagingStudySeries.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

function TFhirImagingStudySeries.GetPerformerList : TFhirImagingStudySeriesPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirImagingStudySeriesPerformerList.Create;
  result := FPerformerList;
end;

function TFhirImagingStudySeries.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirImagingStudySeries.GetInstanceList : TFhirImagingStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

function TFhirImagingStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

procedure TFhirImagingStudySeries.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('number');
  fields.add('modality');
  fields.add('description');
  fields.add('numberOfInstances');
  fields.add('endpoint');
  fields.add('bodySite');
  fields.add('laterality');
  fields.add('specimen');
  fields.add('started');
  fields.add('performer');
  fields.add('instance');
end;

function TFhirImagingStudySeries.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FNumber.sizeInBytes);
  inc(result, FModality.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FLaterality.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FStarted.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
end;

{ TFhirImagingStudySeriesListEnumerator }

constructor TFhirImagingStudySeriesListEnumerator.Create(list : TFhirImagingStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesListEnumerator.GetCurrent : TFhirImagingStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesList }

procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;

function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.GetEnumerator : TFhirImagingStudySeriesListEnumerator;
begin
  result := TFhirImagingStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeries;
end;
function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesPerformer }

constructor TFhirImagingStudySeriesPerformer.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirImagingStudySeriesPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirImagingStudySeriesPerformer(oSource).function_.Clone;
  actor := TFhirImagingStudySeriesPerformer(oSource).actor.Clone;
end;

procedure TFhirImagingStudySeriesPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirImagingStudySeriesPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirImagingStudySeriesPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudySeriesPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesPerformer.fhirType : string;
begin
  result := 'ImagingStudy.series.performer';
end;

function TFhirImagingStudySeriesPerformer.Link : TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(inherited Link);
end;

function TFhirImagingStudySeriesPerformer.Clone : TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(inherited Clone);
end;

function TFhirImagingStudySeriesPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeriesPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesPerformer)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirImagingStudySeriesPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirImagingStudySeriesPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirImagingStudySeriesPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirImagingStudySeriesPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirImagingStudySeriesPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirImagingStudySeriesPerformerListEnumerator }

constructor TFhirImagingStudySeriesPerformerListEnumerator.Create(list : TFhirImagingStudySeriesPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesPerformerListEnumerator.GetCurrent : TFhirImagingStudySeriesPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesPerformerList }

procedure TFhirImagingStudySeriesPerformerList.AddItem(value: TFhirImagingStudySeriesPerformer);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesPerformer');
  add(value);
end;

function TFhirImagingStudySeriesPerformerList.Append: TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesPerformerList.GetEnumerator : TFhirImagingStudySeriesPerformerListEnumerator;
begin
  result := TFhirImagingStudySeriesPerformerListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesPerformerList.Clone: TFhirImagingStudySeriesPerformerList;
begin
  result := TFhirImagingStudySeriesPerformerList(inherited Clone);
end;

function TFhirImagingStudySeriesPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesPerformerList.GetItemN(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesPerformer;
end;
function TFhirImagingStudySeriesPerformerList.IndexOf(value: TFhirImagingStudySeriesPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesPerformerList.Insert(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesPerformerList.InsertItem(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesPerformerList.Item(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesPerformerList.Link: TFhirImagingStudySeriesPerformerList;
begin
  result := TFhirImagingStudySeriesPerformerList(inherited Link);
end;

procedure TFhirImagingStudySeriesPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesPerformerList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  FhirImagingStudySeriesPerformers[index] := value;
end;

procedure TFhirImagingStudySeriesPerformerList.SetItemN(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FUid.free;
  FSopClass.free;
  FNumber.free;
  FTitle.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeriesInstance(oSource).uidElement.Clone;
  sopClass := TFhirImagingStudySeriesInstance(oSource).sopClass.Clone;
  numberElement := TFhirImagingStudySeriesInstance(oSource).numberElement.Clone;
  titleElement := TFhirImagingStudySeriesInstance(oSource).titleElement.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'id', false, TFhirId, FUid.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sopClass', 'Coding', false, TFhirCoding, FSopClass.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link)); {L1172}
end;

function TFhirImagingStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asId(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'sopClass') then
  begin
    SopClass := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirId.create() {L1223}
  else if (propName = 'sopClass') then result := TFhirCoding.create() {L1203}
  else if (propName = 'number') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'title') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'id'
  else if (propName = 'sopClass') then result := 'Coding'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'title') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'title') then TitleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asId(new) {L1222}
  else if (propName = 'sopClass') then SopClassElement := new as TFhirCoding {L1195}
  else if (propName = 'number') then NumberElement := asUnsignedInt(new) {L1222}
  else if (propName = 'title') then TitleElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesInstance.fhirType : string;
begin
  result := 'ImagingStudy.series.instance';
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

function TFhirImagingStudySeriesInstance.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesInstance(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(sopClassElement, o.sopClassElement, true) and 
      compareDeep(numberElement, o.numberElement, true) and compareDeep(titleElement, o.titleElement, true);
  end;
end;

function TFhirImagingStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FSopClass) and isEmptyProp(FNumber) and isEmptyProp(FTitle);
end;

procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirId);
begin
  FUid.free;
  FUid := value; {L1134}
end;

function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirId.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

procedure TFhirImagingStudySeriesInstance.SetSopClass(value : TFhirCoding);
begin
  FSopClass.free;
  FSopClass := value; {L1134}
end;

procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value; {L1134}
end;

function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirImagingStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('sopClass');
  fields.add('number');
  fields.add('title');
end;

function TFhirImagingStudySeriesInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FSopClass.sizeInBytes);
  inc(result, FNumber.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceListEnumerator }

constructor TFhirImagingStudySeriesInstanceListEnumerator.Create(list : TFhirImagingStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceList }

procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;

function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesInstance;
end;
function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudy }

constructor TFhirImagingStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingStudy.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FModalityList.Free;
  FSubject.free;
  FEncounter.free;
  FStarted.free;
  FBasedOnList.Free;
  FReferrer.free;
  FInterpreterList.Free;
  FEndpointList.Free;
  FNumberOfSeries.free;
  FNumberOfInstances.free;
  FProcedure_List.Free;
  FLocation.free;
  FReasonList.Free;
  FNoteList.Free;
  FDescription.free;
  FSeriesList.Free;
  inherited;
end;

procedure TFhirImagingStudy.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImagingStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImagingStudy(oSource).FIdentifierList);
  end;
  statusElement := TFhirImagingStudy(oSource).statusElement.Clone;
  if (TFhirImagingStudy(oSource).FModalityList = nil) then
  begin
    FModalityList.free;
    FModalityList := nil;
  end
  else
  begin
    if FModalityList = nil then
      FModalityList := TFhirCodingList.Create;
    FModalityList.Assign(TFhirImagingStudy(oSource).FModalityList);
  end;
  subject := TFhirImagingStudy(oSource).subject.Clone;
  encounter := TFhirImagingStudy(oSource).encounter.Clone;
  startedElement := TFhirImagingStudy(oSource).startedElement.Clone;
  if (TFhirImagingStudy(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirImagingStudy(oSource).FBasedOnList);
  end;
  referrer := TFhirImagingStudy(oSource).referrer.Clone;
  if (TFhirImagingStudy(oSource).FInterpreterList = nil) then
  begin
    FInterpreterList.free;
    FInterpreterList := nil;
  end
  else
  begin
    if FInterpreterList = nil then
      FInterpreterList := TFhirReferenceList.Create;
    FInterpreterList.Assign(TFhirImagingStudy(oSource).FInterpreterList);
  end;
  if (TFhirImagingStudy(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirImagingStudy(oSource).FEndpointList);
  end;
  numberOfSeriesElement := TFhirImagingStudy(oSource).numberOfSeriesElement.Clone;
  numberOfInstancesElement := TFhirImagingStudy(oSource).numberOfInstancesElement.Clone;
  if (TFhirImagingStudy(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirImagingStudyProcedureList.Create;
    FProcedure_List.Assign(TFhirImagingStudy(oSource).FProcedure_List);
  end;
  location := TFhirImagingStudy(oSource).location.Clone;
  if (TFhirImagingStudy(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirImagingStudy(oSource).FReasonList);
  end;
  if (TFhirImagingStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImagingStudy(oSource).FNoteList);
  end;
  descriptionElement := TFhirImagingStudy(oSource).descriptionElement.Clone;
  if (TFhirImagingStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingStudy(oSource).FSeriesList);
  end;
end;

function TFhirImagingStudy.GetResourceType : TFhirResourceType;
begin
  result := frtImagingStudy;
end;

procedure TFhirImagingStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'modality') Then
    list.addAll(self, 'modality', FModalityList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'referrer') Then
     list.add(self.link, 'referrer', FReferrer.Link);
  if (child_name = 'interpreter') Then
    list.addAll(self, 'interpreter', FInterpreterList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'numberOfSeries') Then
     list.add(self.link, 'numberOfSeries', FNumberOfSeries.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', true, TFhirCoding, FModalityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'referrer', 'Reference', false, TFhirReference, FReferrer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'interpreter', 'Reference', true, TFhirReference, FInterpreterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'numberOfSeries', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfSeries.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirImagingStudyProcedure, FProcedure_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'series', 'BackboneElement', true, TFhirImagingStudySeries, FSeriesList.Link)) {L1039};
end;

function TFhirImagingStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImagingStudyStatusEnum, CODES_TFhirImagingStudyStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    ModalityList.add(propValue as TFhirCoding) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'referrer') then
  begin
    Referrer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'interpreter') then
  begin
    InterpreterList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'numberOfSeries') then
  begin
    NumberOfSeriesElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirImagingStudyProcedure) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingStudySeries) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'modality') then ModalityList.insertItem(index, propValue as TFhirCoding) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'interpreter') then InterpreterList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirImagingStudyProcedure) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingStudySeries) {L1049}
  else inherited;
end;

function TFhirImagingStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImagingStudyStatusEnum[ImagingStudyStatusNull], CODES_TFhirImagingStudyStatusEnum[ImagingStudyStatusNull])  {L1211}
  else if (propName = 'modality') then result := ModalityList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'started') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'referrer') then result := TFhirReference.create() {L1203}
  else if (propName = 'interpreter') then result := InterpreterList.new() {L1053}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else if (propName = 'numberOfSeries') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'procedure') then result := Procedure_List.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'series') then result := SeriesList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'referrer') then result := 'Reference'
  else if (propName = 'interpreter') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'numberOfSeries') then result := 'unsignedInt'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'modality') then deletePropertyValue('modality', ModalityList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'referrer') then ReferrerElement := nil
  else if (propName = 'interpreter') then deletePropertyValue('interpreter', InterpreterList, value) {L1054}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImagingStudyStatusEnum, CODES_TFhirImagingStudyStatusEnum, new) {L1210}
  else if (propName = 'modality') then replacePropertyValue('modality', ModalityList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'started') then StartedElement := asDateTime(new) {L1222}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'referrer') then ReferrerElement := new as TFhirReference {L1195}
  else if (propName = 'interpreter') then replacePropertyValue('interpreter', InterpreterList, existing, new) {L1055}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := asUnsignedInt(new) {L1222}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new) {L1222}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'modality') then ModalityList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'interpreter') then InterpreterList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else if (propName = 'procedure') then Procedure_List.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'series') then SeriesList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudy.fhirType : string;
begin
  result := 'ImagingStudy';
end;

function TFhirImagingStudy.Link : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Link);
end;

function TFhirImagingStudy.Clone : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Clone);
end;

function TFhirImagingStudy.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudy)) then
    result := false
  else
  begin
    o := TFhirImagingStudy(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(modalityList, o.modalityList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(startedElement, o.startedElement, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(referrerElement, o.referrerElement, true) and 
      compareDeep(interpreterList, o.interpreterList, true) and compareDeep(endpointList, o.endpointList, true) and 
      compareDeep(numberOfSeriesElement, o.numberOfSeriesElement, true) and compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FmodalityList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FStarted) and isEmptyProp(FbasedOnList) and isEmptyProp(FReferrer) and isEmptyProp(FinterpreterList) and isEmptyProp(FendpointList) and isEmptyProp(FNumberOfSeries) and isEmptyProp(FNumberOfInstances) and isEmptyProp(Fprocedure_List) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList) and isEmptyProp(FDescription) and isEmptyProp(FseriesList);
end;

function TFhirImagingStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImagingStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImagingStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImagingStudy.GetStatusST : TFhirImagingStudyStatusEnum;
begin
  if FStatus = nil then
    result := TFhirImagingStudyStatusEnum(0)
  else
    result := TFhirImagingStudyStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirImagingStudyStatusEnum, FStatus.value));
end;

procedure TFhirImagingStudy.SetStatusST(value : TFhirImagingStudyStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImagingStudyStatusEnum[value], CODES_TFhirImagingStudyStatusEnum[value]);
end;

function TFhirImagingStudy.GetModalityList : TFhirCodingList;
begin
  if FModalityList = nil then
    FModalityList := TFhirCodingList.Create;
  result := FModalityList;
end;

function TFhirImagingStudy.GetHasModalityList : boolean;
begin
  result := (FModalityList <> nil) and (FModalityList.count > 0);
end;

procedure TFhirImagingStudy.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirImagingStudy.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirImagingStudy.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value; {L1134}
end;

function TFhirImagingStudy.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

procedure TFhirImagingStudy.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

function TFhirImagingStudy.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirImagingStudy.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirImagingStudy.SetReferrer(value : TFhirReference);
begin
  FReferrer.free;
  FReferrer := value; {L1134}
end;

function TFhirImagingStudy.GetInterpreterList : TFhirReferenceList;
begin
  if FInterpreterList = nil then
    FInterpreterList := TFhirReferenceList.Create;
  result := FInterpreterList;
end;

function TFhirImagingStudy.GetHasInterpreterList : boolean;
begin
  result := (FInterpreterList <> nil) and (FInterpreterList.count > 0);
end;

function TFhirImagingStudy.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirImagingStudy.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirImagingStudy.SetNumberOfSeries(value : TFhirUnsignedInt);
begin
  FNumberOfSeries.free;
  FNumberOfSeries := value; {L1134}
end;

function TFhirImagingStudy.GetNumberOfSeriesST : String;
begin
  if FNumberOfSeries = nil then
    result := ''
  else
    result := FNumberOfSeries.value;
end;

procedure TFhirImagingStudy.SetNumberOfSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSeries = nil then
      FNumberOfSeries := TFhirUnsignedInt.create;
    FNumberOfSeries.value := value
  end
  else if FNumberOfSeries <> nil then
    FNumberOfSeries.value := '';
end;

procedure TFhirImagingStudy.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value; {L1134}
end;

function TFhirImagingStudy.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

procedure TFhirImagingStudy.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

function TFhirImagingStudy.GetProcedure_List : TFhirImagingStudyProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirImagingStudyProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirImagingStudy.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

procedure TFhirImagingStudy.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

function TFhirImagingStudy.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirImagingStudy.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirImagingStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirImagingStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirImagingStudy.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirImagingStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImagingStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirImagingStudy.GetSeriesList : TFhirImagingStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingStudySeriesList.Create;
  result := FSeriesList;
end;

function TFhirImagingStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

procedure TFhirImagingStudy.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('modality');
  fields.add('subject');
  fields.add('encounter');
  fields.add('started');
  fields.add('basedOn');
  fields.add('referrer');
  fields.add('interpreter');
  fields.add('endpoint');
  fields.add('numberOfSeries');
  fields.add('numberOfInstances');
  fields.add('procedure');
  fields.add('location');
  fields.add('reason');
  fields.add('note');
  fields.add('description');
  fields.add('series');
end;

function TFhirImagingStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FmodalityList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FStarted.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FReferrer.sizeInBytes);
  inc(result, FinterpreterList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FNumberOfSeries.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FseriesList.sizeInBytes);
end;

{ TFhirImagingStudyListEnumerator }

constructor TFhirImagingStudyListEnumerator.Create(list : TFhirImagingStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudyListEnumerator.GetCurrent : TFhirImagingStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudyList }

procedure TFhirImagingStudyList.AddItem(value: TFhirImagingStudy);
begin
  assert(value.ClassName = 'TFhirImagingStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudy');
  add(value);
end;

function TFhirImagingStudyList.Append: TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudyList.GetEnumerator : TFhirImagingStudyListEnumerator;
begin
  result := TFhirImagingStudyListEnumerator.Create(self.link);
end;

function TFhirImagingStudyList.Clone: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Clone);
end;

function TFhirImagingStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudyList.GetItemN(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudy;
end;
function TFhirImagingStudyList.IndexOf(value: TFhirImagingStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudyList.Insert(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.InsertItem(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingStudyList.Item(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.Link: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Link);
end;

procedure TFhirImagingStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudyList.SetItemByIndex(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  FhirImagingStudies[index] := value;
end;

procedure TFhirImagingStudyList.SetItemN(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
{ TFhirImmunizationPerformer }

constructor TFhirImmunizationPerformer.Create;
begin
  inherited;
end;

destructor TFhirImmunizationPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirImmunizationPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirImmunizationPerformer(oSource).function_.Clone;
  actor := TFhirImmunizationPerformer(oSource).actor.Clone;
end;

procedure TFhirImmunizationPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirImmunizationPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirImmunizationPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationPerformer.fhirType : string;
begin
  result := 'Immunization.performer';
end;

function TFhirImmunizationPerformer.Link : TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(inherited Link);
end;

function TFhirImmunizationPerformer.Clone : TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(inherited Clone);
end;

function TFhirImmunizationPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationPerformer)) then
    result := false
  else
  begin
    o := TFhirImmunizationPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirImmunizationPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirImmunizationPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirImmunizationPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirImmunizationPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirImmunizationPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirImmunizationPerformerListEnumerator }

constructor TFhirImmunizationPerformerListEnumerator.Create(list : TFhirImmunizationPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationPerformerListEnumerator.GetCurrent : TFhirImmunizationPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationPerformerList }

procedure TFhirImmunizationPerformerList.AddItem(value: TFhirImmunizationPerformer);
begin
  assert(value.ClassName = 'TFhirImmunizationPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationPerformer');
  add(value);
end;

function TFhirImmunizationPerformerList.Append: TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationPerformerList.GetEnumerator : TFhirImmunizationPerformerListEnumerator;
begin
  result := TFhirImmunizationPerformerListEnumerator.Create(self.link);
end;

function TFhirImmunizationPerformerList.Clone: TFhirImmunizationPerformerList;
begin
  result := TFhirImmunizationPerformerList(inherited Clone);
end;

function TFhirImmunizationPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationPerformerList.GetItemN(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(ObjectByIndex[index]);
end;

function TFhirImmunizationPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationPerformer;
end;
function TFhirImmunizationPerformerList.IndexOf(value: TFhirImmunizationPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationPerformerList.Insert(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPerformerList.InsertItem(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  Inherited Insert(index, value);
end;

function TFhirImmunizationPerformerList.Item(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(ObjectByIndex[index]);
end;

function TFhirImmunizationPerformerList.Link: TFhirImmunizationPerformerList;
begin
  result := TFhirImmunizationPerformerList(inherited Link);
end;

procedure TFhirImmunizationPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationPerformerList.SetItemByIndex(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  FhirImmunizationPerformers[index] := value;
end;

procedure TFhirImmunizationPerformerList.SetItemN(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationEducation }

constructor TFhirImmunizationEducation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationEducation.Destroy;
begin
  FDocumentType.free;
  FReference.free;
  FPublicationDate.free;
  FPresentationDate.free;
  inherited;
end;

procedure TFhirImmunizationEducation.Assign(oSource : TFslObject);
begin
  inherited;
  documentTypeElement := TFhirImmunizationEducation(oSource).documentTypeElement.Clone;
  referenceElement := TFhirImmunizationEducation(oSource).referenceElement.Clone;
  publicationDateElement := TFhirImmunizationEducation(oSource).publicationDateElement.Clone;
  presentationDateElement := TFhirImmunizationEducation(oSource).presentationDateElement.Clone;
end;

procedure TFhirImmunizationEducation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'documentType') Then
     list.add(self.link, 'documentType', FDocumentType.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
  if (child_name = 'presentationDate') Then
     list.add(self.link, 'presentationDate', FPresentationDate.Link);
end;

procedure TFhirImmunizationEducation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'documentType', 'string', false, TFhirString, FDocumentType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'dateTime', false, TFhirDateTime, FPublicationDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'presentationDate', 'dateTime', false, TFhirDateTime, FPresentationDate.Link)); {L1172}
end;

function TFhirImmunizationEducation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'documentType') then
  begin
    DocumentTypeElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'presentationDate') then
  begin
    PresentationDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationEducation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationEducation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentType') then result := TFhirString.create() {L1223}
  else if (propName = 'reference') then result := TFhirUri.create() {L1223}
  else if (propName = 'publicationDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'presentationDate') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationEducation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'documentType') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'publicationDate') then result := 'dateTime'
  else if (propName = 'presentationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationEducation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'documentType') then DocumentTypeElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else if (propName = 'presentationDate') then PresentationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationEducation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'documentType') then DocumentTypeElement := asString(new) {L1222}
  else if (propName = 'reference') then ReferenceElement := asUri(new) {L1222}
  else if (propName = 'publicationDate') then PublicationDateElement := asDateTime(new) {L1222}
  else if (propName = 'presentationDate') then PresentationDateElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationEducation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationEducation.fhirType : string;
begin
  result := 'Immunization.education';
end;

function TFhirImmunizationEducation.Link : TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(inherited Link);
end;

function TFhirImmunizationEducation.Clone : TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(inherited Clone);
end;

function TFhirImmunizationEducation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationEducation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationEducation)) then
    result := false
  else
  begin
    o := TFhirImmunizationEducation(other);
    result := compareDeep(documentTypeElement, o.documentTypeElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true) and 
      compareDeep(presentationDateElement, o.presentationDateElement, true);
  end;
end;

function TFhirImmunizationEducation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDocumentType) and isEmptyProp(FReference) and isEmptyProp(FPublicationDate) and isEmptyProp(FPresentationDate);
end;

procedure TFhirImmunizationEducation.SetDocumentType(value : TFhirString);
begin
  FDocumentType.free;
  FDocumentType := value; {L1134}
end;

function TFhirImmunizationEducation.GetDocumentTypeST : String;
begin
  if FDocumentType = nil then
    result := ''
  else
    result := FDocumentType.value;
end;

procedure TFhirImmunizationEducation.SetDocumentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentType = nil then
      FDocumentType := TFhirString.create;
    FDocumentType.value := value
  end
  else if FDocumentType <> nil then
    FDocumentType.value := '';
end;

procedure TFhirImmunizationEducation.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value; {L1134}
end;

function TFhirImmunizationEducation.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

procedure TFhirImmunizationEducation.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

procedure TFhirImmunizationEducation.SetPublicationDate(value : TFhirDateTime);
begin
  FPublicationDate.free;
  FPublicationDate := value; {L1134}
end;

function TFhirImmunizationEducation.GetPublicationDateST : TFslDateTime;
begin
  if FPublicationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPublicationDate.value;
end;

procedure TFhirImmunizationEducation.SetPublicationDateST(value : TFslDateTime);
begin
  if FPublicationDate = nil then
    FPublicationDate := TFhirDateTime.create;
  FPublicationDate.value := value
end;

procedure TFhirImmunizationEducation.SetPresentationDate(value : TFhirDateTime);
begin
  FPresentationDate.free;
  FPresentationDate := value; {L1134}
end;

function TFhirImmunizationEducation.GetPresentationDateST : TFslDateTime;
begin
  if FPresentationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPresentationDate.value;
end;

procedure TFhirImmunizationEducation.SetPresentationDateST(value : TFslDateTime);
begin
  if FPresentationDate = nil then
    FPresentationDate := TFhirDateTime.create;
  FPresentationDate.value := value
end;

procedure TFhirImmunizationEducation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('documentType');
  fields.add('reference');
  fields.add('publicationDate');
  fields.add('presentationDate');
end;

function TFhirImmunizationEducation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDocumentType.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FPublicationDate.sizeInBytes);
  inc(result, FPresentationDate.sizeInBytes);
end;

{ TFhirImmunizationEducationListEnumerator }

constructor TFhirImmunizationEducationListEnumerator.Create(list : TFhirImmunizationEducationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationEducationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationEducationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationEducationListEnumerator.GetCurrent : TFhirImmunizationEducation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationEducationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationEducationList }

procedure TFhirImmunizationEducationList.AddItem(value: TFhirImmunizationEducation);
begin
  assert(value.ClassName = 'TFhirImmunizationEducation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationEducation');
  add(value);
end;

function TFhirImmunizationEducationList.Append: TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEducationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationEducationList.GetEnumerator : TFhirImmunizationEducationListEnumerator;
begin
  result := TFhirImmunizationEducationListEnumerator.Create(self.link);
end;

function TFhirImmunizationEducationList.Clone: TFhirImmunizationEducationList;
begin
  result := TFhirImmunizationEducationList(inherited Clone);
end;

function TFhirImmunizationEducationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationEducationList.GetItemN(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(ObjectByIndex[index]);
end;

function TFhirImmunizationEducationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationEducation;
end;
function TFhirImmunizationEducationList.IndexOf(value: TFhirImmunizationEducation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationEducationList.Insert(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEducationList.InsertItem(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationEducationList.Item(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(ObjectByIndex[index]);
end;

function TFhirImmunizationEducationList.Link: TFhirImmunizationEducationList;
begin
  result := TFhirImmunizationEducationList(inherited Link);
end;

procedure TFhirImmunizationEducationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationEducationList.SetItemByIndex(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  FhirImmunizationEducations[index] := value;
end;

procedure TFhirImmunizationEducationList.SetItemN(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationReaction(oSource).dateElement.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reportedElement := TFhirImmunizationReaction(oSource).reportedElement.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', false, TFhirReference, FDetail.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link)); {L1172}
end;

function TFhirImmunizationReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'detail') then result := TFhirReference.create() {L1203}
  else if (propName = 'reported') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'detail') then result := 'Reference'
  else if (propName = 'reported') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'detail') then DetailElement := new as TFhirReference {L1195}
  else if (propName = 'reported') then ReportedElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationReaction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationReaction.fhirType : string;
begin
  result := 'Immunization.reaction';
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

function TFhirImmunizationReaction.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationReaction)) then
    result := false
  else
  begin
    o := TFhirImmunizationReaction(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(reportedElement, o.reportedElement, true);
  end;
end;

function TFhirImmunizationReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FDetail) and isEmptyProp(FReported);
end;

procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirImmunizationReaction.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationReaction.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationReaction.SetDetail(value : TFhirReference);
begin
  FDetail.free;
  FDetail := value; {L1134}
end;

procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value; {L1134}
end;

function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

procedure TFhirImmunizationReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('detail');
  fields.add('reported');
end;

function TFhirImmunizationReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FReported.sizeInBytes);
end;

{ TFhirImmunizationReactionListEnumerator }

constructor TFhirImmunizationReactionListEnumerator.Create(list : TFhirImmunizationReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationReactionListEnumerator.GetCurrent : TFhirImmunizationReaction;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationReactionList }

procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;

function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.GetEnumerator : TFhirImmunizationReactionListEnumerator;
begin
  result := TFhirImmunizationReactionListEnumerator.Create(self.link);
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationReaction;
end;
function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProtocolApplied }

constructor TFhirImmunizationProtocolApplied.Create;
begin
  inherited;
end;

destructor TFhirImmunizationProtocolApplied.Destroy;
begin
  FSeries.free;
  FAuthority.free;
  FTargetDiseaseList.Free;
  FDoseNumber.free;
  FSeriesDoses.free;
  inherited;
end;

procedure TFhirImmunizationProtocolApplied.Assign(oSource : TFslObject);
begin
  inherited;
  seriesElement := TFhirImmunizationProtocolApplied(oSource).seriesElement.Clone;
  authority := TFhirImmunizationProtocolApplied(oSource).authority.Clone;
  if (TFhirImmunizationProtocolApplied(oSource).FTargetDiseaseList = nil) then
  begin
    FTargetDiseaseList.free;
    FTargetDiseaseList := nil;
  end
  else
  begin
    if FTargetDiseaseList = nil then
      FTargetDiseaseList := TFhirCodeableConceptList.Create;
    FTargetDiseaseList.Assign(TFhirImmunizationProtocolApplied(oSource).FTargetDiseaseList);
  end;
  doseNumberElement := TFhirImmunizationProtocolApplied(oSource).doseNumberElement.Clone;
  seriesDosesElement := TFhirImmunizationProtocolApplied(oSource).seriesDosesElement.Clone;
end;

procedure TFhirImmunizationProtocolApplied.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'targetDisease') Then
    list.addAll(self, 'targetDisease', FTargetDiseaseList);
  if (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber', FDoseNumber.Link);
  if (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses', FSeriesDoses.Link);
end;

procedure TFhirImmunizationProtocolApplied.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', true, TFhirCodeableConcept, FTargetDiseaseList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'string', false, TFhirString, FDoseNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'string', false, TFhirString, FSeriesDoses.Link)); {L1172}
end;

function TFhirImmunizationProtocolApplied.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'series') then
  begin
    SeriesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDiseaseList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'doseNumber') then
  begin
    DoseNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'seriesDoses') then
  begin
    SeriesDosesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationProtocolApplied.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirImmunizationProtocolApplied.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'series') then result := TFhirString.create() {L1223}
  else if (propName = 'authority') then result := TFhirReference.create() {L1203}
  else if (propName = 'targetDisease') then result := TargetDiseaseList.new() {L1053}
  else if (propName = 'doseNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'seriesDoses') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationProtocolApplied.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'series') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'doseNumber') then result := 'string'
  else if (propName = 'seriesDoses') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationProtocolApplied.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'series') then SeriesElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'targetDisease') then deletePropertyValue('targetDisease', TargetDiseaseList, value) {L1054}
  else if (propName = 'doseNumber') then DoseNumberElement := nil
  else if (propName = 'seriesDoses') then SeriesDosesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationProtocolApplied.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'series') then SeriesElement := asString(new) {L1222}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference {L1195}
  else if (propName = 'targetDisease') then replacePropertyValue('targetDisease', TargetDiseaseList, existing, new) {L1055}
  else if (propName = 'doseNumber') then DoseNumberElement := asString(new) {L1222}
  else if (propName = 'seriesDoses') then SeriesDosesElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationProtocolApplied.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationProtocolApplied.fhirType : string;
begin
  result := 'Immunization.protocolApplied';
end;

function TFhirImmunizationProtocolApplied.Link : TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(inherited Link);
end;

function TFhirImmunizationProtocolApplied.Clone : TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(inherited Clone);
end;

function TFhirImmunizationProtocolApplied.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationProtocolApplied;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationProtocolApplied)) then
    result := false
  else
  begin
    o := TFhirImmunizationProtocolApplied(other);
    result := compareDeep(seriesElement, o.seriesElement, true) and compareDeep(authorityElement, o.authorityElement, true) and 
      compareDeep(targetDiseaseList, o.targetDiseaseList, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true);
  end;
end;

function TFhirImmunizationProtocolApplied.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeries) and isEmptyProp(FAuthority) and isEmptyProp(FtargetDiseaseList) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses);
end;

procedure TFhirImmunizationProtocolApplied.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value; {L1134}
end;

function TFhirImmunizationProtocolApplied.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationProtocolApplied.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationProtocolApplied.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value; {L1134}
end;

function TFhirImmunizationProtocolApplied.GetTargetDiseaseList : TFhirCodeableConceptList;
begin
  if FTargetDiseaseList = nil then
    FTargetDiseaseList := TFhirCodeableConceptList.Create;
  result := FTargetDiseaseList;
end;

function TFhirImmunizationProtocolApplied.GetHasTargetDiseaseList : boolean;
begin
  result := (FTargetDiseaseList <> nil) and (FTargetDiseaseList.count > 0);
end;

procedure TFhirImmunizationProtocolApplied.SetDoseNumber(value : TFhirString);
begin
  FDoseNumber.free;
  FDoseNumber := value; {L1134}
end;

function TFhirImmunizationProtocolApplied.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

procedure TFhirImmunizationProtocolApplied.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirString.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

procedure TFhirImmunizationProtocolApplied.SetSeriesDoses(value : TFhirString);
begin
  FSeriesDoses.free;
  FSeriesDoses := value; {L1134}
end;

function TFhirImmunizationProtocolApplied.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

procedure TFhirImmunizationProtocolApplied.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirString.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

procedure TFhirImmunizationProtocolApplied.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('series');
  fields.add('authority');
  fields.add('targetDisease');
  fields.add('doseNumber');
  fields.add('seriesDoses');
end;

function TFhirImmunizationProtocolApplied.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSeries.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FtargetDiseaseList.sizeInBytes);
  inc(result, FDoseNumber.sizeInBytes);
  inc(result, FSeriesDoses.sizeInBytes);
end;

{ TFhirImmunizationProtocolAppliedListEnumerator }

constructor TFhirImmunizationProtocolAppliedListEnumerator.Create(list : TFhirImmunizationProtocolAppliedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationProtocolAppliedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationProtocolAppliedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationProtocolAppliedListEnumerator.GetCurrent : TFhirImmunizationProtocolApplied;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationProtocolAppliedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationProtocolAppliedList }

procedure TFhirImmunizationProtocolAppliedList.AddItem(value: TFhirImmunizationProtocolApplied);
begin
  assert(value.ClassName = 'TFhirImmunizationProtocolApplied', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProtocolApplied');
  add(value);
end;

function TFhirImmunizationProtocolAppliedList.Append: TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationProtocolAppliedList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProtocolAppliedList.GetEnumerator : TFhirImmunizationProtocolAppliedListEnumerator;
begin
  result := TFhirImmunizationProtocolAppliedListEnumerator.Create(self.link);
end;

function TFhirImmunizationProtocolAppliedList.Clone: TFhirImmunizationProtocolAppliedList;
begin
  result := TFhirImmunizationProtocolAppliedList(inherited Clone);
end;

function TFhirImmunizationProtocolAppliedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProtocolAppliedList.GetItemN(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(ObjectByIndex[index]);
end;

function TFhirImmunizationProtocolAppliedList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationProtocolApplied;
end;
function TFhirImmunizationProtocolAppliedList.IndexOf(value: TFhirImmunizationProtocolApplied): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationProtocolAppliedList.Insert(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationProtocolAppliedList.InsertItem(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProtocolAppliedList.Item(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(ObjectByIndex[index]);
end;

function TFhirImmunizationProtocolAppliedList.Link: TFhirImmunizationProtocolAppliedList;
begin
  result := TFhirImmunizationProtocolAppliedList(inherited Link);
end;

procedure TFhirImmunizationProtocolAppliedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProtocolAppliedList.SetItemByIndex(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  FhirImmunizationProtocolApplieds[index] := value;
end;

procedure TFhirImmunizationProtocolAppliedList.SetItemN(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunization }

constructor TFhirImmunization.Create;
begin
  inherited;
end;

destructor TFhirImmunization.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FStatusReason.free;
  FVaccineCode.free;
  FManufacturer.free;
  FLotNumber.free;
  FExpirationDate.free;
  FPatient.free;
  FEncounter.free;
  FOccurrence.free;
  FRecorded.free;
  FPrimarySource.free;
  FInformationSource.free;
  FLocation.free;
  FSite.free;
  FRoute.free;
  FDoseQuantity.free;
  FPerformerList.Free;
  FNoteList.Free;
  FReasonList.Free;
  FIsSubpotent.free;
  FSubpotentReasonList.Free;
  FEducationList.Free;
  FProgramEligibilityList.Free;
  FFundingSource.free;
  FReactionList.Free;
  FProtocolAppliedList.Free;
  inherited;
end;

procedure TFhirImmunization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunization(oSource).FIdentifierList);
  end;
  if (TFhirImmunization(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirImmunization(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirImmunization(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirImmunization(oSource).FInstantiatesUriList);
  end;
  if (TFhirImmunization(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirImmunization(oSource).FBasedOnList);
  end;
  statusElement := TFhirImmunization(oSource).statusElement.Clone;
  statusReason := TFhirImmunization(oSource).statusReason.Clone;
  vaccineCode := TFhirImmunization(oSource).vaccineCode.Clone;
  manufacturer := TFhirImmunization(oSource).manufacturer.Clone;
  lotNumberElement := TFhirImmunization(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirImmunization(oSource).expirationDateElement.Clone;
  patient := TFhirImmunization(oSource).patient.Clone;
  encounter := TFhirImmunization(oSource).encounter.Clone;
  occurrence := TFhirImmunization(oSource).occurrence.Clone;
  recordedElement := TFhirImmunization(oSource).recordedElement.Clone;
  primarySourceElement := TFhirImmunization(oSource).primarySourceElement.Clone;
  informationSource := TFhirImmunization(oSource).informationSource.Clone;
  location := TFhirImmunization(oSource).location.Clone;
  site := TFhirImmunization(oSource).site.Clone;
  route := TFhirImmunization(oSource).route.Clone;
  doseQuantity := TFhirImmunization(oSource).doseQuantity.Clone;
  if (TFhirImmunization(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirImmunizationPerformerList.Create;
    FPerformerList.Assign(TFhirImmunization(oSource).FPerformerList);
  end;
  if (TFhirImmunization(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImmunization(oSource).FNoteList);
  end;
  if (TFhirImmunization(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirImmunization(oSource).FReasonList);
  end;
  isSubpotentElement := TFhirImmunization(oSource).isSubpotentElement.Clone;
  if (TFhirImmunization(oSource).FSubpotentReasonList = nil) then
  begin
    FSubpotentReasonList.free;
    FSubpotentReasonList := nil;
  end
  else
  begin
    if FSubpotentReasonList = nil then
      FSubpotentReasonList := TFhirCodeableConceptList.Create;
    FSubpotentReasonList.Assign(TFhirImmunization(oSource).FSubpotentReasonList);
  end;
  if (TFhirImmunization(oSource).FEducationList = nil) then
  begin
    FEducationList.free;
    FEducationList := nil;
  end
  else
  begin
    if FEducationList = nil then
      FEducationList := TFhirImmunizationEducationList.Create;
    FEducationList.Assign(TFhirImmunization(oSource).FEducationList);
  end;
  if (TFhirImmunization(oSource).FProgramEligibilityList = nil) then
  begin
    FProgramEligibilityList.free;
    FProgramEligibilityList := nil;
  end
  else
  begin
    if FProgramEligibilityList = nil then
      FProgramEligibilityList := TFhirCodeableConceptList.Create;
    FProgramEligibilityList.Assign(TFhirImmunization(oSource).FProgramEligibilityList);
  end;
  fundingSource := TFhirImmunization(oSource).fundingSource.Clone;
  if (TFhirImmunization(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirImmunizationReactionList.Create;
    FReactionList.Assign(TFhirImmunization(oSource).FReactionList);
  end;
  if (TFhirImmunization(oSource).FProtocolAppliedList = nil) then
  begin
    FProtocolAppliedList.free;
    FProtocolAppliedList := nil;
  end
  else
  begin
    if FProtocolAppliedList = nil then
      FProtocolAppliedList := TFhirImmunizationProtocolAppliedList.Create;
    FProtocolAppliedList.Assign(TFhirImmunization(oSource).FProtocolAppliedList);
  end;
end;

function TFhirImmunization.GetResourceType : TFhirResourceType;
begin
  result := frtImmunization;
end;

procedure TFhirImmunization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'primarySource') Then
     list.add(self.link, 'primarySource', FPrimarySource.Link);
  if (child_name = 'informationSource[x]') or (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource[x]', FInformationSource.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'doseQuantity') Then
     list.add(self.link, 'doseQuantity', FDoseQuantity.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'isSubpotent') Then
     list.add(self.link, 'isSubpotent', FIsSubpotent.Link);
  if (child_name = 'subpotentReason') Then
    list.addAll(self, 'subpotentReason', FSubpotentReasonList);
  if (child_name = 'education') Then
    list.addAll(self, 'education', FEducationList);
  if (child_name = 'programEligibility') Then
    list.addAll(self, 'programEligibility', FProgramEligibilityList);
  if (child_name = 'fundingSource') Then
     list.add(self.link, 'fundingSource', FFundingSource.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
  if (child_name = 'protocolApplied') Then
    list.addAll(self, 'protocolApplied', FProtocolAppliedList);
end;

procedure TFhirImmunization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'date', false, TFhirDate, FExpirationDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|string', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorded', 'dateTime', false, TFhirDateTime, FRecorded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'primarySource', 'boolean', false, TFhirBoolean, FPrimarySource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'informationSource[x]', 'CodeableConcept|Reference', false, TFhirDataType, FInformationSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', false, TFhirQuantity, FDoseQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirImmunizationPerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'isSubpotent', 'boolean', false, TFhirBoolean, FIsSubpotent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subpotentReason', 'CodeableConcept', true, TFhirCodeableConcept, FSubpotentReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'education', 'BackboneElement', true, TFhirImmunizationEducation, FEducationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programEligibility', 'CodeableConcept', true, TFhirCodeableConcept, FProgramEligibilityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'fundingSource', 'CodeableConcept', false, TFhirCodeableConcept, FFundingSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reaction', 'BackboneElement', true, TFhirImmunizationReaction, FReactionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'protocolApplied', 'BackboneElement', true, TFhirImmunizationProtocolApplied, FProtocolAppliedList.Link)) {L1039};
end;

function TFhirImmunization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusCodesEnum, CODES_TFhirImmunizationStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'informationSource', ['CodeableConcept', 'Reference'])) then
  begin
    InformationSource := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'doseQuantity') then
  begin
    DoseQuantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirImmunizationPerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'isSubpotent') then
  begin
    IsSubpotentElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subpotentReason') then
  begin
    SubpotentReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'education') then
  begin
    EducationList.add(propValue as TFhirImmunizationEducation) {L1048};
    result := propValue;
  end
  else if (propName = 'programEligibility') then
  begin
    ProgramEligibilityList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'fundingSource') then
  begin
    FundingSource := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirImmunizationReaction) {L1048};
    result := propValue;
  end
  else if (propName = 'protocolApplied') then
  begin
    ProtocolAppliedList.add(propValue as TFhirImmunizationProtocolApplied) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirImmunizationPerformer) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'subpotentReason') then SubpotentReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'education') then EducationList.insertItem(index, propValue as TFhirImmunizationEducation) {L1049}
  else if (propName = 'programEligibility') then ProgramEligibilityList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirImmunizationReaction) {L1049}
  else if (propName = 'protocolApplied') then ProtocolAppliedList.insertItem(index, propValue as TFhirImmunizationProtocolApplied) {L1049}
  else inherited;
end;

function TFhirImmunization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImmunizationStatusCodesEnum[ImmunizationStatusCodesNull], CODES_TFhirImmunizationStatusCodesEnum[ImmunizationStatusCodesNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'manufacturer') then result := TFhirReference.create() {L1203}
  else if (propName = 'lotNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'expirationDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'recorded') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'primarySource') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'informationSource', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property InformationSource') {L1191}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'site') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'route') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'doseQuantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'isSubpotent') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'subpotentReason') then result := SubpotentReasonList.new() {L1053}
  else if (propName = 'education') then result := EducationList.new() {L1053}
  else if (propName = 'programEligibility') then result := ProgramEligibilityList.new() {L1053}
  else if (propName = 'fundingSource') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reaction') then result := ReactionList.new() {L1053}
  else if (propName = 'protocolApplied') then result := ProtocolAppliedList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'date'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|string'
  else if (propName = 'recorded') then result := 'dateTime'
  else if (propName = 'primarySource') then result := 'boolean'
  else if (propName = 'informationSource[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'doseQuantity') then result := 'Quantity'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'isSubpotent') then result := 'boolean'
  else if (propName = 'subpotentReason') then result := 'CodeableConcept'
  else if (propName = 'education') then result := 'BackboneElement'
  else if (propName = 'programEligibility') then result := 'CodeableConcept'
  else if (propName = 'fundingSource') then result := 'CodeableConcept'
  else if (propName = 'reaction') then result := 'BackboneElement'
  else if (propName = 'protocolApplied') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'primarySource') then PrimarySourceElement := nil
  else if (isMatchingName(propName, 'informationSource', ['CodeableConcept', 'Reference'])) then InformationSourceElement := nil {L1189}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'doseQuantity') then DoseQuantityElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'isSubpotent') then IsSubpotentElement := nil
  else if (propName = 'subpotentReason') then deletePropertyValue('subpotentReason', SubpotentReasonList, value) {L1054}
  else if (propName = 'education') then deletePropertyValue('education', EducationList, value) {L1054}
  else if (propName = 'programEligibility') then deletePropertyValue('programEligibility', ProgramEligibilityList, value) {L1054}
  else if (propName = 'fundingSource') then FundingSourceElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {L1054}
  else if (propName = 'protocolApplied') then deletePropertyValue('protocolApplied', ProtocolAppliedList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusCodesEnum, CODES_TFhirImmunizationStatusCodesEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference {L1195}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new) {L1222}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDate(new) {L1222}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'recorded') then RecordedElement := asDateTime(new) {L1222}
  else if (propName = 'primarySource') then PrimarySourceElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'informationSource', ['CodeableConcept', 'Reference'])) then InformationSourceElement := new as TFhirDataType {L1190}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'doseQuantity') then DoseQuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'isSubpotent') then IsSubpotentElement := asBoolean(new) {L1222}
  else if (propName = 'subpotentReason') then replacePropertyValue('subpotentReason', SubpotentReasonList, existing, new) {L1055}
  else if (propName = 'education') then replacePropertyValue('education', EducationList, existing, new) {L1055}
  else if (propName = 'programEligibility') then replacePropertyValue('programEligibility', ProgramEligibilityList, existing, new) {L1055}
  else if (propName = 'fundingSource') then FundingSourceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {L1055}
  else if (propName = 'protocolApplied') then replacePropertyValue('protocolApplied', ProtocolAppliedList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'subpotentReason') then SubpotentReasonList.move(source, destination) {L1050}
  else if (propName = 'education') then EducationList.move(source, destination) {L1050}
  else if (propName = 'programEligibility') then ProgramEligibilityList.move(source, destination) {L1050}
  else if (propName = 'reaction') then ReactionList.move(source, destination) {L1050}
  else if (propName = 'protocolApplied') then ProtocolAppliedList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunization.fhirType : string;
begin
  result := 'Immunization';
end;

function TFhirImmunization.Link : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Link);
end;

function TFhirImmunization.Clone : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Clone);
end;

function TFhirImmunization.equals(other : TObject) : boolean; 
var
  o : TFhirImmunization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunization)) then
    result := false
  else
  begin
    o := TFhirImmunization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(recordedElement, o.recordedElement, true) and 
      compareDeep(primarySourceElement, o.primarySourceElement, true) and compareDeep(informationSourceElement, o.informationSourceElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(siteElement, o.siteElement, true) and 
      compareDeep(routeElement, o.routeElement, true) and compareDeep(doseQuantityElement, o.doseQuantityElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(isSubpotentElement, o.isSubpotentElement, true) and 
      compareDeep(subpotentReasonList, o.subpotentReasonList, true) and compareDeep(educationList, o.educationList, true) and 
      compareDeep(programEligibilityList, o.programEligibilityList, true) and compareDeep(fundingSourceElement, o.fundingSourceElement, true) and 
      compareDeep(reactionList, o.reactionList, true) and compareDeep(protocolAppliedList, o.protocolAppliedList, true);
  end;
end;

function TFhirImmunization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FVaccineCode) and isEmptyProp(FManufacturer) and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FRecorded) and isEmptyProp(FPrimarySource) and isEmptyProp(FInformationSource) and isEmptyProp(FLocation) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FDoseQuantity) and isEmptyProp(FperformerList) and isEmptyProp(FnoteList) and isEmptyProp(FreasonList) and isEmptyProp(FIsSubpotent) and isEmptyProp(FsubpotentReasonList) and isEmptyProp(FeducationList) and isEmptyProp(FprogramEligibilityList) and isEmptyProp(FFundingSource) and isEmptyProp(FreactionList) and isEmptyProp(FprotocolAppliedList);
end;

function TFhirImmunization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirImmunization.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirImmunization.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirImmunization.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirImmunization.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirImmunization.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirImmunization.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirImmunization.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImmunization.GetStatusST : TFhirImmunizationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirImmunizationStatusCodesEnum(0)
  else
    result := TFhirImmunizationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirImmunizationStatusCodesEnum, FStatus.value));
end;

procedure TFhirImmunization.SetStatusST(value : TFhirImmunizationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImmunizationStatusCodesEnum[value], CODES_TFhirImmunizationStatusCodesEnum[value]);
end;

procedure TFhirImmunization.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

procedure TFhirImmunization.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value; {L1134}
end;

procedure TFhirImmunization.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value; {L1134}
end;

procedure TFhirImmunization.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value; {L1134}
end;

function TFhirImmunization.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirImmunization.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirImmunization.SetExpirationDate(value : TFhirDate);
begin
  FExpirationDate.free;
  FExpirationDate := value; {L1134}
end;

function TFhirImmunization.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirImmunization.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDate.create;
  FExpirationDate.value := value
end;

procedure TFhirImmunization.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirImmunization.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirImmunization.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirImmunization.SetRecorded(value : TFhirDateTime);
begin
  FRecorded.free;
  FRecorded := value; {L1134}
end;

function TFhirImmunization.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirImmunization.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirDateTime.create;
  FRecorded.value := value
end;

procedure TFhirImmunization.SetPrimarySource(value : TFhirBoolean);
begin
  FPrimarySource.free;
  FPrimarySource := value; {L1134}
end;

function TFhirImmunization.GetPrimarySourceST : Boolean;
begin
  if FPrimarySource = nil then
    result := false
  else
    result := FPrimarySource.value;
end;

procedure TFhirImmunization.SetPrimarySourceST(value : Boolean);
begin
  if FPrimarySource = nil then
    FPrimarySource := TFhirBoolean.create;
  FPrimarySource.value := value
end;

procedure TFhirImmunization.SetInformationSource(value : TFhirDataType);
begin
  FInformationSource.free;
  FInformationSource := value; {L1134}
end;

procedure TFhirImmunization.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirImmunization.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value; {L1134}
end;

procedure TFhirImmunization.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value; {L1134}
end;

procedure TFhirImmunization.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value; {L1134}
end;

function TFhirImmunization.GetPerformerList : TFhirImmunizationPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirImmunizationPerformerList.Create;
  result := FPerformerList;
end;

function TFhirImmunization.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirImmunization.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirImmunization.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirImmunization.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirImmunization.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirImmunization.SetIsSubpotent(value : TFhirBoolean);
begin
  FIsSubpotent.free;
  FIsSubpotent := value; {L1134}
end;

function TFhirImmunization.GetIsSubpotentST : Boolean;
begin
  if FIsSubpotent = nil then
    result := false
  else
    result := FIsSubpotent.value;
end;

procedure TFhirImmunization.SetIsSubpotentST(value : Boolean);
begin
  if FIsSubpotent = nil then
    FIsSubpotent := TFhirBoolean.create;
  FIsSubpotent.value := value
end;

function TFhirImmunization.GetSubpotentReasonList : TFhirCodeableConceptList;
begin
  if FSubpotentReasonList = nil then
    FSubpotentReasonList := TFhirCodeableConceptList.Create;
  result := FSubpotentReasonList;
end;

function TFhirImmunization.GetHasSubpotentReasonList : boolean;
begin
  result := (FSubpotentReasonList <> nil) and (FSubpotentReasonList.count > 0);
end;

function TFhirImmunization.GetEducationList : TFhirImmunizationEducationList;
begin
  if FEducationList = nil then
    FEducationList := TFhirImmunizationEducationList.Create;
  result := FEducationList;
end;

function TFhirImmunization.GetHasEducationList : boolean;
begin
  result := (FEducationList <> nil) and (FEducationList.count > 0);
end;

function TFhirImmunization.GetProgramEligibilityList : TFhirCodeableConceptList;
begin
  if FProgramEligibilityList = nil then
    FProgramEligibilityList := TFhirCodeableConceptList.Create;
  result := FProgramEligibilityList;
end;

function TFhirImmunization.GetHasProgramEligibilityList : boolean;
begin
  result := (FProgramEligibilityList <> nil) and (FProgramEligibilityList.count > 0);
end;

procedure TFhirImmunization.SetFundingSource(value : TFhirCodeableConcept);
begin
  FFundingSource.free;
  FFundingSource := value; {L1134}
end;

function TFhirImmunization.GetReactionList : TFhirImmunizationReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirImmunizationReactionList.Create;
  result := FReactionList;
end;

function TFhirImmunization.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

function TFhirImmunization.GetProtocolAppliedList : TFhirImmunizationProtocolAppliedList;
begin
  if FProtocolAppliedList = nil then
    FProtocolAppliedList := TFhirImmunizationProtocolAppliedList.Create;
  result := FProtocolAppliedList;
end;

function TFhirImmunization.GetHasProtocolAppliedList : boolean;
begin
  result := (FProtocolAppliedList <> nil) and (FProtocolAppliedList.count > 0);
end;

procedure TFhirImmunization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('status');
  fields.add('statusReason');
  fields.add('vaccineCode');
  fields.add('manufacturer');
  fields.add('lotNumber');
  fields.add('expirationDate');
  fields.add('patient');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('recorded');
  fields.add('primarySource');
  fields.add('informationSource[x]');
  fields.add('location');
  fields.add('site');
  fields.add('route');
  fields.add('doseQuantity');
  fields.add('performer');
  fields.add('note');
  fields.add('reason');
  fields.add('isSubpotent');
  fields.add('subpotentReason');
  fields.add('education');
  fields.add('programEligibility');
  fields.add('fundingSource');
  fields.add('reaction');
  fields.add('protocolApplied');
end;

function TFhirImmunization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FVaccineCode.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FPrimarySource.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FDoseQuantity.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FIsSubpotent.sizeInBytes);
  inc(result, FsubpotentReasonList.sizeInBytes);
  inc(result, FeducationList.sizeInBytes);
  inc(result, FprogramEligibilityList.sizeInBytes);
  inc(result, FFundingSource.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
  inc(result, FprotocolAppliedList.sizeInBytes);
end;

{ TFhirImmunizationListEnumerator }

constructor TFhirImmunizationListEnumerator.Create(list : TFhirImmunizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationListEnumerator.GetCurrent : TFhirImmunization;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationList }

procedure TFhirImmunizationList.AddItem(value: TFhirImmunization);
begin
  assert(value.ClassName = 'TFhirImmunization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunization');
  add(value);
end;

function TFhirImmunizationList.Append: TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationList.GetEnumerator : TFhirImmunizationListEnumerator;
begin
  result := TFhirImmunizationListEnumerator.Create(self.link);
end;

function TFhirImmunizationList.Clone: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Clone);
end;

function TFhirImmunizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationList.GetItemN(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunization;
end;
function TFhirImmunizationList.IndexOf(value: TFhirImmunization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationList.Insert(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.InsertItem(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  Inherited Insert(index, value);
end;

function TFhirImmunizationList.Item(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.Link: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Link);
end;

procedure TFhirImmunizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationList.SetItemByIndex(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  FhirImmunizations[index] := value;
end;

procedure TFhirImmunizationList.SetItemN(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
{ TFhirImmunizationEvaluation }

constructor TFhirImmunizationEvaluation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationEvaluation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FDate.free;
  FAuthority.free;
  FTargetDisease.free;
  FImmunizationEvent.free;
  FDoseStatus.free;
  FDoseStatusReasonList.Free;
  FDescription.free;
  FSeries.free;
  FDoseNumber.free;
  FSeriesDoses.free;
  inherited;
end;

procedure TFhirImmunizationEvaluation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationEvaluation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationEvaluation(oSource).FIdentifierList);
  end;
  statusElement := TFhirImmunizationEvaluation(oSource).statusElement.Clone;
  patient := TFhirImmunizationEvaluation(oSource).patient.Clone;
  dateElement := TFhirImmunizationEvaluation(oSource).dateElement.Clone;
  authority := TFhirImmunizationEvaluation(oSource).authority.Clone;
  targetDisease := TFhirImmunizationEvaluation(oSource).targetDisease.Clone;
  immunizationEvent := TFhirImmunizationEvaluation(oSource).immunizationEvent.Clone;
  doseStatus := TFhirImmunizationEvaluation(oSource).doseStatus.Clone;
  if (TFhirImmunizationEvaluation(oSource).FDoseStatusReasonList = nil) then
  begin
    FDoseStatusReasonList.free;
    FDoseStatusReasonList := nil;
  end
  else
  begin
    if FDoseStatusReasonList = nil then
      FDoseStatusReasonList := TFhirCodeableConceptList.Create;
    FDoseStatusReasonList.Assign(TFhirImmunizationEvaluation(oSource).FDoseStatusReasonList);
  end;
  descriptionElement := TFhirImmunizationEvaluation(oSource).descriptionElement.Clone;
  seriesElement := TFhirImmunizationEvaluation(oSource).seriesElement.Clone;
  doseNumberElement := TFhirImmunizationEvaluation(oSource).doseNumberElement.Clone;
  seriesDosesElement := TFhirImmunizationEvaluation(oSource).seriesDosesElement.Clone;
end;

function TFhirImmunizationEvaluation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationEvaluation;
end;

procedure TFhirImmunizationEvaluation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'targetDisease') Then
     list.add(self.link, 'targetDisease', FTargetDisease.Link);
  if (child_name = 'immunizationEvent') Then
     list.add(self.link, 'immunizationEvent', FImmunizationEvent.Link);
  if (child_name = 'doseStatus') Then
     list.add(self.link, 'doseStatus', FDoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
    list.addAll(self, 'doseStatusReason', FDoseStatusReasonList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber', FDoseNumber.Link);
  if (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses', FSeriesDoses.Link);
end;

procedure TFhirImmunizationEvaluation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', false, TFhirCodeableConcept, FTargetDisease.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'immunizationEvent', 'Reference', false, TFhirReference, FImmunizationEvent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', true, TFhirCodeableConcept, FDoseStatusReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'string', false, TFhirString, FDoseNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'string', false, TFhirString, FSeriesDoses.Link)); {L1172}
end;

function TFhirImmunizationEvaluation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, CODES_TFhirImmunizationEvaluationStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDisease := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'immunizationEvent') then
  begin
    ImmunizationEvent := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'doseStatus') then
  begin
    DoseStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'doseStatusReason') then
  begin
    DoseStatusReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'doseNumber') then
  begin
    DoseNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'seriesDoses') then
  begin
    SeriesDosesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationEvaluation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'doseStatusReason') then DoseStatusReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirImmunizationEvaluation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum[ImmunizationEvaluationStatusCodesNull], CODES_TFhirImmunizationEvaluationStatusCodesEnum[ImmunizationEvaluationStatusCodesNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'authority') then result := TFhirReference.create() {L1203}
  else if (propName = 'targetDisease') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'immunizationEvent') then result := TFhirReference.create() {L1203}
  else if (propName = 'doseStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'doseStatusReason') then result := DoseStatusReasonList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'series') then result := TFhirString.create() {L1223}
  else if (propName = 'doseNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'seriesDoses') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationEvaluation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'immunizationEvent') then result := 'Reference'
  else if (propName = 'doseStatus') then result := 'CodeableConcept'
  else if (propName = 'doseStatusReason') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'doseNumber') then result := 'string'
  else if (propName = 'seriesDoses') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationEvaluation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'targetDisease') then TargetDiseaseElement := nil
  else if (propName = 'immunizationEvent') then ImmunizationEventElement := nil
  else if (propName = 'doseStatus') then DoseStatusElement := nil
  else if (propName = 'doseStatusReason') then deletePropertyValue('doseStatusReason', DoseStatusReasonList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (propName = 'doseNumber') then DoseNumberElement := nil
  else if (propName = 'seriesDoses') then SeriesDosesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationEvaluation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, CODES_TFhirImmunizationEvaluationStatusCodesEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference {L1195}
  else if (propName = 'targetDisease') then TargetDiseaseElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'immunizationEvent') then ImmunizationEventElement := new as TFhirReference {L1195}
  else if (propName = 'doseStatus') then DoseStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'doseStatusReason') then replacePropertyValue('doseStatusReason', DoseStatusReasonList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'series') then SeriesElement := asString(new) {L1222}
  else if (propName = 'doseNumber') then DoseNumberElement := asString(new) {L1222}
  else if (propName = 'seriesDoses') then SeriesDosesElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationEvaluation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'doseStatusReason') then DoseStatusReasonList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationEvaluation.fhirType : string;
begin
  result := 'ImmunizationEvaluation';
end;

function TFhirImmunizationEvaluation.Link : TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(inherited Link);
end;

function TFhirImmunizationEvaluation.Clone : TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(inherited Clone);
end;

function TFhirImmunizationEvaluation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationEvaluation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationEvaluation)) then
    result := false
  else
  begin
    o := TFhirImmunizationEvaluation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(authorityElement, o.authorityElement, true) and compareDeep(targetDiseaseElement, o.targetDiseaseElement, true) and 
      compareDeep(immunizationEventElement, o.immunizationEventElement, true) and compareDeep(doseStatusElement, o.doseStatusElement, true) and 
      compareDeep(doseStatusReasonList, o.doseStatusReasonList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true);
  end;
end;

function TFhirImmunizationEvaluation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FAuthority) and isEmptyProp(FTargetDisease) and isEmptyProp(FImmunizationEvent) and isEmptyProp(FDoseStatus) and isEmptyProp(FdoseStatusReasonList) and isEmptyProp(FDescription) and isEmptyProp(FSeries) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses);
end;

function TFhirImmunizationEvaluation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunizationEvaluation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImmunizationEvaluation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImmunizationEvaluation.GetStatusST : TFhirImmunizationEvaluationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirImmunizationEvaluationStatusCodesEnum(0)
  else
    result := TFhirImmunizationEvaluationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirImmunizationEvaluationStatusCodesEnum, FStatus.value));
end;

procedure TFhirImmunizationEvaluation.SetStatusST(value : TFhirImmunizationEvaluationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum[value], CODES_TFhirImmunizationEvaluationStatusCodesEnum[value]);
end;

procedure TFhirImmunizationEvaluation.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirImmunizationEvaluation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationEvaluation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationEvaluation.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value; {L1134}
end;

procedure TFhirImmunizationEvaluation.SetTargetDisease(value : TFhirCodeableConcept);
begin
  FTargetDisease.free;
  FTargetDisease := value; {L1134}
end;

procedure TFhirImmunizationEvaluation.SetImmunizationEvent(value : TFhirReference);
begin
  FImmunizationEvent.free;
  FImmunizationEvent := value; {L1134}
end;

procedure TFhirImmunizationEvaluation.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetDoseStatusReasonList : TFhirCodeableConceptList;
begin
  if FDoseStatusReasonList = nil then
    FDoseStatusReasonList := TFhirCodeableConceptList.Create;
  result := FDoseStatusReasonList;
end;

function TFhirImmunizationEvaluation.GetHasDoseStatusReasonList : boolean;
begin
  result := (FDoseStatusReasonList <> nil) and (FDoseStatusReasonList.count > 0);
end;

procedure TFhirImmunizationEvaluation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImmunizationEvaluation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImmunizationEvaluation.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationEvaluation.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationEvaluation.SetDoseNumber(value : TFhirString);
begin
  FDoseNumber.free;
  FDoseNumber := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

procedure TFhirImmunizationEvaluation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirString.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

procedure TFhirImmunizationEvaluation.SetSeriesDoses(value : TFhirString);
begin
  FSeriesDoses.free;
  FSeriesDoses := value; {L1134}
end;

function TFhirImmunizationEvaluation.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

procedure TFhirImmunizationEvaluation.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirString.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

procedure TFhirImmunizationEvaluation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('date');
  fields.add('authority');
  fields.add('targetDisease');
  fields.add('immunizationEvent');
  fields.add('doseStatus');
  fields.add('doseStatusReason');
  fields.add('description');
  fields.add('series');
  fields.add('doseNumber');
  fields.add('seriesDoses');
end;

function TFhirImmunizationEvaluation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FTargetDisease.sizeInBytes);
  inc(result, FImmunizationEvent.sizeInBytes);
  inc(result, FDoseStatus.sizeInBytes);
  inc(result, FdoseStatusReasonList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
  inc(result, FDoseNumber.sizeInBytes);
  inc(result, FSeriesDoses.sizeInBytes);
end;

{ TFhirImmunizationEvaluationListEnumerator }

constructor TFhirImmunizationEvaluationListEnumerator.Create(list : TFhirImmunizationEvaluationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationEvaluationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationEvaluationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationEvaluationListEnumerator.GetCurrent : TFhirImmunizationEvaluation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationEvaluationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationEvaluationList }

procedure TFhirImmunizationEvaluationList.AddItem(value: TFhirImmunizationEvaluation);
begin
  assert(value.ClassName = 'TFhirImmunizationEvaluation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationEvaluation');
  add(value);
end;

function TFhirImmunizationEvaluationList.Append: TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEvaluationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationEvaluationList.GetEnumerator : TFhirImmunizationEvaluationListEnumerator;
begin
  result := TFhirImmunizationEvaluationListEnumerator.Create(self.link);
end;

function TFhirImmunizationEvaluationList.Clone: TFhirImmunizationEvaluationList;
begin
  result := TFhirImmunizationEvaluationList(inherited Clone);
end;

function TFhirImmunizationEvaluationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationEvaluationList.GetItemN(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(ObjectByIndex[index]);
end;

function TFhirImmunizationEvaluationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationEvaluation;
end;
function TFhirImmunizationEvaluationList.IndexOf(value: TFhirImmunizationEvaluation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationEvaluationList.Insert(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEvaluationList.InsertItem(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationEvaluationList.Item(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(ObjectByIndex[index]);
end;

function TFhirImmunizationEvaluationList.Link: TFhirImmunizationEvaluationList;
begin
  result := TFhirImmunizationEvaluationList(inherited Link);
end;

procedure TFhirImmunizationEvaluationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationEvaluationList.SetItemByIndex(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  FhirImmunizationEvaluations[index] := value;
end;

procedure TFhirImmunizationEvaluationList.SetItemN(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FVaccineCodeList.Free;
  FTargetDiseaseList.Free;
  FContraindicatedVaccineCodeList.Free;
  FForecastStatus.free;
  FForecastReasonList.Free;
  FDateCriterionList.Free;
  FDescription.free;
  FSeries.free;
  FDoseNumber.free;
  FSeriesDoses.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FVaccineCodeList = nil) then
  begin
    FVaccineCodeList.free;
    FVaccineCodeList := nil;
  end
  else
  begin
    if FVaccineCodeList = nil then
      FVaccineCodeList := TFhirCodeableConceptList.Create;
    FVaccineCodeList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FVaccineCodeList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FTargetDiseaseList = nil) then
  begin
    FTargetDiseaseList.free;
    FTargetDiseaseList := nil;
  end
  else
  begin
    if FTargetDiseaseList = nil then
      FTargetDiseaseList := TFhirCodeableConceptList.Create;
    FTargetDiseaseList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FTargetDiseaseList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FContraindicatedVaccineCodeList = nil) then
  begin
    FContraindicatedVaccineCodeList.free;
    FContraindicatedVaccineCodeList := nil;
  end
  else
  begin
    if FContraindicatedVaccineCodeList = nil then
      FContraindicatedVaccineCodeList := TFhirCodeableConceptList.Create;
    FContraindicatedVaccineCodeList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FContraindicatedVaccineCodeList);
  end;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FForecastReasonList = nil) then
  begin
    FForecastReasonList.free;
    FForecastReasonList := nil;
  end
  else
  begin
    if FForecastReasonList = nil then
      FForecastReasonList := TFhirCodeableConceptList.Create;
    FForecastReasonList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FForecastReasonList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList = nil) then
  begin
    FDateCriterionList.free;
    FDateCriterionList := nil;
  end
  else
  begin
    if FDateCriterionList = nil then
      FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
    FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  end;
  descriptionElement := TFhirImmunizationRecommendationRecommendation(oSource).descriptionElement.Clone;
  seriesElement := TFhirImmunizationRecommendationRecommendation(oSource).seriesElement.Clone;
  doseNumberElement := TFhirImmunizationRecommendationRecommendation(oSource).doseNumberElement.Clone;
  seriesDosesElement := TFhirImmunizationRecommendationRecommendation(oSource).seriesDosesElement.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList = nil) then
  begin
    FSupportingImmunizationList.free;
    FSupportingImmunizationList := nil;
  end
  else
  begin
    if FSupportingImmunizationList = nil then
      FSupportingImmunizationList := TFhirReferenceList.Create;
    FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList = nil) then
  begin
    FSupportingPatientInformationList.free;
    FSupportingPatientInformationList := nil;
  end
  else
  begin
    if FSupportingPatientInformationList = nil then
      FSupportingPatientInformationList := TFhirReferenceList.Create;
    FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
  end;
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'vaccineCode') Then
    list.addAll(self, 'vaccineCode', FVaccineCodeList);
  if (child_name = 'targetDisease') Then
    list.addAll(self, 'targetDisease', FTargetDiseaseList);
  if (child_name = 'contraindicatedVaccineCode') Then
    list.addAll(self, 'contraindicatedVaccineCode', FContraindicatedVaccineCodeList);
  if (child_name = 'forecastStatus') Then
     list.add(self.link, 'forecastStatus', FForecastStatus.Link);
  if (child_name = 'forecastReason') Then
    list.addAll(self, 'forecastReason', FForecastReasonList);
  if (child_name = 'dateCriterion') Then
    list.addAll(self, 'dateCriterion', FDateCriterionList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber', FDoseNumber.Link);
  if (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses', FSeriesDoses.Link);
  if (child_name = 'supportingImmunization') Then
    list.addAll(self, 'supportingImmunization', FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
    list.addAll(self, 'supportingPatientInformation', FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', true, TFhirCodeableConcept, FVaccineCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', true, TFhirCodeableConcept, FTargetDiseaseList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contraindicatedVaccineCode', 'CodeableConcept', true, TFhirCodeableConcept, FContraindicatedVaccineCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', false, TFhirCodeableConcept, FForecastStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'forecastReason', 'CodeableConcept', true, TFhirCodeableConcept, FForecastReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'dateCriterion', 'BackboneElement', true, TFhirImmunizationRecommendationRecommendationDateCriterion, FDateCriterionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'string', false, TFhirString, FDoseNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'string', false, TFhirString, FSeriesDoses.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Reference', true, TFhirReference, FSupportingImmunizationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Reference', true, TFhirReference, FSupportingPatientInformationList.Link)) {L1039};
end;

function TFhirImmunizationRecommendationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'vaccineCode') then
  begin
    VaccineCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDiseaseList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'contraindicatedVaccineCode') then
  begin
    ContraindicatedVaccineCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'forecastStatus') then
  begin
    ForecastStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'forecastReason') then
  begin
    ForecastReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'dateCriterion') then
  begin
    DateCriterionList.add(propValue as TFhirImmunizationRecommendationRecommendationDateCriterion) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'doseNumber') then
  begin
    DoseNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'seriesDoses') then
  begin
    SeriesDosesElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'supportingImmunization') then
  begin
    SupportingImmunizationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingPatientInformation') then
  begin
    SupportingPatientInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'vaccineCode') then VaccineCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'targetDisease') then TargetDiseaseList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'contraindicatedVaccineCode') then ContraindicatedVaccineCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'forecastReason') then ForecastReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'dateCriterion') then DateCriterionList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendationDateCriterion) {L1049}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'vaccineCode') then result := VaccineCodeList.new() {L1053}
  else if (propName = 'targetDisease') then result := TargetDiseaseList.new() {L1053}
  else if (propName = 'contraindicatedVaccineCode') then result := ContraindicatedVaccineCodeList.new() {L1053}
  else if (propName = 'forecastStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'forecastReason') then result := ForecastReasonList.new() {L1053}
  else if (propName = 'dateCriterion') then result := DateCriterionList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'series') then result := TFhirString.create() {L1223}
  else if (propName = 'doseNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'seriesDoses') then result := TFhirString.create() {L1223}
  else if (propName = 'supportingImmunization') then result := SupportingImmunizationList.new() {L1053}
  else if (propName = 'supportingPatientInformation') then result := SupportingPatientInformationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'contraindicatedVaccineCode') then result := 'CodeableConcept'
  else if (propName = 'forecastStatus') then result := 'CodeableConcept'
  else if (propName = 'forecastReason') then result := 'CodeableConcept'
  else if (propName = 'dateCriterion') then result := 'BackboneElement'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'doseNumber') then result := 'string'
  else if (propName = 'seriesDoses') then result := 'string'
  else if (propName = 'supportingImmunization') then result := 'Reference'
  else if (propName = 'supportingPatientInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'vaccineCode') then deletePropertyValue('vaccineCode', VaccineCodeList, value) {L1054}
  else if (propName = 'targetDisease') then deletePropertyValue('targetDisease', TargetDiseaseList, value) {L1054}
  else if (propName = 'contraindicatedVaccineCode') then deletePropertyValue('contraindicatedVaccineCode', ContraindicatedVaccineCodeList, value) {L1054}
  else if (propName = 'forecastStatus') then ForecastStatusElement := nil
  else if (propName = 'forecastReason') then deletePropertyValue('forecastReason', ForecastReasonList, value) {L1054}
  else if (propName = 'dateCriterion') then deletePropertyValue('dateCriterion', DateCriterionList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (propName = 'doseNumber') then DoseNumberElement := nil
  else if (propName = 'seriesDoses') then SeriesDosesElement := nil
  else if (propName = 'supportingImmunization') then deletePropertyValue('supportingImmunization', SupportingImmunizationList, value) {L1054}
  else if (propName = 'supportingPatientInformation') then deletePropertyValue('supportingPatientInformation', SupportingPatientInformationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'vaccineCode') then replacePropertyValue('vaccineCode', VaccineCodeList, existing, new) {L1055}
  else if (propName = 'targetDisease') then replacePropertyValue('targetDisease', TargetDiseaseList, existing, new) {L1055}
  else if (propName = 'contraindicatedVaccineCode') then replacePropertyValue('contraindicatedVaccineCode', ContraindicatedVaccineCodeList, existing, new) {L1055}
  else if (propName = 'forecastStatus') then ForecastStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'forecastReason') then replacePropertyValue('forecastReason', ForecastReasonList, existing, new) {L1055}
  else if (propName = 'dateCriterion') then replacePropertyValue('dateCriterion', DateCriterionList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'series') then SeriesElement := asString(new) {L1222}
  else if (propName = 'doseNumber') then DoseNumberElement := asString(new) {L1222}
  else if (propName = 'seriesDoses') then SeriesDosesElement := asString(new) {L1222}
  else if (propName = 'supportingImmunization') then replacePropertyValue('supportingImmunization', SupportingImmunizationList, existing, new) {L1055}
  else if (propName = 'supportingPatientInformation') then replacePropertyValue('supportingPatientInformation', SupportingPatientInformationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'vaccineCode') then VaccineCodeList.move(source, destination) {L1050}
  else if (propName = 'targetDisease') then TargetDiseaseList.move(source, destination) {L1050}
  else if (propName = 'contraindicatedVaccineCode') then ContraindicatedVaccineCodeList.move(source, destination) {L1050}
  else if (propName = 'forecastReason') then ForecastReasonList.move(source, destination) {L1050}
  else if (propName = 'dateCriterion') then DateCriterionList.move(source, destination) {L1050}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.move(source, destination) {L1050}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation.recommendation';
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendation(other);
    result := compareDeep(vaccineCodeList, o.vaccineCodeList, true) and compareDeep(targetDiseaseList, o.targetDiseaseList, true) and 
      compareDeep(contraindicatedVaccineCodeList, o.contraindicatedVaccineCodeList, true) and 
      compareDeep(forecastStatusElement, o.forecastStatusElement, true) and compareDeep(forecastReasonList, o.forecastReasonList, true) and 
      compareDeep(dateCriterionList, o.dateCriterionList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true) and compareDeep(supportingImmunizationList, o.supportingImmunizationList, true) and 
      compareDeep(supportingPatientInformationList, o.supportingPatientInformationList, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FvaccineCodeList) and isEmptyProp(FtargetDiseaseList) and isEmptyProp(FcontraindicatedVaccineCodeList) and isEmptyProp(FForecastStatus) and isEmptyProp(FforecastReasonList) and isEmptyProp(FdateCriterionList) and isEmptyProp(FDescription) and isEmptyProp(FSeries) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses) and isEmptyProp(FsupportingImmunizationList) and isEmptyProp(FsupportingPatientInformationList);
end;

function TFhirImmunizationRecommendationRecommendation.GetVaccineCodeList : TFhirCodeableConceptList;
begin
  if FVaccineCodeList = nil then
    FVaccineCodeList := TFhirCodeableConceptList.Create;
  result := FVaccineCodeList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasVaccineCodeList : boolean;
begin
  result := (FVaccineCodeList <> nil) and (FVaccineCodeList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetTargetDiseaseList : TFhirCodeableConceptList;
begin
  if FTargetDiseaseList = nil then
    FTargetDiseaseList := TFhirCodeableConceptList.Create;
  result := FTargetDiseaseList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasTargetDiseaseList : boolean;
begin
  result := (FTargetDiseaseList <> nil) and (FTargetDiseaseList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetContraindicatedVaccineCodeList : TFhirCodeableConceptList;
begin
  if FContraindicatedVaccineCodeList = nil then
    FContraindicatedVaccineCodeList := TFhirCodeableConceptList.Create;
  result := FContraindicatedVaccineCodeList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasContraindicatedVaccineCodeList : boolean;
begin
  result := (FContraindicatedVaccineCodeList <> nil) and (FContraindicatedVaccineCodeList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendation.GetForecastReasonList : TFhirCodeableConceptList;
begin
  if FForecastReasonList = nil then
    FForecastReasonList := TFhirCodeableConceptList.Create;
  result := FForecastReasonList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasForecastReasonList : boolean;
begin
  result := (FForecastReasonList <> nil) and (FForecastReasonList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  if FDateCriterionList = nil then
    FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  result := FDateCriterionList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasDateCriterionList : boolean;
begin
  result := (FDateCriterionList <> nil) and (FDateCriterionList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendation.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirString);
begin
  FDoseNumber.free;
  FDoseNumber := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirString.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeriesDoses(value : TFhirString);
begin
  FSeriesDoses.free;
  FSeriesDoses := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendation.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirString.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

function TFhirImmunizationRecommendationRecommendation.GetSupportingImmunizationList : TFhirReferenceList;
begin
  if FSupportingImmunizationList = nil then
    FSupportingImmunizationList := TFhirReferenceList.Create;
  result := FSupportingImmunizationList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasSupportingImmunizationList : boolean;
begin
  result := (FSupportingImmunizationList <> nil) and (FSupportingImmunizationList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetSupportingPatientInformationList : TFhirReferenceList;
begin
  if FSupportingPatientInformationList = nil then
    FSupportingPatientInformationList := TFhirReferenceList.Create;
  result := FSupportingPatientInformationList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasSupportingPatientInformationList : boolean;
begin
  result := (FSupportingPatientInformationList <> nil) and (FSupportingPatientInformationList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('vaccineCode');
  fields.add('targetDisease');
  fields.add('contraindicatedVaccineCode');
  fields.add('forecastStatus');
  fields.add('forecastReason');
  fields.add('dateCriterion');
  fields.add('description');
  fields.add('series');
  fields.add('doseNumber');
  fields.add('seriesDoses');
  fields.add('supportingImmunization');
  fields.add('supportingPatientInformation');
end;

function TFhirImmunizationRecommendationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FvaccineCodeList.sizeInBytes);
  inc(result, FtargetDiseaseList.sizeInBytes);
  inc(result, FcontraindicatedVaccineCodeList.sizeInBytes);
  inc(result, FForecastStatus.sizeInBytes);
  inc(result, FforecastReasonList.sizeInBytes);
  inc(result, FdateCriterionList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
  inc(result, FDoseNumber.sizeInBytes);
  inc(result, FSeriesDoses.sizeInBytes);
  inc(result, FsupportingImmunizationList.sizeInBytes);
  inc(result, FsupportingPatientInformationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationListEnumerator }

constructor TFhirImmunizationRecommendationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationList }

procedure TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendation;
end;
function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  valueElement := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).valueElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', false, TFhirDateTime, FValue.Link)); {L1172}
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'value') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'value') then ValueElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.fhirType : string;
begin
  result := 'ImmunizationRecommendation.recommendation.dateCriterion';
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationDateCriterion)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationDateCriterion(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TFslDateTime;
begin
  if FValue = nil then
    result := TFslDateTime.makeNull
  else
    result := FValue.value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TFslDateTime);
begin
  if FValue = nil then
    FValue := TFhirDateTime.create;
  FValue.value := value
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator }

constructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionList }

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion;
end;
function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendation }

constructor TFhirImmunizationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendation.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FPatient.free;
  FDate.free;
  FAuthority.free;
  FRecommendationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationRecommendation(oSource).FIdentifierList);
  end;
  if (TFhirImmunizationRecommendation(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirImmunizationRecommendation(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirImmunizationRecommendation(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirImmunizationRecommendation(oSource).FInstantiatesUriList);
  end;
  patient := TFhirImmunizationRecommendation(oSource).patient.Clone;
  dateElement := TFhirImmunizationRecommendation(oSource).dateElement.Clone;
  authority := TFhirImmunizationRecommendation(oSource).authority.Clone;
  if (TFhirImmunizationRecommendation(oSource).FRecommendationList = nil) then
  begin
    FRecommendationList.free;
    FRecommendationList := nil;
  end
  else
  begin
    if FRecommendationList = nil then
      FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
    FRecommendationList.Assign(TFhirImmunizationRecommendation(oSource).FRecommendationList);
  end;
end;

function TFhirImmunizationRecommendation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationRecommendation;
end;

procedure TFhirImmunizationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'recommendation') Then
    list.addAll(self, 'recommendation', FRecommendationList);
end;

procedure TFhirImmunizationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recommendation', 'BackboneElement', true, TFhirImmunizationRecommendationRecommendation, FRecommendationList.Link)) {L1039};
end;

function TFhirImmunizationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'recommendation') then
  begin
    RecommendationList.add(propValue as TFhirImmunizationRecommendationRecommendation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'recommendation') then RecommendationList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendation) {L1049}
  else inherited;
end;

function TFhirImmunizationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'authority') then result := TFhirReference.create() {L1203}
  else if (propName = 'recommendation') then result := RecommendationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'recommendation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'recommendation') then deletePropertyValue('recommendation', RecommendationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference {L1195}
  else if (propName = 'recommendation') then replacePropertyValue('recommendation', RecommendationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'recommendation') then RecommendationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation';
end;

function TFhirImmunizationRecommendation.Link : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendation.Clone : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorityElement, o.authorityElement, true) and 
      compareDeep(recommendationList, o.recommendationList, true);
  end;
end;

function TFhirImmunizationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FAuthority) and isEmptyProp(FrecommendationList);
end;

function TFhirImmunizationRecommendation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunizationRecommendation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirImmunizationRecommendation.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirImmunizationRecommendation.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirImmunizationRecommendation.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirImmunizationRecommendation.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

procedure TFhirImmunizationRecommendation.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirImmunizationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirImmunizationRecommendation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationRecommendation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationRecommendation.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value; {L1134}
end;

function TFhirImmunizationRecommendation.GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
begin
  if FRecommendationList = nil then
    FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
  result := FRecommendationList;
end;

function TFhirImmunizationRecommendation.GetHasRecommendationList : boolean;
begin
  result := (FRecommendationList <> nil) and (FRecommendationList.count > 0);
end;

procedure TFhirImmunizationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('patient');
  fields.add('date');
  fields.add('authority');
  fields.add('recommendation');
end;

function TFhirImmunizationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FrecommendationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationListEnumerator }

constructor TFhirImmunizationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationList }

procedure TFhirImmunizationRecommendationList.AddItem(value: TFhirImmunizationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationList.Append: TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationList.Clone: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendation;
end;
function TFhirImmunizationRecommendationList.IndexOf(value: TFhirImmunizationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.Link: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  FhirImmunizationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
{ TFhirMedicationAdministrationPerformer }

constructor TFhirMedicationAdministrationPerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirMedicationAdministrationPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirMedicationAdministrationPerformer(oSource).function_.Clone;
  actor := TFhirMedicationAdministrationPerformer(oSource).actor.Clone;
end;

procedure TFhirMedicationAdministrationPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirMedicationAdministrationPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirMedicationAdministrationPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationPerformer.fhirType : string;
begin
  result := 'MedicationAdministration.performer';
end;

function TFhirMedicationAdministrationPerformer.Link : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Link);
end;

function TFhirMedicationAdministrationPerformer.Clone : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Clone);
end;

function TFhirMedicationAdministrationPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministrationPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationPerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirMedicationAdministrationPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirMedicationAdministrationPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirMedicationAdministrationPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirMedicationAdministrationPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirMedicationAdministrationPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirMedicationAdministrationPerformerListEnumerator }

constructor TFhirMedicationAdministrationPerformerListEnumerator.Create(list : TFhirMedicationAdministrationPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.GetCurrent : TFhirMedicationAdministrationPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationPerformerList }

procedure TFhirMedicationAdministrationPerformerList.AddItem(value: TFhirMedicationAdministrationPerformer);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationPerformer');
  add(value);
end;

function TFhirMedicationAdministrationPerformerList.Append: TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationPerformerList.GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;
begin
  result := TFhirMedicationAdministrationPerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationPerformerList.Clone: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Clone);
end;

function TFhirMedicationAdministrationPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationPerformerList.GetItemN(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationPerformer;
end;
function TFhirMedicationAdministrationPerformerList.IndexOf(value: TFhirMedicationAdministrationPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationPerformerList.Insert(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.InsertItem(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationPerformerList.Item(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.Link: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Link);
end;

procedure TFhirMedicationAdministrationPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  FhirMedicationAdministrationPerformers[index] := value;
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemN(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FText.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDose.free;
  FRate.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationAdministrationDosage(oSource).textElement.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  dose := TFhirMedicationAdministrationDosage(oSource).dose.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'dose') Then
     list.add(self.link, 'dose', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dose', 'Quantity', false, TFhirQuantity, FDose.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Quantity', false, TFhirDataType, FRate.Link)); {L1172}
end;

function TFhirMedicationAdministrationDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'dose') then
  begin
    Dose := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then
  begin
    Rate := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {L1223}
  else if (propName = 'site') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'route') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'dose') then result := TFhirQuantity.create() {L1203}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then raise EFHIRException.create('Cannot make property Rate') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'dose') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'dose') then DoseElement := nil
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new) {L1222}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'dose') then DoseElement := new as TFhirQuantity {L1195}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationDosage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationDosage.fhirType : string;
begin
  result := 'MedicationAdministration.dosage';
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

function TFhirMedicationAdministrationDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministrationDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationDosage(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(siteElement, o.siteElement, true) and 
      compareDeep(routeElement, o.routeElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(doseElement, o.doseElement, true) and compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirMedicationAdministrationDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FDose) and isEmptyProp(FRate);
end;

procedure TFhirMedicationAdministrationDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirMedicationAdministrationDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirMedicationAdministrationDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value; {L1134}
end;

procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value; {L1134}
end;

procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirMedicationAdministrationDosage.SetDose(value : TFhirQuantity);
begin
  FDose.free;
  FDose := value; {L1134}
end;

procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirDataType);
begin
  FRate.free;
  FRate := value; {L1134}
end;

procedure TFhirMedicationAdministrationDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('site');
  fields.add('route');
  fields.add('method');
  fields.add('dose');
  fields.add('rate[x]');
end;

function TFhirMedicationAdministrationDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FDose.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageListEnumerator }

constructor TFhirMedicationAdministrationDosageListEnumerator.Create(list : TFhirMedicationAdministrationDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationDosageListEnumerator.GetCurrent : TFhirMedicationAdministrationDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageList }

procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;

function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
begin
  result := TFhirMedicationAdministrationDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationDosage;
end;
function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministration }

constructor TFhirMedicationAdministration.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministration.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FCategoryList.Free;
  FMedication.free;
  FSubject.free;
  FEncounter.free;
  FSupportingInformationList.Free;
  FOccurence.free;
  FRecorded.free;
  FPerformerList.Free;
  FReasonList.Free;
  FRequest.free;
  FDeviceList.Free;
  FNoteList.Free;
  FDosage.free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationAdministration(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationAdministration(oSource).FIdentifierList);
  end;
  if (TFhirMedicationAdministration(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirMedicationAdministration(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirMedicationAdministration(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirMedicationAdministration(oSource).FInstantiatesUriList);
  end;
  if (TFhirMedicationAdministration(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationAdministration(oSource).FBasedOnList);
  end;
  if (TFhirMedicationAdministration(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationAdministration(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationAdministration(oSource).statusElement.Clone;
  if (TFhirMedicationAdministration(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirMedicationAdministration(oSource).FStatusReasonList);
  end;
  if (TFhirMedicationAdministration(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirMedicationAdministration(oSource).FCategoryList);
  end;
  medication := TFhirMedicationAdministration(oSource).medication.Clone;
  subject := TFhirMedicationAdministration(oSource).subject.Clone;
  encounter := TFhirMedicationAdministration(oSource).encounter.Clone;
  if (TFhirMedicationAdministration(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationAdministration(oSource).FSupportingInformationList);
  end;
  occurence := TFhirMedicationAdministration(oSource).occurence.Clone;
  recordedElement := TFhirMedicationAdministration(oSource).recordedElement.Clone;
  if (TFhirMedicationAdministration(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
    FPerformerList.Assign(TFhirMedicationAdministration(oSource).FPerformerList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirMedicationAdministration(oSource).FReasonList);
  end;
  request := TFhirMedicationAdministration(oSource).request.Clone;
  if (TFhirMedicationAdministration(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList.Create;
    FDeviceList.Assign(TFhirMedicationAdministration(oSource).FDeviceList);
  end;
  if (TFhirMedicationAdministration(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationAdministration(oSource).FNoteList);
  end;
  dosage := TFhirMedicationAdministration(oSource).dosage.Clone;
  if (TFhirMedicationAdministration(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationAdministration(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationAdministration.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationAdministration;
end;

procedure TFhirMedicationAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'medication') Then
     list.add(self.link, 'medication', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'occurence[x]') or (child_name = 'occurence') Then
     list.add(self.link, 'occurence[x]', FOccurence.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosage') Then
     list.add(self.link, 'dosage', FDosage.Link);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'medication', 'CodeableReference', false, TFhirCodeableReference, FMedication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'occurence[x]', 'dateTime|Period', false, TFhirDataType, FOccurence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorded', 'dateTime', false, TFhirDateTime, FRecorded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirMedicationAdministrationPerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', true, TFhirReference, FDeviceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'dosage', 'BackboneElement', false, TFhirMedicationAdministrationDosage, FDosage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link)) {L1039};
end;

function TFhirMedicationAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, CODES_TFhirMedicationAdministrationStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'medication') then
  begin
    Medication := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurence', ['DateTime', 'Period'])) then
  begin
    Occurence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationAdministrationPerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    Dosage := propValue as TFhirMedicationAdministrationDosage {L1199};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationAdministrationPerformer) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirMedicationAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum[MedicationAdministrationStatusCodesNull], CODES_TFhirMedicationAdministrationStatusCodesEnum[MedicationAdministrationStatusCodesNull])  {L1211}
  else if (propName = 'statusReason') then result := StatusReasonList.new() {L1053}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'medication') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new() {L1053}
  else if (isMatchingName(propName, 'occurence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurence') {L1191}
  else if (propName = 'recorded') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'device') then result := DeviceList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'dosage') then result := TFhirMedicationAdministrationDosage.create() {L1203}
  else if (propName = 'eventHistory') then result := EventHistoryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication') then result := 'CodeableReference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'occurence[x]') then result := 'dateTime|Period'
  else if (propName = 'recorded') then result := 'dateTime'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosage') then result := 'BackboneElement'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value) {L1054}
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'medication') then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {L1054}
  else if (isMatchingName(propName, 'occurence', ['DateTime', 'Period'])) then OccurenceElement := nil {L1189}
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'dosage') then DosageElement := nil
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, CODES_TFhirMedicationAdministrationStatusCodesEnum, new) {L1210}
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new) {L1055}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'medication') then MedicationElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {L1055}
  else if (isMatchingName(propName, 'occurence', ['DateTime', 'Period'])) then OccurenceElement := new as TFhirDataType {L1190}
  else if (propName = 'recorded') then RecordedElement := asDateTime(new) {L1222}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'dosage') then DosageElement := new as TFhirMedicationAdministrationDosage {L1195}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'device') then DeviceList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministration.fhirType : string;
begin
  result := 'MedicationAdministration';
end;

function TFhirMedicationAdministration.Link : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Link);
end;

function TFhirMedicationAdministration.Clone : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Clone);
end;

function TFhirMedicationAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministration)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministration(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(occurenceElement, o.occurenceElement, true) and compareDeep(recordedElement, o.recordedElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(deviceList, o.deviceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(dosageElement, o.dosageElement, true) and 
      compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FcategoryList) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FOccurence) and isEmptyProp(FRecorded) and isEmptyProp(FperformerList) and isEmptyProp(FreasonList) and isEmptyProp(FRequest) and isEmptyProp(FdeviceList) and isEmptyProp(FnoteList) and isEmptyProp(FDosage) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationAdministration.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationAdministration.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationAdministration.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirMedicationAdministration.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirMedicationAdministration.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirMedicationAdministration.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirMedicationAdministration.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationAdministration.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirMedicationAdministration.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationAdministration.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationAdministration.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationAdministration.GetStatusST : TFhirMedicationAdministrationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationAdministrationStatusCodesEnum(0)
  else
    result := TFhirMedicationAdministrationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationAdministrationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationAdministration.SetStatusST(value : TFhirMedicationAdministrationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum[value], CODES_TFhirMedicationAdministrationStatusCodesEnum[value]);
end;

function TFhirMedicationAdministration.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirMedicationAdministration.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

function TFhirMedicationAdministration.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirMedicationAdministration.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirMedicationAdministration.SetMedication(value : TFhirCodeableReference);
begin
  FMedication.free;
  FMedication := value; {L1134}
end;

procedure TFhirMedicationAdministration.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirMedicationAdministration.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

function TFhirMedicationAdministration.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationAdministration.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirMedicationAdministration.SetOccurence(value : TFhirDataType);
begin
  FOccurence.free;
  FOccurence := value; {L1134}
end;

procedure TFhirMedicationAdministration.SetRecorded(value : TFhirDateTime);
begin
  FRecorded.free;
  FRecorded := value; {L1134}
end;

function TFhirMedicationAdministration.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirMedicationAdministration.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirDateTime.create;
  FRecorded.value := value
end;

function TFhirMedicationAdministration.GetPerformerList : TFhirMedicationAdministrationPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
  result := FPerformerList;
end;

function TFhirMedicationAdministration.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirMedicationAdministration.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirMedicationAdministration.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirMedicationAdministration.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

function TFhirMedicationAdministration.GetDeviceList : TFhirReferenceList;
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList.Create;
  result := FDeviceList;
end;

function TFhirMedicationAdministration.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

function TFhirMedicationAdministration.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationAdministration.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationAdministration.SetDosage(value : TFhirMedicationAdministrationDosage);
begin
  FDosage.free;
  FDosage := value; {L1134}
end;

function TFhirMedicationAdministration.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationAdministration.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

procedure TFhirMedicationAdministration.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('medication');
  fields.add('subject');
  fields.add('encounter');
  fields.add('supportingInformation');
  fields.add('occurence[x]');
  fields.add('recorded');
  fields.add('performer');
  fields.add('reason');
  fields.add('request');
  fields.add('device');
  fields.add('note');
  fields.add('dosage');
  fields.add('eventHistory');
end;

function TFhirMedicationAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusReasonList.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FOccurence.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FDosage.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationAdministrationListEnumerator }

constructor TFhirMedicationAdministrationListEnumerator.Create(list : TFhirMedicationAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationListEnumerator.GetCurrent : TFhirMedicationAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationList }

procedure TFhirMedicationAdministrationList.AddItem(value: TFhirMedicationAdministration);
begin
  assert(value.ClassName = 'TFhirMedicationAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministration');
  add(value);
end;

function TFhirMedicationAdministrationList.Append: TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationList.GetEnumerator : TFhirMedicationAdministrationListEnumerator;
begin
  result := TFhirMedicationAdministrationListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationList.Clone: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Clone);
end;

function TFhirMedicationAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationList.GetItemN(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministration;
end;
function TFhirMedicationAdministrationList.IndexOf(value: TFhirMedicationAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationList.Insert(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.InsertItem(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationList.Item(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.Link: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Link);
end;

procedure TFhirMedicationAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  FhirMedicationAdministrations[index] := value;
end;

procedure TFhirMedicationAdministrationList.SetItemN(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
{ TFhirMedicationDispensePerformer }

constructor TFhirMedicationDispensePerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispensePerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirMedicationDispensePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirMedicationDispensePerformer(oSource).function_.Clone;
  actor := TFhirMedicationDispensePerformer(oSource).actor.Clone;
end;

procedure TFhirMedicationDispensePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirMedicationDispensePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirMedicationDispensePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispensePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationDispensePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispensePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispensePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispensePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispensePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispensePerformer.fhirType : string;
begin
  result := 'MedicationDispense.performer';
end;

function TFhirMedicationDispensePerformer.Link : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Link);
end;

function TFhirMedicationDispensePerformer.Clone : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Clone);
end;

function TFhirMedicationDispensePerformer.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispensePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispensePerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationDispensePerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirMedicationDispensePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirMedicationDispensePerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirMedicationDispensePerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirMedicationDispensePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirMedicationDispensePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirMedicationDispensePerformerListEnumerator }

constructor TFhirMedicationDispensePerformerListEnumerator.Create(list : TFhirMedicationDispensePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispensePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispensePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispensePerformerListEnumerator.GetCurrent : TFhirMedicationDispensePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispensePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispensePerformerList }

procedure TFhirMedicationDispensePerformerList.AddItem(value: TFhirMedicationDispensePerformer);
begin
  assert(value.ClassName = 'TFhirMedicationDispensePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispensePerformer');
  add(value);
end;

function TFhirMedicationDispensePerformerList.Append: TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispensePerformerList.GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;
begin
  result := TFhirMedicationDispensePerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationDispensePerformerList.Clone: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Clone);
end;

function TFhirMedicationDispensePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispensePerformerList.GetItemN(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispensePerformer;
end;
function TFhirMedicationDispensePerformerList.IndexOf(value: TFhirMedicationDispensePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispensePerformerList.Insert(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.InsertItem(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispensePerformerList.Item(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.Link: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Link);
end;

procedure TFhirMedicationDispensePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispensePerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  FhirMedicationDispensePerformers[index] := value;
end;

procedure TFhirMedicationDispensePerformerList.SetItemN(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FWasSubstituted.free;
  FType_.free;
  FReasonList.Free;
  FResponsibleParty.free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  wasSubstitutedElement := TFhirMedicationDispenseSubstitution(oSource).wasSubstitutedElement.Clone;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  if (TFhirMedicationDispenseSubstitution(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  end;
  responsibleParty := TFhirMedicationDispenseSubstitution(oSource).responsibleParty.Clone;
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'wasSubstituted') Then
     list.add(self.link, 'wasSubstituted', FWasSubstituted.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'responsibleParty') Then
     list.add(self.link, 'responsibleParty', FResponsibleParty.Link);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'wasSubstituted', 'boolean', false, TFhirBoolean, FWasSubstituted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Reference', false, TFhirReference, FResponsibleParty.Link)); {L1172}
end;

function TFhirMedicationDispenseSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then
  begin
    WasSubstitutedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'responsibleParty') then
  begin
    ResponsibleParty := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispenseSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirMedicationDispenseSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'responsibleParty') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispenseSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'wasSubstituted') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'responsibleParty') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispenseSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'responsibleParty') then ResponsiblePartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispenseSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := asBoolean(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'responsibleParty') then ResponsiblePartyElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispenseSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispenseSubstitution.fhirType : string;
begin
  result := 'MedicationDispense.substitution';
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

function TFhirMedicationDispenseSubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispenseSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispenseSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationDispenseSubstitution(other);
    result := compareDeep(wasSubstitutedElement, o.wasSubstitutedElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(responsiblePartyElement, o.responsiblePartyElement, true);
  end;
end;

function TFhirMedicationDispenseSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWasSubstituted) and isEmptyProp(FType_) and isEmptyProp(FreasonList) and isEmptyProp(FResponsibleParty);
end;

procedure TFhirMedicationDispenseSubstitution.SetWasSubstituted(value : TFhirBoolean);
begin
  FWasSubstituted.free;
  FWasSubstituted := value; {L1134}
end;

function TFhirMedicationDispenseSubstitution.GetWasSubstitutedST : Boolean;
begin
  if FWasSubstituted = nil then
    result := false
  else
    result := FWasSubstituted.value;
end;

procedure TFhirMedicationDispenseSubstitution.SetWasSubstitutedST(value : Boolean);
begin
  if FWasSubstituted = nil then
    FWasSubstituted := TFhirBoolean.create;
  FWasSubstituted.value := value
end;

procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirMedicationDispenseSubstitution.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirMedicationDispenseSubstitution.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirMedicationDispenseSubstitution.SetResponsibleParty(value : TFhirReference);
begin
  FResponsibleParty.free;
  FResponsibleParty := value; {L1134}
end;

procedure TFhirMedicationDispenseSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('wasSubstituted');
  fields.add('type');
  fields.add('reason');
  fields.add('responsibleParty');
end;

function TFhirMedicationDispenseSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FWasSubstituted.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FResponsibleParty.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionListEnumerator }

constructor TFhirMedicationDispenseSubstitutionListEnumerator.Create(list : TFhirMedicationDispenseSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.GetCurrent : TFhirMedicationDispenseSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionList }

procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;

function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
begin
  result := TFhirMedicationDispenseSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispenseSubstitution;
end;
function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispense }

constructor TFhirMedicationDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispense.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FMedication.free;
  FSubject.free;
  FEncounter.free;
  FSupportingInformationList.Free;
  FPerformerList.Free;
  FLocation.free;
  FAuthorizingPrescriptionList.Free;
  FType_.free;
  FQuantity.free;
  FDaysSupply.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FNoteList.Free;
  FRenderedDosageInstruction.free;
  FDosageInstructionList.Free;
  FSubstitution.free;
  FDetectedIssueList.Free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationDispense.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationDispense(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationDispense(oSource).FIdentifierList);
  end;
  if (TFhirMedicationDispense(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationDispense(oSource).FBasedOnList);
  end;
  if (TFhirMedicationDispense(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationDispense(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationDispense(oSource).statusElement.Clone;
  statusReason := TFhirMedicationDispense(oSource).statusReason.Clone;
  if (TFhirMedicationDispense(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirMedicationDispense(oSource).FCategoryList);
  end;
  medication := TFhirMedicationDispense(oSource).medication.Clone;
  subject := TFhirMedicationDispense(oSource).subject.Clone;
  encounter := TFhirMedicationDispense(oSource).encounter.Clone;
  if (TFhirMedicationDispense(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationDispense(oSource).FSupportingInformationList);
  end;
  if (TFhirMedicationDispense(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationDispensePerformerList.Create;
    FPerformerList.Assign(TFhirMedicationDispense(oSource).FPerformerList);
  end;
  location := TFhirMedicationDispense(oSource).location.Clone;
  if (TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList = nil) then
  begin
    FAuthorizingPrescriptionList.free;
    FAuthorizingPrescriptionList := nil;
  end
  else
  begin
    if FAuthorizingPrescriptionList = nil then
      FAuthorizingPrescriptionList := TFhirReferenceList.Create;
    FAuthorizingPrescriptionList.Assign(TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList);
  end;
  type_ := TFhirMedicationDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispense(oSource).quantity.Clone;
  daysSupply := TFhirMedicationDispense(oSource).daysSupply.Clone;
  whenPreparedElement := TFhirMedicationDispense(oSource).whenPreparedElement.Clone;
  whenHandedOverElement := TFhirMedicationDispense(oSource).whenHandedOverElement.Clone;
  destination := TFhirMedicationDispense(oSource).destination.Clone;
  if (TFhirMedicationDispense(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList.Create;
    FReceiverList.Assign(TFhirMedicationDispense(oSource).FReceiverList);
  end;
  if (TFhirMedicationDispense(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationDispense(oSource).FNoteList);
  end;
  renderedDosageInstructionElement := TFhirMedicationDispense(oSource).renderedDosageInstructionElement.Clone;
  if (TFhirMedicationDispense(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationDispense(oSource).FDosageInstructionList);
  end;
  substitution := TFhirMedicationDispense(oSource).substitution.Clone;
  if (TFhirMedicationDispense(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList.Create;
    FDetectedIssueList.Assign(TFhirMedicationDispense(oSource).FDetectedIssueList);
  end;
  if (TFhirMedicationDispense(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationDispense(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationDispense.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationDispense;
end;

procedure TFhirMedicationDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'medication') Then
     list.add(self.link, 'medication', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'authorizingPrescription') Then
    list.addAll(self, 'authorizingPrescription', FAuthorizingPrescriptionList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'daysSupply') Then
     list.add(self.link, 'daysSupply', FDaysSupply.Link);
  if (child_name = 'whenPrepared') Then
     list.add(self.link, 'whenPrepared', FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(self.link, 'whenHandedOver', FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'renderedDosageInstruction') Then
     list.add(self.link, 'renderedDosageInstruction', FRenderedDosageInstruction.Link);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableReference', false, TFhirCodeableReference, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'medication', 'CodeableReference', false, TFhirCodeableReference, FMedication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirMedicationDispensePerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authorizingPrescription', 'Reference', true, TFhirReference, FAuthorizingPrescriptionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'daysSupply', 'Quantity', false, TFhirQuantity, FDaysSupply.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', false, TFhirDateTime, FWhenPrepared.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', false, TFhirDateTime, FWhenHandedOver.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', true, TFhirReference, FReceiverList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'renderedDosageInstruction', 'string', false, TFhirString, FRenderedDosageInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', false, TFhirMedicationDispenseSubstitution, FSubstitution.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference', true, TFhirReference, FDetectedIssueList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link)) {L1039};
end;

function TFhirMedicationDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, CODES_TFhirMedicationDispenseStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'medication') then
  begin
    Medication := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationDispensePerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'authorizingPrescription') then
  begin
    AuthorizingPrescriptionList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'daysSupply') then
  begin
    DaysSupply := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'whenPrepared') then
  begin
    WhenPreparedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'whenHandedOver') then
  begin
    WhenHandedOverElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'renderedDosageInstruction') then
  begin
    RenderedDosageInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage) {L1048};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationDispenseSubstitution {L1199};
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationDispensePerformer) {L1049}
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage) {L1049}
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirMedicationDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum[MedicationDispenseStatusCodesNull], CODES_TFhirMedicationDispenseStatusCodesEnum[MedicationDispenseStatusCodesNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'medication') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new() {L1053}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'authorizingPrescription') then result := AuthorizingPrescriptionList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'daysSupply') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'whenPrepared') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'whenHandedOver') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'destination') then result := TFhirReference.create() {L1203}
  else if (propName = 'receiver') then result := ReceiverList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'renderedDosageInstruction') then result := TFhirString.create() {L1223}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new() {L1053}
  else if (propName = 'substitution') then result := TFhirMedicationDispenseSubstitution.create() {L1203}
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new() {L1053}
  else if (propName = 'eventHistory') then result := EventHistoryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableReference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication') then result := 'CodeableReference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'authorizingPrescription') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'daysSupply') then result := 'Quantity'
  else if (propName = 'whenPrepared') then result := 'dateTime'
  else if (propName = 'whenHandedOver') then result := 'dateTime'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'renderedDosageInstruction') then result := 'string'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'medication') then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {L1054}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'authorizingPrescription') then deletePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'daysSupply') then DaysSupplyElement := nil
  else if (propName = 'whenPrepared') then WhenPreparedElement := nil
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := nil
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {L1054}
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value) {L1054}
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, CODES_TFhirMedicationDispenseStatusCodesEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'medication') then MedicationElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {L1055}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'authorizingPrescription') then replacePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'daysSupply') then DaysSupplyElement := new as TFhirQuantity {L1195}
  else if (propName = 'whenPrepared') then WhenPreparedElement := asDateTime(new) {L1222}
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := asDateTime(new) {L1222}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference {L1195}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := asString(new) {L1222}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {L1055}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationDispenseSubstitution {L1195}
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new) {L1055}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispense.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.move(source, destination) {L1050}
  else if (propName = 'receiver') then ReceiverList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination) {L1050}
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination) {L1050}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispense.fhirType : string;
begin
  result := 'MedicationDispense';
end;

function TFhirMedicationDispense.Link : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Link);
end;

function TFhirMedicationDispense.Clone : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Clone);
end;

function TFhirMedicationDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationDispense(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(authorizingPrescriptionList, o.authorizingPrescriptionList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(daysSupplyElement, o.daysSupplyElement, true) and compareDeep(whenPreparedElement, o.whenPreparedElement, true) and 
      compareDeep(whenHandedOverElement, o.whenHandedOverElement, true) and compareDeep(destinationElement, o.destinationElement, true) and 
      compareDeep(receiverList, o.receiverList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(renderedDosageInstructionElement, o.renderedDosageInstructionElement, true) and 
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(substitutionElement, o.substitutionElement, true) and 
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FauthorizingPrescriptionList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FDaysSupply) and isEmptyProp(FWhenPrepared) and isEmptyProp(FWhenHandedOver) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList) and isEmptyProp(FnoteList) and isEmptyProp(FRenderedDosageInstruction) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FSubstitution) and isEmptyProp(FdetectedIssueList) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationDispense.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationDispense.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationDispense.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationDispense.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirMedicationDispense.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationDispense.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationDispense.GetStatusST : TFhirMedicationDispenseStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatusCodesEnum(0)
  else
    result := TFhirMedicationDispenseStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationDispenseStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationDispense.SetStatusST(value : TFhirMedicationDispenseStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum[value], CODES_TFhirMedicationDispenseStatusCodesEnum[value]);
end;

procedure TFhirMedicationDispense.SetStatusReason(value : TFhirCodeableReference);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

function TFhirMedicationDispense.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirMedicationDispense.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirMedicationDispense.SetMedication(value : TFhirCodeableReference);
begin
  FMedication.free;
  FMedication := value; {L1134}
end;

procedure TFhirMedicationDispense.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirMedicationDispense.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

function TFhirMedicationDispense.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationDispense.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

function TFhirMedicationDispense.GetPerformerList : TFhirMedicationDispensePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationDispensePerformerList.Create;
  result := FPerformerList;
end;

function TFhirMedicationDispense.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirMedicationDispense.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

function TFhirMedicationDispense.GetAuthorizingPrescriptionList : TFhirReferenceList;
begin
  if FAuthorizingPrescriptionList = nil then
    FAuthorizingPrescriptionList := TFhirReferenceList.Create;
  result := FAuthorizingPrescriptionList;
end;

function TFhirMedicationDispense.GetHasAuthorizingPrescriptionList : boolean;
begin
  result := (FAuthorizingPrescriptionList <> nil) and (FAuthorizingPrescriptionList.count > 0);
end;

procedure TFhirMedicationDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMedicationDispense.SetDaysSupply(value : TFhirQuantity);
begin
  FDaysSupply.free;
  FDaysSupply := value; {L1134}
end;

procedure TFhirMedicationDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value; {L1134}
end;

function TFhirMedicationDispense.GetWhenPreparedST : TFslDateTime;
begin
  if FWhenPrepared = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenPrepared.value;
end;

procedure TFhirMedicationDispense.SetWhenPreparedST(value : TFslDateTime);
begin
  if FWhenPrepared = nil then
    FWhenPrepared := TFhirDateTime.create;
  FWhenPrepared.value := value
end;

procedure TFhirMedicationDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value; {L1134}
end;

function TFhirMedicationDispense.GetWhenHandedOverST : TFslDateTime;
begin
  if FWhenHandedOver = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenHandedOver.value;
end;

procedure TFhirMedicationDispense.SetWhenHandedOverST(value : TFslDateTime);
begin
  if FWhenHandedOver = nil then
    FWhenHandedOver := TFhirDateTime.create;
  FWhenHandedOver.value := value
end;

procedure TFhirMedicationDispense.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value; {L1134}
end;

function TFhirMedicationDispense.GetReceiverList : TFhirReferenceList;
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList.Create;
  result := FReceiverList;
end;

function TFhirMedicationDispense.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

function TFhirMedicationDispense.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationDispense.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationDispense.SetRenderedDosageInstruction(value : TFhirString);
begin
  FRenderedDosageInstruction.free;
  FRenderedDosageInstruction := value; {L1134}
end;

function TFhirMedicationDispense.GetRenderedDosageInstructionST : String;
begin
  if FRenderedDosageInstruction = nil then
    result := ''
  else
    result := FRenderedDosageInstruction.value;
end;

procedure TFhirMedicationDispense.SetRenderedDosageInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FRenderedDosageInstruction = nil then
      FRenderedDosageInstruction := TFhirString.create;
    FRenderedDosageInstruction.value := value
  end
  else if FRenderedDosageInstruction <> nil then
    FRenderedDosageInstruction.value := '';
end;

function TFhirMedicationDispense.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

function TFhirMedicationDispense.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

procedure TFhirMedicationDispense.SetSubstitution(value : TFhirMedicationDispenseSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value; {L1134}
end;

function TFhirMedicationDispense.GetDetectedIssueList : TFhirReferenceList;
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList.Create;
  result := FDetectedIssueList;
end;

function TFhirMedicationDispense.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

function TFhirMedicationDispense.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationDispense.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

procedure TFhirMedicationDispense.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('medication');
  fields.add('subject');
  fields.add('encounter');
  fields.add('supportingInformation');
  fields.add('performer');
  fields.add('location');
  fields.add('authorizingPrescription');
  fields.add('type');
  fields.add('quantity');
  fields.add('daysSupply');
  fields.add('whenPrepared');
  fields.add('whenHandedOver');
  fields.add('destination');
  fields.add('receiver');
  fields.add('note');
  fields.add('renderedDosageInstruction');
  fields.add('dosageInstruction');
  fields.add('substitution');
  fields.add('detectedIssue');
  fields.add('eventHistory');
end;

function TFhirMedicationDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FauthorizingPrescriptionList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDaysSupply.sizeInBytes);
  inc(result, FWhenPrepared.sizeInBytes);
  inc(result, FWhenHandedOver.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FRenderedDosageInstruction.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FdetectedIssueList.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationDispenseListEnumerator }

constructor TFhirMedicationDispenseListEnumerator.Create(list : TFhirMedicationDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseListEnumerator.GetCurrent : TFhirMedicationDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseList }

procedure TFhirMedicationDispenseList.AddItem(value: TFhirMedicationDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispense');
  add(value);
end;

function TFhirMedicationDispenseList.Append: TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseList.GetEnumerator : TFhirMedicationDispenseListEnumerator;
begin
  result := TFhirMedicationDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseList.Clone: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseList.GetItemN(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispense;
end;
function TFhirMedicationDispenseList.IndexOf(value: TFhirMedicationDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseList.Insert(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseList.Item(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.Link: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  FhirMedicationDispenses[index] := value;
end;

procedure TFhirMedicationDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
{ TFhirMedicationRequestDispenseRequest }

constructor TFhirMedicationRequestDispenseRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestDispenseRequest.Destroy;
begin
  FInitialFill.free;
  FDispenseInterval.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  FDispenser.free;
  inherited;
end;

procedure TFhirMedicationRequestDispenseRequest.Assign(oSource : TFslObject);
begin
  inherited;
  initialFill := TFhirMedicationRequestDispenseRequest(oSource).initialFill.Clone;
  dispenseInterval := TFhirMedicationRequestDispenseRequest(oSource).dispenseInterval.Clone;
  validityPeriod := TFhirMedicationRequestDispenseRequest(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowedElement := TFhirMedicationRequestDispenseRequest(oSource).numberOfRepeatsAllowedElement.Clone;
  quantity := TFhirMedicationRequestDispenseRequest(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationRequestDispenseRequest(oSource).expectedSupplyDuration.Clone;
  dispenser := TFhirMedicationRequestDispenseRequest(oSource).dispenser.Clone;
end;

procedure TFhirMedicationRequestDispenseRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'initialFill') Then
     list.add(self.link, 'initialFill', FInitialFill.Link);
  if (child_name = 'dispenseInterval') Then
     list.add(self.link, 'dispenseInterval', FDispenseInterval.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(self.link, 'numberOfRepeatsAllowed', FNumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(self.link, 'expectedSupplyDuration', FExpectedSupplyDuration.Link);
  if (child_name = 'dispenser') Then
     list.add(self.link, 'dispenser', FDispenser.Link);
end;

procedure TFhirMedicationRequestDispenseRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'initialFill', 'BackboneElement', false, TFhirMedicationRequestDispenseRequestInitialFill, FInitialFill.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dispenseInterval', 'Duration', false, TFhirDuration, FDispenseInterval.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfRepeatsAllowed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', false, TFhirDuration, FExpectedSupplyDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dispenser', 'Reference', false, TFhirReference, FDispenser.Link)); {L1172}
end;

function TFhirMedicationRequestDispenseRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'initialFill') then
  begin
    InitialFill := propValue as TFhirMedicationRequestDispenseRequestInitialFill {L1199};
    result := propValue;
  end
  else if (propName = 'dispenseInterval') then
  begin
    DispenseInterval := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'numberOfRepeatsAllowed') then
  begin
    NumberOfRepeatsAllowedElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'expectedSupplyDuration') then
  begin
    ExpectedSupplyDuration := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'dispenser') then
  begin
    Dispenser := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestDispenseRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestDispenseRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'initialFill') then result := TFhirMedicationRequestDispenseRequestInitialFill.create() {L1203}
  else if (propName = 'dispenseInterval') then result := TFhirDuration.create() {L1203}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'numberOfRepeatsAllowed') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'expectedSupplyDuration') then result := TFhirDuration.create() {L1203}
  else if (propName = 'dispenser') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestDispenseRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'initialFill') then result := 'BackboneElement'
  else if (propName = 'dispenseInterval') then result := 'Duration'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'numberOfRepeatsAllowed') then result := 'unsignedInt'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'expectedSupplyDuration') then result := 'Duration'
  else if (propName = 'dispenser') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestDispenseRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'initialFill') then InitialFillElement := nil
  else if (propName = 'dispenseInterval') then DispenseIntervalElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := nil
  else if (propName = 'dispenser') then DispenserElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestDispenseRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'initialFill') then InitialFillElement := new as TFhirMedicationRequestDispenseRequestInitialFill {L1195}
  else if (propName = 'dispenseInterval') then DispenseIntervalElement := new as TFhirDuration {L1195}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := asUnsignedInt(new) {L1222}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := new as TFhirDuration {L1195}
  else if (propName = 'dispenser') then DispenserElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestDispenseRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestDispenseRequest.fhirType : string;
begin
  result := 'MedicationRequest.dispenseRequest';
end;

function TFhirMedicationRequestDispenseRequest.Link : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Link);
end;

function TFhirMedicationRequestDispenseRequest.Clone : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequest.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestDispenseRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestDispenseRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestDispenseRequest(other);
    result := compareDeep(initialFillElement, o.initialFillElement, true) and compareDeep(dispenseIntervalElement, o.dispenseIntervalElement, true) and 
      compareDeep(validityPeriodElement, o.validityPeriodElement, true) and compareDeep(numberOfRepeatsAllowedElement, o.numberOfRepeatsAllowedElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(expectedSupplyDurationElement, o.expectedSupplyDurationElement, true) and 
      compareDeep(dispenserElement, o.dispenserElement, true);
  end;
end;

function TFhirMedicationRequestDispenseRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInitialFill) and isEmptyProp(FDispenseInterval) and isEmptyProp(FValidityPeriod) and isEmptyProp(FNumberOfRepeatsAllowed) and isEmptyProp(FQuantity) and isEmptyProp(FExpectedSupplyDuration) and isEmptyProp(FDispenser);
end;

procedure TFhirMedicationRequestDispenseRequest.SetInitialFill(value : TFhirMedicationRequestDispenseRequestInitialFill);
begin
  FInitialFill.free;
  FInitialFill := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.SetDispenseInterval(value : TFhirDuration);
begin
  FDispenseInterval.free;
  FDispenseInterval := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowed(value : TFhirUnsignedInt);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value; {L1134}
end;

function TFhirMedicationRequestDispenseRequest.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := FNumberOfRepeatsAllowed.value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirUnsignedInt.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

procedure TFhirMedicationRequestDispenseRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.SetExpectedSupplyDuration(value : TFhirDuration);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.SetDispenser(value : TFhirReference);
begin
  FDispenser.free;
  FDispenser := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('initialFill');
  fields.add('dispenseInterval');
  fields.add('validityPeriod');
  fields.add('numberOfRepeatsAllowed');
  fields.add('quantity');
  fields.add('expectedSupplyDuration');
  fields.add('dispenser');
end;

function TFhirMedicationRequestDispenseRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FInitialFill.sizeInBytes);
  inc(result, FDispenseInterval.sizeInBytes);
  inc(result, FValidityPeriod.sizeInBytes);
  inc(result, FNumberOfRepeatsAllowed.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FExpectedSupplyDuration.sizeInBytes);
  inc(result, FDispenser.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestListEnumerator }

constructor TFhirMedicationRequestDispenseRequestListEnumerator.Create(list : TFhirMedicationRequestDispenseRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestDispenseRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.GetCurrent : TFhirMedicationRequestDispenseRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestList }

procedure TFhirMedicationRequestDispenseRequestList.AddItem(value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value.ClassName = 'TFhirMedicationRequestDispenseRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestDispenseRequest');
  add(value);
end;

function TFhirMedicationRequestDispenseRequestList.Append: TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestDispenseRequestList.GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;
begin
  result := TFhirMedicationRequestDispenseRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestDispenseRequestList.Clone: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestDispenseRequestList.GetItemN(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestDispenseRequest;
end;
function TFhirMedicationRequestDispenseRequestList.IndexOf(value: TFhirMedicationRequestDispenseRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestDispenseRequestList.Insert(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.InsertItem(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestDispenseRequestList.Item(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.Link: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Link);
end;

procedure TFhirMedicationRequestDispenseRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  FhirMedicationRequestDispenseRequests[index] := value;
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemN(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestDispenseRequestInitialFill }

constructor TFhirMedicationRequestDispenseRequestInitialFill.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestDispenseRequestInitialFill.Destroy;
begin
  FQuantity.free;
  FDuration.free;
  inherited;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationRequestDispenseRequestInitialFill(oSource).quantity.Clone;
  duration := TFhirMedicationRequestDispenseRequestInitialFill(oSource).duration.Clone;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'duration', 'Duration', false, TFhirDuration, FDuration.Link)); {L1172}
end;

function TFhirMedicationRequestDispenseRequestInitialFill.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestDispenseRequestInitialFill.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'duration') then result := TFhirDuration.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'duration') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'duration') then DurationElement := new as TFhirDuration {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.fhirType : string;
begin
  result := 'MedicationRequest.dispenseRequest.initialFill';
end;

function TFhirMedicationRequestDispenseRequestInitialFill.Link : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(inherited Link);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.Clone : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestDispenseRequestInitialFill)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestDispenseRequestInitialFill(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirMedicationRequestDispenseRequestInitialFill.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FDuration);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.SetDuration(value : TFhirDuration);
begin
  FDuration.free;
  FDuration := value; {L1134}
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('duration');
end;

function TFhirMedicationRequestDispenseRequestInitialFill.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestInitialFillListEnumerator }

constructor TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Create(list : TFhirMedicationRequestDispenseRequestInitialFillList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.GetCurrent : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestInitialFillList }

procedure TFhirMedicationRequestDispenseRequestInitialFillList.AddItem(value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value.ClassName = 'TFhirMedicationRequestDispenseRequestInitialFill', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestDispenseRequestInitialFill');
  add(value);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Append: TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.GetEnumerator : TFhirMedicationRequestDispenseRequestInitialFillListEnumerator;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Clone: TFhirMedicationRequestDispenseRequestInitialFillList;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillList(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.GetItemN(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill;
end;
function TFhirMedicationRequestDispenseRequestInitialFillList.IndexOf(value: TFhirMedicationRequestDispenseRequestInitialFill): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Insert(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.InsertItem(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Item(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Link: TFhirMedicationRequestDispenseRequestInitialFillList;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillList(inherited Link);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  FhirMedicationRequestDispenseRequestInitialFills[index] := value;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.SetItemN(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestSubstitution }

constructor TFhirMedicationRequestSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestSubstitution.Destroy;
begin
  FAllowed.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationRequestSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  allowed := TFhirMedicationRequestSubstitution(oSource).allowed.Clone;
  reason := TFhirMedicationRequestSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationRequestSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirMedicationRequestSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAllowed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link)); {L1172}
end;

function TFhirMedicationRequestSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then
  begin
    Allowed := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Allowed') {L1191}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'allowed[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then AllowedElement := nil {L1189}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then AllowedElement := new as TFhirDataType {L1190}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestSubstitution.fhirType : string;
begin
  result := 'MedicationRequest.substitution';
end;

function TFhirMedicationRequestSubstitution.Link : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Link);
end;

function TFhirMedicationRequestSubstitution.Clone : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Clone);
end;

function TFhirMedicationRequestSubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestSubstitution(other);
    result := compareDeep(allowedElement, o.allowedElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirMedicationRequestSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAllowed) and isEmptyProp(FReason);
end;

procedure TFhirMedicationRequestSubstitution.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value; {L1134}
end;

procedure TFhirMedicationRequestSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value; {L1134}
end;

procedure TFhirMedicationRequestSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('allowed[x]');
  fields.add('reason');
end;

function TFhirMedicationRequestSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAllowed.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirMedicationRequestSubstitutionListEnumerator }

constructor TFhirMedicationRequestSubstitutionListEnumerator.Create(list : TFhirMedicationRequestSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.GetCurrent : TFhirMedicationRequestSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestSubstitutionList }

procedure TFhirMedicationRequestSubstitutionList.AddItem(value: TFhirMedicationRequestSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationRequestSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestSubstitution');
  add(value);
end;

function TFhirMedicationRequestSubstitutionList.Append: TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestSubstitutionList.GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;
begin
  result := TFhirMedicationRequestSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestSubstitutionList.Clone: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Clone);
end;

function TFhirMedicationRequestSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestSubstitutionList.GetItemN(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestSubstitution;
end;
function TFhirMedicationRequestSubstitutionList.IndexOf(value: TFhirMedicationRequestSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestSubstitutionList.Insert(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestSubstitutionList.Item(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.Link: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Link);
end;

procedure TFhirMedicationRequestSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  FhirMedicationRequestSubstitutions[index] := value;
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequest }

constructor TFhirMedicationRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusReason.free;
  FIntent.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FReported.free;
  FInformationSource.free;
  FMedication.free;
  FSubject.free;
  FEncounter.free;
  FSupportingInformationList.Free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformer.free;
  FPerformerType.free;
  FRecorder.free;
  FReasonList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FCourseOfTherapyType.free;
  FInsuranceList.Free;
  FNoteList.Free;
  FRenderedDosageInstruction.free;
  FDosageInstructionList.Free;
  FDispenseRequest.free;
  FSubstitution.free;
  FPriorPrescription.free;
  FDetectedIssueList.Free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirMedicationRequest(oSource).statusElement.Clone;
  statusReason := TFhirMedicationRequest(oSource).statusReason.Clone;
  intentElement := TFhirMedicationRequest(oSource).intentElement.Clone;
  if (TFhirMedicationRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirMedicationRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirMedicationRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirMedicationRequest(oSource).doNotPerformElement.Clone;
  reportedElement := TFhirMedicationRequest(oSource).reportedElement.Clone;
  informationSource := TFhirMedicationRequest(oSource).informationSource.Clone;
  medication := TFhirMedicationRequest(oSource).medication.Clone;
  subject := TFhirMedicationRequest(oSource).subject.Clone;
  encounter := TFhirMedicationRequest(oSource).encounter.Clone;
  if (TFhirMedicationRequest(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationRequest(oSource).FSupportingInformationList);
  end;
  authoredOnElement := TFhirMedicationRequest(oSource).authoredOnElement.Clone;
  requester := TFhirMedicationRequest(oSource).requester.Clone;
  performer := TFhirMedicationRequest(oSource).performer.Clone;
  performerType := TFhirMedicationRequest(oSource).performerType.Clone;
  recorder := TFhirMedicationRequest(oSource).recorder.Clone;
  if (TFhirMedicationRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirMedicationRequest(oSource).FReasonList);
  end;
  if (TFhirMedicationRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirMedicationRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirMedicationRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirMedicationRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirMedicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationRequest(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirMedicationRequest(oSource).groupIdentifier.Clone;
  courseOfTherapyType := TFhirMedicationRequest(oSource).courseOfTherapyType.Clone;
  if (TFhirMedicationRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirMedicationRequest(oSource).FInsuranceList);
  end;
  if (TFhirMedicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationRequest(oSource).FNoteList);
  end;
  renderedDosageInstructionElement := TFhirMedicationRequest(oSource).renderedDosageInstructionElement.Clone;
  if (TFhirMedicationRequest(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationRequest(oSource).FDosageInstructionList);
  end;
  dispenseRequest := TFhirMedicationRequest(oSource).dispenseRequest.Clone;
  substitution := TFhirMedicationRequest(oSource).substitution.Clone;
  priorPrescription := TFhirMedicationRequest(oSource).priorPrescription.Clone;
  if (TFhirMedicationRequest(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList.Create;
    FDetectedIssueList.Assign(TFhirMedicationRequest(oSource).FDetectedIssueList);
  end;
  if (TFhirMedicationRequest(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationRequest(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationRequest;
end;

procedure TFhirMedicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'medication') Then
     list.add(self.link, 'medication', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'courseOfTherapyType') Then
     list.add(self.link, 'courseOfTherapyType', FCourseOfTherapyType.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'renderedDosageInstruction') Then
     list.add(self.link, 'renderedDosageInstruction', FRenderedDosageInstruction.Link);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'dispenseRequest') Then
     list.add(self.link, 'dispenseRequest', FDispenseRequest.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'priorPrescription') Then
     list.add(self.link, 'priorPrescription', FPriorPrescription.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', false, TFhirReference, FInformationSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'medication', 'CodeableReference', false, TFhirCodeableReference, FMedication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'courseOfTherapyType', 'CodeableConcept', false, TFhirCodeableConcept, FCourseOfTherapyType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'renderedDosageInstruction', 'string', false, TFhirString, FRenderedDosageInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'dispenseRequest', 'BackboneElement', false, TFhirMedicationRequestDispenseRequest, FDispenseRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', false, TFhirMedicationRequestSubstitution, FSubstitution.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priorPrescription', 'Reference', false, TFhirReference, FPriorPrescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference', true, TFhirReference, FDetectedIssueList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link)) {L1039};
end;

function TFhirMedicationRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationrequestStatusEnum, CODES_TFhirMedicationrequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'medication') then
  begin
    Medication := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'courseOfTherapyType') then
  begin
    CourseOfTherapyType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'renderedDosageInstruction') then
  begin
    RenderedDosageInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage) {L1048};
    result := propValue;
  end
  else if (propName = 'dispenseRequest') then
  begin
    DispenseRequest := propValue as TFhirMedicationRequestDispenseRequest {L1199};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationRequestSubstitution {L1199};
    result := propValue;
  end
  else if (propName = 'priorPrescription') then
  begin
    PriorPrescription := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage) {L1049}
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirMedicationRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationrequestStatusEnum[MedicationrequestStatusNull], CODES_TFhirMedicationrequestStatusEnum[MedicationrequestStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestIntentEnum[MedicationRequestIntentNull], CODES_TFhirMedicationRequestIntentEnum[MedicationRequestIntentNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'reported') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'informationSource') then result := TFhirReference.create() {L1203}
  else if (propName = 'medication') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new() {L1053}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requester') then result := TFhirReference.create() {L1203}
  else if (propName = 'performer') then result := TFhirReference.create() {L1203}
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'recorder') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'courseOfTherapyType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'renderedDosageInstruction') then result := TFhirString.create() {L1223}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new() {L1053}
  else if (propName = 'dispenseRequest') then result := TFhirMedicationRequestDispenseRequest.create() {L1203}
  else if (propName = 'substitution') then result := TFhirMedicationRequestSubstitution.create() {L1203}
  else if (propName = 'priorPrescription') then result := TFhirReference.create() {L1203}
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new() {L1053}
  else if (propName = 'eventHistory') then result := EventHistoryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'reported') then result := 'boolean'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'medication') then result := 'CodeableReference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'courseOfTherapyType') then result := 'CodeableConcept'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'renderedDosageInstruction') then result := 'string'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'dispenseRequest') then result := 'BackboneElement'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'priorPrescription') then result := 'Reference'
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'medication') then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {L1054}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'courseOfTherapyType') then CourseOfTherapyTypeElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := nil
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {L1054}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value) {L1054}
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationrequestStatusEnum, CODES_TFhirMedicationrequestStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new) {L1222}
  else if (propName = 'reported') then ReportedElement := asBoolean(new) {L1222}
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference {L1195}
  else if (propName = 'medication') then MedicationElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {L1055}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new) {L1222}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference {L1195}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference {L1195}
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'courseOfTherapyType') then CourseOfTherapyTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := asString(new) {L1222}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {L1055}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := new as TFhirMedicationRequestDispenseRequest {L1195}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationRequestSubstitution {L1195}
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := new as TFhirReference {L1195}
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new) {L1055}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination) {L1050}
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination) {L1050}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequest.fhirType : string;
begin
  result := 'MedicationRequest';
end;

function TFhirMedicationRequest.Link : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Link);
end;

function TFhirMedicationRequest.Clone : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Clone);
end;

function TFhirMedicationRequest.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(reportedElement, o.reportedElement, true) and 
      compareDeep(informationSourceElement, o.informationSourceElement, true) and compareDeep(medicationElement, o.medicationElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(performerTypeElement, o.performerTypeElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(courseOfTherapyTypeElement, o.courseOfTherapyTypeElement, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(renderedDosageInstructionElement, o.renderedDosageInstructionElement, true) and 
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(dispenseRequestElement, o.dispenseRequestElement, true) and 
      compareDeep(substitutionElement, o.substitutionElement, true) and compareDeep(priorPrescriptionElement, o.priorPrescriptionElement, true) and 
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FReported) and isEmptyProp(FInformationSource) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformer) and isEmptyProp(FPerformerType) and isEmptyProp(FRecorder) and isEmptyProp(FreasonList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FCourseOfTherapyType) and isEmptyProp(FinsuranceList) and isEmptyProp(FnoteList) and isEmptyProp(FRenderedDosageInstruction) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FDispenseRequest) and isEmptyProp(FSubstitution)
       and isEmptyProp(FPriorPrescription) and isEmptyProp(FdetectedIssueList) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationRequest.GetStatusST : TFhirMedicationrequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationrequestStatusEnum(0)
  else
    result := TFhirMedicationrequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationrequestStatusEnum, FStatus.value));
end;

procedure TFhirMedicationRequest.SetStatusST(value : TFhirMedicationrequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationrequestStatusEnum[value], CODES_TFhirMedicationrequestStatusEnum[value]);
end;

procedure TFhirMedicationRequest.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

procedure TFhirMedicationRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirMedicationRequest.GetIntentST : TFhirMedicationRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirMedicationRequestIntentEnum(0)
  else
    result := TFhirMedicationRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationRequestIntentEnum, FIntent.value));
end;

procedure TFhirMedicationRequest.SetIntentST(value : TFhirMedicationRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestIntentEnum[value], CODES_TFhirMedicationRequestIntentEnum[value]);
end;

function TFhirMedicationRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirMedicationRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirMedicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirMedicationRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirMedicationRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirMedicationRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value; {L1134}
end;

function TFhirMedicationRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirMedicationRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirMedicationRequest.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value; {L1134}
end;

function TFhirMedicationRequest.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

procedure TFhirMedicationRequest.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

procedure TFhirMedicationRequest.SetInformationSource(value : TFhirReference);
begin
  FInformationSource.free;
  FInformationSource := value; {L1134}
end;

procedure TFhirMedicationRequest.SetMedication(value : TFhirCodeableReference);
begin
  FMedication.free;
  FMedication := value; {L1134}
end;

procedure TFhirMedicationRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirMedicationRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

function TFhirMedicationRequest.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationRequest.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirMedicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value; {L1134}
end;

function TFhirMedicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirMedicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirMedicationRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value; {L1134}
end;

procedure TFhirMedicationRequest.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value; {L1134}
end;

procedure TFhirMedicationRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value; {L1134}
end;

procedure TFhirMedicationRequest.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value; {L1134}
end;

function TFhirMedicationRequest.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirMedicationRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirMedicationRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirMedicationRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirMedicationRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirMedicationRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirMedicationRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirMedicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value; {L1134}
end;

procedure TFhirMedicationRequest.SetCourseOfTherapyType(value : TFhirCodeableConcept);
begin
  FCourseOfTherapyType.free;
  FCourseOfTherapyType := value; {L1134}
end;

function TFhirMedicationRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirMedicationRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirMedicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationRequest.SetRenderedDosageInstruction(value : TFhirString);
begin
  FRenderedDosageInstruction.free;
  FRenderedDosageInstruction := value; {L1134}
end;

function TFhirMedicationRequest.GetRenderedDosageInstructionST : String;
begin
  if FRenderedDosageInstruction = nil then
    result := ''
  else
    result := FRenderedDosageInstruction.value;
end;

procedure TFhirMedicationRequest.SetRenderedDosageInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FRenderedDosageInstruction = nil then
      FRenderedDosageInstruction := TFhirString.create;
    FRenderedDosageInstruction.value := value
  end
  else if FRenderedDosageInstruction <> nil then
    FRenderedDosageInstruction.value := '';
end;

function TFhirMedicationRequest.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

function TFhirMedicationRequest.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

procedure TFhirMedicationRequest.SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
begin
  FDispenseRequest.free;
  FDispenseRequest := value; {L1134}
end;

procedure TFhirMedicationRequest.SetSubstitution(value : TFhirMedicationRequestSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value; {L1134}
end;

procedure TFhirMedicationRequest.SetPriorPrescription(value : TFhirReference);
begin
  FPriorPrescription.free;
  FPriorPrescription := value; {L1134}
end;

function TFhirMedicationRequest.GetDetectedIssueList : TFhirReferenceList;
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList.Create;
  result := FDetectedIssueList;
end;

function TFhirMedicationRequest.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

function TFhirMedicationRequest.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationRequest.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

procedure TFhirMedicationRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('intent');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('reported');
  fields.add('informationSource');
  fields.add('medication');
  fields.add('subject');
  fields.add('encounter');
  fields.add('supportingInformation');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performer');
  fields.add('performerType');
  fields.add('recorder');
  fields.add('reason');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('courseOfTherapyType');
  fields.add('insurance');
  fields.add('note');
  fields.add('renderedDosageInstruction');
  fields.add('dosageInstruction');
  fields.add('dispenseRequest');
  fields.add('substitution');
  fields.add('priorPrescription');
  fields.add('detectedIssue');
  fields.add('eventHistory');
end;

function TFhirMedicationRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FReported.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FPerformerType.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FCourseOfTherapyType.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FRenderedDosageInstruction.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FDispenseRequest.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FPriorPrescription.sizeInBytes);
  inc(result, FdetectedIssueList.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationRequestListEnumerator }

constructor TFhirMedicationRequestListEnumerator.Create(list : TFhirMedicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestListEnumerator.GetCurrent : TFhirMedicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestList }

procedure TFhirMedicationRequestList.AddItem(value: TFhirMedicationRequest);
begin
  assert(value.ClassName = 'TFhirMedicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequest');
  add(value);
end;

function TFhirMedicationRequestList.Append: TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestList.GetEnumerator : TFhirMedicationRequestListEnumerator;
begin
  result := TFhirMedicationRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestList.Clone: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Clone);
end;

function TFhirMedicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestList.GetItemN(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequest;
end;
function TFhirMedicationRequestList.IndexOf(value: TFhirMedicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestList.Insert(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.InsertItem(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestList.Item(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.Link: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Link);
end;

procedure TFhirMedicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  FhirMedicationRequests[index] := value;
end;

procedure TFhirMedicationRequestList.SetItemN(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONUSAGE}
{ TFhirMedicationUsage }

constructor TFhirMedicationUsage.Create;
begin
  inherited;
end;

destructor TFhirMedicationUsage.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FCategoryList.Free;
  FMedication.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FDateAsserted.free;
  FInformationSource.free;
  FDerivedFromList.Free;
  FReasonList.Free;
  FNoteList.Free;
  FRenderedDosageInstruction.free;
  FDosageList.Free;
  FTakenAsOrdered.free;
  inherited;
end;

procedure TFhirMedicationUsage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationUsage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationUsage(oSource).FIdentifierList);
  end;
  if (TFhirMedicationUsage(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationUsage(oSource).FBasedOnList);
  end;
  if (TFhirMedicationUsage(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationUsage(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationUsage(oSource).statusElement.Clone;
  if (TFhirMedicationUsage(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirMedicationUsage(oSource).FStatusReasonList);
  end;
  if (TFhirMedicationUsage(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirMedicationUsage(oSource).FCategoryList);
  end;
  medication := TFhirMedicationUsage(oSource).medication.Clone;
  subject := TFhirMedicationUsage(oSource).subject.Clone;
  encounter := TFhirMedicationUsage(oSource).encounter.Clone;
  effective := TFhirMedicationUsage(oSource).effective.Clone;
  dateAssertedElement := TFhirMedicationUsage(oSource).dateAssertedElement.Clone;
  informationSource := TFhirMedicationUsage(oSource).informationSource.Clone;
  if (TFhirMedicationUsage(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirMedicationUsage(oSource).FDerivedFromList);
  end;
  if (TFhirMedicationUsage(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirMedicationUsage(oSource).FReasonList);
  end;
  if (TFhirMedicationUsage(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationUsage(oSource).FNoteList);
  end;
  renderedDosageInstructionElement := TFhirMedicationUsage(oSource).renderedDosageInstructionElement.Clone;
  if (TFhirMedicationUsage(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationUsage(oSource).FDosageList);
  end;
  takenAsOrderedElement := TFhirMedicationUsage(oSource).takenAsOrderedElement.Clone;
end;

function TFhirMedicationUsage.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationUsage;
end;

procedure TFhirMedicationUsage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'medication') Then
     list.add(self.link, 'medication', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'dateAsserted') Then
     list.add(self.link, 'dateAsserted', FDateAsserted.Link);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'renderedDosageInstruction') Then
     list.add(self.link, 'renderedDosageInstruction', FRenderedDosageInstruction.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'takenAsOrdered') Then
     list.add(self.link, 'takenAsOrdered', FTakenAsOrdered.Link);
end;

procedure TFhirMedicationUsage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'medication', 'CodeableReference', false, TFhirCodeableReference, FMedication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateAsserted', 'dateTime', false, TFhirDateTime, FDateAsserted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', false, TFhirReference, FInformationSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'renderedDosageInstruction', 'string', false, TFhirString, FRenderedDosageInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'takenAsOrdered', 'boolean', false, TFhirBoolean, FTakenAsOrdered.Link)); {L1172}
end;

function TFhirMedicationUsage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationUsageStatusCodesEnum, CODES_TFhirMedicationUsageStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'medication') then
  begin
    Medication := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'dateAsserted') then
  begin
    DateAssertedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'renderedDosageInstruction') then
  begin
    RenderedDosageInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage) {L1048};
    result := propValue;
  end
  else if (propName = 'takenAsOrdered') then
  begin
    TakenAsOrderedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationUsage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage) {L1049}
  else inherited;
end;

function TFhirMedicationUsage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationUsageStatusCodesEnum[MedicationUsageStatusCodesNull], CODES_TFhirMedicationUsageStatusCodesEnum[MedicationUsageStatusCodesNull])  {L1211}
  else if (propName = 'statusReason') then result := StatusReasonList.new() {L1053}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'medication') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective') {L1191}
  else if (propName = 'dateAsserted') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'informationSource') then result := TFhirReference.create() {L1203}
  else if (propName = 'derivedFrom') then result := DerivedFromList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'renderedDosageInstruction') then result := TFhirString.create() {L1223}
  else if (propName = 'dosage') then result := DosageList.new() {L1053}
  else if (propName = 'takenAsOrdered') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationUsage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication') then result := 'CodeableReference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'dateAsserted') then result := 'dateTime'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'renderedDosageInstruction') then result := 'string'
  else if (propName = 'dosage') then result := 'Dosage'
  else if (propName = 'takenAsOrdered') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationUsage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value) {L1054}
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'medication') then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil {L1189}
  else if (propName = 'dateAsserted') then DateAssertedElement := nil
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {L1054}
  else if (propName = 'takenAsOrdered') then TakenAsOrderedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationUsage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationUsageStatusCodesEnum, CODES_TFhirMedicationUsageStatusCodesEnum, new) {L1210}
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new) {L1055}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'medication') then MedicationElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType {L1190}
  else if (propName = 'dateAsserted') then DateAssertedElement := asDateTime(new) {L1222}
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference {L1195}
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'renderedDosageInstruction') then RenderedDosageInstructionElement := asString(new) {L1222}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {L1055}
  else if (propName = 'takenAsOrdered') then TakenAsOrderedElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationUsage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'dosage') then DosageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationUsage.fhirType : string;
begin
  result := 'MedicationUsage';
end;

function TFhirMedicationUsage.Link : TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage(inherited Link);
end;

function TFhirMedicationUsage.Clone : TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage(inherited Clone);
end;

function TFhirMedicationUsage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationUsage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationUsage)) then
    result := false
  else
  begin
    o := TFhirMedicationUsage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(dateAssertedElement, o.dateAssertedElement, true) and compareDeep(informationSourceElement, o.informationSourceElement, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(renderedDosageInstructionElement, o.renderedDosageInstructionElement, true) and 
      compareDeep(dosageList, o.dosageList, true) and compareDeep(takenAsOrderedElement, o.takenAsOrderedElement, true);
  end;
end;

function TFhirMedicationUsage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FcategoryList) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FDateAsserted) and isEmptyProp(FInformationSource) and isEmptyProp(FderivedFromList) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList) and isEmptyProp(FRenderedDosageInstruction) and isEmptyProp(FdosageList) and isEmptyProp(FTakenAsOrdered);
end;

function TFhirMedicationUsage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationUsage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationUsage.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationUsage.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirMedicationUsage.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationUsage.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationUsage.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationUsage.GetStatusST : TFhirMedicationUsageStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationUsageStatusCodesEnum(0)
  else
    result := TFhirMedicationUsageStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationUsageStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationUsage.SetStatusST(value : TFhirMedicationUsageStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationUsageStatusCodesEnum[value], CODES_TFhirMedicationUsageStatusCodesEnum[value]);
end;

function TFhirMedicationUsage.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirMedicationUsage.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

function TFhirMedicationUsage.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirMedicationUsage.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirMedicationUsage.SetMedication(value : TFhirCodeableReference);
begin
  FMedication.free;
  FMedication := value; {L1134}
end;

procedure TFhirMedicationUsage.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirMedicationUsage.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirMedicationUsage.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value; {L1134}
end;

procedure TFhirMedicationUsage.SetDateAsserted(value : TFhirDateTime);
begin
  FDateAsserted.free;
  FDateAsserted := value; {L1134}
end;

function TFhirMedicationUsage.GetDateAssertedST : TFslDateTime;
begin
  if FDateAsserted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAsserted.value;
end;

procedure TFhirMedicationUsage.SetDateAssertedST(value : TFslDateTime);
begin
  if FDateAsserted = nil then
    FDateAsserted := TFhirDateTime.create;
  FDateAsserted.value := value
end;

procedure TFhirMedicationUsage.SetInformationSource(value : TFhirReference);
begin
  FInformationSource.free;
  FInformationSource := value; {L1134}
end;

function TFhirMedicationUsage.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirMedicationUsage.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

function TFhirMedicationUsage.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirMedicationUsage.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirMedicationUsage.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationUsage.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationUsage.SetRenderedDosageInstruction(value : TFhirString);
begin
  FRenderedDosageInstruction.free;
  FRenderedDosageInstruction := value; {L1134}
end;

function TFhirMedicationUsage.GetRenderedDosageInstructionST : String;
begin
  if FRenderedDosageInstruction = nil then
    result := ''
  else
    result := FRenderedDosageInstruction.value;
end;

procedure TFhirMedicationUsage.SetRenderedDosageInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FRenderedDosageInstruction = nil then
      FRenderedDosageInstruction := TFhirString.create;
    FRenderedDosageInstruction.value := value
  end
  else if FRenderedDosageInstruction <> nil then
    FRenderedDosageInstruction.value := '';
end;

function TFhirMedicationUsage.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationUsage.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

procedure TFhirMedicationUsage.SetTakenAsOrdered(value : TFhirBoolean);
begin
  FTakenAsOrdered.free;
  FTakenAsOrdered := value; {L1134}
end;

function TFhirMedicationUsage.GetTakenAsOrderedST : Boolean;
begin
  if FTakenAsOrdered = nil then
    result := false
  else
    result := FTakenAsOrdered.value;
end;

procedure TFhirMedicationUsage.SetTakenAsOrderedST(value : Boolean);
begin
  if FTakenAsOrdered = nil then
    FTakenAsOrdered := TFhirBoolean.create;
  FTakenAsOrdered.value := value
end;

procedure TFhirMedicationUsage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('medication');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('dateAsserted');
  fields.add('informationSource');
  fields.add('derivedFrom');
  fields.add('reason');
  fields.add('note');
  fields.add('renderedDosageInstruction');
  fields.add('dosage');
  fields.add('takenAsOrdered');
end;

function TFhirMedicationUsage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusReasonList.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FDateAsserted.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FderivedFromList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FRenderedDosageInstruction.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
  inc(result, FTakenAsOrdered.sizeInBytes);
end;

{ TFhirMedicationUsageListEnumerator }

constructor TFhirMedicationUsageListEnumerator.Create(list : TFhirMedicationUsageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationUsageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationUsageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationUsageListEnumerator.GetCurrent : TFhirMedicationUsage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationUsageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationUsageList }

procedure TFhirMedicationUsageList.AddItem(value: TFhirMedicationUsage);
begin
  assert(value.ClassName = 'TFhirMedicationUsage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationUsage');
  add(value);
end;

function TFhirMedicationUsageList.Append: TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationUsageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationUsageList.GetEnumerator : TFhirMedicationUsageListEnumerator;
begin
  result := TFhirMedicationUsageListEnumerator.Create(self.link);
end;

function TFhirMedicationUsageList.Clone: TFhirMedicationUsageList;
begin
  result := TFhirMedicationUsageList(inherited Clone);
end;

function TFhirMedicationUsageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationUsageList.GetItemN(index: Integer): TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage(ObjectByIndex[index]);
end;

function TFhirMedicationUsageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationUsage;
end;
function TFhirMedicationUsageList.IndexOf(value: TFhirMedicationUsage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationUsageList.Insert(index: Integer): TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationUsageList.InsertItem(index: Integer; value: TFhirMedicationUsage);
begin
  assert(value is TFhirMedicationUsage);
  Inherited Insert(index, value);
end;

function TFhirMedicationUsageList.Item(index: Integer): TFhirMedicationUsage;
begin
  result := TFhirMedicationUsage(ObjectByIndex[index]);
end;

function TFhirMedicationUsageList.Link: TFhirMedicationUsageList;
begin
  result := TFhirMedicationUsageList(inherited Link);
end;

procedure TFhirMedicationUsageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationUsageList.SetItemByIndex(index: Integer; value: TFhirMedicationUsage);
begin
  assert(value is TFhirMedicationUsage);
  FhirMedicationUsages[index] := value;
end;

procedure TFhirMedicationUsageList.SetItemN(index: Integer; value: TFhirMedicationUsage);
begin
  assert(value is TFhirMedicationUsage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONUSAGE}
{$IFDEF FHIR_MOLECULARSEQUENCE}
{ TFhirMolecularSequenceReferenceSeq }

constructor TFhirMolecularSequenceReferenceSeq.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceReferenceSeq.Destroy;
begin
  FChromosome.free;
  FGenomeBuild.free;
  FOrientation.free;
  FReferenceSeqId.free;
  FReferenceSeqPointer.free;
  FReferenceSeqString.free;
  FStrand.free;
  FWindowStart.free;
  FWindowEnd.free;
  inherited;
end;

procedure TFhirMolecularSequenceReferenceSeq.Assign(oSource : TFslObject);
begin
  inherited;
  chromosome := TFhirMolecularSequenceReferenceSeq(oSource).chromosome.Clone;
  genomeBuildElement := TFhirMolecularSequenceReferenceSeq(oSource).genomeBuildElement.Clone;
  orientationElement := TFhirMolecularSequenceReferenceSeq(oSource).orientationElement.Clone;
  referenceSeqId := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqId.Clone;
  referenceSeqPointer := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqPointer.Clone;
  referenceSeqStringElement := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqStringElement.Clone;
  strandElement := TFhirMolecularSequenceReferenceSeq(oSource).strandElement.Clone;
  windowStartElement := TFhirMolecularSequenceReferenceSeq(oSource).windowStartElement.Clone;
  windowEndElement := TFhirMolecularSequenceReferenceSeq(oSource).windowEndElement.Clone;
end;

procedure TFhirMolecularSequenceReferenceSeq.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'chromosome') Then
     list.add(self.link, 'chromosome', FChromosome.Link);
  if (child_name = 'genomeBuild') Then
     list.add(self.link, 'genomeBuild', FGenomeBuild.Link);
  if (child_name = 'orientation') Then
     list.add(self.link, 'orientation', FOrientation.Link);
  if (child_name = 'referenceSeqId') Then
     list.add(self.link, 'referenceSeqId', FReferenceSeqId.Link);
  if (child_name = 'referenceSeqPointer') Then
     list.add(self.link, 'referenceSeqPointer', FReferenceSeqPointer.Link);
  if (child_name = 'referenceSeqString') Then
     list.add(self.link, 'referenceSeqString', FReferenceSeqString.Link);
  if (child_name = 'strand') Then
     list.add(self.link, 'strand', FStrand.Link);
  if (child_name = 'windowStart') Then
     list.add(self.link, 'windowStart', FWindowStart.Link);
  if (child_name = 'windowEnd') Then
     list.add(self.link, 'windowEnd', FWindowEnd.Link);
end;

procedure TFhirMolecularSequenceReferenceSeq.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'chromosome', 'CodeableConcept', false, TFhirCodeableConcept, FChromosome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'genomeBuild', 'string', false, TFhirString, FGenomeBuild.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'orientation', 'code', false, TFhirEnum, FOrientation.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'referenceSeqId', 'CodeableConcept', false, TFhirCodeableConcept, FReferenceSeqId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceSeqPointer', 'Reference', false, TFhirReference, FReferenceSeqPointer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceSeqString', 'string', false, TFhirString, FReferenceSeqString.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strand', 'code', false, TFhirEnum, FStrand.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'windowStart', 'integer', false, TFhirInteger, FWindowStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'windowEnd', 'integer', false, TFhirInteger, FWindowEnd.Link)); {L1172}
end;

function TFhirMolecularSequenceReferenceSeq.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'chromosome') then
  begin
    Chromosome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'genomeBuild') then
  begin
    GenomeBuildElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'orientation') then
  begin
    OrientationElement := asEnum(SYSTEMS_TFhirOrientationTypeEnum, CODES_TFhirOrientationTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'referenceSeqId') then
  begin
    ReferenceSeqId := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'referenceSeqPointer') then
  begin
    ReferenceSeqPointer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'referenceSeqString') then
  begin
    ReferenceSeqStringElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'strand') then
  begin
    StrandElement := asEnum(SYSTEMS_TFhirStrandTypeEnum, CODES_TFhirStrandTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'windowStart') then
  begin
    WindowStartElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'windowEnd') then
  begin
    WindowEndElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceReferenceSeq.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceReferenceSeq.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'chromosome') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'genomeBuild') then result := TFhirString.create() {L1223}
  else if (propName = 'orientation') then result := TFhirEnum.create(SYSTEMS_TFhirOrientationTypeEnum[OrientationTypeNull], CODES_TFhirOrientationTypeEnum[OrientationTypeNull])  {L1211}
  else if (propName = 'referenceSeqId') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'referenceSeqPointer') then result := TFhirReference.create() {L1203}
  else if (propName = 'referenceSeqString') then result := TFhirString.create() {L1223}
  else if (propName = 'strand') then result := TFhirEnum.create(SYSTEMS_TFhirStrandTypeEnum[StrandTypeNull], CODES_TFhirStrandTypeEnum[StrandTypeNull])  {L1211}
  else if (propName = 'windowStart') then result := TFhirInteger.create() {L1223}
  else if (propName = 'windowEnd') then result := TFhirInteger.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceReferenceSeq.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'chromosome') then result := 'CodeableConcept'
  else if (propName = 'genomeBuild') then result := 'string'
  else if (propName = 'orientation') then result := 'code'
  else if (propName = 'referenceSeqId') then result := 'CodeableConcept'
  else if (propName = 'referenceSeqPointer') then result := 'Reference'
  else if (propName = 'referenceSeqString') then result := 'string'
  else if (propName = 'strand') then result := 'code'
  else if (propName = 'windowStart') then result := 'integer'
  else if (propName = 'windowEnd') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceReferenceSeq.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := nil
  else if (propName = 'genomeBuild') then GenomeBuildElement := nil
  else if (propName = 'orientation') then OrientationElement := nil
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := nil
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := nil
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := nil
  else if (propName = 'strand') then StrandElement := nil
  else if (propName = 'windowStart') then WindowStartElement := nil
  else if (propName = 'windowEnd') then WindowEndElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceReferenceSeq.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'genomeBuild') then GenomeBuildElement := asString(new) {L1222}
  else if (propName = 'orientation') then OrientationElement := asEnum(SYSTEMS_TFhirOrientationTypeEnum, CODES_TFhirOrientationTypeEnum, new) {L1210}
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := new as TFhirReference {L1195}
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := asString(new) {L1222}
  else if (propName = 'strand') then StrandElement := asEnum(SYSTEMS_TFhirStrandTypeEnum, CODES_TFhirStrandTypeEnum, new) {L1210}
  else if (propName = 'windowStart') then WindowStartElement := asInteger(new) {L1222}
  else if (propName = 'windowEnd') then WindowEndElement := asInteger(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceReferenceSeq.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceReferenceSeq.fhirType : string;
begin
  result := 'MolecularSequence.referenceSeq';
end;

function TFhirMolecularSequenceReferenceSeq.Link : TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(inherited Link);
end;

function TFhirMolecularSequenceReferenceSeq.Clone : TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(inherited Clone);
end;

function TFhirMolecularSequenceReferenceSeq.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceReferenceSeq;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceReferenceSeq)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceReferenceSeq(other);
    result := compareDeep(chromosomeElement, o.chromosomeElement, true) and compareDeep(genomeBuildElement, o.genomeBuildElement, true) and 
      compareDeep(orientationElement, o.orientationElement, true) and compareDeep(referenceSeqIdElement, o.referenceSeqIdElement, true) and 
      compareDeep(referenceSeqPointerElement, o.referenceSeqPointerElement, true) and 
      compareDeep(referenceSeqStringElement, o.referenceSeqStringElement, true) and 
      compareDeep(strandElement, o.strandElement, true) and compareDeep(windowStartElement, o.windowStartElement, true) and 
      compareDeep(windowEndElement, o.windowEndElement, true);
  end;
end;

function TFhirMolecularSequenceReferenceSeq.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FChromosome) and isEmptyProp(FGenomeBuild) and isEmptyProp(FOrientation) and isEmptyProp(FReferenceSeqId) and isEmptyProp(FReferenceSeqPointer) and isEmptyProp(FReferenceSeqString) and isEmptyProp(FStrand) and isEmptyProp(FWindowStart) and isEmptyProp(FWindowEnd);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetChromosome(value : TFhirCodeableConcept);
begin
  FChromosome.free;
  FChromosome := value; {L1134}
end;

procedure TFhirMolecularSequenceReferenceSeq.SetGenomeBuild(value : TFhirString);
begin
  FGenomeBuild.free;
  FGenomeBuild := value; {L1134}
end;

function TFhirMolecularSequenceReferenceSeq.GetGenomeBuildST : String;
begin
  if FGenomeBuild = nil then
    result := ''
  else
    result := FGenomeBuild.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetGenomeBuildST(value : String);
begin
  if value <> '' then
  begin
    if FGenomeBuild = nil then
      FGenomeBuild := TFhirString.create;
    FGenomeBuild.value := value
  end
  else if FGenomeBuild <> nil then
    FGenomeBuild.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetOrientation(value : TFhirEnum);
begin
  FOrientation.free;
  FOrientation := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetOrientationST : TFhirOrientationTypeEnum;
begin
  if FOrientation = nil then
    result := TFhirOrientationTypeEnum(0)
  else
    result := TFhirOrientationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirOrientationTypeEnum, FOrientation.value));
end;

procedure TFhirMolecularSequenceReferenceSeq.SetOrientationST(value : TFhirOrientationTypeEnum);
begin
  if ord(value) = 0 then
    OrientationElement := nil
  else
    OrientationElement := TFhirEnum.create(SYSTEMS_TFhirOrientationTypeEnum[value], CODES_TFhirOrientationTypeEnum[value]);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqId(value : TFhirCodeableConcept);
begin
  FReferenceSeqId.free;
  FReferenceSeqId := value; {L1134}
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqPointer(value : TFhirReference);
begin
  FReferenceSeqPointer.free;
  FReferenceSeqPointer := value; {L1134}
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqString(value : TFhirString);
begin
  FReferenceSeqString.free;
  FReferenceSeqString := value; {L1134}
end;

function TFhirMolecularSequenceReferenceSeq.GetReferenceSeqStringST : String;
begin
  if FReferenceSeqString = nil then
    result := ''
  else
    result := FReferenceSeqString.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqStringST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceSeqString = nil then
      FReferenceSeqString := TFhirString.create;
    FReferenceSeqString.value := value
  end
  else if FReferenceSeqString <> nil then
    FReferenceSeqString.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetStrand(value : TFhirEnum);
begin
  FStrand.free;
  FStrand := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetStrandST : TFhirStrandTypeEnum;
begin
  if FStrand = nil then
    result := TFhirStrandTypeEnum(0)
  else
    result := TFhirStrandTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirStrandTypeEnum, FStrand.value));
end;

procedure TFhirMolecularSequenceReferenceSeq.SetStrandST(value : TFhirStrandTypeEnum);
begin
  if ord(value) = 0 then
    StrandElement := nil
  else
    StrandElement := TFhirEnum.create(SYSTEMS_TFhirStrandTypeEnum[value], CODES_TFhirStrandTypeEnum[value]);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowStart(value : TFhirInteger);
begin
  FWindowStart.free;
  FWindowStart := value; {L1134}
end;

function TFhirMolecularSequenceReferenceSeq.GetWindowStartST : String;
begin
  if FWindowStart = nil then
    result := ''
  else
    result := FWindowStart.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowStartST(value : String);
begin
  if value <> '' then
  begin
    if FWindowStart = nil then
      FWindowStart := TFhirInteger.create;
    FWindowStart.value := value
  end
  else if FWindowStart <> nil then
    FWindowStart.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowEnd(value : TFhirInteger);
begin
  FWindowEnd.free;
  FWindowEnd := value; {L1134}
end;

function TFhirMolecularSequenceReferenceSeq.GetWindowEndST : String;
begin
  if FWindowEnd = nil then
    result := ''
  else
    result := FWindowEnd.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowEndST(value : String);
begin
  if value <> '' then
  begin
    if FWindowEnd = nil then
      FWindowEnd := TFhirInteger.create;
    FWindowEnd.value := value
  end
  else if FWindowEnd <> nil then
    FWindowEnd.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('chromosome');
  fields.add('genomeBuild');
  fields.add('orientation');
  fields.add('referenceSeqId');
  fields.add('referenceSeqPointer');
  fields.add('referenceSeqString');
  fields.add('strand');
  fields.add('windowStart');
  fields.add('windowEnd');
end;

function TFhirMolecularSequenceReferenceSeq.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FChromosome.sizeInBytes);
  inc(result, FGenomeBuild.sizeInBytes);
  inc(result, FOrientation.sizeInBytes);
  inc(result, FReferenceSeqId.sizeInBytes);
  inc(result, FReferenceSeqPointer.sizeInBytes);
  inc(result, FReferenceSeqString.sizeInBytes);
  inc(result, FStrand.sizeInBytes);
  inc(result, FWindowStart.sizeInBytes);
  inc(result, FWindowEnd.sizeInBytes);
end;

{ TFhirMolecularSequenceReferenceSeqListEnumerator }

constructor TFhirMolecularSequenceReferenceSeqListEnumerator.Create(list : TFhirMolecularSequenceReferenceSeqList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceReferenceSeqListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.GetCurrent : TFhirMolecularSequenceReferenceSeq;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceReferenceSeqList }

procedure TFhirMolecularSequenceReferenceSeqList.AddItem(value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceReferenceSeq', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceReferenceSeq');
  add(value);
end;

function TFhirMolecularSequenceReferenceSeqList.Append: TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceReferenceSeqList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceReferenceSeqList.GetEnumerator : TFhirMolecularSequenceReferenceSeqListEnumerator;
begin
  result := TFhirMolecularSequenceReferenceSeqListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceReferenceSeqList.Clone: TFhirMolecularSequenceReferenceSeqList;
begin
  result := TFhirMolecularSequenceReferenceSeqList(inherited Clone);
end;

function TFhirMolecularSequenceReferenceSeqList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceReferenceSeqList.GetItemN(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceReferenceSeqList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceReferenceSeq;
end;
function TFhirMolecularSequenceReferenceSeqList.IndexOf(value: TFhirMolecularSequenceReferenceSeq): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceReferenceSeqList.Insert(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceReferenceSeqList.InsertItem(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceReferenceSeqList.Item(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceReferenceSeqList.Link: TFhirMolecularSequenceReferenceSeqList;
begin
  result := TFhirMolecularSequenceReferenceSeqList(inherited Link);
end;

procedure TFhirMolecularSequenceReferenceSeqList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceReferenceSeqList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  FhirMolecularSequenceReferenceSeqs[index] := value;
end;

procedure TFhirMolecularSequenceReferenceSeqList.SetItemN(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceVariant }

constructor TFhirMolecularSequenceVariant.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceVariant.Destroy;
begin
  FStart.free;
  FEnd_.free;
  FObservedAllele.free;
  FReferenceAllele.free;
  FCigar.free;
  FVariantPointer.free;
  inherited;
end;

procedure TFhirMolecularSequenceVariant.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceVariant(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceVariant(oSource).end_Element.Clone;
  observedAlleleElement := TFhirMolecularSequenceVariant(oSource).observedAlleleElement.Clone;
  referenceAlleleElement := TFhirMolecularSequenceVariant(oSource).referenceAlleleElement.Clone;
  cigarElement := TFhirMolecularSequenceVariant(oSource).cigarElement.Clone;
  variantPointer := TFhirMolecularSequenceVariant(oSource).variantPointer.Clone;
end;

procedure TFhirMolecularSequenceVariant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'observedAllele') Then
     list.add(self.link, 'observedAllele', FObservedAllele.Link);
  if (child_name = 'referenceAllele') Then
     list.add(self.link, 'referenceAllele', FReferenceAllele.Link);
  if (child_name = 'cigar') Then
     list.add(self.link, 'cigar', FCigar.Link);
  if (child_name = 'variantPointer') Then
     list.add(self.link, 'variantPointer', FVariantPointer.Link);
end;

procedure TFhirMolecularSequenceVariant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'observedAllele', 'string', false, TFhirString, FObservedAllele.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceAllele', 'string', false, TFhirString, FReferenceAllele.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cigar', 'string', false, TFhirString, FCigar.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'variantPointer', 'Reference', false, TFhirReference, FVariantPointer.Link)); {L1172}
end;

function TFhirMolecularSequenceVariant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'observedAllele') then
  begin
    ObservedAlleleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'referenceAllele') then
  begin
    ReferenceAlleleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'cigar') then
  begin
    CigarElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'variantPointer') then
  begin
    VariantPointer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceVariant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceVariant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create() {L1223}
  else if (propName = 'end') then result := TFhirInteger.create() {L1223}
  else if (propName = 'observedAllele') then result := TFhirString.create() {L1223}
  else if (propName = 'referenceAllele') then result := TFhirString.create() {L1223}
  else if (propName = 'cigar') then result := TFhirString.create() {L1223}
  else if (propName = 'variantPointer') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceVariant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'observedAllele') then result := 'string'
  else if (propName = 'referenceAllele') then result := 'string'
  else if (propName = 'cigar') then result := 'string'
  else if (propName = 'variantPointer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceVariant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'observedAllele') then ObservedAlleleElement := nil
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := nil
  else if (propName = 'cigar') then CigarElement := nil
  else if (propName = 'variantPointer') then VariantPointerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceVariant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new) {L1222}
  else if (propName = 'end') then End_Element := asInteger(new) {L1222}
  else if (propName = 'observedAllele') then ObservedAlleleElement := asString(new) {L1222}
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := asString(new) {L1222}
  else if (propName = 'cigar') then CigarElement := asString(new) {L1222}
  else if (propName = 'variantPointer') then VariantPointerElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceVariant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceVariant.fhirType : string;
begin
  result := 'MolecularSequence.variant';
end;

function TFhirMolecularSequenceVariant.Link : TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(inherited Link);
end;

function TFhirMolecularSequenceVariant.Clone : TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(inherited Clone);
end;

function TFhirMolecularSequenceVariant.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceVariant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceVariant)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceVariant(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(observedAlleleElement, o.observedAlleleElement, true) and compareDeep(referenceAlleleElement, o.referenceAlleleElement, true) and 
      compareDeep(cigarElement, o.cigarElement, true) and compareDeep(variantPointerElement, o.variantPointerElement, true);
  end;
end;

function TFhirMolecularSequenceVariant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FObservedAllele) and isEmptyProp(FReferenceAllele) and isEmptyProp(FCigar) and isEmptyProp(FVariantPointer);
end;

procedure TFhirMolecularSequenceVariant.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirMolecularSequenceVariant.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceVariant.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirMolecularSequenceVariant.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceVariant.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetObservedAllele(value : TFhirString);
begin
  FObservedAllele.free;
  FObservedAllele := value; {L1134}
end;

function TFhirMolecularSequenceVariant.GetObservedAlleleST : String;
begin
  if FObservedAllele = nil then
    result := ''
  else
    result := FObservedAllele.value;
end;

procedure TFhirMolecularSequenceVariant.SetObservedAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FObservedAllele = nil then
      FObservedAllele := TFhirString.create;
    FObservedAllele.value := value
  end
  else if FObservedAllele <> nil then
    FObservedAllele.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetReferenceAllele(value : TFhirString);
begin
  FReferenceAllele.free;
  FReferenceAllele := value; {L1134}
end;

function TFhirMolecularSequenceVariant.GetReferenceAlleleST : String;
begin
  if FReferenceAllele = nil then
    result := ''
  else
    result := FReferenceAllele.value;
end;

procedure TFhirMolecularSequenceVariant.SetReferenceAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceAllele = nil then
      FReferenceAllele := TFhirString.create;
    FReferenceAllele.value := value
  end
  else if FReferenceAllele <> nil then
    FReferenceAllele.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetCigar(value : TFhirString);
begin
  FCigar.free;
  FCigar := value; {L1134}
end;

function TFhirMolecularSequenceVariant.GetCigarST : String;
begin
  if FCigar = nil then
    result := ''
  else
    result := FCigar.value;
end;

procedure TFhirMolecularSequenceVariant.SetCigarST(value : String);
begin
  if value <> '' then
  begin
    if FCigar = nil then
      FCigar := TFhirString.create;
    FCigar.value := value
  end
  else if FCigar <> nil then
    FCigar.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetVariantPointer(value : TFhirReference);
begin
  FVariantPointer.free;
  FVariantPointer := value; {L1134}
end;

procedure TFhirMolecularSequenceVariant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
  fields.add('observedAllele');
  fields.add('referenceAllele');
  fields.add('cigar');
  fields.add('variantPointer');
end;

function TFhirMolecularSequenceVariant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FObservedAllele.sizeInBytes);
  inc(result, FReferenceAllele.sizeInBytes);
  inc(result, FCigar.sizeInBytes);
  inc(result, FVariantPointer.sizeInBytes);
end;

{ TFhirMolecularSequenceVariantListEnumerator }

constructor TFhirMolecularSequenceVariantListEnumerator.Create(list : TFhirMolecularSequenceVariantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceVariantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceVariantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceVariantListEnumerator.GetCurrent : TFhirMolecularSequenceVariant;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceVariantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceVariantList }

procedure TFhirMolecularSequenceVariantList.AddItem(value: TFhirMolecularSequenceVariant);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceVariant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceVariant');
  add(value);
end;

function TFhirMolecularSequenceVariantList.Append: TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceVariantList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceVariantList.GetEnumerator : TFhirMolecularSequenceVariantListEnumerator;
begin
  result := TFhirMolecularSequenceVariantListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceVariantList.Clone: TFhirMolecularSequenceVariantList;
begin
  result := TFhirMolecularSequenceVariantList(inherited Clone);
end;

function TFhirMolecularSequenceVariantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceVariantList.GetItemN(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceVariantList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceVariant;
end;
function TFhirMolecularSequenceVariantList.IndexOf(value: TFhirMolecularSequenceVariant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceVariantList.Insert(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceVariantList.InsertItem(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceVariantList.Item(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceVariantList.Link: TFhirMolecularSequenceVariantList;
begin
  result := TFhirMolecularSequenceVariantList(inherited Link);
end;

procedure TFhirMolecularSequenceVariantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceVariantList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  FhirMolecularSequenceVariants[index] := value;
end;

procedure TFhirMolecularSequenceVariantList.SetItemN(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceQuality }

constructor TFhirMolecularSequenceQuality.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceQuality.Destroy;
begin
  FType_.free;
  FStandardSequence.free;
  FStart.free;
  FEnd_.free;
  FScore.free;
  FMethod.free;
  FTruthTP.free;
  FQueryTP.free;
  FTruthFN.free;
  FQueryFP.free;
  FGtFP.free;
  FPrecision.free;
  FRecall.free;
  FFScore_.free;
  FRoc.free;
  inherited;
end;

procedure TFhirMolecularSequenceQuality.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirMolecularSequenceQuality(oSource).type_Element.Clone;
  standardSequence := TFhirMolecularSequenceQuality(oSource).standardSequence.Clone;
  startElement := TFhirMolecularSequenceQuality(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceQuality(oSource).end_Element.Clone;
  score := TFhirMolecularSequenceQuality(oSource).score.Clone;
  method := TFhirMolecularSequenceQuality(oSource).method.Clone;
  truthTPElement := TFhirMolecularSequenceQuality(oSource).truthTPElement.Clone;
  queryTPElement := TFhirMolecularSequenceQuality(oSource).queryTPElement.Clone;
  truthFNElement := TFhirMolecularSequenceQuality(oSource).truthFNElement.Clone;
  queryFPElement := TFhirMolecularSequenceQuality(oSource).queryFPElement.Clone;
  gtFPElement := TFhirMolecularSequenceQuality(oSource).gtFPElement.Clone;
  precisionElement := TFhirMolecularSequenceQuality(oSource).precisionElement.Clone;
  recallElement := TFhirMolecularSequenceQuality(oSource).recallElement.Clone;
  fScore_Element := TFhirMolecularSequenceQuality(oSource).fScore_Element.Clone;
  roc := TFhirMolecularSequenceQuality(oSource).roc.Clone;
end;

procedure TFhirMolecularSequenceQuality.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'standardSequence') Then
     list.add(self.link, 'standardSequence', FStandardSequence.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'truthTP') Then
     list.add(self.link, 'truthTP', FTruthTP.Link);
  if (child_name = 'queryTP') Then
     list.add(self.link, 'queryTP', FQueryTP.Link);
  if (child_name = 'truthFN') Then
     list.add(self.link, 'truthFN', FTruthFN.Link);
  if (child_name = 'queryFP') Then
     list.add(self.link, 'queryFP', FQueryFP.Link);
  if (child_name = 'gtFP') Then
     list.add(self.link, 'gtFP', FGtFP.Link);
  if (child_name = 'precision') Then
     list.add(self.link, 'precision', FPrecision.Link);
  if (child_name = 'recall') Then
     list.add(self.link, 'recall', FRecall.Link);
  if (child_name = 'fScore') Then
     list.add(self.link, 'fScore', FFScore_.Link);
  if (child_name = 'roc') Then
     list.add(self.link, 'roc', FRoc.Link);
end;

procedure TFhirMolecularSequenceQuality.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'standardSequence', 'CodeableConcept', false, TFhirCodeableConcept, FStandardSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'score', 'Quantity', false, TFhirQuantity, FScore.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'truthTP', 'decimal', false, TFhirDecimal, FTruthTP.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'queryTP', 'decimal', false, TFhirDecimal, FQueryTP.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'truthFN', 'decimal', false, TFhirDecimal, FTruthFN.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'queryFP', 'decimal', false, TFhirDecimal, FQueryFP.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'gtFP', 'decimal', false, TFhirDecimal, FGtFP.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'precision', 'decimal', false, TFhirDecimal, FPrecision.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recall', 'decimal', false, TFhirDecimal, FRecall.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fScore', 'decimal', false, TFhirDecimal, FFScore_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'roc', 'BackboneElement', false, TFhirMolecularSequenceQualityRoc, FRoc.Link)); {L1172}
end;

function TFhirMolecularSequenceQuality.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'standardSequence') then
  begin
    StandardSequence := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    Score := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'truthTP') then
  begin
    TruthTPElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'queryTP') then
  begin
    QueryTPElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'truthFN') then
  begin
    TruthFNElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'queryFP') then
  begin
    QueryFPElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'gtFP') then
  begin
    GtFPElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'precision') then
  begin
    PrecisionElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recall') then
  begin
    RecallElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'fScore') then
  begin
    FScore_Element := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'roc') then
  begin
    Roc := propValue as TFhirMolecularSequenceQualityRoc {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceQuality.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceQuality.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirQualityTypeEnum[QualityTypeNull], CODES_TFhirQualityTypeEnum[QualityTypeNull])  {L1211}
  else if (propName = 'standardSequence') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'start') then result := TFhirInteger.create() {L1223}
  else if (propName = 'end') then result := TFhirInteger.create() {L1223}
  else if (propName = 'score') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'truthTP') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'queryTP') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'truthFN') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'queryFP') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'gtFP') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'precision') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'recall') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'fScore') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'roc') then result := TFhirMolecularSequenceQualityRoc.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceQuality.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'standardSequence') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'score') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'truthTP') then result := 'decimal'
  else if (propName = 'queryTP') then result := 'decimal'
  else if (propName = 'truthFN') then result := 'decimal'
  else if (propName = 'queryFP') then result := 'decimal'
  else if (propName = 'gtFP') then result := 'decimal'
  else if (propName = 'precision') then result := 'decimal'
  else if (propName = 'recall') then result := 'decimal'
  else if (propName = 'fScore') then result := 'decimal'
  else if (propName = 'roc') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceQuality.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'standardSequence') then StandardSequenceElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'truthTP') then TruthTPElement := nil
  else if (propName = 'queryTP') then QueryTPElement := nil
  else if (propName = 'truthFN') then TruthFNElement := nil
  else if (propName = 'queryFP') then QueryFPElement := nil
  else if (propName = 'gtFP') then GtFPElement := nil
  else if (propName = 'precision') then PrecisionElement := nil
  else if (propName = 'recall') then RecallElement := nil
  else if (propName = 'fScore') then FScore_Element := nil
  else if (propName = 'roc') then RocElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceQuality.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, new) {L1210}
  else if (propName = 'standardSequence') then StandardSequenceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'start') then StartElement := asInteger(new) {L1222}
  else if (propName = 'end') then End_Element := asInteger(new) {L1222}
  else if (propName = 'score') then ScoreElement := new as TFhirQuantity {L1195}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'truthTP') then TruthTPElement := asDecimal(new) {L1222}
  else if (propName = 'queryTP') then QueryTPElement := asDecimal(new) {L1222}
  else if (propName = 'truthFN') then TruthFNElement := asDecimal(new) {L1222}
  else if (propName = 'queryFP') then QueryFPElement := asDecimal(new) {L1222}
  else if (propName = 'gtFP') then GtFPElement := asDecimal(new) {L1222}
  else if (propName = 'precision') then PrecisionElement := asDecimal(new) {L1222}
  else if (propName = 'recall') then RecallElement := asDecimal(new) {L1222}
  else if (propName = 'fScore') then FScore_Element := asDecimal(new) {L1222}
  else if (propName = 'roc') then RocElement := new as TFhirMolecularSequenceQualityRoc {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceQuality.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceQuality.fhirType : string;
begin
  result := 'MolecularSequence.quality';
end;

function TFhirMolecularSequenceQuality.Link : TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(inherited Link);
end;

function TFhirMolecularSequenceQuality.Clone : TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(inherited Clone);
end;

function TFhirMolecularSequenceQuality.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceQuality;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceQuality)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceQuality(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(standardSequenceElement, o.standardSequenceElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(scoreElement, o.scoreElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(truthTPElement, o.truthTPElement, true) and compareDeep(queryTPElement, o.queryTPElement, true) and 
      compareDeep(truthFNElement, o.truthFNElement, true) and compareDeep(queryFPElement, o.queryFPElement, true) and 
      compareDeep(gtFPElement, o.gtFPElement, true) and compareDeep(precisionElement, o.precisionElement, true) and 
      compareDeep(recallElement, o.recallElement, true) and compareDeep(fScore_Element, o.fScore_Element, true) and 
      compareDeep(rocElement, o.rocElement, true);
  end;
end;

function TFhirMolecularSequenceQuality.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FStandardSequence) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FScore) and isEmptyProp(FMethod) and isEmptyProp(FTruthTP) and isEmptyProp(FQueryTP) and isEmptyProp(FTruthFN) and isEmptyProp(FQueryFP) and isEmptyProp(FGtFP) and isEmptyProp(FPrecision) and isEmptyProp(FRecall) and isEmptyProp(FFScore_) and isEmptyProp(FRoc);
end;

procedure TFhirMolecularSequenceQuality.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequenceQuality.GetType_ST : TFhirQualityTypeEnum;
begin
  if FType_ = nil then
    result := TFhirQualityTypeEnum(0)
  else
    result := TFhirQualityTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirQualityTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequenceQuality.SetType_ST(value : TFhirQualityTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirQualityTypeEnum[value], CODES_TFhirQualityTypeEnum[value]);
end;

procedure TFhirMolecularSequenceQuality.SetStandardSequence(value : TFhirCodeableConcept);
begin
  FStandardSequence.free;
  FStandardSequence := value; {L1134}
end;

procedure TFhirMolecularSequenceQuality.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceQuality.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceQuality.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetScore(value : TFhirQuantity);
begin
  FScore.free;
  FScore := value; {L1134}
end;

procedure TFhirMolecularSequenceQuality.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirMolecularSequenceQuality.SetTruthTP(value : TFhirDecimal);
begin
  FTruthTP.free;
  FTruthTP := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetTruthTPST : String;
begin
  if FTruthTP = nil then
    result := ''
  else
    result := FTruthTP.value;
end;

procedure TFhirMolecularSequenceQuality.SetTruthTPST(value : String);
begin
  if value <> '' then
  begin
    if FTruthTP = nil then
      FTruthTP := TFhirDecimal.create;
    FTruthTP.value := value
  end
  else if FTruthTP <> nil then
    FTruthTP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetQueryTP(value : TFhirDecimal);
begin
  FQueryTP.free;
  FQueryTP := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetQueryTPST : String;
begin
  if FQueryTP = nil then
    result := ''
  else
    result := FQueryTP.value;
end;

procedure TFhirMolecularSequenceQuality.SetQueryTPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryTP = nil then
      FQueryTP := TFhirDecimal.create;
    FQueryTP.value := value
  end
  else if FQueryTP <> nil then
    FQueryTP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetTruthFN(value : TFhirDecimal);
begin
  FTruthFN.free;
  FTruthFN := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetTruthFNST : String;
begin
  if FTruthFN = nil then
    result := ''
  else
    result := FTruthFN.value;
end;

procedure TFhirMolecularSequenceQuality.SetTruthFNST(value : String);
begin
  if value <> '' then
  begin
    if FTruthFN = nil then
      FTruthFN := TFhirDecimal.create;
    FTruthFN.value := value
  end
  else if FTruthFN <> nil then
    FTruthFN.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetQueryFP(value : TFhirDecimal);
begin
  FQueryFP.free;
  FQueryFP := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetQueryFPST : String;
begin
  if FQueryFP = nil then
    result := ''
  else
    result := FQueryFP.value;
end;

procedure TFhirMolecularSequenceQuality.SetQueryFPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryFP = nil then
      FQueryFP := TFhirDecimal.create;
    FQueryFP.value := value
  end
  else if FQueryFP <> nil then
    FQueryFP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetGtFP(value : TFhirDecimal);
begin
  FGtFP.free;
  FGtFP := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetGtFPST : String;
begin
  if FGtFP = nil then
    result := ''
  else
    result := FGtFP.value;
end;

procedure TFhirMolecularSequenceQuality.SetGtFPST(value : String);
begin
  if value <> '' then
  begin
    if FGtFP = nil then
      FGtFP := TFhirDecimal.create;
    FGtFP.value := value
  end
  else if FGtFP <> nil then
    FGtFP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetPrecision(value : TFhirDecimal);
begin
  FPrecision.free;
  FPrecision := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetPrecisionST : String;
begin
  if FPrecision = nil then
    result := ''
  else
    result := FPrecision.value;
end;

procedure TFhirMolecularSequenceQuality.SetPrecisionST(value : String);
begin
  if value <> '' then
  begin
    if FPrecision = nil then
      FPrecision := TFhirDecimal.create;
    FPrecision.value := value
  end
  else if FPrecision <> nil then
    FPrecision.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetRecall(value : TFhirDecimal);
begin
  FRecall.free;
  FRecall := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetRecallST : String;
begin
  if FRecall = nil then
    result := ''
  else
    result := FRecall.value;
end;

procedure TFhirMolecularSequenceQuality.SetRecallST(value : String);
begin
  if value <> '' then
  begin
    if FRecall = nil then
      FRecall := TFhirDecimal.create;
    FRecall.value := value
  end
  else if FRecall <> nil then
    FRecall.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetFScore_(value : TFhirDecimal);
begin
  FFScore_.free;
  FFScore_ := value; {L1134}
end;

function TFhirMolecularSequenceQuality.GetFScore_ST : String;
begin
  if FFScore_ = nil then
    result := ''
  else
    result := FFScore_.value;
end;

procedure TFhirMolecularSequenceQuality.SetFScore_ST(value : String);
begin
  if value <> '' then
  begin
    if FFScore_ = nil then
      FFScore_ := TFhirDecimal.create;
    FFScore_.value := value
  end
  else if FFScore_ <> nil then
    FFScore_.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetRoc(value : TFhirMolecularSequenceQualityRoc);
begin
  FRoc.free;
  FRoc := value; {L1134}
end;

procedure TFhirMolecularSequenceQuality.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('standardSequence');
  fields.add('start');
  fields.add('end');
  fields.add('score');
  fields.add('method');
  fields.add('truthTP');
  fields.add('queryTP');
  fields.add('truthFN');
  fields.add('queryFP');
  fields.add('gtFP');
  fields.add('precision');
  fields.add('recall');
  fields.add('fScore');
  fields.add('roc');
end;

function TFhirMolecularSequenceQuality.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FStandardSequence.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FScore.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FTruthTP.sizeInBytes);
  inc(result, FQueryTP.sizeInBytes);
  inc(result, FTruthFN.sizeInBytes);
  inc(result, FQueryFP.sizeInBytes);
  inc(result, FGtFP.sizeInBytes);
  inc(result, FPrecision.sizeInBytes);
  inc(result, FRecall.sizeInBytes);
  inc(result, FFScore_.sizeInBytes);
  inc(result, FRoc.sizeInBytes);
end;

{ TFhirMolecularSequenceQualityListEnumerator }

constructor TFhirMolecularSequenceQualityListEnumerator.Create(list : TFhirMolecularSequenceQualityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceQualityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceQualityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceQualityListEnumerator.GetCurrent : TFhirMolecularSequenceQuality;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceQualityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceQualityList }

procedure TFhirMolecularSequenceQualityList.AddItem(value: TFhirMolecularSequenceQuality);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceQuality', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceQuality');
  add(value);
end;

function TFhirMolecularSequenceQualityList.Append: TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceQualityList.GetEnumerator : TFhirMolecularSequenceQualityListEnumerator;
begin
  result := TFhirMolecularSequenceQualityListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceQualityList.Clone: TFhirMolecularSequenceQualityList;
begin
  result := TFhirMolecularSequenceQualityList(inherited Clone);
end;

function TFhirMolecularSequenceQualityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceQualityList.GetItemN(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceQuality;
end;
function TFhirMolecularSequenceQualityList.IndexOf(value: TFhirMolecularSequenceQuality): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceQualityList.Insert(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityList.InsertItem(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceQualityList.Item(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityList.Link: TFhirMolecularSequenceQualityList;
begin
  result := TFhirMolecularSequenceQualityList(inherited Link);
end;

procedure TFhirMolecularSequenceQualityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceQualityList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  FhirMolecularSequenceQualities[index] := value;
end;

procedure TFhirMolecularSequenceQualityList.SetItemN(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceQualityRoc }

constructor TFhirMolecularSequenceQualityRoc.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceQualityRoc.Destroy;
begin
  FScoreList.Free;
  FNumTPList.Free;
  FNumFPList.Free;
  FNumFNList.Free;
  FPrecisionList.Free;
  FSensitivityList.Free;
  FFMeasureList.Free;
  inherited;
end;

procedure TFhirMolecularSequenceQualityRoc.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMolecularSequenceQualityRoc(oSource).FScoreList = nil) then
  begin
    FScoreList.free;
    FScoreList := nil;
  end
  else
  begin
    if FScoreList = nil then
      FScoreList := TFhirIntegerList.Create;
    FScoreList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FScoreList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumTPList = nil) then
  begin
    FNumTPList.free;
    FNumTPList := nil;
  end
  else
  begin
    if FNumTPList = nil then
      FNumTPList := TFhirIntegerList.Create;
    FNumTPList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumTPList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumFPList = nil) then
  begin
    FNumFPList.free;
    FNumFPList := nil;
  end
  else
  begin
    if FNumFPList = nil then
      FNumFPList := TFhirIntegerList.Create;
    FNumFPList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumFPList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumFNList = nil) then
  begin
    FNumFNList.free;
    FNumFNList := nil;
  end
  else
  begin
    if FNumFNList = nil then
      FNumFNList := TFhirIntegerList.Create;
    FNumFNList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumFNList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FPrecisionList = nil) then
  begin
    FPrecisionList.free;
    FPrecisionList := nil;
  end
  else
  begin
    if FPrecisionList = nil then
      FPrecisionList := TFhirDecimalList.Create;
    FPrecisionList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FPrecisionList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FSensitivityList = nil) then
  begin
    FSensitivityList.free;
    FSensitivityList := nil;
  end
  else
  begin
    if FSensitivityList = nil then
      FSensitivityList := TFhirDecimalList.Create;
    FSensitivityList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FSensitivityList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FFMeasureList = nil) then
  begin
    FFMeasureList.free;
    FFMeasureList := nil;
  end
  else
  begin
    if FFMeasureList = nil then
      FFMeasureList := TFhirDecimalList.Create;
    FFMeasureList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FFMeasureList);
  end;
end;

procedure TFhirMolecularSequenceQualityRoc.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'score') Then
    list.addAll(self, 'score', FScoreList);
  if (child_name = 'numTP') Then
    list.addAll(self, 'numTP', FNumTPList);
  if (child_name = 'numFP') Then
    list.addAll(self, 'numFP', FNumFPList);
  if (child_name = 'numFN') Then
    list.addAll(self, 'numFN', FNumFNList);
  if (child_name = 'precision') Then
    list.addAll(self, 'precision', FPrecisionList);
  if (child_name = 'sensitivity') Then
    list.addAll(self, 'sensitivity', FSensitivityList);
  if (child_name = 'fMeasure') Then
    list.addAll(self, 'fMeasure', FFMeasureList);
end;

procedure TFhirMolecularSequenceQualityRoc.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'score', 'integer', true, TFhirInteger, FScoreList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'numTP', 'integer', true, TFhirInteger, FNumTPList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'numFP', 'integer', true, TFhirInteger, FNumFPList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'numFN', 'integer', true, TFhirInteger, FNumFNList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'precision', 'decimal', true, TFhirDecimal, FPrecisionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'sensitivity', 'decimal', true, TFhirDecimal, FSensitivityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'fMeasure', 'decimal', true, TFhirDecimal, FFMeasureList.Link)) {L1039};
end;

function TFhirMolecularSequenceQualityRoc.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'score') then
  begin
    ScoreList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numTP') then
  begin
    NumTPList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numFP') then
  begin
    NumFPList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numFN') then
  begin
    NumFNList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'precision') then
  begin
    PrecisionList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else if (propName = 'sensitivity') then
  begin
    SensitivityList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else if (propName = 'fMeasure') then
  begin
    FMeasureList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceQualityRoc.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'score') then ScoreList.insertItem(index, asInteger(propValue)) {L1045}
  else if (propName = 'numTP') then NumTPList.insertItem(index, asInteger(propValue)) {L1045}
  else if (propName = 'numFP') then NumFPList.insertItem(index, asInteger(propValue)) {L1045}
  else if (propName = 'numFN') then NumFNList.insertItem(index, asInteger(propValue)) {L1045}
  else if (propName = 'precision') then PrecisionList.insertItem(index, asDecimal(propValue)) {L1045}
  else if (propName = 'sensitivity') then SensitivityList.insertItem(index, asDecimal(propValue)) {L1045}
  else if (propName = 'fMeasure') then FMeasureList.insertItem(index, asDecimal(propValue)) {L1045}
  else inherited;
end;

function TFhirMolecularSequenceQualityRoc.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'score') then result := ScoreList.new() {L1053}
  else if (propName = 'numTP') then result := NumTPList.new() {L1053}
  else if (propName = 'numFP') then result := NumFPList.new() {L1053}
  else if (propName = 'numFN') then result := NumFNList.new() {L1053}
  else if (propName = 'precision') then result := PrecisionList.new() {L1053}
  else if (propName = 'sensitivity') then result := SensitivityList.new() {L1053}
  else if (propName = 'fMeasure') then result := FMeasureList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceQualityRoc.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'score') then result := 'integer'
  else if (propName = 'numTP') then result := 'integer'
  else if (propName = 'numFP') then result := 'integer'
  else if (propName = 'numFN') then result := 'integer'
  else if (propName = 'precision') then result := 'decimal'
  else if (propName = 'sensitivity') then result := 'decimal'
  else if (propName = 'fMeasure') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceQualityRoc.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'score') then deletePropertyValue('score', ScoreList, value) {L1054}
  else if (propName = 'numTP') then deletePropertyValue('numTP', NumTPList, value) {L1054}
  else if (propName = 'numFP') then deletePropertyValue('numFP', NumFPList, value) {L1054}
  else if (propName = 'numFN') then deletePropertyValue('numFN', NumFNList, value) {L1054}
  else if (propName = 'precision') then deletePropertyValue('precision', PrecisionList, value) {L1054}
  else if (propName = 'sensitivity') then deletePropertyValue('sensitivity', SensitivityList, value) {L1054}
  else if (propName = 'fMeasure') then deletePropertyValue('fMeasure', FMeasureList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceQualityRoc.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'score') then replacePropertyValue('score', ScoreList, existing, new) {L1055}
  else if (propName = 'numTP') then replacePropertyValue('numTP', NumTPList, existing, new) {L1055}
  else if (propName = 'numFP') then replacePropertyValue('numFP', NumFPList, existing, new) {L1055}
  else if (propName = 'numFN') then replacePropertyValue('numFN', NumFNList, existing, new) {L1055}
  else if (propName = 'precision') then replacePropertyValue('precision', PrecisionList, existing, new) {L1055}
  else if (propName = 'sensitivity') then replacePropertyValue('sensitivity', SensitivityList, existing, new) {L1055}
  else if (propName = 'fMeasure') then replacePropertyValue('fMeasure', FMeasureList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceQualityRoc.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'score') then ScoreList.move(source, destination) {L1046}
  else if (propName = 'numTP') then NumTPList.move(source, destination) {L1046}
  else if (propName = 'numFP') then NumFPList.move(source, destination) {L1046}
  else if (propName = 'numFN') then NumFNList.move(source, destination) {L1046}
  else if (propName = 'precision') then PrecisionList.move(source, destination) {L1046}
  else if (propName = 'sensitivity') then SensitivityList.move(source, destination) {L1046}
  else if (propName = 'fMeasure') then FMeasureList.move(source, destination) {L1046}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceQualityRoc.fhirType : string;
begin
  result := 'MolecularSequence.quality.roc';
end;

function TFhirMolecularSequenceQualityRoc.Link : TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(inherited Link);
end;

function TFhirMolecularSequenceQualityRoc.Clone : TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(inherited Clone);
end;

function TFhirMolecularSequenceQualityRoc.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceQualityRoc;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceQualityRoc)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceQualityRoc(other);
    result := compareDeep(scoreList, o.scoreList, true) and compareDeep(numTPList, o.numTPList, true) and 
      compareDeep(numFPList, o.numFPList, true) and compareDeep(numFNList, o.numFNList, true) and 
      compareDeep(precisionList, o.precisionList, true) and compareDeep(sensitivityList, o.sensitivityList, true) and 
      compareDeep(fMeasureList, o.fMeasureList, true);
  end;
end;

function TFhirMolecularSequenceQualityRoc.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FscoreList) and isEmptyProp(FnumTPList) and isEmptyProp(FnumFPList) and isEmptyProp(FnumFNList) and isEmptyProp(FprecisionList) and isEmptyProp(FsensitivityList) and isEmptyProp(FfMeasureList);
end;

function TFhirMolecularSequenceQualityRoc.GetScoreList : TFhirIntegerList;
begin
  if FScoreList = nil then
    FScoreList := TFhirIntegerList.Create;
  result := FScoreList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasScoreList : boolean;
begin
  result := (FScoreList <> nil) and (FScoreList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumTPList : TFhirIntegerList;
begin
  if FNumTPList = nil then
    FNumTPList := TFhirIntegerList.Create;
  result := FNumTPList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumTPList : boolean;
begin
  result := (FNumTPList <> nil) and (FNumTPList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumFPList : TFhirIntegerList;
begin
  if FNumFPList = nil then
    FNumFPList := TFhirIntegerList.Create;
  result := FNumFPList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumFPList : boolean;
begin
  result := (FNumFPList <> nil) and (FNumFPList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumFNList : TFhirIntegerList;
begin
  if FNumFNList = nil then
    FNumFNList := TFhirIntegerList.Create;
  result := FNumFNList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumFNList : boolean;
begin
  result := (FNumFNList <> nil) and (FNumFNList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetPrecisionList : TFhirDecimalList;
begin
  if FPrecisionList = nil then
    FPrecisionList := TFhirDecimalList.Create;
  result := FPrecisionList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasPrecisionList : boolean;
begin
  result := (FPrecisionList <> nil) and (FPrecisionList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetSensitivityList : TFhirDecimalList;
begin
  if FSensitivityList = nil then
    FSensitivityList := TFhirDecimalList.Create;
  result := FSensitivityList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasSensitivityList : boolean;
begin
  result := (FSensitivityList <> nil) and (FSensitivityList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetFMeasureList : TFhirDecimalList;
begin
  if FFMeasureList = nil then
    FFMeasureList := TFhirDecimalList.Create;
  result := FFMeasureList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasFMeasureList : boolean;
begin
  result := (FFMeasureList <> nil) and (FFMeasureList.count > 0);
end;

procedure TFhirMolecularSequenceQualityRoc.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('score');
  fields.add('numTP');
  fields.add('numFP');
  fields.add('numFN');
  fields.add('precision');
  fields.add('sensitivity');
  fields.add('fMeasure');
end;

function TFhirMolecularSequenceQualityRoc.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FscoreList.sizeInBytes);
  inc(result, FnumTPList.sizeInBytes);
  inc(result, FnumFPList.sizeInBytes);
  inc(result, FnumFNList.sizeInBytes);
  inc(result, FprecisionList.sizeInBytes);
  inc(result, FsensitivityList.sizeInBytes);
  inc(result, FfMeasureList.sizeInBytes);
end;

{ TFhirMolecularSequenceQualityRocListEnumerator }

constructor TFhirMolecularSequenceQualityRocListEnumerator.Create(list : TFhirMolecularSequenceQualityRocList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceQualityRocListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceQualityRocListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceQualityRocListEnumerator.GetCurrent : TFhirMolecularSequenceQualityRoc;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceQualityRocListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceQualityRocList }

procedure TFhirMolecularSequenceQualityRocList.AddItem(value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceQualityRoc', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceQualityRoc');
  add(value);
end;

function TFhirMolecularSequenceQualityRocList.Append: TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityRocList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceQualityRocList.GetEnumerator : TFhirMolecularSequenceQualityRocListEnumerator;
begin
  result := TFhirMolecularSequenceQualityRocListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceQualityRocList.Clone: TFhirMolecularSequenceQualityRocList;
begin
  result := TFhirMolecularSequenceQualityRocList(inherited Clone);
end;

function TFhirMolecularSequenceQualityRocList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceQualityRocList.GetItemN(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityRocList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceQualityRoc;
end;
function TFhirMolecularSequenceQualityRocList.IndexOf(value: TFhirMolecularSequenceQualityRoc): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceQualityRocList.Insert(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityRocList.InsertItem(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceQualityRocList.Item(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityRocList.Link: TFhirMolecularSequenceQualityRocList;
begin
  result := TFhirMolecularSequenceQualityRocList(inherited Link);
end;

procedure TFhirMolecularSequenceQualityRocList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceQualityRocList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  FhirMolecularSequenceQualityRocs[index] := value;
end;

procedure TFhirMolecularSequenceQualityRocList.SetItemN(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceRepository }

constructor TFhirMolecularSequenceRepository.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceRepository.Destroy;
begin
  FType_.free;
  FUrl.free;
  FName.free;
  FDatasetId.free;
  FVariantsetId.free;
  FReadsetId.free;
  inherited;
end;

procedure TFhirMolecularSequenceRepository.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirMolecularSequenceRepository(oSource).type_Element.Clone;
  urlElement := TFhirMolecularSequenceRepository(oSource).urlElement.Clone;
  nameElement := TFhirMolecularSequenceRepository(oSource).nameElement.Clone;
  datasetIdElement := TFhirMolecularSequenceRepository(oSource).datasetIdElement.Clone;
  variantsetIdElement := TFhirMolecularSequenceRepository(oSource).variantsetIdElement.Clone;
  readsetIdElement := TFhirMolecularSequenceRepository(oSource).readsetIdElement.Clone;
end;

procedure TFhirMolecularSequenceRepository.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'datasetId') Then
     list.add(self.link, 'datasetId', FDatasetId.Link);
  if (child_name = 'variantsetId') Then
     list.add(self.link, 'variantsetId', FVariantsetId.Link);
  if (child_name = 'readsetId') Then
     list.add(self.link, 'readsetId', FReadsetId.Link);
end;

procedure TFhirMolecularSequenceRepository.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'datasetId', 'string', false, TFhirString, FDatasetId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'variantsetId', 'string', false, TFhirString, FVariantsetId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'readsetId', 'string', false, TFhirString, FReadsetId.Link)); {L1172}
end;

function TFhirMolecularSequenceRepository.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'datasetId') then
  begin
    DatasetIdElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'variantsetId') then
  begin
    VariantsetIdElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'readsetId') then
  begin
    ReadsetIdElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceRepository.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceRepository.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirRepositoryTypeEnum[RepositoryTypeNull], CODES_TFhirRepositoryTypeEnum[RepositoryTypeNull])  {L1211}
  else if (propName = 'url') then result := TFhirUri.create() {L1223}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'datasetId') then result := TFhirString.create() {L1223}
  else if (propName = 'variantsetId') then result := TFhirString.create() {L1223}
  else if (propName = 'readsetId') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceRepository.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'datasetId') then result := 'string'
  else if (propName = 'variantsetId') then result := 'string'
  else if (propName = 'readsetId') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceRepository.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'datasetId') then DatasetIdElement := nil
  else if (propName = 'variantsetId') then VariantsetIdElement := nil
  else if (propName = 'readsetId') then ReadsetIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceRepository.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, new) {L1210}
  else if (propName = 'url') then UrlElement := asUri(new) {L1222}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'datasetId') then DatasetIdElement := asString(new) {L1222}
  else if (propName = 'variantsetId') then VariantsetIdElement := asString(new) {L1222}
  else if (propName = 'readsetId') then ReadsetIdElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceRepository.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceRepository.fhirType : string;
begin
  result := 'MolecularSequence.repository';
end;

function TFhirMolecularSequenceRepository.Link : TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(inherited Link);
end;

function TFhirMolecularSequenceRepository.Clone : TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(inherited Clone);
end;

function TFhirMolecularSequenceRepository.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceRepository;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceRepository)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceRepository(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(datasetIdElement, o.datasetIdElement, true) and 
      compareDeep(variantsetIdElement, o.variantsetIdElement, true) and compareDeep(readsetIdElement, o.readsetIdElement, true);
  end;
end;

function TFhirMolecularSequenceRepository.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUrl) and isEmptyProp(FName) and isEmptyProp(FDatasetId) and isEmptyProp(FVariantsetId) and isEmptyProp(FReadsetId);
end;

procedure TFhirMolecularSequenceRepository.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequenceRepository.GetType_ST : TFhirRepositoryTypeEnum;
begin
  if FType_ = nil then
    result := TFhirRepositoryTypeEnum(0)
  else
    result := TFhirRepositoryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRepositoryTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequenceRepository.SetType_ST(value : TFhirRepositoryTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirRepositoryTypeEnum[value], CODES_TFhirRepositoryTypeEnum[value]);
end;

procedure TFhirMolecularSequenceRepository.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value; {L1134}
end;

function TFhirMolecularSequenceRepository.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirMolecularSequenceRepository.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirMolecularSequenceRepository.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMolecularSequenceRepository.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetDatasetId(value : TFhirString);
begin
  FDatasetId.free;
  FDatasetId := value; {L1134}
end;

function TFhirMolecularSequenceRepository.GetDatasetIdST : String;
begin
  if FDatasetId = nil then
    result := ''
  else
    result := FDatasetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetDatasetIdST(value : String);
begin
  if value <> '' then
  begin
    if FDatasetId = nil then
      FDatasetId := TFhirString.create;
    FDatasetId.value := value
  end
  else if FDatasetId <> nil then
    FDatasetId.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetVariantsetId(value : TFhirString);
begin
  FVariantsetId.free;
  FVariantsetId := value; {L1134}
end;

function TFhirMolecularSequenceRepository.GetVariantsetIdST : String;
begin
  if FVariantsetId = nil then
    result := ''
  else
    result := FVariantsetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetVariantsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FVariantsetId = nil then
      FVariantsetId := TFhirString.create;
    FVariantsetId.value := value
  end
  else if FVariantsetId <> nil then
    FVariantsetId.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetReadsetId(value : TFhirString);
begin
  FReadsetId.free;
  FReadsetId := value; {L1134}
end;

function TFhirMolecularSequenceRepository.GetReadsetIdST : String;
begin
  if FReadsetId = nil then
    result := ''
  else
    result := FReadsetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetReadsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FReadsetId = nil then
      FReadsetId := TFhirString.create;
    FReadsetId.value := value
  end
  else if FReadsetId <> nil then
    FReadsetId.value := '';
end;

procedure TFhirMolecularSequenceRepository.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('url');
  fields.add('name');
  fields.add('datasetId');
  fields.add('variantsetId');
  fields.add('readsetId');
end;

function TFhirMolecularSequenceRepository.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDatasetId.sizeInBytes);
  inc(result, FVariantsetId.sizeInBytes);
  inc(result, FReadsetId.sizeInBytes);
end;

{ TFhirMolecularSequenceRepositoryListEnumerator }

constructor TFhirMolecularSequenceRepositoryListEnumerator.Create(list : TFhirMolecularSequenceRepositoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceRepositoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceRepositoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceRepositoryListEnumerator.GetCurrent : TFhirMolecularSequenceRepository;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceRepositoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceRepositoryList }

procedure TFhirMolecularSequenceRepositoryList.AddItem(value: TFhirMolecularSequenceRepository);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceRepository', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceRepository');
  add(value);
end;

function TFhirMolecularSequenceRepositoryList.Append: TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceRepositoryList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceRepositoryList.GetEnumerator : TFhirMolecularSequenceRepositoryListEnumerator;
begin
  result := TFhirMolecularSequenceRepositoryListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceRepositoryList.Clone: TFhirMolecularSequenceRepositoryList;
begin
  result := TFhirMolecularSequenceRepositoryList(inherited Clone);
end;

function TFhirMolecularSequenceRepositoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceRepositoryList.GetItemN(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceRepositoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceRepository;
end;
function TFhirMolecularSequenceRepositoryList.IndexOf(value: TFhirMolecularSequenceRepository): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceRepositoryList.Insert(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceRepositoryList.InsertItem(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceRepositoryList.Item(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceRepositoryList.Link: TFhirMolecularSequenceRepositoryList;
begin
  result := TFhirMolecularSequenceRepositoryList(inherited Link);
end;

procedure TFhirMolecularSequenceRepositoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceRepositoryList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  FhirMolecularSequenceRepositories[index] := value;
end;

procedure TFhirMolecularSequenceRepositoryList.SetItemN(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariant }

constructor TFhirMolecularSequenceStructureVariant.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariant.Destroy;
begin
  FVariantType.free;
  FExact.free;
  FLength.free;
  FOuter.free;
  FInner.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariant.Assign(oSource : TFslObject);
begin
  inherited;
  variantType := TFhirMolecularSequenceStructureVariant(oSource).variantType.Clone;
  exactElement := TFhirMolecularSequenceStructureVariant(oSource).exactElement.Clone;
  lengthElement := TFhirMolecularSequenceStructureVariant(oSource).lengthElement.Clone;
  outer := TFhirMolecularSequenceStructureVariant(oSource).outer.Clone;
  inner := TFhirMolecularSequenceStructureVariant(oSource).inner.Clone;
end;

procedure TFhirMolecularSequenceStructureVariant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'variantType') Then
     list.add(self.link, 'variantType', FVariantType.Link);
  if (child_name = 'exact') Then
     list.add(self.link, 'exact', FExact.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'outer') Then
     list.add(self.link, 'outer', FOuter.Link);
  if (child_name = 'inner') Then
     list.add(self.link, 'inner', FInner.Link);
end;

procedure TFhirMolecularSequenceStructureVariant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'variantType', 'CodeableConcept', false, TFhirCodeableConcept, FVariantType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'exact', 'boolean', false, TFhirBoolean, FExact.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outer', 'BackboneElement', false, TFhirMolecularSequenceStructureVariantOuter, FOuter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'inner', 'BackboneElement', false, TFhirMolecularSequenceStructureVariantInner, FInner.Link)); {L1172}
end;

function TFhirMolecularSequenceStructureVariant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'variantType') then
  begin
    VariantType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'exact') then
  begin
    ExactElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'outer') then
  begin
    Outer := propValue as TFhirMolecularSequenceStructureVariantOuter {L1199};
    result := propValue;
  end
  else if (propName = 'inner') then
  begin
    Inner := propValue as TFhirMolecularSequenceStructureVariantInner {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'variantType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'exact') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'length') then result := TFhirInteger.create() {L1223}
  else if (propName = 'outer') then result := TFhirMolecularSequenceStructureVariantOuter.create() {L1203}
  else if (propName = 'inner') then result := TFhirMolecularSequenceStructureVariantInner.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'variantType') then result := 'CodeableConcept'
  else if (propName = 'exact') then result := 'boolean'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'outer') then result := 'BackboneElement'
  else if (propName = 'inner') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'variantType') then VariantTypeElement := nil
  else if (propName = 'exact') then ExactElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'outer') then OuterElement := nil
  else if (propName = 'inner') then InnerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'variantType') then VariantTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'exact') then ExactElement := asBoolean(new) {L1222}
  else if (propName = 'length') then LengthElement := asInteger(new) {L1222}
  else if (propName = 'outer') then OuterElement := new as TFhirMolecularSequenceStructureVariantOuter {L1195}
  else if (propName = 'inner') then InnerElement := new as TFhirMolecularSequenceStructureVariantInner {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariant.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant';
end;

function TFhirMolecularSequenceStructureVariant.Link : TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(inherited Link);
end;

function TFhirMolecularSequenceStructureVariant.Clone : TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariant.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariant)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariant(other);
    result := compareDeep(variantTypeElement, o.variantTypeElement, true) and compareDeep(exactElement, o.exactElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(outerElement, o.outerElement, true) and 
      compareDeep(innerElement, o.innerElement, true);
  end;
end;

function TFhirMolecularSequenceStructureVariant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVariantType) and isEmptyProp(FExact) and isEmptyProp(FLength) and isEmptyProp(FOuter) and isEmptyProp(FInner);
end;

procedure TFhirMolecularSequenceStructureVariant.SetVariantType(value : TFhirCodeableConcept);
begin
  FVariantType.free;
  FVariantType := value; {L1134}
end;

procedure TFhirMolecularSequenceStructureVariant.SetExact(value : TFhirBoolean);
begin
  FExact.free;
  FExact := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariant.GetExactST : Boolean;
begin
  if FExact = nil then
    result := false
  else
    result := FExact.value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetExactST(value : Boolean);
begin
  if FExact = nil then
    FExact := TFhirBoolean.create;
  FExact.value := value
end;

procedure TFhirMolecularSequenceStructureVariant.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariant.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirMolecularSequenceStructureVariant.SetOuter(value : TFhirMolecularSequenceStructureVariantOuter);
begin
  FOuter.free;
  FOuter := value; {L1134}
end;

procedure TFhirMolecularSequenceStructureVariant.SetInner(value : TFhirMolecularSequenceStructureVariantInner);
begin
  FInner.free;
  FInner := value; {L1134}
end;

procedure TFhirMolecularSequenceStructureVariant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('variantType');
  fields.add('exact');
  fields.add('length');
  fields.add('outer');
  fields.add('inner');
end;

function TFhirMolecularSequenceStructureVariant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FVariantType.sizeInBytes);
  inc(result, FExact.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FOuter.sizeInBytes);
  inc(result, FInner.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantListEnumerator }

constructor TFhirMolecularSequenceStructureVariantListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariant;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantList }

procedure TFhirMolecularSequenceStructureVariantList.AddItem(value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariant');
  add(value);
end;

function TFhirMolecularSequenceStructureVariantList.Append: TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantList.GetEnumerator : TFhirMolecularSequenceStructureVariantListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantList.Clone: TFhirMolecularSequenceStructureVariantList;
begin
  result := TFhirMolecularSequenceStructureVariantList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariant;
end;
function TFhirMolecularSequenceStructureVariantList.IndexOf(value: TFhirMolecularSequenceStructureVariant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantList.Insert(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantList.Item(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantList.Link: TFhirMolecularSequenceStructureVariantList;
begin
  result := TFhirMolecularSequenceStructureVariantList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  FhirMolecularSequenceStructureVariants[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariantOuter }

constructor TFhirMolecularSequenceStructureVariantOuter.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariantOuter.Destroy;
begin
  FStart.free;
  FEnd_.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceStructureVariantOuter(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceStructureVariantOuter(oSource).end_Element.Clone;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link)); {L1172}
end;

function TFhirMolecularSequenceStructureVariantOuter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariantOuter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create() {L1223}
  else if (propName = 'end') then result := TFhirInteger.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariantOuter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new) {L1222}
  else if (propName = 'end') then End_Element := asInteger(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariantOuter.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant.outer';
end;

function TFhirMolecularSequenceStructureVariantOuter.Link : TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(inherited Link);
end;

function TFhirMolecularSequenceStructureVariantOuter.Clone : TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantOuter.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariantOuter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariantOuter)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariantOuter(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true);
  end;
end;

function TFhirMolecularSequenceStructureVariantOuter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariantOuter.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariantOuter.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantOuter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
end;

function TFhirMolecularSequenceStructureVariantOuter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantOuterListEnumerator }

constructor TFhirMolecularSequenceStructureVariantOuterListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantOuterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantOuterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariantOuter;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantOuterList }

procedure TFhirMolecularSequenceStructureVariantOuterList.AddItem(value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariantOuter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariantOuter');
  add(value);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Append: TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantOuterList.GetEnumerator : TFhirMolecularSequenceStructureVariantOuterListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantOuterListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Clone: TFhirMolecularSequenceStructureVariantOuterList;
begin
  result := TFhirMolecularSequenceStructureVariantOuterList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantOuterList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantOuterList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariantOuter;
end;
function TFhirMolecularSequenceStructureVariantOuterList.IndexOf(value: TFhirMolecularSequenceStructureVariantOuter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Insert(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Item(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Link: TFhirMolecularSequenceStructureVariantOuterList;
begin
  result := TFhirMolecularSequenceStructureVariantOuterList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  FhirMolecularSequenceStructureVariantOuters[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariantInner }

constructor TFhirMolecularSequenceStructureVariantInner.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariantInner.Destroy;
begin
  FStart.free;
  FEnd_.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariantInner.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceStructureVariantInner(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceStructureVariantInner(oSource).end_Element.Clone;
end;

procedure TFhirMolecularSequenceStructureVariantInner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
end;

procedure TFhirMolecularSequenceStructureVariantInner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link)); {L1172}
end;

function TFhirMolecularSequenceStructureVariantInner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariantInner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariantInner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create() {L1223}
  else if (propName = 'end') then result := TFhirInteger.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariantInner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariantInner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariantInner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new) {L1222}
  else if (propName = 'end') then End_Element := asInteger(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariantInner.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariantInner.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant.inner';
end;

function TFhirMolecularSequenceStructureVariantInner.Link : TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(inherited Link);
end;

function TFhirMolecularSequenceStructureVariantInner.Clone : TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantInner.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariantInner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariantInner)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariantInner(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true);
  end;
end;

function TFhirMolecularSequenceStructureVariantInner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_);
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariantInner.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirMolecularSequenceStructureVariantInner.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantInner.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
end;

function TFhirMolecularSequenceStructureVariantInner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantInnerListEnumerator }

constructor TFhirMolecularSequenceStructureVariantInnerListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantInnerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantInnerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariantInner;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceStructureVariantInnerList }

procedure TFhirMolecularSequenceStructureVariantInnerList.AddItem(value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariantInner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariantInner');
  add(value);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Append: TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantInnerList.GetEnumerator : TFhirMolecularSequenceStructureVariantInnerListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantInnerListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Clone: TFhirMolecularSequenceStructureVariantInnerList;
begin
  result := TFhirMolecularSequenceStructureVariantInnerList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantInnerList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantInnerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariantInner;
end;
function TFhirMolecularSequenceStructureVariantInnerList.IndexOf(value: TFhirMolecularSequenceStructureVariantInner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Insert(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Item(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Link: TFhirMolecularSequenceStructureVariantInnerList;
begin
  result := TFhirMolecularSequenceStructureVariantInnerList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  FhirMolecularSequenceStructureVariantInners[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequence }

constructor TFhirMolecularSequence.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequence.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoordinateSystem.free;
  FPatient.free;
  FSpecimen.free;
  FDevice.free;
  FPerformer.free;
  FQuantity.free;
  FReferenceSeq.free;
  FVariantList.Free;
  FObservedSeq.free;
  FQualityList.Free;
  FReadCoverage.free;
  FRepositoryList.Free;
  FPointerList.Free;
  FStructureVariantList.Free;
  inherited;
end;

procedure TFhirMolecularSequence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMolecularSequence(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMolecularSequence(oSource).FIdentifierList);
  end;
  type_Element := TFhirMolecularSequence(oSource).type_Element.Clone;
  coordinateSystemElement := TFhirMolecularSequence(oSource).coordinateSystemElement.Clone;
  patient := TFhirMolecularSequence(oSource).patient.Clone;
  specimen := TFhirMolecularSequence(oSource).specimen.Clone;
  device := TFhirMolecularSequence(oSource).device.Clone;
  performer := TFhirMolecularSequence(oSource).performer.Clone;
  quantity := TFhirMolecularSequence(oSource).quantity.Clone;
  referenceSeq := TFhirMolecularSequence(oSource).referenceSeq.Clone;
  if (TFhirMolecularSequence(oSource).FVariantList = nil) then
  begin
    FVariantList.free;
    FVariantList := nil;
  end
  else
  begin
    if FVariantList = nil then
      FVariantList := TFhirMolecularSequenceVariantList.Create;
    FVariantList.Assign(TFhirMolecularSequence(oSource).FVariantList);
  end;
  observedSeqElement := TFhirMolecularSequence(oSource).observedSeqElement.Clone;
  if (TFhirMolecularSequence(oSource).FQualityList = nil) then
  begin
    FQualityList.free;
    FQualityList := nil;
  end
  else
  begin
    if FQualityList = nil then
      FQualityList := TFhirMolecularSequenceQualityList.Create;
    FQualityList.Assign(TFhirMolecularSequence(oSource).FQualityList);
  end;
  readCoverageElement := TFhirMolecularSequence(oSource).readCoverageElement.Clone;
  if (TFhirMolecularSequence(oSource).FRepositoryList = nil) then
  begin
    FRepositoryList.free;
    FRepositoryList := nil;
  end
  else
  begin
    if FRepositoryList = nil then
      FRepositoryList := TFhirMolecularSequenceRepositoryList.Create;
    FRepositoryList.Assign(TFhirMolecularSequence(oSource).FRepositoryList);
  end;
  if (TFhirMolecularSequence(oSource).FPointerList = nil) then
  begin
    FPointerList.free;
    FPointerList := nil;
  end
  else
  begin
    if FPointerList = nil then
      FPointerList := TFhirReferenceList.Create;
    FPointerList.Assign(TFhirMolecularSequence(oSource).FPointerList);
  end;
  if (TFhirMolecularSequence(oSource).FStructureVariantList = nil) then
  begin
    FStructureVariantList.free;
    FStructureVariantList := nil;
  end
  else
  begin
    if FStructureVariantList = nil then
      FStructureVariantList := TFhirMolecularSequenceStructureVariantList.Create;
    FStructureVariantList.Assign(TFhirMolecularSequence(oSource).FStructureVariantList);
  end;
end;

function TFhirMolecularSequence.GetResourceType : TFhirResourceType;
begin
  result := frtMolecularSequence;
end;

procedure TFhirMolecularSequence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coordinateSystem') Then
     list.add(self.link, 'coordinateSystem', FCoordinateSystem.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'referenceSeq') Then
     list.add(self.link, 'referenceSeq', FReferenceSeq.Link);
  if (child_name = 'variant') Then
    list.addAll(self, 'variant', FVariantList);
  if (child_name = 'observedSeq') Then
     list.add(self.link, 'observedSeq', FObservedSeq.Link);
  if (child_name = 'quality') Then
    list.addAll(self, 'quality', FQualityList);
  if (child_name = 'readCoverage') Then
     list.add(self.link, 'readCoverage', FReadCoverage.Link);
  if (child_name = 'repository') Then
    list.addAll(self, 'repository', FRepositoryList);
  if (child_name = 'pointer') Then
    list.addAll(self, 'pointer', FPointerList);
  if (child_name = 'structureVariant') Then
    list.addAll(self, 'structureVariant', FStructureVariantList);
end;

procedure TFhirMolecularSequence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'coordinateSystem', 'integer', false, TFhirInteger, FCoordinateSystem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', false, TFhirReference, FSpecimen.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceSeq', 'BackboneElement', false, TFhirMolecularSequenceReferenceSeq, FReferenceSeq.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'variant', 'BackboneElement', true, TFhirMolecularSequenceVariant, FVariantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'observedSeq', 'string', false, TFhirString, FObservedSeq.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quality', 'BackboneElement', true, TFhirMolecularSequenceQuality, FQualityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'readCoverage', 'integer', false, TFhirInteger, FReadCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'repository', 'BackboneElement', true, TFhirMolecularSequenceRepository, FRepositoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'pointer', 'Reference', true, TFhirReference, FPointerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'structureVariant', 'BackboneElement', true, TFhirMolecularSequenceStructureVariant, FStructureVariantList.Link)) {L1039};
end;

function TFhirMolecularSequence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSequenceTypeEnum, CODES_TFhirSequenceTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'coordinateSystem') then
  begin
    CoordinateSystemElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'referenceSeq') then
  begin
    ReferenceSeq := propValue as TFhirMolecularSequenceReferenceSeq {L1199};
    result := propValue;
  end
  else if (propName = 'variant') then
  begin
    VariantList.add(propValue as TFhirMolecularSequenceVariant) {L1048};
    result := propValue;
  end
  else if (propName = 'observedSeq') then
  begin
    ObservedSeqElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'quality') then
  begin
    QualityList.add(propValue as TFhirMolecularSequenceQuality) {L1048};
    result := propValue;
  end
  else if (propName = 'readCoverage') then
  begin
    ReadCoverageElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'repository') then
  begin
    RepositoryList.add(propValue as TFhirMolecularSequenceRepository) {L1048};
    result := propValue;
  end
  else if (propName = 'pointer') then
  begin
    PointerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'structureVariant') then
  begin
    StructureVariantList.add(propValue as TFhirMolecularSequenceStructureVariant) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'variant') then VariantList.insertItem(index, propValue as TFhirMolecularSequenceVariant) {L1049}
  else if (propName = 'quality') then QualityList.insertItem(index, propValue as TFhirMolecularSequenceQuality) {L1049}
  else if (propName = 'repository') then RepositoryList.insertItem(index, propValue as TFhirMolecularSequenceRepository) {L1049}
  else if (propName = 'pointer') then PointerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'structureVariant') then StructureVariantList.insertItem(index, propValue as TFhirMolecularSequenceStructureVariant) {L1049}
  else inherited;
end;

function TFhirMolecularSequence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSequenceTypeEnum[SequenceTypeNull], CODES_TFhirSequenceTypeEnum[SequenceTypeNull])  {L1211}
  else if (propName = 'coordinateSystem') then result := TFhirInteger.create() {L1223}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'specimen') then result := TFhirReference.create() {L1203}
  else if (propName = 'device') then result := TFhirReference.create() {L1203}
  else if (propName = 'performer') then result := TFhirReference.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'referenceSeq') then result := TFhirMolecularSequenceReferenceSeq.create() {L1203}
  else if (propName = 'variant') then result := VariantList.new() {L1053}
  else if (propName = 'observedSeq') then result := TFhirString.create() {L1223}
  else if (propName = 'quality') then result := QualityList.new() {L1053}
  else if (propName = 'readCoverage') then result := TFhirInteger.create() {L1223}
  else if (propName = 'repository') then result := RepositoryList.new() {L1053}
  else if (propName = 'pointer') then result := PointerList.new() {L1053}
  else if (propName = 'structureVariant') then result := StructureVariantList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'coordinateSystem') then result := 'integer'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'referenceSeq') then result := 'BackboneElement'
  else if (propName = 'variant') then result := 'BackboneElement'
  else if (propName = 'observedSeq') then result := 'string'
  else if (propName = 'quality') then result := 'BackboneElement'
  else if (propName = 'readCoverage') then result := 'integer'
  else if (propName = 'repository') then result := 'BackboneElement'
  else if (propName = 'pointer') then result := 'Reference'
  else if (propName = 'structureVariant') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'referenceSeq') then ReferenceSeqElement := nil
  else if (propName = 'variant') then deletePropertyValue('variant', VariantList, value) {L1054}
  else if (propName = 'observedSeq') then ObservedSeqElement := nil
  else if (propName = 'quality') then deletePropertyValue('quality', QualityList, value) {L1054}
  else if (propName = 'readCoverage') then ReadCoverageElement := nil
  else if (propName = 'repository') then deletePropertyValue('repository', RepositoryList, value) {L1054}
  else if (propName = 'pointer') then deletePropertyValue('pointer', PointerList, value) {L1054}
  else if (propName = 'structureVariant') then deletePropertyValue('structureVariant', StructureVariantList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSequenceTypeEnum, CODES_TFhirSequenceTypeEnum, new) {L1210}
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := asInteger(new) {L1222}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference {L1195}
  else if (propName = 'device') then DeviceElement := new as TFhirReference {L1195}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'referenceSeq') then ReferenceSeqElement := new as TFhirMolecularSequenceReferenceSeq {L1195}
  else if (propName = 'variant') then replacePropertyValue('variant', VariantList, existing, new) {L1055}
  else if (propName = 'observedSeq') then ObservedSeqElement := asString(new) {L1222}
  else if (propName = 'quality') then replacePropertyValue('quality', QualityList, existing, new) {L1055}
  else if (propName = 'readCoverage') then ReadCoverageElement := asInteger(new) {L1222}
  else if (propName = 'repository') then replacePropertyValue('repository', RepositoryList, existing, new) {L1055}
  else if (propName = 'pointer') then replacePropertyValue('pointer', PointerList, existing, new) {L1055}
  else if (propName = 'structureVariant') then replacePropertyValue('structureVariant', StructureVariantList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'variant') then VariantList.move(source, destination) {L1050}
  else if (propName = 'quality') then QualityList.move(source, destination) {L1050}
  else if (propName = 'repository') then RepositoryList.move(source, destination) {L1050}
  else if (propName = 'pointer') then PointerList.move(source, destination) {L1050}
  else if (propName = 'structureVariant') then StructureVariantList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequence.fhirType : string;
begin
  result := 'MolecularSequence';
end;

function TFhirMolecularSequence.Link : TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(inherited Link);
end;

function TFhirMolecularSequence.Clone : TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(inherited Clone);
end;

function TFhirMolecularSequence.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequence)) then
    result := false
  else
  begin
    o := TFhirMolecularSequence(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(coordinateSystemElement, o.coordinateSystemElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(referenceSeqElement, o.referenceSeqElement, true) and compareDeep(variantList, o.variantList, true) and 
      compareDeep(observedSeqElement, o.observedSeqElement, true) and compareDeep(qualityList, o.qualityList, true) and 
      compareDeep(readCoverageElement, o.readCoverageElement, true) and compareDeep(repositoryList, o.repositoryList, true) and 
      compareDeep(pointerList, o.pointerList, true) and compareDeep(structureVariantList, o.structureVariantList, true);
  end;
end;

function TFhirMolecularSequence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FCoordinateSystem) and isEmptyProp(FPatient) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FPerformer) and isEmptyProp(FQuantity) and isEmptyProp(FReferenceSeq) and isEmptyProp(FvariantList) and isEmptyProp(FObservedSeq) and isEmptyProp(FqualityList) and isEmptyProp(FReadCoverage) and isEmptyProp(FrepositoryList) and isEmptyProp(FpointerList) and isEmptyProp(FstructureVariantList);
end;

function TFhirMolecularSequence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMolecularSequence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMolecularSequence.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequence.GetType_ST : TFhirSequenceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSequenceTypeEnum(0)
  else
    result := TFhirSequenceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSequenceTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequence.SetType_ST(value : TFhirSequenceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSequenceTypeEnum[value], CODES_TFhirSequenceTypeEnum[value]);
end;

procedure TFhirMolecularSequence.SetCoordinateSystem(value : TFhirInteger);
begin
  FCoordinateSystem.free;
  FCoordinateSystem := value; {L1134}
end;

function TFhirMolecularSequence.GetCoordinateSystemST : String;
begin
  if FCoordinateSystem = nil then
    result := ''
  else
    result := FCoordinateSystem.value;
end;

procedure TFhirMolecularSequence.SetCoordinateSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCoordinateSystem = nil then
      FCoordinateSystem := TFhirInteger.create;
    FCoordinateSystem.value := value
  end
  else if FCoordinateSystem <> nil then
    FCoordinateSystem.value := '';
end;

procedure TFhirMolecularSequence.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirMolecularSequence.SetSpecimen(value : TFhirReference);
begin
  FSpecimen.free;
  FSpecimen := value; {L1134}
end;

procedure TFhirMolecularSequence.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value; {L1134}
end;

procedure TFhirMolecularSequence.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value; {L1134}
end;

procedure TFhirMolecularSequence.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMolecularSequence.SetReferenceSeq(value : TFhirMolecularSequenceReferenceSeq);
begin
  FReferenceSeq.free;
  FReferenceSeq := value; {L1134}
end;

function TFhirMolecularSequence.GetVariantList : TFhirMolecularSequenceVariantList;
begin
  if FVariantList = nil then
    FVariantList := TFhirMolecularSequenceVariantList.Create;
  result := FVariantList;
end;

function TFhirMolecularSequence.GetHasVariantList : boolean;
begin
  result := (FVariantList <> nil) and (FVariantList.count > 0);
end;

procedure TFhirMolecularSequence.SetObservedSeq(value : TFhirString);
begin
  FObservedSeq.free;
  FObservedSeq := value; {L1134}
end;

function TFhirMolecularSequence.GetObservedSeqST : String;
begin
  if FObservedSeq = nil then
    result := ''
  else
    result := FObservedSeq.value;
end;

procedure TFhirMolecularSequence.SetObservedSeqST(value : String);
begin
  if value <> '' then
  begin
    if FObservedSeq = nil then
      FObservedSeq := TFhirString.create;
    FObservedSeq.value := value
  end
  else if FObservedSeq <> nil then
    FObservedSeq.value := '';
end;

function TFhirMolecularSequence.GetQualityList : TFhirMolecularSequenceQualityList;
begin
  if FQualityList = nil then
    FQualityList := TFhirMolecularSequenceQualityList.Create;
  result := FQualityList;
end;

function TFhirMolecularSequence.GetHasQualityList : boolean;
begin
  result := (FQualityList <> nil) and (FQualityList.count > 0);
end;

procedure TFhirMolecularSequence.SetReadCoverage(value : TFhirInteger);
begin
  FReadCoverage.free;
  FReadCoverage := value; {L1134}
end;

function TFhirMolecularSequence.GetReadCoverageST : String;
begin
  if FReadCoverage = nil then
    result := ''
  else
    result := FReadCoverage.value;
end;

procedure TFhirMolecularSequence.SetReadCoverageST(value : String);
begin
  if value <> '' then
  begin
    if FReadCoverage = nil then
      FReadCoverage := TFhirInteger.create;
    FReadCoverage.value := value
  end
  else if FReadCoverage <> nil then
    FReadCoverage.value := '';
end;

function TFhirMolecularSequence.GetRepositoryList : TFhirMolecularSequenceRepositoryList;
begin
  if FRepositoryList = nil then
    FRepositoryList := TFhirMolecularSequenceRepositoryList.Create;
  result := FRepositoryList;
end;

function TFhirMolecularSequence.GetHasRepositoryList : boolean;
begin
  result := (FRepositoryList <> nil) and (FRepositoryList.count > 0);
end;

function TFhirMolecularSequence.GetPointerList : TFhirReferenceList;
begin
  if FPointerList = nil then
    FPointerList := TFhirReferenceList.Create;
  result := FPointerList;
end;

function TFhirMolecularSequence.GetHasPointerList : boolean;
begin
  result := (FPointerList <> nil) and (FPointerList.count > 0);
end;

function TFhirMolecularSequence.GetStructureVariantList : TFhirMolecularSequenceStructureVariantList;
begin
  if FStructureVariantList = nil then
    FStructureVariantList := TFhirMolecularSequenceStructureVariantList.Create;
  result := FStructureVariantList;
end;

function TFhirMolecularSequence.GetHasStructureVariantList : boolean;
begin
  result := (FStructureVariantList <> nil) and (FStructureVariantList.count > 0);
end;

procedure TFhirMolecularSequence.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coordinateSystem');
  fields.add('patient');
  fields.add('specimen');
  fields.add('device');
  fields.add('performer');
  fields.add('quantity');
  fields.add('referenceSeq');
  fields.add('variant');
  fields.add('observedSeq');
  fields.add('quality');
  fields.add('readCoverage');
  fields.add('repository');
  fields.add('pointer');
  fields.add('structureVariant');
end;

function TFhirMolecularSequence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCoordinateSystem.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FSpecimen.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FReferenceSeq.sizeInBytes);
  inc(result, FvariantList.sizeInBytes);
  inc(result, FObservedSeq.sizeInBytes);
  inc(result, FqualityList.sizeInBytes);
  inc(result, FReadCoverage.sizeInBytes);
  inc(result, FrepositoryList.sizeInBytes);
  inc(result, FpointerList.sizeInBytes);
  inc(result, FstructureVariantList.sizeInBytes);
end;

{ TFhirMolecularSequenceListEnumerator }

constructor TFhirMolecularSequenceListEnumerator.Create(list : TFhirMolecularSequenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceListEnumerator.GetCurrent : TFhirMolecularSequence;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMolecularSequenceList }

procedure TFhirMolecularSequenceList.AddItem(value: TFhirMolecularSequence);
begin
  assert(value.ClassName = 'TFhirMolecularSequence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequence');
  add(value);
end;

function TFhirMolecularSequenceList.Append: TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceList.GetEnumerator : TFhirMolecularSequenceListEnumerator;
begin
  result := TFhirMolecularSequenceListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceList.Clone: TFhirMolecularSequenceList;
begin
  result := TFhirMolecularSequenceList(inherited Clone);
end;

function TFhirMolecularSequenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceList.GetItemN(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequence;
end;
function TFhirMolecularSequenceList.IndexOf(value: TFhirMolecularSequence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceList.Insert(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceList.InsertItem(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceList.Item(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceList.Link: TFhirMolecularSequenceList;
begin
  result := TFhirMolecularSequenceList(inherited Link);
end;

procedure TFhirMolecularSequenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceList.SetItemByIndex(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  FhirMolecularSequences[index] := value;
end;

procedure TFhirMolecularSequenceList.SetItemN(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONINTAKE}
{ TFhirNutritionIntakeConsumedItem }

constructor TFhirNutritionIntakeConsumedItem.Create;
begin
  inherited;
end;

destructor TFhirNutritionIntakeConsumedItem.Destroy;
begin
  FType_.free;
  FNutritionProduct.free;
  FSchedule.free;
  FAmount.free;
  FRate.free;
  FNotConsumed.free;
  FNotConsumedReason.free;
  inherited;
end;

procedure TFhirNutritionIntakeConsumedItem.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionIntakeConsumedItem(oSource).type_.Clone;
  nutritionProduct := TFhirNutritionIntakeConsumedItem(oSource).nutritionProduct.Clone;
  schedule := TFhirNutritionIntakeConsumedItem(oSource).schedule.Clone;
  amount := TFhirNutritionIntakeConsumedItem(oSource).amount.Clone;
  rate := TFhirNutritionIntakeConsumedItem(oSource).rate.Clone;
  notConsumedElement := TFhirNutritionIntakeConsumedItem(oSource).notConsumedElement.Clone;
  notConsumedReason := TFhirNutritionIntakeConsumedItem(oSource).notConsumedReason.Clone;
end;

procedure TFhirNutritionIntakeConsumedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'nutritionProduct') Then
     list.add(self.link, 'nutritionProduct', FNutritionProduct.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'rate') Then
     list.add(self.link, 'rate', FRate.Link);
  if (child_name = 'notConsumed') Then
     list.add(self.link, 'notConsumed', FNotConsumed.Link);
  if (child_name = 'notConsumedReason') Then
     list.add(self.link, 'notConsumedReason', FNotConsumedReason.Link);
end;

procedure TFhirNutritionIntakeConsumedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'nutritionProduct', 'CodeableReference', false, TFhirCodeableReference, FNutritionProduct.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rate', 'Quantity', false, TFhirQuantity, FRate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'notConsumed', 'boolean', false, TFhirBoolean, FNotConsumed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'notConsumedReason', 'CodeableConcept', false, TFhirCodeableConcept, FNotConsumedReason.Link)); {L1172}
end;

function TFhirNutritionIntakeConsumedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'nutritionProduct') then
  begin
    NutritionProduct := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'rate') then
  begin
    Rate := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'notConsumed') then
  begin
    NotConsumedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'notConsumedReason') then
  begin
    NotConsumedReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionIntakeConsumedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionIntakeConsumedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'nutritionProduct') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'schedule') then result := TFhirTiming.create() {L1203}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'rate') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'notConsumed') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'notConsumedReason') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionIntakeConsumedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'nutritionProduct') then result := 'CodeableReference'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'rate') then result := 'Quantity'
  else if (propName = 'notConsumed') then result := 'boolean'
  else if (propName = 'notConsumedReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionIntakeConsumedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'nutritionProduct') then NutritionProductElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'rate') then RateElement := nil
  else if (propName = 'notConsumed') then NotConsumedElement := nil
  else if (propName = 'notConsumedReason') then NotConsumedReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionIntakeConsumedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'nutritionProduct') then NutritionProductElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'schedule') then ScheduleElement := new as TFhirTiming {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else if (propName = 'rate') then RateElement := new as TFhirQuantity {L1195}
  else if (propName = 'notConsumed') then NotConsumedElement := asBoolean(new) {L1222}
  else if (propName = 'notConsumedReason') then NotConsumedReasonElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionIntakeConsumedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionIntakeConsumedItem.fhirType : string;
begin
  result := 'NutritionIntake.consumedItem';
end;

function TFhirNutritionIntakeConsumedItem.Link : TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem(inherited Link);
end;

function TFhirNutritionIntakeConsumedItem.Clone : TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem(inherited Clone);
end;

function TFhirNutritionIntakeConsumedItem.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionIntakeConsumedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionIntakeConsumedItem)) then
    result := false
  else
  begin
    o := TFhirNutritionIntakeConsumedItem(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nutritionProductElement, o.nutritionProductElement, true) and 
      compareDeep(scheduleElement, o.scheduleElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(rateElement, o.rateElement, true) and compareDeep(notConsumedElement, o.notConsumedElement, true) and 
      compareDeep(notConsumedReasonElement, o.notConsumedReasonElement, true);
  end;
end;

function TFhirNutritionIntakeConsumedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FNutritionProduct) and isEmptyProp(FSchedule) and isEmptyProp(FAmount) and isEmptyProp(FRate) and isEmptyProp(FNotConsumed) and isEmptyProp(FNotConsumedReason);
end;

procedure TFhirNutritionIntakeConsumedItem.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.SetNutritionProduct(value : TFhirCodeableReference);
begin
  FNutritionProduct.free;
  FNutritionProduct := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.SetRate(value : TFhirQuantity);
begin
  FRate.free;
  FRate := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.SetNotConsumed(value : TFhirBoolean);
begin
  FNotConsumed.free;
  FNotConsumed := value; {L1134}
end;

function TFhirNutritionIntakeConsumedItem.GetNotConsumedST : Boolean;
begin
  if FNotConsumed = nil then
    result := false
  else
    result := FNotConsumed.value;
end;

procedure TFhirNutritionIntakeConsumedItem.SetNotConsumedST(value : Boolean);
begin
  if FNotConsumed = nil then
    FNotConsumed := TFhirBoolean.create;
  FNotConsumed.value := value
end;

procedure TFhirNutritionIntakeConsumedItem.SetNotConsumedReason(value : TFhirCodeableConcept);
begin
  FNotConsumedReason.free;
  FNotConsumedReason := value; {L1134}
end;

procedure TFhirNutritionIntakeConsumedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('nutritionProduct');
  fields.add('schedule');
  fields.add('amount');
  fields.add('rate');
  fields.add('notConsumed');
  fields.add('notConsumedReason');
end;

function TFhirNutritionIntakeConsumedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FNutritionProduct.sizeInBytes);
  inc(result, FSchedule.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FRate.sizeInBytes);
  inc(result, FNotConsumed.sizeInBytes);
  inc(result, FNotConsumedReason.sizeInBytes);
end;

{ TFhirNutritionIntakeConsumedItemListEnumerator }

constructor TFhirNutritionIntakeConsumedItemListEnumerator.Create(list : TFhirNutritionIntakeConsumedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionIntakeConsumedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionIntakeConsumedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionIntakeConsumedItemListEnumerator.GetCurrent : TFhirNutritionIntakeConsumedItem;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionIntakeConsumedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionIntakeConsumedItemList }

procedure TFhirNutritionIntakeConsumedItemList.AddItem(value: TFhirNutritionIntakeConsumedItem);
begin
  assert(value.ClassName = 'TFhirNutritionIntakeConsumedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionIntakeConsumedItem');
  add(value);
end;

function TFhirNutritionIntakeConsumedItemList.Append: TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeConsumedItemList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionIntakeConsumedItemList.GetEnumerator : TFhirNutritionIntakeConsumedItemListEnumerator;
begin
  result := TFhirNutritionIntakeConsumedItemListEnumerator.Create(self.link);
end;

function TFhirNutritionIntakeConsumedItemList.Clone: TFhirNutritionIntakeConsumedItemList;
begin
  result := TFhirNutritionIntakeConsumedItemList(inherited Clone);
end;

function TFhirNutritionIntakeConsumedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionIntakeConsumedItemList.GetItemN(index: Integer): TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeConsumedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionIntakeConsumedItem;
end;
function TFhirNutritionIntakeConsumedItemList.IndexOf(value: TFhirNutritionIntakeConsumedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionIntakeConsumedItemList.Insert(index: Integer): TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeConsumedItemList.InsertItem(index: Integer; value: TFhirNutritionIntakeConsumedItem);
begin
  assert(value is TFhirNutritionIntakeConsumedItem);
  Inherited Insert(index, value);
end;

function TFhirNutritionIntakeConsumedItemList.Item(index: Integer): TFhirNutritionIntakeConsumedItem;
begin
  result := TFhirNutritionIntakeConsumedItem(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeConsumedItemList.Link: TFhirNutritionIntakeConsumedItemList;
begin
  result := TFhirNutritionIntakeConsumedItemList(inherited Link);
end;

procedure TFhirNutritionIntakeConsumedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionIntakeConsumedItemList.SetItemByIndex(index: Integer; value: TFhirNutritionIntakeConsumedItem);
begin
  assert(value is TFhirNutritionIntakeConsumedItem);
  FhirNutritionIntakeConsumedItems[index] := value;
end;

procedure TFhirNutritionIntakeConsumedItemList.SetItemN(index: Integer; value: TFhirNutritionIntakeConsumedItem);
begin
  assert(value is TFhirNutritionIntakeConsumedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionIntakeIngredientLabel }

constructor TFhirNutritionIntakeIngredientLabel.Create;
begin
  inherited;
end;

destructor TFhirNutritionIntakeIngredientLabel.Destroy;
begin
  FNutrient.free;
  FAmount.free;
  inherited;
end;

procedure TFhirNutritionIntakeIngredientLabel.Assign(oSource : TFslObject);
begin
  inherited;
  nutrient := TFhirNutritionIntakeIngredientLabel(oSource).nutrient.Clone;
  amount := TFhirNutritionIntakeIngredientLabel(oSource).amount.Clone;
end;

procedure TFhirNutritionIntakeIngredientLabel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'nutrient') Then
     list.add(self.link, 'nutrient', FNutrient.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirNutritionIntakeIngredientLabel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'nutrient', 'CodeableReference', false, TFhirCodeableReference, FNutrient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
end;

function TFhirNutritionIntakeIngredientLabel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'nutrient') then
  begin
    Nutrient := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionIntakeIngredientLabel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionIntakeIngredientLabel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'nutrient') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionIntakeIngredientLabel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'nutrient') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionIntakeIngredientLabel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'nutrient') then NutrientElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionIntakeIngredientLabel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'nutrient') then NutrientElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionIntakeIngredientLabel.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionIntakeIngredientLabel.fhirType : string;
begin
  result := 'NutritionIntake.ingredientLabel';
end;

function TFhirNutritionIntakeIngredientLabel.Link : TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel(inherited Link);
end;

function TFhirNutritionIntakeIngredientLabel.Clone : TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel(inherited Clone);
end;

function TFhirNutritionIntakeIngredientLabel.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionIntakeIngredientLabel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionIntakeIngredientLabel)) then
    result := false
  else
  begin
    o := TFhirNutritionIntakeIngredientLabel(other);
    result := compareDeep(nutrientElement, o.nutrientElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirNutritionIntakeIngredientLabel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNutrient) and isEmptyProp(FAmount);
end;

procedure TFhirNutritionIntakeIngredientLabel.SetNutrient(value : TFhirCodeableReference);
begin
  FNutrient.free;
  FNutrient := value; {L1134}
end;

procedure TFhirNutritionIntakeIngredientLabel.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirNutritionIntakeIngredientLabel.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('nutrient');
  fields.add('amount');
end;

function TFhirNutritionIntakeIngredientLabel.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNutrient.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirNutritionIntakeIngredientLabelListEnumerator }

constructor TFhirNutritionIntakeIngredientLabelListEnumerator.Create(list : TFhirNutritionIntakeIngredientLabelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionIntakeIngredientLabelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionIntakeIngredientLabelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionIntakeIngredientLabelListEnumerator.GetCurrent : TFhirNutritionIntakeIngredientLabel;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionIntakeIngredientLabelListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionIntakeIngredientLabelList }

procedure TFhirNutritionIntakeIngredientLabelList.AddItem(value: TFhirNutritionIntakeIngredientLabel);
begin
  assert(value.ClassName = 'TFhirNutritionIntakeIngredientLabel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionIntakeIngredientLabel');
  add(value);
end;

function TFhirNutritionIntakeIngredientLabelList.Append: TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeIngredientLabelList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionIntakeIngredientLabelList.GetEnumerator : TFhirNutritionIntakeIngredientLabelListEnumerator;
begin
  result := TFhirNutritionIntakeIngredientLabelListEnumerator.Create(self.link);
end;

function TFhirNutritionIntakeIngredientLabelList.Clone: TFhirNutritionIntakeIngredientLabelList;
begin
  result := TFhirNutritionIntakeIngredientLabelList(inherited Clone);
end;

function TFhirNutritionIntakeIngredientLabelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionIntakeIngredientLabelList.GetItemN(index: Integer): TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeIngredientLabelList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionIntakeIngredientLabel;
end;
function TFhirNutritionIntakeIngredientLabelList.IndexOf(value: TFhirNutritionIntakeIngredientLabel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionIntakeIngredientLabelList.Insert(index: Integer): TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeIngredientLabelList.InsertItem(index: Integer; value: TFhirNutritionIntakeIngredientLabel);
begin
  assert(value is TFhirNutritionIntakeIngredientLabel);
  Inherited Insert(index, value);
end;

function TFhirNutritionIntakeIngredientLabelList.Item(index: Integer): TFhirNutritionIntakeIngredientLabel;
begin
  result := TFhirNutritionIntakeIngredientLabel(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeIngredientLabelList.Link: TFhirNutritionIntakeIngredientLabelList;
begin
  result := TFhirNutritionIntakeIngredientLabelList(inherited Link);
end;

procedure TFhirNutritionIntakeIngredientLabelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionIntakeIngredientLabelList.SetItemByIndex(index: Integer; value: TFhirNutritionIntakeIngredientLabel);
begin
  assert(value is TFhirNutritionIntakeIngredientLabel);
  FhirNutritionIntakeIngredientLabels[index] := value;
end;

procedure TFhirNutritionIntakeIngredientLabelList.SetItemN(index: Integer; value: TFhirNutritionIntakeIngredientLabel);
begin
  assert(value is TFhirNutritionIntakeIngredientLabel);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionIntakePerformer }

constructor TFhirNutritionIntakePerformer.Create;
begin
  inherited;
end;

destructor TFhirNutritionIntakePerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirNutritionIntakePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirNutritionIntakePerformer(oSource).function_.Clone;
  actor := TFhirNutritionIntakePerformer(oSource).actor.Clone;
end;

procedure TFhirNutritionIntakePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirNutritionIntakePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirNutritionIntakePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionIntakePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionIntakePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionIntakePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionIntakePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionIntakePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionIntakePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionIntakePerformer.fhirType : string;
begin
  result := 'NutritionIntake.performer';
end;

function TFhirNutritionIntakePerformer.Link : TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer(inherited Link);
end;

function TFhirNutritionIntakePerformer.Clone : TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer(inherited Clone);
end;

function TFhirNutritionIntakePerformer.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionIntakePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionIntakePerformer)) then
    result := false
  else
  begin
    o := TFhirNutritionIntakePerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirNutritionIntakePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirNutritionIntakePerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirNutritionIntakePerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirNutritionIntakePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirNutritionIntakePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirNutritionIntakePerformerListEnumerator }

constructor TFhirNutritionIntakePerformerListEnumerator.Create(list : TFhirNutritionIntakePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionIntakePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionIntakePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionIntakePerformerListEnumerator.GetCurrent : TFhirNutritionIntakePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionIntakePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionIntakePerformerList }

procedure TFhirNutritionIntakePerformerList.AddItem(value: TFhirNutritionIntakePerformer);
begin
  assert(value.ClassName = 'TFhirNutritionIntakePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionIntakePerformer');
  add(value);
end;

function TFhirNutritionIntakePerformerList.Append: TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionIntakePerformerList.GetEnumerator : TFhirNutritionIntakePerformerListEnumerator;
begin
  result := TFhirNutritionIntakePerformerListEnumerator.Create(self.link);
end;

function TFhirNutritionIntakePerformerList.Clone: TFhirNutritionIntakePerformerList;
begin
  result := TFhirNutritionIntakePerformerList(inherited Clone);
end;

function TFhirNutritionIntakePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionIntakePerformerList.GetItemN(index: Integer): TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer(ObjectByIndex[index]);
end;

function TFhirNutritionIntakePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionIntakePerformer;
end;
function TFhirNutritionIntakePerformerList.IndexOf(value: TFhirNutritionIntakePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionIntakePerformerList.Insert(index: Integer): TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakePerformerList.InsertItem(index: Integer; value: TFhirNutritionIntakePerformer);
begin
  assert(value is TFhirNutritionIntakePerformer);
  Inherited Insert(index, value);
end;

function TFhirNutritionIntakePerformerList.Item(index: Integer): TFhirNutritionIntakePerformer;
begin
  result := TFhirNutritionIntakePerformer(ObjectByIndex[index]);
end;

function TFhirNutritionIntakePerformerList.Link: TFhirNutritionIntakePerformerList;
begin
  result := TFhirNutritionIntakePerformerList(inherited Link);
end;

procedure TFhirNutritionIntakePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionIntakePerformerList.SetItemByIndex(index: Integer; value: TFhirNutritionIntakePerformer);
begin
  assert(value is TFhirNutritionIntakePerformer);
  FhirNutritionIntakePerformers[index] := value;
end;

procedure TFhirNutritionIntakePerformerList.SetItemN(index: Integer; value: TFhirNutritionIntakePerformer);
begin
  assert(value is TFhirNutritionIntakePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionIntake }

constructor TFhirNutritionIntake.Create;
begin
  inherited;
end;

destructor TFhirNutritionIntake.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FRecorded.free;
  FReported.free;
  FConsumedItemList.Free;
  FIngredientLabelList.Free;
  FPerformerList.Free;
  FLocation.free;
  FDerivedFromList.Free;
  FReasonList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionIntake.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionIntake(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionIntake(oSource).FIdentifierList);
  end;
  if (TFhirNutritionIntake(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirNutritionIntake(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirNutritionIntake(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirNutritionIntake(oSource).FInstantiatesUriList);
  end;
  if (TFhirNutritionIntake(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirNutritionIntake(oSource).FBasedOnList);
  end;
  if (TFhirNutritionIntake(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirNutritionIntake(oSource).FPartOfList);
  end;
  statusElement := TFhirNutritionIntake(oSource).statusElement.Clone;
  if (TFhirNutritionIntake(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirNutritionIntake(oSource).FStatusReasonList);
  end;
  code := TFhirNutritionIntake(oSource).code.Clone;
  subject := TFhirNutritionIntake(oSource).subject.Clone;
  encounter := TFhirNutritionIntake(oSource).encounter.Clone;
  occurrence := TFhirNutritionIntake(oSource).occurrence.Clone;
  recordedElement := TFhirNutritionIntake(oSource).recordedElement.Clone;
  reported := TFhirNutritionIntake(oSource).reported.Clone;
  if (TFhirNutritionIntake(oSource).FConsumedItemList = nil) then
  begin
    FConsumedItemList.free;
    FConsumedItemList := nil;
  end
  else
  begin
    if FConsumedItemList = nil then
      FConsumedItemList := TFhirNutritionIntakeConsumedItemList.Create;
    FConsumedItemList.Assign(TFhirNutritionIntake(oSource).FConsumedItemList);
  end;
  if (TFhirNutritionIntake(oSource).FIngredientLabelList = nil) then
  begin
    FIngredientLabelList.free;
    FIngredientLabelList := nil;
  end
  else
  begin
    if FIngredientLabelList = nil then
      FIngredientLabelList := TFhirNutritionIntakeIngredientLabelList.Create;
    FIngredientLabelList.Assign(TFhirNutritionIntake(oSource).FIngredientLabelList);
  end;
  if (TFhirNutritionIntake(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirNutritionIntakePerformerList.Create;
    FPerformerList.Assign(TFhirNutritionIntake(oSource).FPerformerList);
  end;
  location := TFhirNutritionIntake(oSource).location.Clone;
  if (TFhirNutritionIntake(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirNutritionIntake(oSource).FDerivedFromList);
  end;
  if (TFhirNutritionIntake(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirNutritionIntake(oSource).FReasonList);
  end;
  if (TFhirNutritionIntake(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionIntake(oSource).FNoteList);
  end;
end;

function TFhirNutritionIntake.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionIntake;
end;

procedure TFhirNutritionIntake.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'reported[x]') or (child_name = 'reported') Then
     list.add(self.link, 'reported[x]', FReported.Link);
  if (child_name = 'consumedItem') Then
    list.addAll(self, 'consumedItem', FConsumedItemList);
  if (child_name = 'ingredientLabel') Then
    list.addAll(self, 'ingredientLabel', FIngredientLabelList);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionIntake.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorded', 'dateTime', false, TFhirDateTime, FRecorded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reported[x]', 'boolean|Reference', false, TFhirDataType, FReported.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'consumedItem', 'BackboneElement', true, TFhirNutritionIntakeConsumedItem, FConsumedItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredientLabel', 'BackboneElement', true, TFhirNutritionIntakeIngredientLabel, FIngredientLabelList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirNutritionIntakePerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirNutritionIntake.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then
  begin
    Reported := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'consumedItem') then
  begin
    ConsumedItemList.add(propValue as TFhirNutritionIntakeConsumedItem) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredientLabel') then
  begin
    IngredientLabelList.add(propValue as TFhirNutritionIntakeIngredientLabel) {L1048};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirNutritionIntakePerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionIntake.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'consumedItem') then ConsumedItemList.insertItem(index, propValue as TFhirNutritionIntakeConsumedItem) {L1049}
  else if (propName = 'ingredientLabel') then IngredientLabelList.insertItem(index, propValue as TFhirNutritionIntakeIngredientLabel) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirNutritionIntakePerformer) {L1049}
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirNutritionIntake.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := StatusReasonList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'recorded') then result := TFhirDateTime.create() {L1223}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then raise EFHIRException.create('Cannot make property Reported') {L1191}
  else if (propName = 'consumedItem') then result := ConsumedItemList.new() {L1053}
  else if (propName = 'ingredientLabel') then result := IngredientLabelList.new() {L1053}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'derivedFrom') then result := DerivedFromList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionIntake.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'recorded') then result := 'dateTime'
  else if (propName = 'reported[x]') then result := 'boolean|Reference'
  else if (propName = 'consumedItem') then result := 'BackboneElement'
  else if (propName = 'ingredientLabel') then result := 'BackboneElement'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionIntake.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'recorded') then RecordedElement := nil
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := nil {L1189}
  else if (propName = 'consumedItem') then deletePropertyValue('consumedItem', ConsumedItemList, value) {L1054}
  else if (propName = 'ingredientLabel') then deletePropertyValue('ingredientLabel', IngredientLabelList, value) {L1054}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionIntake.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'recorded') then RecordedElement := asDateTime(new) {L1222}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := new as TFhirDataType {L1190}
  else if (propName = 'consumedItem') then replacePropertyValue('consumedItem', ConsumedItemList, existing, new) {L1055}
  else if (propName = 'ingredientLabel') then replacePropertyValue('ingredientLabel', IngredientLabelList, existing, new) {L1055}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionIntake.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination) {L1050}
  else if (propName = 'consumedItem') then ConsumedItemList.move(source, destination) {L1050}
  else if (propName = 'ingredientLabel') then IngredientLabelList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionIntake.fhirType : string;
begin
  result := 'NutritionIntake';
end;

function TFhirNutritionIntake.Link : TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake(inherited Link);
end;

function TFhirNutritionIntake.Clone : TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake(inherited Clone);
end;

function TFhirNutritionIntake.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionIntake;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionIntake)) then
    result := false
  else
  begin
    o := TFhirNutritionIntake(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(recordedElement, o.recordedElement, true) and 
      compareDeep(reportedElement, o.reportedElement, true) and compareDeep(consumedItemList, o.consumedItemList, true) and 
      compareDeep(ingredientLabelList, o.ingredientLabelList, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(derivedFromList, o.derivedFromList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionIntake.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FRecorded) and isEmptyProp(FReported) and isEmptyProp(FconsumedItemList) and isEmptyProp(FingredientLabelList) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FderivedFromList) and isEmptyProp(FreasonList) and isEmptyProp(FnoteList);
end;

function TFhirNutritionIntake.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionIntake.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirNutritionIntake.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirNutritionIntake.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirNutritionIntake.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirNutritionIntake.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirNutritionIntake.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirNutritionIntake.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirNutritionIntake.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirNutritionIntake.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirNutritionIntake.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionIntake.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirNutritionIntake.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

function TFhirNutritionIntake.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirNutritionIntake.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirNutritionIntake.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirNutritionIntake.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirNutritionIntake.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirNutritionIntake.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirNutritionIntake.SetRecorded(value : TFhirDateTime);
begin
  FRecorded.free;
  FRecorded := value; {L1134}
end;

function TFhirNutritionIntake.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirNutritionIntake.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirDateTime.create;
  FRecorded.value := value
end;

procedure TFhirNutritionIntake.SetReported(value : TFhirDataType);
begin
  FReported.free;
  FReported := value; {L1134}
end;

function TFhirNutritionIntake.GetConsumedItemList : TFhirNutritionIntakeConsumedItemList;
begin
  if FConsumedItemList = nil then
    FConsumedItemList := TFhirNutritionIntakeConsumedItemList.Create;
  result := FConsumedItemList;
end;

function TFhirNutritionIntake.GetHasConsumedItemList : boolean;
begin
  result := (FConsumedItemList <> nil) and (FConsumedItemList.count > 0);
end;

function TFhirNutritionIntake.GetIngredientLabelList : TFhirNutritionIntakeIngredientLabelList;
begin
  if FIngredientLabelList = nil then
    FIngredientLabelList := TFhirNutritionIntakeIngredientLabelList.Create;
  result := FIngredientLabelList;
end;

function TFhirNutritionIntake.GetHasIngredientLabelList : boolean;
begin
  result := (FIngredientLabelList <> nil) and (FIngredientLabelList.count > 0);
end;

function TFhirNutritionIntake.GetPerformerList : TFhirNutritionIntakePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirNutritionIntakePerformerList.Create;
  result := FPerformerList;
end;

function TFhirNutritionIntake.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirNutritionIntake.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

function TFhirNutritionIntake.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirNutritionIntake.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

function TFhirNutritionIntake.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirNutritionIntake.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirNutritionIntake.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionIntake.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirNutritionIntake.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('recorded');
  fields.add('reported[x]');
  fields.add('consumedItem');
  fields.add('ingredientLabel');
  fields.add('performer');
  fields.add('location');
  fields.add('derivedFrom');
  fields.add('reason');
  fields.add('note');
end;

function TFhirNutritionIntake.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusReasonList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FReported.sizeInBytes);
  inc(result, FconsumedItemList.sizeInBytes);
  inc(result, FingredientLabelList.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FderivedFromList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirNutritionIntakeListEnumerator }

constructor TFhirNutritionIntakeListEnumerator.Create(list : TFhirNutritionIntakeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionIntakeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionIntakeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionIntakeListEnumerator.GetCurrent : TFhirNutritionIntake;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionIntakeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionIntakeList }

procedure TFhirNutritionIntakeList.AddItem(value: TFhirNutritionIntake);
begin
  assert(value.ClassName = 'TFhirNutritionIntake', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionIntake');
  add(value);
end;

function TFhirNutritionIntakeList.Append: TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionIntakeList.GetEnumerator : TFhirNutritionIntakeListEnumerator;
begin
  result := TFhirNutritionIntakeListEnumerator.Create(self.link);
end;

function TFhirNutritionIntakeList.Clone: TFhirNutritionIntakeList;
begin
  result := TFhirNutritionIntakeList(inherited Clone);
end;

function TFhirNutritionIntakeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionIntakeList.GetItemN(index: Integer): TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionIntake;
end;
function TFhirNutritionIntakeList.IndexOf(value: TFhirNutritionIntake): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionIntakeList.Insert(index: Integer): TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionIntakeList.InsertItem(index: Integer; value: TFhirNutritionIntake);
begin
  assert(value is TFhirNutritionIntake);
  Inherited Insert(index, value);
end;

function TFhirNutritionIntakeList.Item(index: Integer): TFhirNutritionIntake;
begin
  result := TFhirNutritionIntake(ObjectByIndex[index]);
end;

function TFhirNutritionIntakeList.Link: TFhirNutritionIntakeList;
begin
  result := TFhirNutritionIntakeList(inherited Link);
end;

procedure TFhirNutritionIntakeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionIntakeList.SetItemByIndex(index: Integer; value: TFhirNutritionIntake);
begin
  assert(value is TFhirNutritionIntake);
  FhirNutritionIntakes[index] := value;
end;

procedure TFhirNutritionIntakeList.SetItemN(index: Integer; value: TFhirNutritionIntake);
begin
  assert(value is TFhirNutritionIntake);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONINTAKE}
{$IFDEF FHIR_NUTRITIONORDER}
{ TFhirNutritionOrderOralDiet }

constructor TFhirNutritionOrderOralDiet.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDiet.Destroy;
begin
  FType_List.Free;
  FScheduleList.Free;
  FNutrientList.Free;
  FTextureList.Free;
  FFluidConsistencyTypeList.Free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDiet.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrderOralDiet(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirNutritionOrderOralDiet(oSource).FType_List);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderOralDiet(oSource).FScheduleList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionOrderOralDiet(oSource).FNutrientList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FTextureList = nil) then
  begin
    FTextureList.free;
    FTextureList := nil;
  end
  else
  begin
    if FTextureList = nil then
      FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
    FTextureList.Assign(TFhirNutritionOrderOralDiet(oSource).FTextureList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList = nil) then
  begin
    FFluidConsistencyTypeList.free;
    FFluidConsistencyTypeList := nil;
  end
  else
  begin
    if FFluidConsistencyTypeList = nil then
      FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
    FFluidConsistencyTypeList.Assign(TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList);
  end;
  instructionElement := TFhirNutritionOrderOralDiet(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderOralDiet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'texture') Then
    list.addAll(self, 'texture', FTextureList);
  if (child_name = 'fluidConsistencyType') Then
    list.addAll(self, 'fluidConsistencyType', FFluidConsistencyTypeList);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderOralDiet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'nutrient', 'BackboneElement', true, TFhirNutritionOrderOralDietNutrient, FNutrientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'texture', 'BackboneElement', true, TFhirNutritionOrderOralDietTexture, FTextureList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'fluidConsistencyType', 'CodeableConcept', true, TFhirCodeableConcept, FFluidConsistencyTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link)); {L1172}
end;

function TFhirNutritionOrderOralDiet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming) {L1048};
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionOrderOralDietNutrient) {L1048};
    result := propValue;
  end
  else if (propName = 'texture') then
  begin
    TextureList.add(propValue as TFhirNutritionOrderOralDietTexture) {L1048};
    result := propValue;
  end
  else if (propName = 'fluidConsistencyType') then
  begin
    FluidConsistencyTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDiet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming) {L1049}
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionOrderOralDietNutrient) {L1049}
  else if (propName = 'texture') then TextureList.insertItem(index, propValue as TFhirNutritionOrderOralDietTexture) {L1049}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirNutritionOrderOralDiet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'schedule') then result := ScheduleList.new() {L1053}
  else if (propName = 'nutrient') then result := NutrientList.new() {L1053}
  else if (propName = 'texture') then result := TextureList.new() {L1053}
  else if (propName = 'fluidConsistencyType') then result := FluidConsistencyTypeList.new() {L1053}
  else if (propName = 'instruction') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDiet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'nutrient') then result := 'BackboneElement'
  else if (propName = 'texture') then result := 'BackboneElement'
  else if (propName = 'fluidConsistencyType') then result := 'CodeableConcept'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDiet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {L1054}
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value) {L1054}
  else if (propName = 'texture') then deletePropertyValue('texture', TextureList, value) {L1054}
  else if (propName = 'fluidConsistencyType') then deletePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, value) {L1054}
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDiet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {L1055}
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new) {L1055}
  else if (propName = 'texture') then replacePropertyValue('texture', TextureList, existing, new) {L1055}
  else if (propName = 'fluidConsistencyType') then replacePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, existing, new) {L1055}
  else if (propName = 'instruction') then InstructionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDiet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'schedule') then ScheduleList.move(source, destination) {L1050}
  else if (propName = 'nutrient') then NutrientList.move(source, destination) {L1050}
  else if (propName = 'texture') then TextureList.move(source, destination) {L1050}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDiet.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet';
end;

function TFhirNutritionOrderOralDiet.Link : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Link);
end;

function TFhirNutritionOrderOralDiet.Clone : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Clone);
end;

function TFhirNutritionOrderOralDiet.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDiet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDiet)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDiet(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(textureList, o.textureList, true) and 
      compareDeep(fluidConsistencyTypeList, o.fluidConsistencyTypeList, true) and compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderOralDiet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FscheduleList) and isEmptyProp(FnutrientList) and isEmptyProp(FtextureList) and isEmptyProp(FfluidConsistencyTypeList) and isEmptyProp(FInstruction);
end;

function TFhirNutritionOrderOralDiet.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirNutritionOrderOralDiet.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

function TFhirNutritionOrderOralDiet.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
  result := FNutrientList;
end;

function TFhirNutritionOrderOralDiet.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetTextureList : TFhirNutritionOrderOralDietTextureList;
begin
  if FTextureList = nil then
    FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
  result := FTextureList;
end;

function TFhirNutritionOrderOralDiet.GetHasTextureList : boolean;
begin
  result := (FTextureList <> nil) and (FTextureList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetFluidConsistencyTypeList : TFhirCodeableConceptList;
begin
  if FFluidConsistencyTypeList = nil then
    FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
  result := FFluidConsistencyTypeList;
end;

function TFhirNutritionOrderOralDiet.GetHasFluidConsistencyTypeList : boolean;
begin
  result := (FFluidConsistencyTypeList <> nil) and (FFluidConsistencyTypeList.count > 0);
end;

procedure TFhirNutritionOrderOralDiet.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value; {L1134}
end;

function TFhirNutritionOrderOralDiet.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

procedure TFhirNutritionOrderOralDiet.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

procedure TFhirNutritionOrderOralDiet.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('schedule');
  fields.add('nutrient');
  fields.add('texture');
  fields.add('fluidConsistencyType');
  fields.add('instruction');
end;

function TFhirNutritionOrderOralDiet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FnutrientList.sizeInBytes);
  inc(result, FtextureList.sizeInBytes);
  inc(result, FfluidConsistencyTypeList.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietListEnumerator }

constructor TFhirNutritionOrderOralDietListEnumerator.Create(list : TFhirNutritionOrderOralDietList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietListEnumerator.GetCurrent : TFhirNutritionOrderOralDiet;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietList }

procedure TFhirNutritionOrderOralDietList.AddItem(value: TFhirNutritionOrderOralDiet);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDiet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDiet');
  add(value);
end;

function TFhirNutritionOrderOralDietList.Append: TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietList.GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
begin
  result := TFhirNutritionOrderOralDietListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietList.Clone: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Clone);
end;

function TFhirNutritionOrderOralDietList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietList.GetItemN(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDiet;
end;
function TFhirNutritionOrderOralDietList.IndexOf(value: TFhirNutritionOrderOralDiet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietList.Insert(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietList.Item(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.Link: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  FhirNutritionOrderOralDiets[index] := value;
end;

procedure TFhirNutritionOrderOralDietList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietNutrient }

constructor TFhirNutritionOrderOralDietNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietNutrient.Destroy;
begin
  FModifier.free;
  FAmount.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietNutrient(oSource).modifier.Clone;
  amount := TFhirNutritionOrderOralDietNutrient(oSource).amount.Clone;
end;

procedure TFhirNutritionOrderOralDietNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirNutritionOrderOralDietNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
end;

function TFhirNutritionOrderOralDietNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietNutrient.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet.nutrient';
end;

function TFhirNutritionOrderOralDietNutrient.Link : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Link);
end;

function TFhirNutritionOrderOralDietNutrient.Clone : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDietNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietNutrient(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirNutritionOrderOralDietNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FAmount);
end;

procedure TFhirNutritionOrderOralDietNutrient.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value; {L1134}
end;

procedure TFhirNutritionOrderOralDietNutrient.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirNutritionOrderOralDietNutrient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('amount');
end;

function TFhirNutritionOrderOralDietNutrient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientListEnumerator }

constructor TFhirNutritionOrderOralDietNutrientListEnumerator.Create(list : TFhirNutritionOrderOralDietNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.GetCurrent : TFhirNutritionOrderOralDietNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientList }

procedure TFhirNutritionOrderOralDietNutrientList.AddItem(value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietNutrient');
  add(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Append: TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietNutrientList.GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
begin
  result := TFhirNutritionOrderOralDietNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietNutrientList.Clone: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietNutrientList.GetItemN(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietNutrient;
end;
function TFhirNutritionOrderOralDietNutrientList.IndexOf(value: TFhirNutritionOrderOralDietNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Insert(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietNutrientList.Item(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.Link: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  FhirNutritionOrderOralDietNutrients[index] := value;
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietTexture }

constructor TFhirNutritionOrderOralDietTexture.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietTexture.Destroy;
begin
  FModifier.free;
  FFoodType.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietTexture.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietTexture(oSource).modifier.Clone;
  foodType := TFhirNutritionOrderOralDietTexture(oSource).foodType.Clone;
end;

procedure TFhirNutritionOrderOralDietTexture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'foodType') Then
     list.add(self.link, 'foodType', FFoodType.Link);
end;

procedure TFhirNutritionOrderOralDietTexture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'foodType', 'CodeableConcept', false, TFhirCodeableConcept, FFoodType.Link)); {L1172}
end;

function TFhirNutritionOrderOralDietTexture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'foodType') then
  begin
    FoodType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietTexture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietTexture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'foodType') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietTexture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'foodType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietTexture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'foodType') then FoodTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietTexture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'foodType') then FoodTypeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietTexture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietTexture.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet.texture';
end;

function TFhirNutritionOrderOralDietTexture.Link : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Link);
end;

function TFhirNutritionOrderOralDietTexture.Clone : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Clone);
end;

function TFhirNutritionOrderOralDietTexture.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDietTexture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietTexture)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietTexture(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(foodTypeElement, o.foodTypeElement, true);
  end;
end;

function TFhirNutritionOrderOralDietTexture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FFoodType);
end;

procedure TFhirNutritionOrderOralDietTexture.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value; {L1134}
end;

procedure TFhirNutritionOrderOralDietTexture.SetFoodType(value : TFhirCodeableConcept);
begin
  FFoodType.free;
  FFoodType := value; {L1134}
end;

procedure TFhirNutritionOrderOralDietTexture.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('foodType');
end;

function TFhirNutritionOrderOralDietTexture.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FFoodType.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureListEnumerator }

constructor TFhirNutritionOrderOralDietTextureListEnumerator.Create(list : TFhirNutritionOrderOralDietTextureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietTextureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.GetCurrent : TFhirNutritionOrderOralDietTexture;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureList }

procedure TFhirNutritionOrderOralDietTextureList.AddItem(value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietTexture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietTexture');
  add(value);
end;

function TFhirNutritionOrderOralDietTextureList.Append: TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietTextureList.GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
begin
  result := TFhirNutritionOrderOralDietTextureListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietTextureList.Clone: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Clone);
end;

function TFhirNutritionOrderOralDietTextureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietTextureList.GetItemN(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietTexture;
end;
function TFhirNutritionOrderOralDietTextureList.IndexOf(value: TFhirNutritionOrderOralDietTexture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietTextureList.Insert(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietTextureList.Item(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.Link: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietTextureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  FhirNutritionOrderOralDietTextures[index] := value;
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderSupplement }

constructor TFhirNutritionOrderSupplement.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderSupplement.Destroy;
begin
  FType_.free;
  FProductName.free;
  FScheduleList.Free;
  FQuantity.free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderSupplement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionOrderSupplement(oSource).type_.Clone;
  productNameElement := TFhirNutritionOrderSupplement(oSource).productNameElement.Clone;
  if (TFhirNutritionOrderSupplement(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderSupplement(oSource).FScheduleList);
  end;
  quantity := TFhirNutritionOrderSupplement(oSource).quantity.Clone;
  instructionElement := TFhirNutritionOrderSupplement(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderSupplement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderSupplement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link)); {L1172}
end;

function TFhirNutritionOrderSupplement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderSupplement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming) {L1049}
  else inherited;
end;

function TFhirNutritionOrderSupplement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productName') then result := TFhirString.create() {L1223}
  else if (propName = 'schedule') then result := ScheduleList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'instruction') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderSupplement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'productName') then result := 'string'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderSupplement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderSupplement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productName') then ProductNameElement := asString(new) {L1222}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'instruction') then InstructionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderSupplement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'schedule') then ScheduleList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderSupplement.fhirType : string;
begin
  result := 'NutritionOrder.supplement';
end;

function TFhirNutritionOrderSupplement.Link : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Link);
end;

function TFhirNutritionOrderSupplement.Clone : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Clone);
end;

function TFhirNutritionOrderSupplement.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderSupplement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderSupplement)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderSupplement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(productNameElement, o.productNameElement, true) and 
      compareDeep(scheduleList, o.scheduleList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderSupplement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProductName) and isEmptyProp(FscheduleList) and isEmptyProp(FQuantity) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderSupplement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirNutritionOrderSupplement.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value; {L1134}
end;

function TFhirNutritionOrderSupplement.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

procedure TFhirNutritionOrderSupplement.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

function TFhirNutritionOrderSupplement.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

function TFhirNutritionOrderSupplement.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

procedure TFhirNutritionOrderSupplement.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirNutritionOrderSupplement.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value; {L1134}
end;

function TFhirNutritionOrderSupplement.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

procedure TFhirNutritionOrderSupplement.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

procedure TFhirNutritionOrderSupplement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('productName');
  fields.add('schedule');
  fields.add('quantity');
  fields.add('instruction');
end;

function TFhirNutritionOrderSupplement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProductName.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementListEnumerator }

constructor TFhirNutritionOrderSupplementListEnumerator.Create(list : TFhirNutritionOrderSupplementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderSupplementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderSupplementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderSupplementListEnumerator.GetCurrent : TFhirNutritionOrderSupplement;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderSupplementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementList }

procedure TFhirNutritionOrderSupplementList.AddItem(value: TFhirNutritionOrderSupplement);
begin
  assert(value.ClassName = 'TFhirNutritionOrderSupplement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderSupplement');
  add(value);
end;

function TFhirNutritionOrderSupplementList.Append: TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderSupplementList.GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
begin
  result := TFhirNutritionOrderSupplementListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderSupplementList.Clone: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Clone);
end;

function TFhirNutritionOrderSupplementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderSupplementList.GetItemN(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderSupplement;
end;
function TFhirNutritionOrderSupplementList.IndexOf(value: TFhirNutritionOrderSupplement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderSupplementList.Insert(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.InsertItem(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderSupplementList.Item(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.Link: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Link);
end;

procedure TFhirNutritionOrderSupplementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderSupplementList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  FhirNutritionOrderSupplements[index] := value;
end;

procedure TFhirNutritionOrderSupplementList.SetItemN(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormula }

constructor TFhirNutritionOrderEnteralFormula.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormula.Destroy;
begin
  FBaseFormulaType.free;
  FBaseFormulaProductName.free;
  FAdditiveType.free;
  FAdditiveProductName.free;
  FCaloricDensity.free;
  FRouteofAdministration.free;
  FAdministrationList.Free;
  FMaxVolumeToDeliver.free;
  FAdministrationInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormula.Assign(oSource : TFslObject);
begin
  inherited;
  baseFormulaType := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaType.Clone;
  baseFormulaProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaProductNameElement.Clone;
  additiveType := TFhirNutritionOrderEnteralFormula(oSource).additiveType.Clone;
  additiveProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).additiveProductNameElement.Clone;
  caloricDensity := TFhirNutritionOrderEnteralFormula(oSource).caloricDensity.Clone;
  routeofAdministration := TFhirNutritionOrderEnteralFormula(oSource).routeofAdministration.Clone;
  if (TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList = nil) then
  begin
    FAdministrationList.free;
    FAdministrationList := nil;
  end
  else
  begin
    if FAdministrationList = nil then
      FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
    FAdministrationList.Assign(TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList);
  end;
  maxVolumeToDeliver := TFhirNutritionOrderEnteralFormula(oSource).maxVolumeToDeliver.Clone;
  administrationInstructionElement := TFhirNutritionOrderEnteralFormula(oSource).administrationInstructionElement.Clone;
end;

procedure TFhirNutritionOrderEnteralFormula.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'baseFormulaType') Then
     list.add(self.link, 'baseFormulaType', FBaseFormulaType.Link);
  if (child_name = 'baseFormulaProductName') Then
     list.add(self.link, 'baseFormulaProductName', FBaseFormulaProductName.Link);
  if (child_name = 'additiveType') Then
     list.add(self.link, 'additiveType', FAdditiveType.Link);
  if (child_name = 'additiveProductName') Then
     list.add(self.link, 'additiveProductName', FAdditiveProductName.Link);
  if (child_name = 'caloricDensity') Then
     list.add(self.link, 'caloricDensity', FCaloricDensity.Link);
  if (child_name = 'routeofAdministration') Then
     list.add(self.link, 'routeofAdministration', FRouteofAdministration.Link);
  if (child_name = 'administration') Then
    list.addAll(self, 'administration', FAdministrationList);
  if (child_name = 'maxVolumeToDeliver') Then
     list.add(self.link, 'maxVolumeToDeliver', FMaxVolumeToDeliver.Link);
  if (child_name = 'administrationInstruction') Then
     list.add(self.link, 'administrationInstruction', FAdministrationInstruction.Link);
end;

procedure TFhirNutritionOrderEnteralFormula.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'baseFormulaType', 'CodeableConcept', false, TFhirCodeableConcept, FBaseFormulaType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'baseFormulaProductName', 'string', false, TFhirString, FBaseFormulaProductName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additiveType', 'CodeableConcept', false, TFhirCodeableConcept, FAdditiveType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additiveProductName', 'string', false, TFhirString, FAdditiveProductName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'caloricDensity', 'Quantity', false, TFhirQuantity, FCaloricDensity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'routeofAdministration', 'CodeableConcept', false, TFhirCodeableConcept, FRouteofAdministration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'administration', 'BackboneElement', true, TFhirNutritionOrderEnteralFormulaAdministration, FAdministrationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'maxVolumeToDeliver', 'Quantity', false, TFhirQuantity, FMaxVolumeToDeliver.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'administrationInstruction', 'string', false, TFhirString, FAdministrationInstruction.Link)); {L1172}
end;

function TFhirNutritionOrderEnteralFormula.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then
  begin
    BaseFormulaType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'baseFormulaProductName') then
  begin
    BaseFormulaProductNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'additiveType') then
  begin
    AdditiveType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'additiveProductName') then
  begin
    AdditiveProductNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'caloricDensity') then
  begin
    CaloricDensity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'routeofAdministration') then
  begin
    RouteofAdministration := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'administration') then
  begin
    AdministrationList.add(propValue as TFhirNutritionOrderEnteralFormulaAdministration) {L1048};
    result := propValue;
  end
  else if (propName = 'maxVolumeToDeliver') then
  begin
    MaxVolumeToDeliver := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'administrationInstruction') then
  begin
    AdministrationInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormula.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'administration') then AdministrationList.insertItem(index, propValue as TFhirNutritionOrderEnteralFormulaAdministration) {L1049}
  else inherited;
end;

function TFhirNutritionOrderEnteralFormula.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'baseFormulaProductName') then result := TFhirString.create() {L1223}
  else if (propName = 'additiveType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'additiveProductName') then result := TFhirString.create() {L1223}
  else if (propName = 'caloricDensity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'routeofAdministration') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'administration') then result := AdministrationList.new() {L1053}
  else if (propName = 'maxVolumeToDeliver') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'administrationInstruction') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormula.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'baseFormulaType') then result := 'CodeableConcept'
  else if (propName = 'baseFormulaProductName') then result := 'string'
  else if (propName = 'additiveType') then result := 'CodeableConcept'
  else if (propName = 'additiveProductName') then result := 'string'
  else if (propName = 'caloricDensity') then result := 'Quantity'
  else if (propName = 'routeofAdministration') then result := 'CodeableConcept'
  else if (propName = 'administration') then result := 'BackboneElement'
  else if (propName = 'maxVolumeToDeliver') then result := 'Quantity'
  else if (propName = 'administrationInstruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormula.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := nil
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := nil
  else if (propName = 'additiveType') then AdditiveTypeElement := nil
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := nil
  else if (propName = 'caloricDensity') then CaloricDensityElement := nil
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := nil
  else if (propName = 'administration') then deletePropertyValue('administration', AdministrationList, value) {L1054}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := nil
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormula.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := asString(new) {L1222}
  else if (propName = 'additiveType') then AdditiveTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := asString(new) {L1222}
  else if (propName = 'caloricDensity') then CaloricDensityElement := new as TFhirQuantity {L1195}
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'administration') then replacePropertyValue('administration', AdministrationList, existing, new) {L1055}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := new as TFhirQuantity {L1195}
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormula.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'administration') then AdministrationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormula.fhirType : string;
begin
  result := 'NutritionOrder.enteralFormula';
end;

function TFhirNutritionOrderEnteralFormula.Link : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Link);
end;

function TFhirNutritionOrderEnteralFormula.Clone : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormula.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderEnteralFormula;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormula)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormula(other);
    result := compareDeep(baseFormulaTypeElement, o.baseFormulaTypeElement, true) and 
      compareDeep(baseFormulaProductNameElement, o.baseFormulaProductNameElement, true) and 
      compareDeep(additiveTypeElement, o.additiveTypeElement, true) and compareDeep(additiveProductNameElement, o.additiveProductNameElement, true) and 
      compareDeep(caloricDensityElement, o.caloricDensityElement, true) and compareDeep(routeofAdministrationElement, o.routeofAdministrationElement, true) and 
      compareDeep(administrationList, o.administrationList, true) and compareDeep(maxVolumeToDeliverElement, o.maxVolumeToDeliverElement, true) and 
      compareDeep(administrationInstructionElement, o.administrationInstructionElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormula.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBaseFormulaType) and isEmptyProp(FBaseFormulaProductName) and isEmptyProp(FAdditiveType) and isEmptyProp(FAdditiveProductName) and isEmptyProp(FCaloricDensity) and isEmptyProp(FRouteofAdministration) and isEmptyProp(FadministrationList) and isEmptyProp(FMaxVolumeToDeliver) and isEmptyProp(FAdministrationInstruction);
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaType(value : TFhirCodeableConcept);
begin
  FBaseFormulaType.free;
  FBaseFormulaType := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductName(value : TFhirString);
begin
  FBaseFormulaProductName.free;
  FBaseFormulaProductName := value; {L1134}
end;

function TFhirNutritionOrderEnteralFormula.GetBaseFormulaProductNameST : String;
begin
  if FBaseFormulaProductName = nil then
    result := ''
  else
    result := FBaseFormulaProductName.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FBaseFormulaProductName = nil then
      FBaseFormulaProductName := TFhirString.create;
    FBaseFormulaProductName.value := value
  end
  else if FBaseFormulaProductName <> nil then
    FBaseFormulaProductName.value := '';
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveType(value : TFhirCodeableConcept);
begin
  FAdditiveType.free;
  FAdditiveType := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductName(value : TFhirString);
begin
  FAdditiveProductName.free;
  FAdditiveProductName := value; {L1134}
end;

function TFhirNutritionOrderEnteralFormula.GetAdditiveProductNameST : String;
begin
  if FAdditiveProductName = nil then
    result := ''
  else
    result := FAdditiveProductName.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FAdditiveProductName = nil then
      FAdditiveProductName := TFhirString.create;
    FAdditiveProductName.value := value
  end
  else if FAdditiveProductName <> nil then
    FAdditiveProductName.value := '';
end;

procedure TFhirNutritionOrderEnteralFormula.SetCaloricDensity(value : TFhirQuantity);
begin
  FCaloricDensity.free;
  FCaloricDensity := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormula.SetRouteofAdministration(value : TFhirCodeableConcept);
begin
  FRouteofAdministration.free;
  FRouteofAdministration := value; {L1134}
end;

function TFhirNutritionOrderEnteralFormula.GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  if FAdministrationList = nil then
    FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
  result := FAdministrationList;
end;

function TFhirNutritionOrderEnteralFormula.GetHasAdministrationList : boolean;
begin
  result := (FAdministrationList <> nil) and (FAdministrationList.count > 0);
end;

procedure TFhirNutritionOrderEnteralFormula.SetMaxVolumeToDeliver(value : TFhirQuantity);
begin
  FMaxVolumeToDeliver.free;
  FMaxVolumeToDeliver := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstruction(value : TFhirString);
begin
  FAdministrationInstruction.free;
  FAdministrationInstruction := value; {L1134}
end;

function TFhirNutritionOrderEnteralFormula.GetAdministrationInstructionST : String;
begin
  if FAdministrationInstruction = nil then
    result := ''
  else
    result := FAdministrationInstruction.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FAdministrationInstruction = nil then
      FAdministrationInstruction := TFhirString.create;
    FAdministrationInstruction.value := value
  end
  else if FAdministrationInstruction <> nil then
    FAdministrationInstruction.value := '';
end;

procedure TFhirNutritionOrderEnteralFormula.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('baseFormulaType');
  fields.add('baseFormulaProductName');
  fields.add('additiveType');
  fields.add('additiveProductName');
  fields.add('caloricDensity');
  fields.add('routeofAdministration');
  fields.add('administration');
  fields.add('maxVolumeToDeliver');
  fields.add('administrationInstruction');
end;

function TFhirNutritionOrderEnteralFormula.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBaseFormulaType.sizeInBytes);
  inc(result, FBaseFormulaProductName.sizeInBytes);
  inc(result, FAdditiveType.sizeInBytes);
  inc(result, FAdditiveProductName.sizeInBytes);
  inc(result, FCaloricDensity.sizeInBytes);
  inc(result, FRouteofAdministration.sizeInBytes);
  inc(result, FadministrationList.sizeInBytes);
  inc(result, FMaxVolumeToDeliver.sizeInBytes);
  inc(result, FAdministrationInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaListEnumerator }

constructor TFhirNutritionOrderEnteralFormulaListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormula;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaList }

procedure TFhirNutritionOrderEnteralFormulaList.AddItem(value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormula', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormula');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Append: TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaList.GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaList.Clone: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormula;
end;
function TFhirNutritionOrderEnteralFormulaList.IndexOf(value: TFhirNutritionOrderEnteralFormula): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Insert(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaList.Item(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.Link: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  FhirNutritionOrderEnteralFormulas[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

constructor TFhirNutritionOrderEnteralFormulaAdministration.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministration.Destroy;
begin
  FSchedule.free;
  FQuantity.free;
  FRate.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirNutritionOrderEnteralFormulaAdministration(oSource).schedule.Clone;
  quantity := TFhirNutritionOrderEnteralFormulaAdministration(oSource).quantity.Clone;
  rate := TFhirNutritionOrderEnteralFormulaAdministration(oSource).rate.Clone;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Quantity|Ratio', false, TFhirDataType, FRate.Link)); {L1172}
end;

function TFhirNutritionOrderEnteralFormulaAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then
  begin
    Rate := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirTiming.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then raise EFHIRException.create('Cannot make property Rate') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Quantity|Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirTiming {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.fhirType : string;
begin
  result := 'NutritionOrder.enteralFormula.administration';
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Link : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Link);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Clone : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormulaAdministration)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormulaAdministration(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule) and isEmptyProp(FQuantity) and isEmptyProp(FRate);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetRate(value : TFhirDataType);
begin
  FRate.free;
  FRate := value; {L1134}
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('schedule');
  fields.add('quantity');
  fields.add('rate[x]');
end;

function TFhirNutritionOrderEnteralFormulaAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSchedule.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator }

constructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationList }

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.AddItem(value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormulaAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormulaAdministration');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Append: TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Clone: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration;
end;
function TFhirNutritionOrderEnteralFormulaAdministrationList.IndexOf(value: TFhirNutritionOrderEnteralFormulaAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Insert(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Item(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Link: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  FhirNutritionOrderEnteralFormulaAdministrations[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrder }

constructor TFhirNutritionOrder.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrder.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FInstantiatesList.Free;
  FStatus.free;
  FIntent.free;
  FPatient.free;
  FEncounter.free;
  FDateTime.free;
  FOrderer.free;
  FAllergyIntoleranceList.Free;
  FFoodPreferenceModifierList.Free;
  FExcludeFoodModifierList.Free;
  FOralDiet.free;
  FSupplementList.Free;
  FEnteralFormula.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionOrder.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionOrder(oSource).FIdentifierList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirNutritionOrder(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirNutritionOrder(oSource).FInstantiatesUriList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesList = nil) then
  begin
    FInstantiatesList.free;
    FInstantiatesList := nil;
  end
  else
  begin
    if FInstantiatesList = nil then
      FInstantiatesList := TFhirUriList.Create;
    FInstantiatesList.Assign(TFhirNutritionOrder(oSource).FInstantiatesList);
  end;
  statusElement := TFhirNutritionOrder(oSource).statusElement.Clone;
  intentElement := TFhirNutritionOrder(oSource).intentElement.Clone;
  patient := TFhirNutritionOrder(oSource).patient.Clone;
  encounter := TFhirNutritionOrder(oSource).encounter.Clone;
  dateTimeElement := TFhirNutritionOrder(oSource).dateTimeElement.Clone;
  orderer := TFhirNutritionOrder(oSource).orderer.Clone;
  if (TFhirNutritionOrder(oSource).FAllergyIntoleranceList = nil) then
  begin
    FAllergyIntoleranceList.free;
    FAllergyIntoleranceList := nil;
  end
  else
  begin
    if FAllergyIntoleranceList = nil then
      FAllergyIntoleranceList := TFhirReferenceList.Create;
    FAllergyIntoleranceList.Assign(TFhirNutritionOrder(oSource).FAllergyIntoleranceList);
  end;
  if (TFhirNutritionOrder(oSource).FFoodPreferenceModifierList = nil) then
  begin
    FFoodPreferenceModifierList.free;
    FFoodPreferenceModifierList := nil;
  end
  else
  begin
    if FFoodPreferenceModifierList = nil then
      FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
    FFoodPreferenceModifierList.Assign(TFhirNutritionOrder(oSource).FFoodPreferenceModifierList);
  end;
  if (TFhirNutritionOrder(oSource).FExcludeFoodModifierList = nil) then
  begin
    FExcludeFoodModifierList.free;
    FExcludeFoodModifierList := nil;
  end
  else
  begin
    if FExcludeFoodModifierList = nil then
      FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
    FExcludeFoodModifierList.Assign(TFhirNutritionOrder(oSource).FExcludeFoodModifierList);
  end;
  oralDiet := TFhirNutritionOrder(oSource).oralDiet.Clone;
  if (TFhirNutritionOrder(oSource).FSupplementList = nil) then
  begin
    FSupplementList.free;
    FSupplementList := nil;
  end
  else
  begin
    if FSupplementList = nil then
      FSupplementList := TFhirNutritionOrderSupplementList.Create;
    FSupplementList.Assign(TFhirNutritionOrder(oSource).FSupplementList);
  end;
  enteralFormula := TFhirNutritionOrder(oSource).enteralFormula.Clone;
  if (TFhirNutritionOrder(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionOrder(oSource).FNoteList);
  end;
end;

function TFhirNutritionOrder.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionOrder;
end;

procedure TFhirNutritionOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'instantiates') Then
    list.addAll(self, 'instantiates', FInstantiatesList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'allergyIntolerance') Then
    list.addAll(self, 'allergyIntolerance', FAllergyIntoleranceList);
  if (child_name = 'foodPreferenceModifier') Then
    list.addAll(self, 'foodPreferenceModifier', FFoodPreferenceModifierList);
  if (child_name = 'excludeFoodModifier') Then
    list.addAll(self, 'excludeFoodModifier', FExcludeFoodModifierList);
  if (child_name = 'oralDiet') Then
     list.add(self.link, 'oralDiet', FOralDiet.Link);
  if (child_name = 'supplement') Then
    list.addAll(self, 'supplement', FSupplementList);
  if (child_name = 'enteralFormula') Then
     list.add(self.link, 'enteralFormula', FEnteralFormula.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiates', 'uri', true, TFhirUri, FInstantiatesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference', false, TFhirReference, FOrderer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allergyIntolerance', 'Reference', true, TFhirReference, FAllergyIntoleranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'foodPreferenceModifier', 'CodeableConcept', true, TFhirCodeableConcept, FFoodPreferenceModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'excludeFoodModifier', 'CodeableConcept', true, TFhirCodeableConcept, FExcludeFoodModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'oralDiet', 'BackboneElement', false, TFhirNutritionOrderOralDiet, FOralDiet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supplement', 'BackboneElement', true, TFhirNutritionOrderSupplement, FSupplementList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'enteralFormula', 'BackboneElement', false, TFhirNutritionOrderEnteralFormula, FEnteralFormula.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirNutritionOrder.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiates') then
  begin
    InstantiatesList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'allergyIntolerance') then
  begin
    AllergyIntoleranceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'foodPreferenceModifier') then
  begin
    FoodPreferenceModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'excludeFoodModifier') then
  begin
    ExcludeFoodModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'oralDiet') then
  begin
    OralDiet := propValue as TFhirNutritionOrderOralDiet {L1199};
    result := propValue;
  end
  else if (propName = 'supplement') then
  begin
    SupplementList.add(propValue as TFhirNutritionOrderSupplement) {L1048};
    result := propValue;
  end
  else if (propName = 'enteralFormula') then
  begin
    EnteralFormula := propValue as TFhirNutritionOrderEnteralFormula {L1199};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'instantiates') then InstantiatesList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'supplement') then SupplementList.insertItem(index, propValue as TFhirNutritionOrderSupplement) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirNutritionOrder.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'instantiates') then result := InstantiatesList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull])  {L1211}
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'orderer') then result := TFhirReference.create() {L1203}
  else if (propName = 'allergyIntolerance') then result := AllergyIntoleranceList.new() {L1053}
  else if (propName = 'foodPreferenceModifier') then result := FoodPreferenceModifierList.new() {L1053}
  else if (propName = 'excludeFoodModifier') then result := ExcludeFoodModifierList.new() {L1053}
  else if (propName = 'oralDiet') then result := TFhirNutritionOrderOralDiet.create() {L1203}
  else if (propName = 'supplement') then result := SupplementList.new() {L1053}
  else if (propName = 'enteralFormula') then result := TFhirNutritionOrderEnteralFormula.create() {L1203}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'instantiates') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'allergyIntolerance') then result := 'Reference'
  else if (propName = 'foodPreferenceModifier') then result := 'CodeableConcept'
  else if (propName = 'excludeFoodModifier') then result := 'CodeableConcept'
  else if (propName = 'oralDiet') then result := 'BackboneElement'
  else if (propName = 'supplement') then result := 'BackboneElement'
  else if (propName = 'enteralFormula') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrder.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'instantiates') then deletePropertyValue('instantiates', InstantiatesList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'allergyIntolerance') then deletePropertyValue('allergyIntolerance', AllergyIntoleranceList, value) {L1054}
  else if (propName = 'foodPreferenceModifier') then deletePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, value) {L1054}
  else if (propName = 'excludeFoodModifier') then deletePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, value) {L1054}
  else if (propName = 'oralDiet') then OralDietElement := nil
  else if (propName = 'supplement') then deletePropertyValue('supplement', SupplementList, value) {L1054}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'instantiates') then replacePropertyValue('instantiates', InstantiatesList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new) {L1210}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new) {L1222}
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference {L1195}
  else if (propName = 'allergyIntolerance') then replacePropertyValue('allergyIntolerance', AllergyIntoleranceList, existing, new) {L1055}
  else if (propName = 'foodPreferenceModifier') then replacePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, existing, new) {L1055}
  else if (propName = 'excludeFoodModifier') then replacePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, existing, new) {L1055}
  else if (propName = 'oralDiet') then OralDietElement := new as TFhirNutritionOrderOralDiet {L1195}
  else if (propName = 'supplement') then replacePropertyValue('supplement', SupplementList, existing, new) {L1055}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := new as TFhirNutritionOrderEnteralFormula {L1195}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'instantiates') then InstantiatesList.move(source, destination) {L1046}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.move(source, destination) {L1050}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.move(source, destination) {L1050}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.move(source, destination) {L1050}
  else if (propName = 'supplement') then SupplementList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrder.fhirType : string;
begin
  result := 'NutritionOrder';
end;

function TFhirNutritionOrder.Link : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Link);
end;

function TFhirNutritionOrder.Clone : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Clone);
end;

function TFhirNutritionOrder.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrder)) then
    result := false
  else
  begin
    o := TFhirNutritionOrder(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(instantiatesList, o.instantiatesList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(ordererElement, o.ordererElement, true) and 
      compareDeep(allergyIntoleranceList, o.allergyIntoleranceList, true) and compareDeep(foodPreferenceModifierList, o.foodPreferenceModifierList, true) and 
      compareDeep(excludeFoodModifierList, o.excludeFoodModifierList, true) and compareDeep(oralDietElement, o.oralDietElement, true) and 
      compareDeep(supplementList, o.supplementList, true) and compareDeep(enteralFormulaElement, o.enteralFormulaElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FinstantiatesList) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateTime) and isEmptyProp(FOrderer) and isEmptyProp(FallergyIntoleranceList) and isEmptyProp(FfoodPreferenceModifierList) and isEmptyProp(FexcludeFoodModifierList) and isEmptyProp(FOralDiet) and isEmptyProp(FsupplementList) and isEmptyProp(FEnteralFormula) and isEmptyProp(FnoteList);
end;

function TFhirNutritionOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirNutritionOrder.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirNutritionOrder.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesList : TFhirUriList;
begin
  if FInstantiatesList = nil then
    FInstantiatesList := TFhirUriList.Create;
  result := FInstantiatesList;
end;

function TFhirNutritionOrder.GetHasInstantiatesList : boolean;
begin
  result := (FInstantiatesList <> nil) and (FInstantiatesList.count > 0);
end;

procedure TFhirNutritionOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionOrder.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirNutritionOrder.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirNutritionOrder.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirNutritionOrder.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirNutritionOrder.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirNutritionOrder.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirNutritionOrder.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirNutritionOrder.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value; {L1134}
end;

function TFhirNutritionOrder.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

procedure TFhirNutritionOrder.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

procedure TFhirNutritionOrder.SetOrderer(value : TFhirReference);
begin
  FOrderer.free;
  FOrderer := value; {L1134}
end;

function TFhirNutritionOrder.GetAllergyIntoleranceList : TFhirReferenceList;
begin
  if FAllergyIntoleranceList = nil then
    FAllergyIntoleranceList := TFhirReferenceList.Create;
  result := FAllergyIntoleranceList;
end;

function TFhirNutritionOrder.GetHasAllergyIntoleranceList : boolean;
begin
  result := (FAllergyIntoleranceList <> nil) and (FAllergyIntoleranceList.count > 0);
end;

function TFhirNutritionOrder.GetFoodPreferenceModifierList : TFhirCodeableConceptList;
begin
  if FFoodPreferenceModifierList = nil then
    FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
  result := FFoodPreferenceModifierList;
end;

function TFhirNutritionOrder.GetHasFoodPreferenceModifierList : boolean;
begin
  result := (FFoodPreferenceModifierList <> nil) and (FFoodPreferenceModifierList.count > 0);
end;

function TFhirNutritionOrder.GetExcludeFoodModifierList : TFhirCodeableConceptList;
begin
  if FExcludeFoodModifierList = nil then
    FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
  result := FExcludeFoodModifierList;
end;

function TFhirNutritionOrder.GetHasExcludeFoodModifierList : boolean;
begin
  result := (FExcludeFoodModifierList <> nil) and (FExcludeFoodModifierList.count > 0);
end;

procedure TFhirNutritionOrder.SetOralDiet(value : TFhirNutritionOrderOralDiet);
begin
  FOralDiet.free;
  FOralDiet := value; {L1134}
end;

function TFhirNutritionOrder.GetSupplementList : TFhirNutritionOrderSupplementList;
begin
  if FSupplementList = nil then
    FSupplementList := TFhirNutritionOrderSupplementList.Create;
  result := FSupplementList;
end;

function TFhirNutritionOrder.GetHasSupplementList : boolean;
begin
  result := (FSupplementList <> nil) and (FSupplementList.count > 0);
end;

procedure TFhirNutritionOrder.SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
begin
  FEnteralFormula.free;
  FEnteralFormula := value; {L1134}
end;

function TFhirNutritionOrder.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionOrder.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirNutritionOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('instantiates');
  fields.add('status');
  fields.add('intent');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateTime');
  fields.add('orderer');
  fields.add('allergyIntolerance');
  fields.add('foodPreferenceModifier');
  fields.add('excludeFoodModifier');
  fields.add('oralDiet');
  fields.add('supplement');
  fields.add('enteralFormula');
  fields.add('note');
end;

function TFhirNutritionOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FinstantiatesList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FOrderer.sizeInBytes);
  inc(result, FallergyIntoleranceList.sizeInBytes);
  inc(result, FfoodPreferenceModifierList.sizeInBytes);
  inc(result, FexcludeFoodModifierList.sizeInBytes);
  inc(result, FOralDiet.sizeInBytes);
  inc(result, FsupplementList.sizeInBytes);
  inc(result, FEnteralFormula.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirNutritionOrderListEnumerator }

constructor TFhirNutritionOrderListEnumerator.Create(list : TFhirNutritionOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderListEnumerator.GetCurrent : TFhirNutritionOrder;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderList }

procedure TFhirNutritionOrderList.AddItem(value: TFhirNutritionOrder);
begin
  assert(value.ClassName = 'TFhirNutritionOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrder');
  add(value);
end;

function TFhirNutritionOrderList.Append: TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderList.GetEnumerator : TFhirNutritionOrderListEnumerator;
begin
  result := TFhirNutritionOrderListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderList.Clone: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Clone);
end;

function TFhirNutritionOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderList.GetItemN(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrder;
end;
function TFhirNutritionOrderList.IndexOf(value: TFhirNutritionOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderList.Insert(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.InsertItem(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderList.Item(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.Link: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Link);
end;

procedure TFhirNutritionOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderList.SetItemByIndex(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  FhirNutritionOrders[index] := value;
end;

procedure TFhirNutritionOrderList.SetItemN(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FType_.free;
  FAppliesToList.Free;
  FAge.free;
  FText.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TFslObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  type_ := TFhirObservationReferenceRange(oSource).type_.Clone;
  if (TFhirObservationReferenceRange(oSource).FAppliesToList = nil) then
  begin
    FAppliesToList.free;
    FAppliesToList := nil;
  end
  else
  begin
    if FAppliesToList = nil then
      FAppliesToList := TFhirCodeableConceptList.Create;
    FAppliesToList.Assign(TFhirObservationReferenceRange(oSource).FAppliesToList);
  end;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
  textElement := TFhirObservationReferenceRange(oSource).textElement.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'appliesTo') Then
    list.addAll(self, 'appliesTo', FAppliesToList);
  if (child_name = 'age') Then
     list.add(self.link, 'age', FAge.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', false, TFhirQuantity, FLow.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', false, TFhirQuantity, FHigh.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'appliesTo', 'CodeableConcept', true, TFhirCodeableConcept, FAppliesToList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'age', 'Range', false, TFhirRange, FAge.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
end;

function TFhirObservationReferenceRange.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'low') then
  begin
    Low := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    High := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'appliesTo') then
  begin
    AppliesToList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'age') then
  begin
    Age := propValue as TFhirRange {L1199};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationReferenceRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirObservationReferenceRange.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'low') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'high') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'appliesTo') then result := AppliesToList.new() {L1053}
  else if (propName = 'age') then result := TFhirRange.create() {L1203}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationReferenceRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'low') then result := 'Quantity'
  else if (propName = 'high') then result := 'Quantity'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'appliesTo') then result := 'CodeableConcept'
  else if (propName = 'age') then result := 'Range'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationReferenceRange.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'appliesTo') then deletePropertyValue('appliesTo', AppliesToList, value) {L1054}
  else if (propName = 'age') then AgeElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationReferenceRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'low') then LowElement := new as TFhirQuantity {L1195}
  else if (propName = 'high') then HighElement := new as TFhirQuantity {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'appliesTo') then replacePropertyValue('appliesTo', AppliesToList, existing, new) {L1055}
  else if (propName = 'age') then AgeElement := new as TFhirRange {L1195}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationReferenceRange.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationReferenceRange.fhirType : string;
begin
  result := 'Observation.referenceRange';
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

function TFhirObservationReferenceRange.equals(other : TObject) : boolean; 
var
  o : TFhirObservationReferenceRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationReferenceRange)) then
    result := false
  else
  begin
    o := TFhirObservationReferenceRange(other);
    result := compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(appliesToList, o.appliesToList, true) and 
      compareDeep(ageElement, o.ageElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirObservationReferenceRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLow) and isEmptyProp(FHigh) and isEmptyProp(FType_) and isEmptyProp(FappliesToList) and isEmptyProp(FAge) and isEmptyProp(FText);
end;

procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value; {L1134}
end;

procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value; {L1134}
end;

procedure TFhirObservationReferenceRange.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirObservationReferenceRange.GetAppliesToList : TFhirCodeableConceptList;
begin
  if FAppliesToList = nil then
    FAppliesToList := TFhirCodeableConceptList.Create;
  result := FAppliesToList;
end;

function TFhirObservationReferenceRange.GetHasAppliesToList : boolean;
begin
  result := (FAppliesToList <> nil) and (FAppliesToList.count > 0);
end;

procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value; {L1134}
end;

procedure TFhirObservationReferenceRange.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirObservationReferenceRange.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirObservationReferenceRange.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirObservationReferenceRange.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('low');
  fields.add('high');
  fields.add('type');
  fields.add('appliesTo');
  fields.add('age');
  fields.add('text');
end;

function TFhirObservationReferenceRange.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLow.sizeInBytes);
  inc(result, FHigh.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FappliesToList.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirObservationReferenceRangeListEnumerator }

constructor TFhirObservationReferenceRangeListEnumerator.Create(list : TFhirObservationReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationReferenceRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationReferenceRangeListEnumerator.GetCurrent : TFhirObservationReferenceRange;
begin
  Result := FList[FIndex];
end;

function TFhirObservationReferenceRangeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationReferenceRangeList }

procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;

function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
begin
  result := TFhirObservationReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationReferenceRange;
end;
function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationComponent }

constructor TFhirObservationComponent.Create;
begin
  inherited;
end;

destructor TFhirObservationComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretationList.Free;
  FReferenceRangeList.Free;
  inherited;
end;

procedure TFhirObservationComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirObservationComponent(oSource).code.Clone;
  value := TFhirObservationComponent(oSource).value.Clone;
  dataAbsentReason := TFhirObservationComponent(oSource).dataAbsentReason.Clone;
  if (TFhirObservationComponent(oSource).FInterpretationList = nil) then
  begin
    FInterpretationList.free;
    FInterpretationList := nil;
  end
  else
  begin
    if FInterpretationList = nil then
      FInterpretationList := TFhirCodeableConceptList.Create;
    FInterpretationList.Assign(TFhirObservationComponent(oSource).FInterpretationList);
  end;
  if (TFhirObservationComponent(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservationComponent(oSource).FReferenceRangeList);
  end;
end;

procedure TFhirObservationComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
    list.addAll(self, 'interpretation', FInterpretationList);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
end;

procedure TFhirObservationComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', true, TFhirCodeableConcept, FInterpretationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'referenceRange', '', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)) {L1039};
end;

function TFhirObservationComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    InterpretationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interpretation') then InterpretationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange) {L1049}
  else inherited;
end;

function TFhirObservationComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'interpretation') then result := InterpretationList.new() {L1053}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period|Attachment'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'referenceRange') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then ValueElement := nil {L1189}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then deletePropertyValue('interpretation', InterpretationList, value) {L1054}
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'interpretation') then replacePropertyValue('interpretation', InterpretationList, existing, new) {L1055}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationComponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interpretation') then InterpretationList.move(source, destination) {L1050}
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationComponent.fhirType : string;
begin
  result := 'Observation.component';
end;

function TFhirObservationComponent.Link : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Link);
end;

function TFhirObservationComponent.Clone : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Clone);
end;

function TFhirObservationComponent.equals(other : TObject) : boolean; 
var
  o : TFhirObservationComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationComponent)) then
    result := false
  else
  begin
    o := TFhirObservationComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(interpretationList, o.interpretationList, true) and 
      compareDeep(referenceRangeList, o.referenceRangeList, true);
  end;
end;

function TFhirObservationComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FinterpretationList) and isEmptyProp(FreferenceRangeList);
end;

procedure TFhirObservationComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirObservationComponent.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirObservationComponent.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value; {L1134}
end;

function TFhirObservationComponent.GetInterpretationList : TFhirCodeableConceptList;
begin
  if FInterpretationList = nil then
    FInterpretationList := TFhirCodeableConceptList.Create;
  result := FInterpretationList;
end;

function TFhirObservationComponent.GetHasInterpretationList : boolean;
begin
  result := (FInterpretationList <> nil) and (FInterpretationList.count > 0);
end;

function TFhirObservationComponent.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

function TFhirObservationComponent.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

procedure TFhirObservationComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('referenceRange');
end;

function TFhirObservationComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FinterpretationList.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
end;

{ TFhirObservationComponentListEnumerator }

constructor TFhirObservationComponentListEnumerator.Create(list : TFhirObservationComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationComponentListEnumerator.GetCurrent : TFhirObservationComponent;
begin
  Result := FList[FIndex];
end;

function TFhirObservationComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationComponentList }

procedure TFhirObservationComponentList.AddItem(value: TFhirObservationComponent);
begin
  assert(value.ClassName = 'TFhirObservationComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationComponent');
  add(value);
end;

function TFhirObservationComponentList.Append: TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.ClearItems;
begin
  Clear;
end;

function TFhirObservationComponentList.GetEnumerator : TFhirObservationComponentListEnumerator;
begin
  result := TFhirObservationComponentListEnumerator.Create(self.link);
end;

function TFhirObservationComponentList.Clone: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Clone);
end;

function TFhirObservationComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationComponentList.GetItemN(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationComponent;
end;
function TFhirObservationComponentList.IndexOf(value: TFhirObservationComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationComponentList.Insert(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.InsertItem(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  Inherited Insert(index, value);
end;

function TFhirObservationComponentList.Item(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.Link: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Link);
end;

procedure TFhirObservationComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationComponentList.SetItemByIndex(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  FhirObservationComponents[index] := value;
end;

procedure TFhirObservationComponentList.SetItemN(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirObservation }

constructor TFhirObservation.Create;
begin
  inherited;
end;

destructor TFhirObservation.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FFocusList.Free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretationList.Free;
  FNoteList.Free;
  FBodySite.free;
  FMethod.free;
  FSpecimen.free;
  FDevice.free;
  FReferenceRangeList.Free;
  FHasMemberList.Free;
  FDerivedFromList.Free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirObservation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirObservation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirObservation(oSource).FIdentifierList);
  end;
  if (TFhirObservation(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirObservation(oSource).FBasedOnList);
  end;
  if (TFhirObservation(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirObservation(oSource).FPartOfList);
  end;
  statusElement := TFhirObservation(oSource).statusElement.Clone;
  if (TFhirObservation(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirObservation(oSource).FCategoryList);
  end;
  code := TFhirObservation(oSource).code.Clone;
  subject := TFhirObservation(oSource).subject.Clone;
  if (TFhirObservation(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList.Create;
    FFocusList.Assign(TFhirObservation(oSource).FFocusList);
  end;
  encounter := TFhirObservation(oSource).encounter.Clone;
  effective := TFhirObservation(oSource).effective.Clone;
  issuedElement := TFhirObservation(oSource).issuedElement.Clone;
  if (TFhirObservation(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirObservation(oSource).FPerformerList);
  end;
  value := TFhirObservation(oSource).value.Clone;
  dataAbsentReason := TFhirObservation(oSource).dataAbsentReason.Clone;
  if (TFhirObservation(oSource).FInterpretationList = nil) then
  begin
    FInterpretationList.free;
    FInterpretationList := nil;
  end
  else
  begin
    if FInterpretationList = nil then
      FInterpretationList := TFhirCodeableConceptList.Create;
    FInterpretationList.Assign(TFhirObservation(oSource).FInterpretationList);
  end;
  if (TFhirObservation(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirObservation(oSource).FNoteList);
  end;
  bodySite := TFhirObservation(oSource).bodySite.Clone;
  method := TFhirObservation(oSource).method.Clone;
  specimen := TFhirObservation(oSource).specimen.Clone;
  device := TFhirObservation(oSource).device.Clone;
  if (TFhirObservation(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservation(oSource).FReferenceRangeList);
  end;
  if (TFhirObservation(oSource).FHasMemberList = nil) then
  begin
    FHasMemberList.free;
    FHasMemberList := nil;
  end
  else
  begin
    if FHasMemberList = nil then
      FHasMemberList := TFhirReferenceList.Create;
    FHasMemberList.Assign(TFhirObservation(oSource).FHasMemberList);
  end;
  if (TFhirObservation(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirObservation(oSource).FDerivedFromList);
  end;
  if (TFhirObservation(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirObservationComponentList.Create;
    FComponentList.Assign(TFhirObservation(oSource).FComponentList);
  end;
end;

function TFhirObservation.GetResourceType : TFhirResourceType;
begin
  result := frtObservation;
end;

procedure TFhirObservation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
    list.addAll(self, 'interpretation', FInterpretationList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
  if (child_name = 'hasMember') Then
    list.addAll(self, 'hasMember', FHasMemberList);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirObservation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', true, TFhirReference, FFocusList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period|Timing|instant', false, TFhirDataType, FEffective.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', true, TFhirCodeableConcept, FInterpretationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', false, TFhirReference, FSpecimen.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceRange', 'BackboneElement', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'hasMember', 'Reference', true, TFhirReference, FHasMemberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirObservationComponent, FComponentList.Link)) {L1039};
end;

function TFhirObservation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then
  begin
    Effective := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    InterpretationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange) {L1048};
    result := propValue;
  end
  else if (propName = 'hasMember') then
  begin
    HasMemberList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirObservationComponent) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'interpretation') then InterpretationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange) {L1049}
  else if (propName = 'hasMember') then HasMemberList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirObservationComponent) {L1049}
  else inherited;
end;

function TFhirObservation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'focus') then result := FocusList.new() {L1053}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then raise EFHIRException.create('Cannot make property Effective') {L1191}
  else if (propName = 'issued') then result := TFhirInstant.create() {L1223}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'interpretation') then result := InterpretationList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'specimen') then result := TFhirReference.create() {L1203}
  else if (propName = 'device') then result := TFhirReference.create() {L1203}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new() {L1053}
  else if (propName = 'hasMember') then result := HasMemberList.new() {L1053}
  else if (propName = 'derivedFrom') then result := DerivedFromList.new() {L1053}
  else if (propName = 'component') then result := ComponentList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period|Timing|instant'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period|Attachment'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'referenceRange') then result := 'BackboneElement'
  else if (propName = 'hasMember') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'component') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {L1054}
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then EffectiveElement := nil {L1189}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then ValueElement := nil {L1189}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then deletePropertyValue('interpretation', InterpretationList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {L1054}
  else if (propName = 'hasMember') then deletePropertyValue('hasMember', HasMemberList, value) {L1054}
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value) {L1054}
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {L1055}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then EffectiveElement := new as TFhirDataType {L1190}
  else if (propName = 'issued') then IssuedElement := asInstant(new) {L1222}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'interpretation') then replacePropertyValue('interpretation', InterpretationList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference {L1195}
  else if (propName = 'device') then DeviceElement := new as TFhirReference {L1195}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {L1055}
  else if (propName = 'hasMember') then replacePropertyValue('hasMember', HasMemberList, existing, new) {L1055}
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new) {L1055}
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'focus') then FocusList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'interpretation') then InterpretationList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination) {L1050}
  else if (propName = 'hasMember') then HasMemberList.move(source, destination) {L1050}
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination) {L1050}
  else if (propName = 'component') then ComponentList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservation.fhirType : string;
begin
  result := 'Observation';
end;

function TFhirObservation.Link : TFhirObservation;
begin
  result := TFhirObservation(inherited Link);
end;

function TFhirObservation.Clone : TFhirObservation;
begin
  result := TFhirObservation(inherited Clone);
end;

function TFhirObservation.equals(other : TObject) : boolean; 
var
  o : TFhirObservation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservation)) then
    result := false
  else
  begin
    o := TFhirObservation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(focusList, o.focusList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and 
      compareDeep(interpretationList, o.interpretationList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(referenceRangeList, o.referenceRangeList, true) and compareDeep(hasMemberList, o.hasMemberList, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirObservation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FfocusList) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FinterpretationList) and isEmptyProp(FnoteList) and isEmptyProp(FBodySite) and isEmptyProp(FMethod) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FreferenceRangeList) and isEmptyProp(FhasMemberList) and isEmptyProp(FderivedFromList) and isEmptyProp(FcomponentList);
end;

function TFhirObservation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirObservation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirObservation.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirObservation.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirObservation.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirObservation.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirObservation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirObservation.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirObservation.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

function TFhirObservation.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirObservation.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirObservation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirObservation.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

function TFhirObservation.GetFocusList : TFhirReferenceList;
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList.Create;
  result := FFocusList;
end;

function TFhirObservation.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

procedure TFhirObservation.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirObservation.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value; {L1134}
end;

procedure TFhirObservation.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value; {L1134}
end;

function TFhirObservation.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirObservation.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

function TFhirObservation.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirObservation.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirObservation.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirObservation.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value; {L1134}
end;

function TFhirObservation.GetInterpretationList : TFhirCodeableConceptList;
begin
  if FInterpretationList = nil then
    FInterpretationList := TFhirCodeableConceptList.Create;
  result := FInterpretationList;
end;

function TFhirObservation.GetHasInterpretationList : boolean;
begin
  result := (FInterpretationList <> nil) and (FInterpretationList.count > 0);
end;

function TFhirObservation.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirObservation.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirObservation.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

procedure TFhirObservation.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirObservation.SetSpecimen(value : TFhirReference);
begin
  FSpecimen.free;
  FSpecimen := value; {L1134}
end;

procedure TFhirObservation.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value; {L1134}
end;

function TFhirObservation.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

function TFhirObservation.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

function TFhirObservation.GetHasMemberList : TFhirReferenceList;
begin
  if FHasMemberList = nil then
    FHasMemberList := TFhirReferenceList.Create;
  result := FHasMemberList;
end;

function TFhirObservation.GetHasHasMemberList : boolean;
begin
  result := (FHasMemberList <> nil) and (FHasMemberList.count > 0);
end;

function TFhirObservation.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirObservation.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

function TFhirObservation.GetComponentList : TFhirObservationComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirObservationComponentList.Create;
  result := FComponentList;
end;

function TFhirObservation.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

procedure TFhirObservation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('focus');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('note');
  fields.add('bodySite');
  fields.add('method');
  fields.add('specimen');
  fields.add('device');
  fields.add('referenceRange');
  fields.add('hasMember');
  fields.add('derivedFrom');
  fields.add('component');
end;

function TFhirObservation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FinterpretationList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FSpecimen.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
  inc(result, FhasMemberList.sizeInBytes);
  inc(result, FderivedFromList.sizeInBytes);
  inc(result, FcomponentList.sizeInBytes);
end;

{ TFhirObservationListEnumerator }

constructor TFhirObservationListEnumerator.Create(list : TFhirObservationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationListEnumerator.GetCurrent : TFhirObservation;
begin
  Result := FList[FIndex];
end;

function TFhirObservationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationList }

procedure TFhirObservationList.AddItem(value: TFhirObservation);
begin
  assert(value.ClassName = 'TFhirObservation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservation');
  add(value);
end;

function TFhirObservationList.Append: TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.ClearItems;
begin
  Clear;
end;

function TFhirObservationList.GetEnumerator : TFhirObservationListEnumerator;
begin
  result := TFhirObservationListEnumerator.Create(self.link);
end;

function TFhirObservationList.Clone: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Clone);
end;

function TFhirObservationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationList.GetItemN(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservation;
end;
function TFhirObservationList.IndexOf(value: TFhirObservation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationList.Insert(index: Integer): TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.InsertItem(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  Inherited Insert(index, value);
end;

function TFhirObservationList.Item(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.Link: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Link);
end;

procedure TFhirObservationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationList.SetItemByIndex(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  FhirObservations[index] := value;
end;

procedure TFhirObservationList.SetItemN(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirProcedurePerformer(oSource).function_.Clone;
  actor := TFhirProcedurePerformer(oSource).actor.Clone;
  onBehalfOf := TFhirProcedurePerformer(oSource).onBehalfOf.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link)); {L1172}
end;

function TFhirProcedurePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedurePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedurePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else if (propName = 'onBehalfOf') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedurePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedurePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedurePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedurePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedurePerformer.fhirType : string;
begin
  result := 'Procedure.performer';
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

function TFhirProcedurePerformer.equals(other : TObject) : boolean; 
var
  o : TFhirProcedurePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedurePerformer)) then
    result := false
  else
  begin
    o := TFhirProcedurePerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProcedurePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProcedurePerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirProcedurePerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirProcedurePerformer.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value; {L1134}
end;

procedure TFhirProcedurePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
  fields.add('onBehalfOf');
end;

function TFhirProcedurePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirProcedurePerformerListEnumerator }

constructor TFhirProcedurePerformerListEnumerator.Create(list : TFhirProcedurePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedurePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedurePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedurePerformerListEnumerator.GetCurrent : TFhirProcedurePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirProcedurePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedurePerformerList }

procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;

function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.GetEnumerator : TFhirProcedurePerformerListEnumerator;
begin
  result := TFhirProcedurePerformerListEnumerator.Create(self.link);
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedurePerformer;
end;
function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureFocalDevice }

constructor TFhirProcedureFocalDevice.Create;
begin
  inherited;
end;

destructor TFhirProcedureFocalDevice.Destroy;
begin
  FAction.free;
  FManipulated.free;
  inherited;
end;

procedure TFhirProcedureFocalDevice.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirProcedureFocalDevice(oSource).action.Clone;
  manipulated := TFhirProcedureFocalDevice(oSource).manipulated.Clone;
end;

procedure TFhirProcedureFocalDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'manipulated') Then
     list.add(self.link, 'manipulated', FManipulated.Link);
end;

procedure TFhirProcedureFocalDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manipulated', 'Reference', false, TFhirReference, FManipulated.Link)); {L1172}
end;

function TFhirProcedureFocalDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'manipulated') then
  begin
    Manipulated := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedureFocalDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedureFocalDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'manipulated') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureFocalDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'manipulated') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureFocalDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'manipulated') then ManipulatedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureFocalDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'manipulated') then ManipulatedElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureFocalDevice.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureFocalDevice.fhirType : string;
begin
  result := 'Procedure.focalDevice';
end;

function TFhirProcedureFocalDevice.Link : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Link);
end;

function TFhirProcedureFocalDevice.Clone : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Clone);
end;

function TFhirProcedureFocalDevice.equals(other : TObject) : boolean; 
var
  o : TFhirProcedureFocalDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureFocalDevice)) then
    result := false
  else
  begin
    o := TFhirProcedureFocalDevice(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(manipulatedElement, o.manipulatedElement, true);
  end;
end;

function TFhirProcedureFocalDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FManipulated);
end;

procedure TFhirProcedureFocalDevice.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value; {L1134}
end;

procedure TFhirProcedureFocalDevice.SetManipulated(value : TFhirReference);
begin
  FManipulated.free;
  FManipulated := value; {L1134}
end;

procedure TFhirProcedureFocalDevice.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('manipulated');
end;

function TFhirProcedureFocalDevice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FManipulated.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceListEnumerator }

constructor TFhirProcedureFocalDeviceListEnumerator.Create(list : TFhirProcedureFocalDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureFocalDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureFocalDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureFocalDeviceListEnumerator.GetCurrent : TFhirProcedureFocalDevice;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureFocalDeviceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceList }

procedure TFhirProcedureFocalDeviceList.AddItem(value: TFhirProcedureFocalDevice);
begin
  assert(value.ClassName = 'TFhirProcedureFocalDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureFocalDevice');
  add(value);
end;

function TFhirProcedureFocalDeviceList.Append: TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureFocalDeviceList.GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
begin
  result := TFhirProcedureFocalDeviceListEnumerator.Create(self.link);
end;

function TFhirProcedureFocalDeviceList.Clone: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Clone);
end;

function TFhirProcedureFocalDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureFocalDeviceList.GetItemN(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureFocalDevice;
end;
function TFhirProcedureFocalDeviceList.IndexOf(value: TFhirProcedureFocalDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureFocalDeviceList.Insert(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.InsertItem(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  Inherited Insert(index, value);
end;

function TFhirProcedureFocalDeviceList.Item(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.Link: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Link);
end;

procedure TFhirProcedureFocalDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureFocalDeviceList.SetItemByIndex(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  FhirProcedureFocalDevices[index] := value;
end;

procedure TFhirProcedureFocalDeviceList.SetItemN(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedure }

constructor TFhirProcedure.Create;
begin
  inherited;
end;

destructor TFhirProcedure.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FRecorded.free;
  FRecorder.free;
  FReported.free;
  FPerformerList.Free;
  FLocation.free;
  FReasonList.Free;
  FBodySiteList.Free;
  FOutcome.free;
  FReportList.Free;
  FComplicationList.Free;
  FComplicationDetailList.Free;
  FFollowUpList.Free;
  FNoteList.Free;
  FFocalDeviceList.Free;
  FUsedList.Free;
  inherited;
end;

procedure TFhirProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedure(oSource).FIdentifierList);
  end;
  if (TFhirProcedure(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirProcedure(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirProcedure(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirProcedure(oSource).FInstantiatesUriList);
  end;
  if (TFhirProcedure(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirProcedure(oSource).FBasedOnList);
  end;
  if (TFhirProcedure(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirProcedure(oSource).FPartOfList);
  end;
  statusElement := TFhirProcedure(oSource).statusElement.Clone;
  statusReason := TFhirProcedure(oSource).statusReason.Clone;
  if (TFhirProcedure(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirProcedure(oSource).FCategoryList);
  end;
  code := TFhirProcedure(oSource).code.Clone;
  subject := TFhirProcedure(oSource).subject.Clone;
  encounter := TFhirProcedure(oSource).encounter.Clone;
  occurrence := TFhirProcedure(oSource).occurrence.Clone;
  recordedElement := TFhirProcedure(oSource).recordedElement.Clone;
  recorder := TFhirProcedure(oSource).recorder.Clone;
  reported := TFhirProcedure(oSource).reported.Clone;
  if (TFhirProcedure(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirProcedurePerformerList.Create;
    FPerformerList.Assign(TFhirProcedure(oSource).FPerformerList);
  end;
  location := TFhirProcedure(oSource).location.Clone;
  if (TFhirProcedure(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirProcedure(oSource).FReasonList);
  end;
  if (TFhirProcedure(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedure(oSource).FBodySiteList);
  end;
  outcome := TFhirProcedure(oSource).outcome.Clone;
  if (TFhirProcedure(oSource).FReportList = nil) then
  begin
    FReportList.free;
    FReportList := nil;
  end
  else
  begin
    if FReportList = nil then
      FReportList := TFhirReferenceList.Create;
    FReportList.Assign(TFhirProcedure(oSource).FReportList);
  end;
  if (TFhirProcedure(oSource).FComplicationList = nil) then
  begin
    FComplicationList.free;
    FComplicationList := nil;
  end
  else
  begin
    if FComplicationList = nil then
      FComplicationList := TFhirCodeableConceptList.Create;
    FComplicationList.Assign(TFhirProcedure(oSource).FComplicationList);
  end;
  if (TFhirProcedure(oSource).FComplicationDetailList = nil) then
  begin
    FComplicationDetailList.free;
    FComplicationDetailList := nil;
  end
  else
  begin
    if FComplicationDetailList = nil then
      FComplicationDetailList := TFhirReferenceList.Create;
    FComplicationDetailList.Assign(TFhirProcedure(oSource).FComplicationDetailList);
  end;
  if (TFhirProcedure(oSource).FFollowUpList = nil) then
  begin
    FFollowUpList.free;
    FFollowUpList := nil;
  end
  else
  begin
    if FFollowUpList = nil then
      FFollowUpList := TFhirCodeableConceptList.Create;
    FFollowUpList.Assign(TFhirProcedure(oSource).FFollowUpList);
  end;
  if (TFhirProcedure(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirProcedure(oSource).FNoteList);
  end;
  if (TFhirProcedure(oSource).FFocalDeviceList = nil) then
  begin
    FFocalDeviceList.free;
    FFocalDeviceList := nil;
  end
  else
  begin
    if FFocalDeviceList = nil then
      FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
    FFocalDeviceList.Assign(TFhirProcedure(oSource).FFocalDeviceList);
  end;
  if (TFhirProcedure(oSource).FUsedList = nil) then
  begin
    FUsedList.free;
    FUsedList := nil;
  end
  else
  begin
    if FUsedList = nil then
      FUsedList := TFhirCodeableReferenceList.Create;
    FUsedList.Assign(TFhirProcedure(oSource).FUsedList);
  end;
end;

function TFhirProcedure.GetResourceType : TFhirResourceType;
begin
  result := frtProcedure;
end;

procedure TFhirProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'reported[x]') or (child_name = 'reported') Then
     list.add(self.link, 'reported[x]', FReported.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'report') Then
    list.addAll(self, 'report', FReportList);
  if (child_name = 'complication') Then
    list.addAll(self, 'complication', FComplicationList);
  if (child_name = 'complicationDetail') Then
    list.addAll(self, 'complicationDetail', FComplicationDetailList);
  if (child_name = 'followUp') Then
    list.addAll(self, 'followUp', FFollowUpList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'focalDevice') Then
    list.addAll(self, 'focalDevice', FFocalDeviceList);
  if (child_name = 'used') Then
    list.addAll(self, 'used', FUsedList);
end;

procedure TFhirProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|string|Age|Range|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorded', 'dateTime', false, TFhirDateTime, FRecorded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reported[x]', 'boolean|Reference', false, TFhirDataType, FReported.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirProcedurePerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'report', 'Reference', true, TFhirReference, FReportList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'complication', 'CodeableConcept', true, TFhirCodeableConcept, FComplicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'complicationDetail', 'Reference', true, TFhirReference, FComplicationDetailList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'followUp', 'CodeableConcept', true, TFhirCodeableConcept, FFollowUpList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'focalDevice', 'BackboneElement', true, TFhirProcedureFocalDevice, FFocalDeviceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'used', 'CodeableReference', true, TFhirCodeableReference, FUsedList.Link)) {L1039};
end;

function TFhirProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'String', 'Age', 'Range', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then
  begin
    Reported := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirProcedurePerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'report') then
  begin
    ReportList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'complication') then
  begin
    ComplicationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'complicationDetail') then
  begin
    ComplicationDetailList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'followUp') then
  begin
    FollowUpList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'focalDevice') then
  begin
    FocalDeviceList.add(propValue as TFhirProcedureFocalDevice) {L1048};
    result := propValue;
  end
  else if (propName = 'used') then
  begin
    UsedList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirProcedurePerformer) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'report') then ReportList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'complication') then ComplicationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'complicationDetail') then ComplicationDetailList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'followUp') then FollowUpList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'focalDevice') then FocalDeviceList.insertItem(index, propValue as TFhirProcedureFocalDevice) {L1049}
  else if (propName = 'used') then UsedList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else inherited;
end;

function TFhirProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'String', 'Age', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'recorded') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'recorder') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then raise EFHIRException.create('Cannot make property Reported') {L1191}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'bodySite') then result := BodySiteList.new() {L1053}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'report') then result := ReportList.new() {L1053}
  else if (propName = 'complication') then result := ComplicationList.new() {L1053}
  else if (propName = 'complicationDetail') then result := ComplicationDetailList.new() {L1053}
  else if (propName = 'followUp') then result := FollowUpList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'focalDevice') then result := FocalDeviceList.new() {L1053}
  else if (propName = 'used') then result := UsedList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|string|Age|Range|Timing'
  else if (propName = 'recorded') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'reported[x]') then result := 'boolean|Reference'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'report') then result := 'Reference'
  else if (propName = 'complication') then result := 'CodeableConcept'
  else if (propName = 'complicationDetail') then result := 'Reference'
  else if (propName = 'followUp') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'focalDevice') then result := 'BackboneElement'
  else if (propName = 'used') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'String', 'Age', 'Range', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := nil {L1189}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {L1054}
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'report') then deletePropertyValue('report', ReportList, value) {L1054}
  else if (propName = 'complication') then deletePropertyValue('complication', ComplicationList, value) {L1054}
  else if (propName = 'complicationDetail') then deletePropertyValue('complicationDetail', ComplicationDetailList, value) {L1054}
  else if (propName = 'followUp') then deletePropertyValue('followUp', FollowUpList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'focalDevice') then deletePropertyValue('focalDevice', FocalDeviceList, value) {L1054}
  else if (propName = 'used') then deletePropertyValue('used', UsedList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'String', 'Age', 'Range', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'recorded') then RecordedElement := asDateTime(new) {L1222}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := new as TFhirDataType {L1190}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {L1055}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'report') then replacePropertyValue('report', ReportList, existing, new) {L1055}
  else if (propName = 'complication') then replacePropertyValue('complication', ComplicationList, existing, new) {L1055}
  else if (propName = 'complicationDetail') then replacePropertyValue('complicationDetail', ComplicationDetailList, existing, new) {L1055}
  else if (propName = 'followUp') then replacePropertyValue('followUp', FollowUpList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'focalDevice') then replacePropertyValue('focalDevice', FocalDeviceList, existing, new) {L1055}
  else if (propName = 'used') then replacePropertyValue('used', UsedList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination) {L1050}
  else if (propName = 'report') then ReportList.move(source, destination) {L1050}
  else if (propName = 'complication') then ComplicationList.move(source, destination) {L1050}
  else if (propName = 'complicationDetail') then ComplicationDetailList.move(source, destination) {L1050}
  else if (propName = 'followUp') then FollowUpList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'focalDevice') then FocalDeviceList.move(source, destination) {L1050}
  else if (propName = 'used') then UsedList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedure.fhirType : string;
begin
  result := 'Procedure';
end;

function TFhirProcedure.Link : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Link);
end;

function TFhirProcedure.Clone : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Clone);
end;

function TFhirProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedure)) then
    result := false
  else
  begin
    o := TFhirProcedure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(recorderElement, o.recorderElement, true) and 
      compareDeep(reportedElement, o.reportedElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(bodySiteList, o.bodySiteList, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(reportList, o.reportList, true) and compareDeep(complicationList, o.complicationList, true) and 
      compareDeep(complicationDetailList, o.complicationDetailList, true) and compareDeep(followUpList, o.followUpList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(focalDeviceList, o.focalDeviceList, true) and 
      compareDeep(usedList, o.usedList, true);
  end;
end;

function TFhirProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FRecorded) and isEmptyProp(FRecorder) and isEmptyProp(FReported) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FbodySiteList) and isEmptyProp(FOutcome) and isEmptyProp(FreportList) and isEmptyProp(FcomplicationList) and isEmptyProp(FcomplicationDetailList) and isEmptyProp(FfollowUpList) and isEmptyProp(FnoteList) and isEmptyProp(FfocalDeviceList) and isEmptyProp(FusedList);
end;

function TFhirProcedure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirProcedure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirProcedure.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirProcedure.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirProcedure.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirProcedure.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirProcedure.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirProcedure.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirProcedure.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirProcedure.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirProcedure.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirProcedure.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirProcedure.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirProcedure.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value; {L1134}
end;

function TFhirProcedure.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirProcedure.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirProcedure.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirProcedure.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirProcedure.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirProcedure.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirProcedure.SetRecorded(value : TFhirDateTime);
begin
  FRecorded.free;
  FRecorded := value; {L1134}
end;

function TFhirProcedure.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirProcedure.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirDateTime.create;
  FRecorded.value := value
end;

procedure TFhirProcedure.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value; {L1134}
end;

procedure TFhirProcedure.SetReported(value : TFhirDataType);
begin
  FReported.free;
  FReported := value; {L1134}
end;

function TFhirProcedure.GetPerformerList : TFhirProcedurePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirProcedurePerformerList.Create;
  result := FPerformerList;
end;

function TFhirProcedure.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirProcedure.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

function TFhirProcedure.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirProcedure.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirProcedure.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirProcedure.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

procedure TFhirProcedure.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value; {L1134}
end;

function TFhirProcedure.GetReportList : TFhirReferenceList;
begin
  if FReportList = nil then
    FReportList := TFhirReferenceList.Create;
  result := FReportList;
end;

function TFhirProcedure.GetHasReportList : boolean;
begin
  result := (FReportList <> nil) and (FReportList.count > 0);
end;

function TFhirProcedure.GetComplicationList : TFhirCodeableConceptList;
begin
  if FComplicationList = nil then
    FComplicationList := TFhirCodeableConceptList.Create;
  result := FComplicationList;
end;

function TFhirProcedure.GetHasComplicationList : boolean;
begin
  result := (FComplicationList <> nil) and (FComplicationList.count > 0);
end;

function TFhirProcedure.GetComplicationDetailList : TFhirReferenceList;
begin
  if FComplicationDetailList = nil then
    FComplicationDetailList := TFhirReferenceList.Create;
  result := FComplicationDetailList;
end;

function TFhirProcedure.GetHasComplicationDetailList : boolean;
begin
  result := (FComplicationDetailList <> nil) and (FComplicationDetailList.count > 0);
end;

function TFhirProcedure.GetFollowUpList : TFhirCodeableConceptList;
begin
  if FFollowUpList = nil then
    FFollowUpList := TFhirCodeableConceptList.Create;
  result := FFollowUpList;
end;

function TFhirProcedure.GetHasFollowUpList : boolean;
begin
  result := (FFollowUpList <> nil) and (FFollowUpList.count > 0);
end;

function TFhirProcedure.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirProcedure.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirProcedure.GetFocalDeviceList : TFhirProcedureFocalDeviceList;
begin
  if FFocalDeviceList = nil then
    FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
  result := FFocalDeviceList;
end;

function TFhirProcedure.GetHasFocalDeviceList : boolean;
begin
  result := (FFocalDeviceList <> nil) and (FFocalDeviceList.count > 0);
end;

function TFhirProcedure.GetUsedList : TFhirCodeableReferenceList;
begin
  if FUsedList = nil then
    FUsedList := TFhirCodeableReferenceList.Create;
  result := FUsedList;
end;

function TFhirProcedure.GetHasUsedList : boolean;
begin
  result := (FUsedList <> nil) and (FUsedList.count > 0);
end;

procedure TFhirProcedure.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('recorded');
  fields.add('recorder');
  fields.add('reported[x]');
  fields.add('performer');
  fields.add('location');
  fields.add('reason');
  fields.add('bodySite');
  fields.add('outcome');
  fields.add('report');
  fields.add('complication');
  fields.add('complicationDetail');
  fields.add('followUp');
  fields.add('note');
  fields.add('focalDevice');
  fields.add('used');
end;

function TFhirProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FReported.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FreportList.sizeInBytes);
  inc(result, FcomplicationList.sizeInBytes);
  inc(result, FcomplicationDetailList.sizeInBytes);
  inc(result, FfollowUpList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FfocalDeviceList.sizeInBytes);
  inc(result, FusedList.sizeInBytes);
end;

{ TFhirProcedureListEnumerator }

constructor TFhirProcedureListEnumerator.Create(list : TFhirProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureListEnumerator.GetCurrent : TFhirProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureList }

procedure TFhirProcedureList.AddItem(value: TFhirProcedure);
begin
  assert(value.ClassName = 'TFhirProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedure');
  add(value);
end;

function TFhirProcedureList.Append: TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureList.GetEnumerator : TFhirProcedureListEnumerator;
begin
  result := TFhirProcedureListEnumerator.Create(self.link);
end;

function TFhirProcedureList.Clone: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Clone);
end;

function TFhirProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureList.GetItemN(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedure;
end;
function TFhirProcedureList.IndexOf(value: TFhirProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureList.Insert(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.InsertItem(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  Inherited Insert(index, value);
end;

function TFhirProcedureList.Item(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.Link: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Link);
end;

procedure TFhirProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureList.SetItemByIndex(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  FhirProcedures[index] := value;
end;

procedure TFhirProcedureList.SetItemN(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
{ TFhirRiskAssessmentPrediction }

constructor TFhirRiskAssessmentPrediction.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessmentPrediction.Destroy;
begin
  FOutcome.free;
  FProbability.free;
  FQualitativeRisk.free;
  FRelativeRisk.free;
  FWhen.free;
  FRationale.free;
  inherited;
end;

procedure TFhirRiskAssessmentPrediction.Assign(oSource : TFslObject);
begin
  inherited;
  outcome := TFhirRiskAssessmentPrediction(oSource).outcome.Clone;
  probability := TFhirRiskAssessmentPrediction(oSource).probability.Clone;
  qualitativeRisk := TFhirRiskAssessmentPrediction(oSource).qualitativeRisk.Clone;
  relativeRiskElement := TFhirRiskAssessmentPrediction(oSource).relativeRiskElement.Clone;
  when := TFhirRiskAssessmentPrediction(oSource).when.Clone;
  rationaleElement := TFhirRiskAssessmentPrediction(oSource).rationaleElement.Clone;
end;

procedure TFhirRiskAssessmentPrediction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'probability[x]') or (child_name = 'probability') Then
     list.add(self.link, 'probability[x]', FProbability.Link);
  if (child_name = 'qualitativeRisk') Then
     list.add(self.link, 'qualitativeRisk', FQualitativeRisk.Link);
  if (child_name = 'relativeRisk') Then
     list.add(self.link, 'relativeRisk', FRelativeRisk.Link);
  if (child_name = 'when[x]') or (child_name = 'when') Then
     list.add(self.link, 'when[x]', FWhen.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
end;

procedure TFhirRiskAssessmentPrediction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'probability[x]', 'decimal|Range', false, TFhirDataType, FProbability.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'qualitativeRisk', 'CodeableConcept', false, TFhirCodeableConcept, FQualitativeRisk.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relativeRisk', 'decimal', false, TFhirDecimal, FRelativeRisk.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'when[x]', 'Period|Range', false, TFhirDataType, FWhen.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rationale', 'string', false, TFhirString, FRationale.Link)); {L1172}
end;

function TFhirRiskAssessmentPrediction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then
  begin
    Probability := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'qualitativeRisk') then
  begin
    QualitativeRisk := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'relativeRisk') then
  begin
    RelativeRiskElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then
  begin
    When := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessmentPrediction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskAssessmentPrediction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcome') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then raise EFHIRException.create('Cannot make property Probability') {L1191}
  else if (propName = 'qualitativeRisk') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'relativeRisk') then result := TFhirDecimal.create() {L1223}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then raise EFHIRException.create('Cannot make property When') {L1191}
  else if (propName = 'rationale') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessmentPrediction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'probability[x]') then result := 'decimal|Range'
  else if (propName = 'qualitativeRisk') then result := 'CodeableConcept'
  else if (propName = 'relativeRisk') then result := 'decimal'
  else if (propName = 'when[x]') then result := 'Period|Range'
  else if (propName = 'rationale') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessmentPrediction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := nil {L1189}
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := nil
  else if (propName = 'relativeRisk') then RelativeRiskElement := nil
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := nil {L1189}
  else if (propName = 'rationale') then RationaleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessmentPrediction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := new as TFhirDataType {L1190}
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'relativeRisk') then RelativeRiskElement := asDecimal(new) {L1222}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := new as TFhirDataType {L1190}
  else if (propName = 'rationale') then RationaleElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessmentPrediction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessmentPrediction.fhirType : string;
begin
  result := 'RiskAssessment.prediction';
end;

function TFhirRiskAssessmentPrediction.Link : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Link);
end;

function TFhirRiskAssessmentPrediction.Clone : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Clone);
end;

function TFhirRiskAssessmentPrediction.equals(other : TObject) : boolean; 
var
  o : TFhirRiskAssessmentPrediction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessmentPrediction)) then
    result := false
  else
  begin
    o := TFhirRiskAssessmentPrediction(other);
    result := compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(probabilityElement, o.probabilityElement, true) and 
      compareDeep(qualitativeRiskElement, o.qualitativeRiskElement, true) and compareDeep(relativeRiskElement, o.relativeRiskElement, true) and 
      compareDeep(whenElement, o.whenElement, true) and compareDeep(rationaleElement, o.rationaleElement, true);
  end;
end;

function TFhirRiskAssessmentPrediction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOutcome) and isEmptyProp(FProbability) and isEmptyProp(FQualitativeRisk) and isEmptyProp(FRelativeRisk) and isEmptyProp(FWhen) and isEmptyProp(FRationale);
end;

procedure TFhirRiskAssessmentPrediction.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value; {L1134}
end;

procedure TFhirRiskAssessmentPrediction.SetProbability(value : TFhirDataType);
begin
  FProbability.free;
  FProbability := value; {L1134}
end;

procedure TFhirRiskAssessmentPrediction.SetQualitativeRisk(value : TFhirCodeableConcept);
begin
  FQualitativeRisk.free;
  FQualitativeRisk := value; {L1134}
end;

procedure TFhirRiskAssessmentPrediction.SetRelativeRisk(value : TFhirDecimal);
begin
  FRelativeRisk.free;
  FRelativeRisk := value; {L1134}
end;

function TFhirRiskAssessmentPrediction.GetRelativeRiskST : String;
begin
  if FRelativeRisk = nil then
    result := ''
  else
    result := FRelativeRisk.value;
end;

procedure TFhirRiskAssessmentPrediction.SetRelativeRiskST(value : String);
begin
  if value <> '' then
  begin
    if FRelativeRisk = nil then
      FRelativeRisk := TFhirDecimal.create;
    FRelativeRisk.value := value
  end
  else if FRelativeRisk <> nil then
    FRelativeRisk.value := '';
end;

procedure TFhirRiskAssessmentPrediction.SetWhen(value : TFhirDataType);
begin
  FWhen.free;
  FWhen := value; {L1134}
end;

procedure TFhirRiskAssessmentPrediction.SetRationale(value : TFhirString);
begin
  FRationale.free;
  FRationale := value; {L1134}
end;

function TFhirRiskAssessmentPrediction.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

procedure TFhirRiskAssessmentPrediction.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirString.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

procedure TFhirRiskAssessmentPrediction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outcome');
  fields.add('probability[x]');
  fields.add('qualitativeRisk');
  fields.add('relativeRisk');
  fields.add('when[x]');
  fields.add('rationale');
end;

function TFhirRiskAssessmentPrediction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOutcome.sizeInBytes);
  inc(result, FProbability.sizeInBytes);
  inc(result, FQualitativeRisk.sizeInBytes);
  inc(result, FRelativeRisk.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FRationale.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionListEnumerator }

constructor TFhirRiskAssessmentPredictionListEnumerator.Create(list : TFhirRiskAssessmentPredictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentPredictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentPredictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentPredictionListEnumerator.GetCurrent : TFhirRiskAssessmentPrediction;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentPredictionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionList }

procedure TFhirRiskAssessmentPredictionList.AddItem(value: TFhirRiskAssessmentPrediction);
begin
  assert(value.ClassName = 'TFhirRiskAssessmentPrediction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessmentPrediction');
  add(value);
end;

function TFhirRiskAssessmentPredictionList.Append: TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentPredictionList.GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
begin
  result := TFhirRiskAssessmentPredictionListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentPredictionList.Clone: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Clone);
end;

function TFhirRiskAssessmentPredictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentPredictionList.GetItemN(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessmentPrediction;
end;
function TFhirRiskAssessmentPredictionList.IndexOf(value: TFhirRiskAssessmentPrediction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentPredictionList.Insert(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.InsertItem(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentPredictionList.Item(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.Link: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Link);
end;

procedure TFhirRiskAssessmentPredictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentPredictionList.SetItemByIndex(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  FhirRiskAssessmentPredictions[index] := value;
end;

procedure TFhirRiskAssessmentPredictionList.SetItemN(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskAssessment }

constructor TFhirRiskAssessment.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessment.Destroy;
begin
  FIdentifierList.Free;
  FBasedOn.free;
  FParent.free;
  FStatus.free;
  FMethod.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FCondition.free;
  FPerformer.free;
  FReasonList.Free;
  FBasisList.Free;
  FPredictionList.Free;
  FMitigation.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirRiskAssessment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRiskAssessment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRiskAssessment(oSource).FIdentifierList);
  end;
  basedOn := TFhirRiskAssessment(oSource).basedOn.Clone;
  parent := TFhirRiskAssessment(oSource).parent.Clone;
  statusElement := TFhirRiskAssessment(oSource).statusElement.Clone;
  method := TFhirRiskAssessment(oSource).method.Clone;
  code := TFhirRiskAssessment(oSource).code.Clone;
  subject := TFhirRiskAssessment(oSource).subject.Clone;
  encounter := TFhirRiskAssessment(oSource).encounter.Clone;
  occurrence := TFhirRiskAssessment(oSource).occurrence.Clone;
  condition := TFhirRiskAssessment(oSource).condition.Clone;
  performer := TFhirRiskAssessment(oSource).performer.Clone;
  if (TFhirRiskAssessment(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirRiskAssessment(oSource).FReasonList);
  end;
  if (TFhirRiskAssessment(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirReferenceList.Create;
    FBasisList.Assign(TFhirRiskAssessment(oSource).FBasisList);
  end;
  if (TFhirRiskAssessment(oSource).FPredictionList = nil) then
  begin
    FPredictionList.free;
    FPredictionList := nil;
  end
  else
  begin
    if FPredictionList = nil then
      FPredictionList := TFhirRiskAssessmentPredictionList.Create;
    FPredictionList.Assign(TFhirRiskAssessment(oSource).FPredictionList);
  end;
  mitigationElement := TFhirRiskAssessment(oSource).mitigationElement.Clone;
  if (TFhirRiskAssessment(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRiskAssessment(oSource).FNoteList);
  end;
end;

function TFhirRiskAssessment.GetResourceType : TFhirResourceType;
begin
  result := frtRiskAssessment;
end;

procedure TFhirRiskAssessment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
     list.add(self.link, 'basedOn', FBasedOn.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'prediction') Then
    list.addAll(self, 'prediction', FPredictionList);
  if (child_name = 'mitigation') Then
     list.add(self.link, 'mitigation', FMitigation.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirRiskAssessment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', false, TFhirReference, FBasedOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basis', 'Reference', true, TFhirReference, FBasisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'prediction', 'BackboneElement', true, TFhirRiskAssessmentPrediction, FPredictionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'mitigation', 'string', false, TFhirString, FMitigation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirRiskAssessment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOn := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'prediction') then
  begin
    PredictionList.add(propValue as TFhirRiskAssessmentPrediction) {L1048};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'prediction') then PredictionList.insertItem(index, propValue as TFhirRiskAssessmentPrediction) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirRiskAssessment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := TFhirReference.create() {L1203}
  else if (propName = 'parent') then result := TFhirReference.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull])  {L1211}
  else if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'condition') then result := TFhirReference.create() {L1203}
  else if (propName = 'performer') then result := TFhirReference.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'basis') then result := BasisList.new() {L1053}
  else if (propName = 'prediction') then result := PredictionList.new() {L1053}
  else if (propName = 'mitigation') then result := TFhirString.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'condition') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'basis') then result := 'Reference'
  else if (propName = 'prediction') then result := 'BackboneElement'
  else if (propName = 'mitigation') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then BasedOnElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value) {L1054}
  else if (propName = 'prediction') then deletePropertyValue('prediction', PredictionList, value) {L1054}
  else if (propName = 'mitigation') then MitigationElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then BasedOnElement := new as TFhirReference {L1195}
  else if (propName = 'parent') then ParentElement := new as TFhirReference {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new) {L1210}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'condition') then ConditionElement := new as TFhirReference {L1195}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new) {L1055}
  else if (propName = 'prediction') then replacePropertyValue('prediction', PredictionList, existing, new) {L1055}
  else if (propName = 'mitigation') then MitigationElement := asString(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'basis') then BasisList.move(source, destination) {L1050}
  else if (propName = 'prediction') then PredictionList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessment.fhirType : string;
begin
  result := 'RiskAssessment';
end;

function TFhirRiskAssessment.Link : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Link);
end;

function TFhirRiskAssessment.Clone : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Clone);
end;

function TFhirRiskAssessment.equals(other : TObject) : boolean; 
var
  o : TFhirRiskAssessment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessment)) then
    result := false
  else
  begin
    o := TFhirRiskAssessment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnElement, o.basedOnElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(conditionElement, o.conditionElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(basisList, o.basisList, true) and compareDeep(predictionList, o.predictionList, true) and 
      compareDeep(mitigationElement, o.mitigationElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirRiskAssessment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FBasedOn) and isEmptyProp(FParent) and isEmptyProp(FStatus) and isEmptyProp(FMethod) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FCondition) and isEmptyProp(FPerformer) and isEmptyProp(FreasonList) and isEmptyProp(FbasisList) and isEmptyProp(FpredictionList) and isEmptyProp(FMitigation) and isEmptyProp(FnoteList);
end;

function TFhirRiskAssessment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRiskAssessment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRiskAssessment.SetBasedOn(value : TFhirReference);
begin
  FBasedOn.free;
  FBasedOn := value; {L1134}
end;

procedure TFhirRiskAssessment.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value; {L1134}
end;

procedure TFhirRiskAssessment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirRiskAssessment.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirRiskAssessment.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

procedure TFhirRiskAssessment.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirRiskAssessment.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirRiskAssessment.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirRiskAssessment.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirRiskAssessment.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirRiskAssessment.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value; {L1134}
end;

procedure TFhirRiskAssessment.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value; {L1134}
end;

function TFhirRiskAssessment.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirRiskAssessment.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirRiskAssessment.GetBasisList : TFhirReferenceList;
begin
  if FBasisList = nil then
    FBasisList := TFhirReferenceList.Create;
  result := FBasisList;
end;

function TFhirRiskAssessment.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

function TFhirRiskAssessment.GetPredictionList : TFhirRiskAssessmentPredictionList;
begin
  if FPredictionList = nil then
    FPredictionList := TFhirRiskAssessmentPredictionList.Create;
  result := FPredictionList;
end;

function TFhirRiskAssessment.GetHasPredictionList : boolean;
begin
  result := (FPredictionList <> nil) and (FPredictionList.count > 0);
end;

procedure TFhirRiskAssessment.SetMitigation(value : TFhirString);
begin
  FMitigation.free;
  FMitigation := value; {L1134}
end;

function TFhirRiskAssessment.GetMitigationST : String;
begin
  if FMitigation = nil then
    result := ''
  else
    result := FMitigation.value;
end;

procedure TFhirRiskAssessment.SetMitigationST(value : String);
begin
  if value <> '' then
  begin
    if FMitigation = nil then
      FMitigation := TFhirString.create;
    FMitigation.value := value
  end
  else if FMitigation <> nil then
    FMitigation.value := '';
end;

function TFhirRiskAssessment.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirRiskAssessment.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirRiskAssessment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('parent');
  fields.add('status');
  fields.add('method');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('condition');
  fields.add('performer');
  fields.add('reason');
  fields.add('basis');
  fields.add('prediction');
  fields.add('mitigation');
  fields.add('note');
end;

function TFhirRiskAssessment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FBasedOn.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FbasisList.sizeInBytes);
  inc(result, FpredictionList.sizeInBytes);
  inc(result, FMitigation.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirRiskAssessmentListEnumerator }

constructor TFhirRiskAssessmentListEnumerator.Create(list : TFhirRiskAssessmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentListEnumerator.GetCurrent : TFhirRiskAssessment;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentList }

procedure TFhirRiskAssessmentList.AddItem(value: TFhirRiskAssessment);
begin
  assert(value.ClassName = 'TFhirRiskAssessment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessment');
  add(value);
end;

function TFhirRiskAssessmentList.Append: TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentList.GetEnumerator : TFhirRiskAssessmentListEnumerator;
begin
  result := TFhirRiskAssessmentListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentList.Clone: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Clone);
end;

function TFhirRiskAssessmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentList.GetItemN(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessment;
end;
function TFhirRiskAssessmentList.IndexOf(value: TFhirRiskAssessment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentList.Insert(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.InsertItem(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentList.Item(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.Link: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Link);
end;

procedure TFhirRiskAssessmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentList.SetItemByIndex(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  FhirRiskAssessments[index] := value;
end;

procedure TFhirRiskAssessmentList.SetItemN(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
{ TFhirServiceRequest }

constructor TFhirServiceRequest.Create;
begin
  inherited;
end;

destructor TFhirServiceRequest.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FRequisition.free;
  FStatus.free;
  FIntent.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FCode.free;
  FOrderDetailList.Free;
  FQuantity.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FAsNeeded.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformerList.Free;
  FLocationList.Free;
  FReasonList.Free;
  FInsuranceList.Free;
  FSupportingInfoList.Free;
  FSpecimenList.Free;
  FBodySiteList.Free;
  FNoteList.Free;
  FPatientInstruction.free;
  FRelevantHistoryList.Free;
  inherited;
end;

procedure TFhirServiceRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirServiceRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirServiceRequest(oSource).FIdentifierList);
  end;
  if (TFhirServiceRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirServiceRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirServiceRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirServiceRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirServiceRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirServiceRequest(oSource).FBasedOnList);
  end;
  if (TFhirServiceRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirServiceRequest(oSource).FReplacesList);
  end;
  requisition := TFhirServiceRequest(oSource).requisition.Clone;
  statusElement := TFhirServiceRequest(oSource).statusElement.Clone;
  intentElement := TFhirServiceRequest(oSource).intentElement.Clone;
  if (TFhirServiceRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirServiceRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirServiceRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirServiceRequest(oSource).doNotPerformElement.Clone;
  code := TFhirServiceRequest(oSource).code.Clone;
  if (TFhirServiceRequest(oSource).FOrderDetailList = nil) then
  begin
    FOrderDetailList.free;
    FOrderDetailList := nil;
  end
  else
  begin
    if FOrderDetailList = nil then
      FOrderDetailList := TFhirCodeableConceptList.Create;
    FOrderDetailList.Assign(TFhirServiceRequest(oSource).FOrderDetailList);
  end;
  quantity := TFhirServiceRequest(oSource).quantity.Clone;
  subject := TFhirServiceRequest(oSource).subject.Clone;
  encounter := TFhirServiceRequest(oSource).encounter.Clone;
  occurrence := TFhirServiceRequest(oSource).occurrence.Clone;
  asNeeded := TFhirServiceRequest(oSource).asNeeded.Clone;
  authoredOnElement := TFhirServiceRequest(oSource).authoredOnElement.Clone;
  requester := TFhirServiceRequest(oSource).requester.Clone;
  performerType := TFhirServiceRequest(oSource).performerType.Clone;
  if (TFhirServiceRequest(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirServiceRequest(oSource).FPerformerList);
  end;
  if (TFhirServiceRequest(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirCodeableReferenceList.Create;
    FLocationList.Assign(TFhirServiceRequest(oSource).FLocationList);
  end;
  if (TFhirServiceRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirServiceRequest(oSource).FReasonList);
  end;
  if (TFhirServiceRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirServiceRequest(oSource).FInsuranceList);
  end;
  if (TFhirServiceRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirServiceRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirServiceRequest(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirServiceRequest(oSource).FSpecimenList);
  end;
  if (TFhirServiceRequest(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirServiceRequest(oSource).FBodySiteList);
  end;
  if (TFhirServiceRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirServiceRequest(oSource).FNoteList);
  end;
  patientInstructionElement := TFhirServiceRequest(oSource).patientInstructionElement.Clone;
  if (TFhirServiceRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirServiceRequest(oSource).FRelevantHistoryList);
  end;
end;

function TFhirServiceRequest.GetResourceType : TFhirResourceType;
begin
  result := frtServiceRequest;
end;

procedure TFhirServiceRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'requisition') Then
     list.add(self.link, 'requisition', FRequisition.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'orderDetail') Then
    list.addAll(self, 'orderDetail', FOrderDetailList);
  if (child_name = 'quantity[x]') or (child_name = 'quantity') Then
     list.add(self.link, 'quantity[x]', FQuantity.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'patientInstruction') Then
     list.add(self.link, 'patientInstruction', FPatientInstruction.Link);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirServiceRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'requisition', 'Identifier', false, TFhirIdentifier, FRequisition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'orderDetail', 'CodeableConcept', true, TFhirCodeableConcept, FOrderDetailList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity[x]', 'Quantity|Ratio|Range', false, TFhirDataType, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAsNeeded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableReference', true, TFhirCodeableReference, FLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'patientInstruction', 'string', false, TFhirString, FPatientInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link)) {L1039};
end;

function TFhirServiceRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'requisition') then
  begin
    Requisition := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'orderDetail') then
  begin
    OrderDetailList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then
  begin
    Quantity := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'patientInstruction') then
  begin
    PatientInstructionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirServiceRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'orderDetail') then OrderDetailList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirServiceRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new() {L1053}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'replaces') then result := ReplacesList.new() {L1053}
  else if (propName = 'requisition') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull])  {L1211}
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'orderDetail') then result := OrderDetailList.new() {L1053}
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Quantity') {L1191}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded') {L1191}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requester') then result := TFhirReference.create() {L1203}
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'location') then result := LocationList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'specimen') then result := SpecimenList.new() {L1053}
  else if (propName = 'bodySite') then result := BodySiteList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'patientInstruction') then result := TFhirString.create() {L1223}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirServiceRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'requisition') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'orderDetail') then result := 'CodeableConcept'
  else if (propName = 'quantity[x]') then result := 'Quantity|Ratio|Range'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'location') then result := 'CodeableReference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'patientInstruction') then result := 'string'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirServiceRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {L1054}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {L1054}
  else if (propName = 'requisition') then RequisitionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'orderDetail') then deletePropertyValue('orderDetail', OrderDetailList, value) {L1054}
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then QuantityElement := nil {L1189}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil {L1189}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {L1054}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'patientInstruction') then PatientInstructionElement := nil
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirServiceRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {L1055}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {L1055}
  else if (propName = 'requisition') then RequisitionElement := new as TFhirIdentifier {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new) {L1210}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new) {L1222}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'orderDetail') then replacePropertyValue('orderDetail', OrderDetailList, existing, new) {L1055}
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then QuantityElement := new as TFhirDataType {L1190}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirDataType {L1190}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new) {L1222}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference {L1195}
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {L1055}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'patientInstruction') then PatientInstructionElement := asString(new) {L1222}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirServiceRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination) {L1046}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination) {L1046}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'replaces') then ReplacesList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'orderDetail') then OrderDetailList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'location') then LocationList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'specimen') then SpecimenList.move(source, destination) {L1050}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirServiceRequest.fhirType : string;
begin
  result := 'ServiceRequest';
end;

function TFhirServiceRequest.Link : TFhirServiceRequest;
begin
  result := TFhirServiceRequest(inherited Link);
end;

function TFhirServiceRequest.Clone : TFhirServiceRequest;
begin
  result := TFhirServiceRequest(inherited Clone);
end;

function TFhirServiceRequest.equals(other : TObject) : boolean; 
var
  o : TFhirServiceRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirServiceRequest)) then
    result := false
  else
  begin
    o := TFhirServiceRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(requisitionElement, o.requisitionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(orderDetailList, o.orderDetailList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeElement, o.performerTypeElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(specimenList, o.specimenList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(patientInstructionElement, o.patientInstructionElement, true) and 
      compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirServiceRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FRequisition) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FCode) and isEmptyProp(ForderDetailList) and isEmptyProp(FQuantity) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FAsNeeded) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FperformerList) and isEmptyProp(FlocationList) and isEmptyProp(FreasonList) and isEmptyProp(FinsuranceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FspecimenList) and isEmptyProp(FbodySiteList) and isEmptyProp(FnoteList) and isEmptyProp(FPatientInstruction) and isEmptyProp(FrelevantHistoryList);
end;

function TFhirServiceRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirServiceRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirServiceRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirServiceRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirServiceRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirServiceRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirServiceRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirServiceRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirServiceRequest.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirServiceRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirServiceRequest.SetRequisition(value : TFhirIdentifier);
begin
  FRequisition.free;
  FRequisition := value; {L1134}
end;

procedure TFhirServiceRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirServiceRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirServiceRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirServiceRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirServiceRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirServiceRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

function TFhirServiceRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirServiceRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirServiceRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirServiceRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirServiceRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirServiceRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value; {L1134}
end;

function TFhirServiceRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirServiceRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirServiceRequest.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirServiceRequest.GetOrderDetailList : TFhirCodeableConceptList;
begin
  if FOrderDetailList = nil then
    FOrderDetailList := TFhirCodeableConceptList.Create;
  result := FOrderDetailList;
end;

function TFhirServiceRequest.GetHasOrderDetailList : boolean;
begin
  result := (FOrderDetailList <> nil) and (FOrderDetailList.count > 0);
end;

procedure TFhirServiceRequest.SetQuantity(value : TFhirDataType);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirServiceRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirServiceRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirServiceRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirServiceRequest.SetAsNeeded(value : TFhirDataType);
begin
  FAsNeeded.free;
  FAsNeeded := value; {L1134}
end;

procedure TFhirServiceRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value; {L1134}
end;

function TFhirServiceRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirServiceRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirServiceRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value; {L1134}
end;

procedure TFhirServiceRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value; {L1134}
end;

function TFhirServiceRequest.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirServiceRequest.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirServiceRequest.GetLocationList : TFhirCodeableReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirCodeableReferenceList.Create;
  result := FLocationList;
end;

function TFhirServiceRequest.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirServiceRequest.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirServiceRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirServiceRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirServiceRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirServiceRequest.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirServiceRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirServiceRequest.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirServiceRequest.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

function TFhirServiceRequest.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirServiceRequest.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

function TFhirServiceRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirServiceRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirServiceRequest.SetPatientInstruction(value : TFhirString);
begin
  FPatientInstruction.free;
  FPatientInstruction := value; {L1134}
end;

function TFhirServiceRequest.GetPatientInstructionST : String;
begin
  if FPatientInstruction = nil then
    result := ''
  else
    result := FPatientInstruction.value;
end;

procedure TFhirServiceRequest.SetPatientInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPatientInstruction = nil then
      FPatientInstruction := TFhirString.create;
    FPatientInstruction.value := value
  end
  else if FPatientInstruction <> nil then
    FPatientInstruction.value := '';
end;

function TFhirServiceRequest.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirServiceRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

procedure TFhirServiceRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('requisition');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('code');
  fields.add('orderDetail');
  fields.add('quantity[x]');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('asNeeded[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('location');
  fields.add('reason');
  fields.add('insurance');
  fields.add('supportingInfo');
  fields.add('specimen');
  fields.add('bodySite');
  fields.add('note');
  fields.add('patientInstruction');
  fields.add('relevantHistory');
end;

function TFhirServiceRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FRequisition.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, ForderDetailList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FPerformerType.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FPatientInstruction.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
end;

{ TFhirServiceRequestListEnumerator }

constructor TFhirServiceRequestListEnumerator.Create(list : TFhirServiceRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirServiceRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirServiceRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirServiceRequestListEnumerator.GetCurrent : TFhirServiceRequest;
begin
  Result := FList[FIndex];
end;

function TFhirServiceRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirServiceRequestList }

procedure TFhirServiceRequestList.AddItem(value: TFhirServiceRequest);
begin
  assert(value.ClassName = 'TFhirServiceRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirServiceRequest');
  add(value);
end;

function TFhirServiceRequestList.Append: TFhirServiceRequest;
begin
  result := TFhirServiceRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceRequestList.ClearItems;
begin
  Clear;
end;

function TFhirServiceRequestList.GetEnumerator : TFhirServiceRequestListEnumerator;
begin
  result := TFhirServiceRequestListEnumerator.Create(self.link);
end;

function TFhirServiceRequestList.Clone: TFhirServiceRequestList;
begin
  result := TFhirServiceRequestList(inherited Clone);
end;

function TFhirServiceRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirServiceRequestList.GetItemN(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest(ObjectByIndex[index]);
end;

function TFhirServiceRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirServiceRequest;
end;
function TFhirServiceRequestList.IndexOf(value: TFhirServiceRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirServiceRequestList.Insert(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceRequestList.InsertItem(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  Inherited Insert(index, value);
end;

function TFhirServiceRequestList.Item(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest(ObjectByIndex[index]);
end;

function TFhirServiceRequestList.Link: TFhirServiceRequestList;
begin
  result := TFhirServiceRequestList(inherited Link);
end;

procedure TFhirServiceRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirServiceRequestList.SetItemByIndex(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  FhirServiceRequests[index] := value;
end;

procedure TFhirServiceRequestList.SetItemN(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCollected.free;
  FDuration.free;
  FQuantity.free;
  FMethod.free;
  FBodySite.free;
  FFastingStatus.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  duration := TFhirSpecimenCollection(oSource).duration.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  bodySite := TFhirSpecimenCollection(oSource).bodySite.Clone;
  fastingStatus := TFhirSpecimenCollection(oSource).fastingStatus.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'fastingStatus[x]') or (child_name = 'fastingStatus') Then
     list.add(self.link, 'fastingStatus[x]', FFastingStatus.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference', false, TFhirReference, FCollector.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirDataType, FCollected.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'duration', 'Duration', false, TFhirDuration, FDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fastingStatus[x]', 'CodeableConcept|Duration', false, TFhirDataType, FFastingStatus.Link)); {L1172}
end;

function TFhirSpecimenCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then
  begin
    FastingStatus := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSpecimenCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected') {L1191}
  else if (propName = 'duration') then result := TFhirDuration.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then raise EFHIRException.create('Cannot make property FastingStatus') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else if (propName = 'duration') then result := 'Duration'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'fastingStatus[x]') then result := 'CodeableConcept|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil {L1189}
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then FastingStatusElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirDataType {L1190}
  else if (propName = 'duration') then DurationElement := new as TFhirDuration {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then FastingStatusElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenCollection.fhirType : string;
begin
  result := 'Specimen.collection';
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

function TFhirSpecimenCollection.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenCollection)) then
    result := false
  else
  begin
    o := TFhirSpecimenCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(collectedElement, o.collectedElement, true) and 
      compareDeep(durationElement, o.durationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(fastingStatusElement, o.fastingStatusElement, true);
  end;
end;

function TFhirSpecimenCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FCollected) and isEmptyProp(FDuration) and isEmptyProp(FQuantity) and isEmptyProp(FMethod) and isEmptyProp(FBodySite) and isEmptyProp(FFastingStatus);
end;

procedure TFhirSpecimenCollection.SetCollector(value : TFhirReference);
begin
  FCollector.free;
  FCollector := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetCollected(value : TFhirDataType);
begin
  FCollected.free;
  FCollected := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetDuration(value : TFhirDuration);
begin
  FDuration.free;
  FDuration := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

procedure TFhirSpecimenCollection.SetFastingStatus(value : TFhirDataType);
begin
  FFastingStatus.free;
  FFastingStatus := value; {L1134}
end;

procedure TFhirSpecimenCollection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('collector');
  fields.add('collected[x]');
  fields.add('duration');
  fields.add('quantity');
  fields.add('method');
  fields.add('bodySite');
  fields.add('fastingStatus[x]');
end;

function TFhirSpecimenCollection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCollector.sizeInBytes);
  inc(result, FCollected.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FFastingStatus.sizeInBytes);
end;

{ TFhirSpecimenCollectionListEnumerator }

constructor TFhirSpecimenCollectionListEnumerator.Create(list : TFhirSpecimenCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenCollectionListEnumerator.GetCurrent : TFhirSpecimenCollection;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenCollectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenCollectionList }

procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;

function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.GetEnumerator : TFhirSpecimenCollectionListEnumerator;
begin
  result := TFhirSpecimenCollectionListEnumerator.Create(self.link);
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenCollection;
end;
function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenProcessing }

constructor TFhirSpecimenProcessing.Create;
begin
  inherited;
end;

destructor TFhirSpecimenProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  FTime.free;
  inherited;
end;

procedure TFhirSpecimenProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSpecimenProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirSpecimenProcessing(oSource).procedure_.Clone;
  if (TFhirSpecimenProcessing(oSource).FAdditiveList = nil) then
  begin
    FAdditiveList.free;
    FAdditiveList := nil;
  end
  else
  begin
    if FAdditiveList = nil then
      FAdditiveList := TFhirReferenceList.Create;
    FAdditiveList.Assign(TFhirSpecimenProcessing(oSource).FAdditiveList);
  end;
  time := TFhirSpecimenProcessing(oSource).time.Clone;
end;

procedure TFhirSpecimenProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
    list.addAll(self, 'additive', FAdditiveList);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirSpecimenProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference', true, TFhirReference, FAdditiveList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link)); {L1172}
end;

function TFhirSpecimenProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    AdditiveList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additive') then AdditiveList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSpecimenProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'additive') then result := AdditiveList.new() {L1053}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then deletePropertyValue('additive', AdditiveList, value) {L1054}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'additive') then replacePropertyValue('additive', AdditiveList, existing, new) {L1055}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additive') then AdditiveList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenProcessing.fhirType : string;
begin
  result := 'Specimen.processing';
end;

function TFhirSpecimenProcessing.Link : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Link);
end;

function TFhirSpecimenProcessing.Clone : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Clone);
end;

function TFhirSpecimenProcessing.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenProcessing)) then
    result := false
  else
  begin
    o := TFhirSpecimenProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(additiveList, o.additiveList, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirSpecimenProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FadditiveList) and isEmptyProp(FTime);
end;

procedure TFhirSpecimenProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirSpecimenProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSpecimenProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSpecimenProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value; {L1134}
end;

function TFhirSpecimenProcessing.GetAdditiveList : TFhirReferenceList;
begin
  if FAdditiveList = nil then
    FAdditiveList := TFhirReferenceList.Create;
  result := FAdditiveList;
end;

function TFhirSpecimenProcessing.GetHasAdditiveList : boolean;
begin
  result := (FAdditiveList <> nil) and (FAdditiveList.count > 0);
end;

procedure TFhirSpecimenProcessing.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value; {L1134}
end;

procedure TFhirSpecimenProcessing.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

function TFhirSpecimenProcessing.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FadditiveList.sizeInBytes);
  inc(result, FTime.sizeInBytes);
end;

{ TFhirSpecimenProcessingListEnumerator }

constructor TFhirSpecimenProcessingListEnumerator.Create(list : TFhirSpecimenProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenProcessingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenProcessingListEnumerator.GetCurrent : TFhirSpecimenProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenProcessingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenProcessingList }

procedure TFhirSpecimenProcessingList.AddItem(value: TFhirSpecimenProcessing);
begin
  assert(value.ClassName = 'TFhirSpecimenProcessing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenProcessing');
  add(value);
end;

function TFhirSpecimenProcessingList.Append: TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenProcessingList.GetEnumerator : TFhirSpecimenProcessingListEnumerator;
begin
  result := TFhirSpecimenProcessingListEnumerator.Create(self.link);
end;

function TFhirSpecimenProcessingList.Clone: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Clone);
end;

function TFhirSpecimenProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenProcessingList.GetItemN(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenProcessing;
end;
function TFhirSpecimenProcessingList.IndexOf(value: TFhirSpecimenProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenProcessingList.Insert(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.InsertItem(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  Inherited Insert(index, value);
end;

function TFhirSpecimenProcessingList.Item(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.Link: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Link);
end;

procedure TFhirSpecimenProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenProcessingList.SetItemByIndex(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  FhirSpecimenProcessings[index] := value;
end;

procedure TFhirSpecimenProcessingList.SetItemN(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimenContainer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  end;
  descriptionElement := TFhirSpecimenContainer(oSource).descriptionElement.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'capacity') Then
     list.add(self.link, 'capacity', FCapacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(self.link, 'specimenQuantity', FSpecimenQuantity.Link);
  if (child_name = 'additive[x]') or (child_name = 'additive') Then
     list.add(self.link, 'additive[x]', FAdditive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', false, TFhirQuantity, FCapacity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', false, TFhirQuantity, FSpecimenQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additive[x]', 'CodeableConcept|Reference', false, TFhirDataType, FAdditive.Link)); {L1172}
end;

function TFhirSpecimenContainer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'capacity') then
  begin
    Capacity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'specimenQuantity') then
  begin
    SpecimenQuantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then
  begin
    Additive := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenContainer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirSpecimenContainer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'capacity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'specimenQuantity') then result := TFhirQuantity.create() {L1203}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Additive') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenContainer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'capacity') then result := 'Quantity'
  else if (propName = 'specimenQuantity') then result := 'Quantity'
  else if (propName = 'additive[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenContainer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'capacity') then CapacityElement := nil
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := nil
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenContainer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'capacity') then CapacityElement := new as TFhirQuantity {L1195}
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := new as TFhirQuantity {L1195}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenContainer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenContainer.fhirType : string;
begin
  result := 'Specimen.container';
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

function TFhirSpecimenContainer.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenContainer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenContainer)) then
    result := false
  else
  begin
    o := TFhirSpecimenContainer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(capacityElement, o.capacityElement, true) and 
      compareDeep(specimenQuantityElement, o.specimenQuantityElement, true) and compareDeep(additiveElement, o.additiveElement, true);
  end;
end;

function TFhirSpecimenContainer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FCapacity) and isEmptyProp(FSpecimenQuantity) and isEmptyProp(FAdditive);
end;

function TFhirSpecimenContainer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSpecimenContainer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value; {L1134}
end;

procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value; {L1134}
end;

procedure TFhirSpecimenContainer.SetAdditive(value : TFhirDataType);
begin
  FAdditive.free;
  FAdditive := value; {L1134}
end;

procedure TFhirSpecimenContainer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('description');
  fields.add('type');
  fields.add('capacity');
  fields.add('specimenQuantity');
  fields.add('additive[x]');
end;

function TFhirSpecimenContainer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCapacity.sizeInBytes);
  inc(result, FSpecimenQuantity.sizeInBytes);
  inc(result, FAdditive.sizeInBytes);
end;

{ TFhirSpecimenContainerListEnumerator }

constructor TFhirSpecimenContainerListEnumerator.Create(list : TFhirSpecimenContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenContainerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenContainerListEnumerator.GetCurrent : TFhirSpecimenContainer;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenContainerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenContainerList }

procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;

function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.GetEnumerator : TFhirSpecimenContainerListEnumerator;
begin
  result := TFhirSpecimenContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenContainer;
end;
function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimen }

constructor TFhirSpecimen.Create;
begin
  inherited;
end;

destructor TFhirSpecimen.Destroy;
begin
  FIdentifierList.Free;
  FAccessionIdentifier.free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FReceivedTime.free;
  FParentList.Free;
  FRequestList.Free;
  FCollection.free;
  FProcessingList.Free;
  FContainerList.Free;
  FConditionList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirSpecimen.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimen(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimen(oSource).FIdentifierList);
  end;
  accessionIdentifier := TFhirSpecimen(oSource).accessionIdentifier.Clone;
  statusElement := TFhirSpecimen(oSource).statusElement.Clone;
  type_ := TFhirSpecimen(oSource).type_.Clone;
  subject := TFhirSpecimen(oSource).subject.Clone;
  receivedTimeElement := TFhirSpecimen(oSource).receivedTimeElement.Clone;
  if (TFhirSpecimen(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList.Create;
    FParentList.Assign(TFhirSpecimen(oSource).FParentList);
  end;
  if (TFhirSpecimen(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList.Create;
    FRequestList.Assign(TFhirSpecimen(oSource).FRequestList);
  end;
  collection := TFhirSpecimen(oSource).collection.Clone;
  if (TFhirSpecimen(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirSpecimenProcessingList.Create;
    FProcessingList.Assign(TFhirSpecimen(oSource).FProcessingList);
  end;
  if (TFhirSpecimen(oSource).FContainerList = nil) then
  begin
    FContainerList.free;
    FContainerList := nil;
  end
  else
  begin
    if FContainerList = nil then
      FContainerList := TFhirSpecimenContainerList.Create;
    FContainerList.Assign(TFhirSpecimen(oSource).FContainerList);
  end;
  if (TFhirSpecimen(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodeableConceptList.Create;
    FConditionList.Assign(TFhirSpecimen(oSource).FConditionList);
  end;
  if (TFhirSpecimen(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSpecimen(oSource).FNoteList);
  end;
end;

function TFhirSpecimen.GetResourceType : TFhirResourceType;
begin
  result := frtSpecimen;
end;

procedure TFhirSpecimen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'accessionIdentifier') Then
     list.add(self.link, 'accessionIdentifier', FAccessionIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'receivedTime') Then
     list.add(self.link, 'receivedTime', FReceivedTime.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'container') Then
    list.addAll(self, 'container', FContainerList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirSpecimen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'accessionIdentifier', 'Identifier', false, TFhirIdentifier, FAccessionIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'receivedTime', 'dateTime', false, TFhirDateTime, FReceivedTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', true, TFhirReference, FParentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', true, TFhirReference, FRequestList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'collection', 'BackboneElement', false, TFhirSpecimenCollection, FCollection.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'processing', 'BackboneElement', true, TFhirSpecimenProcessing, FProcessingList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'container', 'BackboneElement', true, TFhirSpecimenContainer, FContainerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'condition', 'CodeableConcept', true, TFhirCodeableConcept, FConditionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirSpecimen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'accessionIdentifier') then
  begin
    AccessionIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'receivedTime') then
  begin
    ReceivedTimeElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirSpecimenCollection {L1199};
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirSpecimenProcessing) {L1048};
    result := propValue;
  end
  else if (propName = 'container') then
  begin
    ContainerList.add(propValue as TFhirSpecimenContainer) {L1048};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirSpecimenProcessing) {L1049}
  else if (propName = 'container') then ContainerList.insertItem(index, propValue as TFhirSpecimenContainer) {L1049}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirSpecimen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'accessionIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[SpecimenStatusNull], CODES_TFhirSpecimenStatusEnum[SpecimenStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'receivedTime') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'parent') then result := ParentList.new() {L1053}
  else if (propName = 'request') then result := RequestList.new() {L1053}
  else if (propName = 'collection') then result := TFhirSpecimenCollection.create() {L1203}
  else if (propName = 'processing') then result := ProcessingList.new() {L1053}
  else if (propName = 'container') then result := ContainerList.new() {L1053}
  else if (propName = 'condition') then result := ConditionList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'accessionIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'receivedTime') then result := 'dateTime'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'collection') then result := 'BackboneElement'
  else if (propName = 'processing') then result := 'BackboneElement'
  else if (propName = 'container') then result := 'BackboneElement'
  else if (propName = 'condition') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'receivedTime') then ReceivedTimeElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {L1054}
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value) {L1054}
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value) {L1054}
  else if (propName = 'container') then deletePropertyValue('container', ContainerList, value) {L1054}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'receivedTime') then ReceivedTimeElement := asDateTime(new) {L1222}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {L1055}
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new) {L1055}
  else if (propName = 'collection') then CollectionElement := new as TFhirSpecimenCollection {L1195}
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new) {L1055}
  else if (propName = 'container') then replacePropertyValue('container', ContainerList, existing, new) {L1055}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimen.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'parent') then ParentList.move(source, destination) {L1050}
  else if (propName = 'request') then RequestList.move(source, destination) {L1050}
  else if (propName = 'processing') then ProcessingList.move(source, destination) {L1050}
  else if (propName = 'container') then ContainerList.move(source, destination) {L1050}
  else if (propName = 'condition') then ConditionList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimen.fhirType : string;
begin
  result := 'Specimen';
end;

function TFhirSpecimen.Link : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Link);
end;

function TFhirSpecimen.Clone : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Clone);
end;

function TFhirSpecimen.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimen)) then
    result := false
  else
  begin
    o := TFhirSpecimen(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(accessionIdentifierElement, o.accessionIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(receivedTimeElement, o.receivedTimeElement, true) and 
      compareDeep(parentList, o.parentList, true) and compareDeep(requestList, o.requestList, true) and 
      compareDeep(collectionElement, o.collectionElement, true) and compareDeep(processingList, o.processingList, true) and 
      compareDeep(containerList, o.containerList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirSpecimen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAccessionIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FReceivedTime) and isEmptyProp(FparentList) and isEmptyProp(FrequestList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FcontainerList) and isEmptyProp(FconditionList) and isEmptyProp(FnoteList);
end;

function TFhirSpecimen.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSpecimen.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSpecimen.SetAccessionIdentifier(value : TFhirIdentifier);
begin
  FAccessionIdentifier.free;
  FAccessionIdentifier := value; {L1134}
end;

procedure TFhirSpecimen.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSpecimen.GetStatusST : TFhirSpecimenStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSpecimenStatusEnum(0)
  else
    result := TFhirSpecimenStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSpecimenStatusEnum, FStatus.value));
end;

procedure TFhirSpecimen.SetStatusST(value : TFhirSpecimenStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[value], CODES_TFhirSpecimenStatusEnum[value]);
end;

procedure TFhirSpecimen.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSpecimen.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirSpecimen.SetReceivedTime(value : TFhirDateTime);
begin
  FReceivedTime.free;
  FReceivedTime := value; {L1134}
end;

function TFhirSpecimen.GetReceivedTimeST : TFslDateTime;
begin
  if FReceivedTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceivedTime.value;
end;

procedure TFhirSpecimen.SetReceivedTimeST(value : TFslDateTime);
begin
  if FReceivedTime = nil then
    FReceivedTime := TFhirDateTime.create;
  FReceivedTime.value := value
end;

function TFhirSpecimen.GetParentList : TFhirReferenceList;
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList.Create;
  result := FParentList;
end;

function TFhirSpecimen.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

function TFhirSpecimen.GetRequestList : TFhirReferenceList;
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList.Create;
  result := FRequestList;
end;

function TFhirSpecimen.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

procedure TFhirSpecimen.SetCollection(value : TFhirSpecimenCollection);
begin
  FCollection.free;
  FCollection := value; {L1134}
end;

function TFhirSpecimen.GetProcessingList : TFhirSpecimenProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirSpecimenProcessingList.Create;
  result := FProcessingList;
end;

function TFhirSpecimen.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

function TFhirSpecimen.GetContainerList : TFhirSpecimenContainerList;
begin
  if FContainerList = nil then
    FContainerList := TFhirSpecimenContainerList.Create;
  result := FContainerList;
end;

function TFhirSpecimen.GetHasContainerList : boolean;
begin
  result := (FContainerList <> nil) and (FContainerList.count > 0);
end;

function TFhirSpecimen.GetConditionList : TFhirCodeableConceptList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodeableConceptList.Create;
  result := FConditionList;
end;

function TFhirSpecimen.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirSpecimen.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSpecimen.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirSpecimen.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('accessionIdentifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('receivedTime');
  fields.add('parent');
  fields.add('request');
  fields.add('collection');
  fields.add('processing');
  fields.add('container');
  fields.add('condition');
  fields.add('note');
end;

function TFhirSpecimen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAccessionIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FReceivedTime.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FrequestList.sizeInBytes);
  inc(result, FCollection.sizeInBytes);
  inc(result, FprocessingList.sizeInBytes);
  inc(result, FcontainerList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirSpecimenListEnumerator }

constructor TFhirSpecimenListEnumerator.Create(list : TFhirSpecimenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenListEnumerator.GetCurrent : TFhirSpecimen;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenList }

procedure TFhirSpecimenList.AddItem(value: TFhirSpecimen);
begin
  assert(value.ClassName = 'TFhirSpecimen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimen');
  add(value);
end;

function TFhirSpecimenList.Append: TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenList.GetEnumerator : TFhirSpecimenListEnumerator;
begin
  result := TFhirSpecimenListEnumerator.Create(self.link);
end;

function TFhirSpecimenList.Clone: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Clone);
end;

function TFhirSpecimenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenList.GetItemN(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimen;
end;
function TFhirSpecimenList.IndexOf(value: TFhirSpecimen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenList.Insert(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.InsertItem(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  Inherited Insert(index, value);
end;

function TFhirSpecimenList.Item(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.Link: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Link);
end;

procedure TFhirSpecimenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenList.SetItemByIndex(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  FhirSpecimen[index] := value;
end;

procedure TFhirSpecimenList.SetItemN(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
{ TFhirSupplyDeliverySuppliedItem }

constructor TFhirSupplyDeliverySuppliedItem.Create;
begin
  inherited;
end;

destructor TFhirSupplyDeliverySuppliedItem.Destroy;
begin
  FQuantity.free;
  FItem.free;
  inherited;
end;

procedure TFhirSupplyDeliverySuppliedItem.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSupplyDeliverySuppliedItem(oSource).quantity.Clone;
  item := TFhirSupplyDeliverySuppliedItem(oSource).item.Clone;
end;

procedure TFhirSupplyDeliverySuppliedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirSupplyDeliverySuppliedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference', false, TFhirDataType, FItem.Link)); {L1172}
end;

function TFhirSupplyDeliverySuppliedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyDeliverySuppliedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyDeliverySuppliedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDeliverySuppliedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDeliverySuppliedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDeliverySuppliedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDeliverySuppliedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDeliverySuppliedItem.fhirType : string;
begin
  result := 'SupplyDelivery.suppliedItem';
end;

function TFhirSupplyDeliverySuppliedItem.Link : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Link);
end;

function TFhirSupplyDeliverySuppliedItem.Clone : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItem.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyDeliverySuppliedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDeliverySuppliedItem)) then
    result := false
  else
  begin
    o := TFhirSupplyDeliverySuppliedItem(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirSupplyDeliverySuppliedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FItem);
end;

procedure TFhirSupplyDeliverySuppliedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirSupplyDeliverySuppliedItem.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirSupplyDeliverySuppliedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('item[x]');
end;

function TFhirSupplyDeliverySuppliedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirSupplyDeliverySuppliedItemListEnumerator }

constructor TFhirSupplyDeliverySuppliedItemListEnumerator.Create(list : TFhirSupplyDeliverySuppliedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliverySuppliedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.GetCurrent : TFhirSupplyDeliverySuppliedItem;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyDeliverySuppliedItemList }

procedure TFhirSupplyDeliverySuppliedItemList.AddItem(value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value.ClassName = 'TFhirSupplyDeliverySuppliedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDeliverySuppliedItem');
  add(value);
end;

function TFhirSupplyDeliverySuppliedItemList.Append: TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliverySuppliedItemList.GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;
begin
  result := TFhirSupplyDeliverySuppliedItemListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliverySuppliedItemList.Clone: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliverySuppliedItemList.GetItemN(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDeliverySuppliedItem;
end;
function TFhirSupplyDeliverySuppliedItemList.IndexOf(value: TFhirSupplyDeliverySuppliedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliverySuppliedItemList.Insert(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.InsertItem(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliverySuppliedItemList.Item(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.Link: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Link);
end;

procedure TFhirSupplyDeliverySuppliedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemByIndex(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  FhirSupplyDeliverySuppliedItems[index] := value;
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemN(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDelivery }

constructor TFhirSupplyDelivery.Create;
begin
  inherited;
end;

destructor TFhirSupplyDelivery.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FPatient.free;
  FType_.free;
  FSuppliedItem.free;
  FOccurrence.free;
  FSupplier.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

procedure TFhirSupplyDelivery.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSupplyDelivery(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSupplyDelivery(oSource).FIdentifierList);
  end;
  if (TFhirSupplyDelivery(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirSupplyDelivery(oSource).FBasedOnList);
  end;
  if (TFhirSupplyDelivery(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirSupplyDelivery(oSource).FPartOfList);
  end;
  statusElement := TFhirSupplyDelivery(oSource).statusElement.Clone;
  patient := TFhirSupplyDelivery(oSource).patient.Clone;
  type_ := TFhirSupplyDelivery(oSource).type_.Clone;
  suppliedItem := TFhirSupplyDelivery(oSource).suppliedItem.Clone;
  occurrence := TFhirSupplyDelivery(oSource).occurrence.Clone;
  supplier := TFhirSupplyDelivery(oSource).supplier.Clone;
  destination := TFhirSupplyDelivery(oSource).destination.Clone;
  if (TFhirSupplyDelivery(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList.Create;
    FReceiverList.Assign(TFhirSupplyDelivery(oSource).FReceiverList);
  end;
end;

function TFhirSupplyDelivery.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyDelivery;
end;

procedure TFhirSupplyDelivery.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'suppliedItem') Then
     list.add(self.link, 'suppliedItem', FSuppliedItem.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'supplier') Then
     list.add(self.link, 'supplier', FSupplier.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
end;

procedure TFhirSupplyDelivery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'BackboneElement', false, TFhirSupplyDeliverySuppliedItem, FSuppliedItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', false, TFhirReference, FSupplier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', true, TFhirReference, FReceiverList.Link)) {L1039};
end;

function TFhirSupplyDelivery.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyDeliveryStatusEnum, CODES_TFhirSupplyDeliveryStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'suppliedItem') then
  begin
    SuppliedItem := propValue as TFhirSupplyDeliverySuppliedItem {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    Supplier := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyDelivery.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSupplyDelivery.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSupplyDeliveryStatusEnum[SupplyDeliveryStatusNull], CODES_TFhirSupplyDeliveryStatusEnum[SupplyDeliveryStatusNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'suppliedItem') then result := TFhirSupplyDeliverySuppliedItem.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'supplier') then result := TFhirReference.create() {L1203}
  else if (propName = 'destination') then result := TFhirReference.create() {L1203}
  else if (propName = 'receiver') then result := ReceiverList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDelivery.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'suppliedItem') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDelivery.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'suppliedItem') then SuppliedItemElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'supplier') then SupplierElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDelivery.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyDeliveryStatusEnum, CODES_TFhirSupplyDeliveryStatusEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'suppliedItem') then SuppliedItemElement := new as TFhirSupplyDeliverySuppliedItem {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'supplier') then SupplierElement := new as TFhirReference {L1195}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference {L1195}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDelivery.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'receiver') then ReceiverList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDelivery.fhirType : string;
begin
  result := 'SupplyDelivery';
end;

function TFhirSupplyDelivery.Link : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Link);
end;

function TFhirSupplyDelivery.Clone : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Clone);
end;

function TFhirSupplyDelivery.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyDelivery;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDelivery)) then
    result := false
  else
  begin
    o := TFhirSupplyDelivery(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(suppliedItemElement, o.suppliedItemElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(supplierElement, o.supplierElement, true) and compareDeep(destinationElement, o.destinationElement, true) and 
      compareDeep(receiverList, o.receiverList, true);
  end;
end;

function TFhirSupplyDelivery.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FType_) and isEmptyProp(FSuppliedItem) and isEmptyProp(FOccurrence) and isEmptyProp(FSupplier) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList);
end;

function TFhirSupplyDelivery.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSupplyDelivery.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirSupplyDelivery.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirSupplyDelivery.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirSupplyDelivery.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirSupplyDelivery.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirSupplyDelivery.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSupplyDelivery.GetStatusST : TFhirSupplyDeliveryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyDeliveryStatusEnum(0)
  else
    result := TFhirSupplyDeliveryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyDeliveryStatusEnum, FStatus.value));
end;

procedure TFhirSupplyDelivery.SetStatusST(value : TFhirSupplyDeliveryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyDeliveryStatusEnum[value], CODES_TFhirSupplyDeliveryStatusEnum[value]);
end;

procedure TFhirSupplyDelivery.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirSupplyDelivery.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSupplyDelivery.SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
begin
  FSuppliedItem.free;
  FSuppliedItem := value; {L1134}
end;

procedure TFhirSupplyDelivery.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirSupplyDelivery.SetSupplier(value : TFhirReference);
begin
  FSupplier.free;
  FSupplier := value; {L1134}
end;

procedure TFhirSupplyDelivery.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value; {L1134}
end;

function TFhirSupplyDelivery.GetReceiverList : TFhirReferenceList;
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList.Create;
  result := FReceiverList;
end;

function TFhirSupplyDelivery.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

procedure TFhirSupplyDelivery.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('patient');
  fields.add('type');
  fields.add('suppliedItem');
  fields.add('occurrence[x]');
  fields.add('supplier');
  fields.add('destination');
  fields.add('receiver');
end;

function TFhirSupplyDelivery.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSuppliedItem.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FSupplier.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
end;

{ TFhirSupplyDeliveryListEnumerator }

constructor TFhirSupplyDeliveryListEnumerator.Create(list : TFhirSupplyDeliveryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliveryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliveryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliveryListEnumerator.GetCurrent : TFhirSupplyDelivery;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliveryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyDeliveryList }

procedure TFhirSupplyDeliveryList.AddItem(value: TFhirSupplyDelivery);
begin
  assert(value.ClassName = 'TFhirSupplyDelivery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDelivery');
  add(value);
end;

function TFhirSupplyDeliveryList.Append: TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliveryList.GetEnumerator : TFhirSupplyDeliveryListEnumerator;
begin
  result := TFhirSupplyDeliveryListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliveryList.Clone: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Clone);
end;

function TFhirSupplyDeliveryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliveryList.GetItemN(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDelivery;
end;
function TFhirSupplyDeliveryList.IndexOf(value: TFhirSupplyDelivery): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliveryList.Insert(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.InsertItem(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliveryList.Item(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.Link: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Link);
end;

procedure TFhirSupplyDeliveryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliveryList.SetItemByIndex(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  FhirSupplyDeliveries[index] := value;
end;

procedure TFhirSupplyDeliveryList.SetItemN(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
{ TFhirSupplyRequestParameter }

constructor TFhirSupplyRequestParameter.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequestParameter.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirSupplyRequestParameter.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSupplyRequestParameter(oSource).code.Clone;
  value := TFhirSupplyRequestParameter(oSource).value.Clone;
end;

procedure TFhirSupplyRequestParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirSupplyRequestParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range|boolean', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirSupplyRequestParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequestParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyRequestParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequestParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequestParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequestParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequestParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequestParameter.fhirType : string;
begin
  result := 'SupplyRequest.parameter';
end;

function TFhirSupplyRequestParameter.Link : TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(inherited Link);
end;

function TFhirSupplyRequestParameter.Clone : TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(inherited Clone);
end;

function TFhirSupplyRequestParameter.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyRequestParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequestParameter)) then
    result := false
  else
  begin
    o := TFhirSupplyRequestParameter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirSupplyRequestParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirSupplyRequestParameter.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirSupplyRequestParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirSupplyRequestParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirSupplyRequestParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirSupplyRequestParameterListEnumerator }

constructor TFhirSupplyRequestParameterListEnumerator.Create(list : TFhirSupplyRequestParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestParameterListEnumerator.GetCurrent : TFhirSupplyRequestParameter;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestParameterList }

procedure TFhirSupplyRequestParameterList.AddItem(value: TFhirSupplyRequestParameter);
begin
  assert(value.ClassName = 'TFhirSupplyRequestParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequestParameter');
  add(value);
end;

function TFhirSupplyRequestParameterList.Append: TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestParameterList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestParameterList.GetEnumerator : TFhirSupplyRequestParameterListEnumerator;
begin
  result := TFhirSupplyRequestParameterListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestParameterList.Clone: TFhirSupplyRequestParameterList;
begin
  result := TFhirSupplyRequestParameterList(inherited Clone);
end;

function TFhirSupplyRequestParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestParameterList.GetItemN(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(ObjectByIndex[index]);
end;

function TFhirSupplyRequestParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequestParameter;
end;
function TFhirSupplyRequestParameterList.IndexOf(value: TFhirSupplyRequestParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestParameterList.Insert(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestParameterList.InsertItem(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestParameterList.Item(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(ObjectByIndex[index]);
end;

function TFhirSupplyRequestParameterList.Link: TFhirSupplyRequestParameterList;
begin
  result := TFhirSupplyRequestParameterList(inherited Link);
end;

procedure TFhirSupplyRequestParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestParameterList.SetItemByIndex(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  FhirSupplyRequestParameters[index] := value;
end;

procedure TFhirSupplyRequestParameterList.SetItemN(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyRequest }

constructor TFhirSupplyRequest.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategory.free;
  FPriority.free;
  FItem.free;
  FQuantity.free;
  FParameterList.Free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FSupplierList.Free;
  FReasonList.Free;
  FDeliverFrom.free;
  FDeliverTo.free;
  inherited;
end;

procedure TFhirSupplyRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSupplyRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSupplyRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirSupplyRequest(oSource).statusElement.Clone;
  category := TFhirSupplyRequest(oSource).category.Clone;
  priorityElement := TFhirSupplyRequest(oSource).priorityElement.Clone;
  item := TFhirSupplyRequest(oSource).item.Clone;
  quantity := TFhirSupplyRequest(oSource).quantity.Clone;
  if (TFhirSupplyRequest(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirSupplyRequestParameterList.Create;
    FParameterList.Assign(TFhirSupplyRequest(oSource).FParameterList);
  end;
  occurrence := TFhirSupplyRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirSupplyRequest(oSource).authoredOnElement.Clone;
  requester := TFhirSupplyRequest(oSource).requester.Clone;
  if (TFhirSupplyRequest(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList.Create;
    FSupplierList.Assign(TFhirSupplyRequest(oSource).FSupplierList);
  end;
  if (TFhirSupplyRequest(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirSupplyRequest(oSource).FReasonList);
  end;
  deliverFrom := TFhirSupplyRequest(oSource).deliverFrom.Clone;
  deliverTo := TFhirSupplyRequest(oSource).deliverTo.Clone;
end;

function TFhirSupplyRequest.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyRequest;
end;

procedure TFhirSupplyRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'deliverFrom') Then
     list.add(self.link, 'deliverFrom', FDeliverFrom.Link);
  if (child_name = 'deliverTo') Then
     list.add(self.link, 'deliverTo', FDeliverTo.Link);
end;

procedure TFhirSupplyRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirSupplyRequestParameter, FParameterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', true, TFhirReference, FSupplierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'deliverFrom', 'Reference', false, TFhirReference, FDeliverFrom.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'deliverTo', 'Reference', false, TFhirReference, FDeliverTo.Link)); {L1172}
end;

function TFhirSupplyRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyRequestStatusEnum, CODES_TFhirSupplyRequestStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirSupplyRequestParameter) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'deliverFrom') then
  begin
    DeliverFrom := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'deliverTo') then
  begin
    DeliverTo := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirSupplyRequestParameter) {L1049}
  else if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else inherited;
end;

function TFhirSupplyRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSupplyRequestStatusEnum[SupplyRequestStatusNull], CODES_TFhirSupplyRequestStatusEnum[SupplyRequestStatusNull])  {L1211}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull])  {L1211}
  else if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'parameter') then result := ParameterList.new() {L1053}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requester') then result := TFhirReference.create() {L1203}
  else if (propName = 'supplier') then result := SupplierList.new() {L1053}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'deliverFrom') then result := TFhirReference.create() {L1203}
  else if (propName = 'deliverTo') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'deliverFrom') then result := 'Reference'
  else if (propName = 'deliverTo') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'item') then ItemElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {L1054}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value) {L1054}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'deliverFrom') then DeliverFromElement := nil
  else if (propName = 'deliverTo') then DeliverToElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyRequestStatusEnum, CODES_TFhirSupplyRequestStatusEnum, new) {L1210}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new) {L1210}
  else if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {L1055}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new) {L1222}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference {L1195}
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new) {L1055}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'deliverFrom') then DeliverFromElement := new as TFhirReference {L1195}
  else if (propName = 'deliverTo') then DeliverToElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'parameter') then ParameterList.move(source, destination) {L1050}
  else if (propName = 'supplier') then SupplierList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequest.fhirType : string;
begin
  result := 'SupplyRequest';
end;

function TFhirSupplyRequest.Link : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Link);
end;

function TFhirSupplyRequest.Clone : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Clone);
end;

function TFhirSupplyRequest.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequest)) then
    result := false
  else
  begin
    o := TFhirSupplyRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(itemElement, o.itemElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(supplierList, o.supplierList, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(deliverFromElement, o.deliverFromElement, true) and compareDeep(deliverToElement, o.deliverToElement, true);
  end;
end;

function TFhirSupplyRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FPriority) and isEmptyProp(FItem) and isEmptyProp(FQuantity) and isEmptyProp(FparameterList) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FsupplierList) and isEmptyProp(FreasonList) and isEmptyProp(FDeliverFrom) and isEmptyProp(FDeliverTo);
end;

function TFhirSupplyRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSupplyRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSupplyRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSupplyRequest.GetStatusST : TFhirSupplyRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyRequestStatusEnum(0)
  else
    result := TFhirSupplyRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyRequestStatusEnum, FStatus.value));
end;

procedure TFhirSupplyRequest.SetStatusST(value : TFhirSupplyRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyRequestStatusEnum[value], CODES_TFhirSupplyRequestStatusEnum[value]);
end;

procedure TFhirSupplyRequest.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirSupplyRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirSupplyRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirSupplyRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirSupplyRequest.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirSupplyRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirSupplyRequest.GetParameterList : TFhirSupplyRequestParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirSupplyRequestParameterList.Create;
  result := FParameterList;
end;

function TFhirSupplyRequest.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

procedure TFhirSupplyRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

procedure TFhirSupplyRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value; {L1134}
end;

function TFhirSupplyRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirSupplyRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirSupplyRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value; {L1134}
end;

function TFhirSupplyRequest.GetSupplierList : TFhirReferenceList;
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList.Create;
  result := FSupplierList;
end;

function TFhirSupplyRequest.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

function TFhirSupplyRequest.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirSupplyRequest.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirSupplyRequest.SetDeliverFrom(value : TFhirReference);
begin
  FDeliverFrom.free;
  FDeliverFrom := value; {L1134}
end;

procedure TFhirSupplyRequest.SetDeliverTo(value : TFhirReference);
begin
  FDeliverTo.free;
  FDeliverTo := value; {L1134}
end;

procedure TFhirSupplyRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('priority');
  fields.add('item');
  fields.add('quantity');
  fields.add('parameter');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('supplier');
  fields.add('reason');
  fields.add('deliverFrom');
  fields.add('deliverTo');
end;

function TFhirSupplyRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FItem.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FsupplierList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FDeliverFrom.sizeInBytes);
  inc(result, FDeliverTo.sizeInBytes);
end;

{ TFhirSupplyRequestListEnumerator }

constructor TFhirSupplyRequestListEnumerator.Create(list : TFhirSupplyRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestListEnumerator.GetCurrent : TFhirSupplyRequest;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestList }

procedure TFhirSupplyRequestList.AddItem(value: TFhirSupplyRequest);
begin
  assert(value.ClassName = 'TFhirSupplyRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequest');
  add(value);
end;

function TFhirSupplyRequestList.Append: TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestList.GetEnumerator : TFhirSupplyRequestListEnumerator;
begin
  result := TFhirSupplyRequestListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestList.Clone: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Clone);
end;

function TFhirSupplyRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestList.GetItemN(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequest;
end;
function TFhirSupplyRequestList.IndexOf(value: TFhirSupplyRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestList.Insert(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.InsertItem(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestList.Item(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.Link: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Link);
end;

procedure TFhirSupplyRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestList.SetItemByIndex(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  FhirSupplyRequests[index] := value;
end;

procedure TFhirSupplyRequestList.SetItemN(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
{ TFhirVisionPrescriptionLensSpecification }

constructor TFhirVisionPrescriptionLensSpecification.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionLensSpecification.Destroy;
begin
  FProduct.free;
  FEye.free;
  FSphere.free;
  FCylinder.free;
  FAxis.free;
  FPrismList.Free;
  FAdd.free;
  FPower.free;
  FBackCurve.free;
  FDiameter.free;
  FDuration.free;
  FColor.free;
  FBrand.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirVisionPrescriptionLensSpecification.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirVisionPrescriptionLensSpecification(oSource).product.Clone;
  eyeElement := TFhirVisionPrescriptionLensSpecification(oSource).eyeElement.Clone;
  sphereElement := TFhirVisionPrescriptionLensSpecification(oSource).sphereElement.Clone;
  cylinderElement := TFhirVisionPrescriptionLensSpecification(oSource).cylinderElement.Clone;
  axisElement := TFhirVisionPrescriptionLensSpecification(oSource).axisElement.Clone;
  if (TFhirVisionPrescriptionLensSpecification(oSource).FPrismList = nil) then
  begin
    FPrismList.free;
    FPrismList := nil;
  end
  else
  begin
    if FPrismList = nil then
      FPrismList := TFhirVisionPrescriptionLensSpecificationPrismList.Create;
    FPrismList.Assign(TFhirVisionPrescriptionLensSpecification(oSource).FPrismList);
  end;
  addElement := TFhirVisionPrescriptionLensSpecification(oSource).addElement.Clone;
  powerElement := TFhirVisionPrescriptionLensSpecification(oSource).powerElement.Clone;
  backCurveElement := TFhirVisionPrescriptionLensSpecification(oSource).backCurveElement.Clone;
  diameterElement := TFhirVisionPrescriptionLensSpecification(oSource).diameterElement.Clone;
  duration := TFhirVisionPrescriptionLensSpecification(oSource).duration.Clone;
  colorElement := TFhirVisionPrescriptionLensSpecification(oSource).colorElement.Clone;
  brandElement := TFhirVisionPrescriptionLensSpecification(oSource).brandElement.Clone;
  if (TFhirVisionPrescriptionLensSpecification(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirVisionPrescriptionLensSpecification(oSource).FNoteList);
  end;
end;

procedure TFhirVisionPrescriptionLensSpecification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'eye') Then
     list.add(self.link, 'eye', FEye.Link);
  if (child_name = 'sphere') Then
     list.add(self.link, 'sphere', FSphere.Link);
  if (child_name = 'cylinder') Then
     list.add(self.link, 'cylinder', FCylinder.Link);
  if (child_name = 'axis') Then
     list.add(self.link, 'axis', FAxis.Link);
  if (child_name = 'prism') Then
    list.addAll(self, 'prism', FPrismList);
  if (child_name = 'add') Then
     list.add(self.link, 'add', FAdd.Link);
  if (child_name = 'power') Then
     list.add(self.link, 'power', FPower.Link);
  if (child_name = 'backCurve') Then
     list.add(self.link, 'backCurve', FBackCurve.Link);
  if (child_name = 'diameter') Then
     list.add(self.link, 'diameter', FDiameter.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'brand') Then
     list.add(self.link, 'brand', FBrand.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirVisionPrescriptionLensSpecification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableConcept', false, TFhirCodeableConcept, FProduct.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'eye', 'code', false, TFhirEnum, FEye.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'sphere', 'decimal', false, TFhirDecimal, FSphere.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cylinder', 'decimal', false, TFhirDecimal, FCylinder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'axis', 'integer', false, TFhirInteger, FAxis.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'prism', 'BackboneElement', true, TFhirVisionPrescriptionLensSpecificationPrism, FPrismList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'add', 'decimal', false, TFhirDecimal, FAdd.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'power', 'decimal', false, TFhirDecimal, FPower.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'backCurve', 'decimal', false, TFhirDecimal, FBackCurve.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diameter', 'decimal', false, TFhirDecimal, FDiameter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'color', 'string', false, TFhirString, FColor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'brand', 'string', false, TFhirString, FBrand.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirVisionPrescriptionLensSpecification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'eye') then
  begin
    EyeElement := asEnum(SYSTEMS_TFhirVisionEyesEnum, CODES_TFhirVisionEyesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'sphere') then
  begin
    SphereElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'cylinder') then
  begin
    CylinderElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'axis') then
  begin
    AxisElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'prism') then
  begin
    PrismList.add(propValue as TFhirVisionPrescriptionLensSpecificationPrism) {L1048};
    result := propValue;
  end
  else if (propName = 'add') then
  begin
    AddElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'power') then
  begin
    PowerElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'backCurve') then
  begin
    BackCurveElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'diameter') then
  begin
    DiameterElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'brand') then
  begin
    BrandElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionLensSpecification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'prism') then PrismList.insertItem(index, propValue as TFhirVisionPrescriptionLensSpecificationPrism) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirVisionPrescriptionLensSpecification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'eye') then result := TFhirEnum.create(SYSTEMS_TFhirVisionEyesEnum[VisionEyesNull], CODES_TFhirVisionEyesEnum[VisionEyesNull])  {L1211}
  else if (propName = 'sphere') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'cylinder') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'axis') then result := TFhirInteger.create() {L1223}
  else if (propName = 'prism') then result := PrismList.new() {L1053}
  else if (propName = 'add') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'power') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'backCurve') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'diameter') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'duration') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'color') then result := TFhirString.create() {L1223}
  else if (propName = 'brand') then result := TFhirString.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionLensSpecification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableConcept'
  else if (propName = 'eye') then result := 'code'
  else if (propName = 'sphere') then result := 'decimal'
  else if (propName = 'cylinder') then result := 'decimal'
  else if (propName = 'axis') then result := 'integer'
  else if (propName = 'prism') then result := 'BackboneElement'
  else if (propName = 'add') then result := 'decimal'
  else if (propName = 'power') then result := 'decimal'
  else if (propName = 'backCurve') then result := 'decimal'
  else if (propName = 'diameter') then result := 'decimal'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'color') then result := 'string'
  else if (propName = 'brand') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionLensSpecification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'eye') then EyeElement := nil
  else if (propName = 'sphere') then SphereElement := nil
  else if (propName = 'cylinder') then CylinderElement := nil
  else if (propName = 'axis') then AxisElement := nil
  else if (propName = 'prism') then deletePropertyValue('prism', PrismList, value) {L1054}
  else if (propName = 'add') then AddElement := nil
  else if (propName = 'power') then PowerElement := nil
  else if (propName = 'backCurve') then BackCurveElement := nil
  else if (propName = 'diameter') then DiameterElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'brand') then BrandElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionLensSpecification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'eye') then EyeElement := asEnum(SYSTEMS_TFhirVisionEyesEnum, CODES_TFhirVisionEyesEnum, new) {L1210}
  else if (propName = 'sphere') then SphereElement := asDecimal(new) {L1222}
  else if (propName = 'cylinder') then CylinderElement := asDecimal(new) {L1222}
  else if (propName = 'axis') then AxisElement := asInteger(new) {L1222}
  else if (propName = 'prism') then replacePropertyValue('prism', PrismList, existing, new) {L1055}
  else if (propName = 'add') then AddElement := asDecimal(new) {L1222}
  else if (propName = 'power') then PowerElement := asDecimal(new) {L1222}
  else if (propName = 'backCurve') then BackCurveElement := asDecimal(new) {L1222}
  else if (propName = 'diameter') then DiameterElement := asDecimal(new) {L1222}
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity {L1195}
  else if (propName = 'color') then ColorElement := asString(new) {L1222}
  else if (propName = 'brand') then BrandElement := asString(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionLensSpecification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'prism') then PrismList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionLensSpecification.fhirType : string;
begin
  result := 'VisionPrescription.lensSpecification';
end;

function TFhirVisionPrescriptionLensSpecification.Link : TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(inherited Link);
end;

function TFhirVisionPrescriptionLensSpecification.Clone : TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecification.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescriptionLensSpecification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionLensSpecification)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionLensSpecification(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(eyeElement, o.eyeElement, true) and 
      compareDeep(sphereElement, o.sphereElement, true) and compareDeep(cylinderElement, o.cylinderElement, true) and 
      compareDeep(axisElement, o.axisElement, true) and compareDeep(prismList, o.prismList, true) and 
      compareDeep(addElement, o.addElement, true) and compareDeep(powerElement, o.powerElement, true) and 
      compareDeep(backCurveElement, o.backCurveElement, true) and compareDeep(diameterElement, o.diameterElement, true) and 
      compareDeep(durationElement, o.durationElement, true) and compareDeep(colorElement, o.colorElement, true) and 
      compareDeep(brandElement, o.brandElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirVisionPrescriptionLensSpecification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FEye) and isEmptyProp(FSphere) and isEmptyProp(FCylinder) and isEmptyProp(FAxis) and isEmptyProp(FprismList) and isEmptyProp(FAdd) and isEmptyProp(FPower) and isEmptyProp(FBackCurve) and isEmptyProp(FDiameter) and isEmptyProp(FDuration) and isEmptyProp(FColor) and isEmptyProp(FBrand) and isEmptyProp(FnoteList);
end;

procedure TFhirVisionPrescriptionLensSpecification.SetProduct(value : TFhirCodeableConcept);
begin
  FProduct.free;
  FProduct := value; {L1134}
end;

procedure TFhirVisionPrescriptionLensSpecification.SetEye(value : TFhirEnum);
begin
  FEye.free;
  FEye := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetEyeST : TFhirVisionEyesEnum;
begin
  if FEye = nil then
    result := TFhirVisionEyesEnum(0)
  else
    result := TFhirVisionEyesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionEyesEnum, FEye.value));
end;

procedure TFhirVisionPrescriptionLensSpecification.SetEyeST(value : TFhirVisionEyesEnum);
begin
  if ord(value) = 0 then
    EyeElement := nil
  else
    EyeElement := TFhirEnum.create(SYSTEMS_TFhirVisionEyesEnum[value], CODES_TFhirVisionEyesEnum[value]);
end;

procedure TFhirVisionPrescriptionLensSpecification.SetSphere(value : TFhirDecimal);
begin
  FSphere.free;
  FSphere := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetSphereST : String;
begin
  if FSphere = nil then
    result := ''
  else
    result := FSphere.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetSphereST(value : String);
begin
  if value <> '' then
  begin
    if FSphere = nil then
      FSphere := TFhirDecimal.create;
    FSphere.value := value
  end
  else if FSphere <> nil then
    FSphere.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetCylinder(value : TFhirDecimal);
begin
  FCylinder.free;
  FCylinder := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetCylinderST : String;
begin
  if FCylinder = nil then
    result := ''
  else
    result := FCylinder.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetCylinderST(value : String);
begin
  if value <> '' then
  begin
    if FCylinder = nil then
      FCylinder := TFhirDecimal.create;
    FCylinder.value := value
  end
  else if FCylinder <> nil then
    FCylinder.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAxis(value : TFhirInteger);
begin
  FAxis.free;
  FAxis := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetAxisST : String;
begin
  if FAxis = nil then
    result := ''
  else
    result := FAxis.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAxisST(value : String);
begin
  if value <> '' then
  begin
    if FAxis = nil then
      FAxis := TFhirInteger.create;
    FAxis.value := value
  end
  else if FAxis <> nil then
    FAxis.value := '';
end;

function TFhirVisionPrescriptionLensSpecification.GetPrismList : TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  if FPrismList = nil then
    FPrismList := TFhirVisionPrescriptionLensSpecificationPrismList.Create;
  result := FPrismList;
end;

function TFhirVisionPrescriptionLensSpecification.GetHasPrismList : boolean;
begin
  result := (FPrismList <> nil) and (FPrismList.count > 0);
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAdd(value : TFhirDecimal);
begin
  FAdd.free;
  FAdd := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetAddST : String;
begin
  if FAdd = nil then
    result := ''
  else
    result := FAdd.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAddST(value : String);
begin
  if value <> '' then
  begin
    if FAdd = nil then
      FAdd := TFhirDecimal.create;
    FAdd.value := value
  end
  else if FAdd <> nil then
    FAdd.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetPower(value : TFhirDecimal);
begin
  FPower.free;
  FPower := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetPowerST : String;
begin
  if FPower = nil then
    result := ''
  else
    result := FPower.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetPowerST(value : String);
begin
  if value <> '' then
  begin
    if FPower = nil then
      FPower := TFhirDecimal.create;
    FPower.value := value
  end
  else if FPower <> nil then
    FPower.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBackCurve(value : TFhirDecimal);
begin
  FBackCurve.free;
  FBackCurve := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetBackCurveST : String;
begin
  if FBackCurve = nil then
    result := ''
  else
    result := FBackCurve.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBackCurveST(value : String);
begin
  if value <> '' then
  begin
    if FBackCurve = nil then
      FBackCurve := TFhirDecimal.create;
    FBackCurve.value := value
  end
  else if FBackCurve <> nil then
    FBackCurve.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDiameter(value : TFhirDecimal);
begin
  FDiameter.free;
  FDiameter := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetDiameterST : String;
begin
  if FDiameter = nil then
    result := ''
  else
    result := FDiameter.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDiameterST(value : String);
begin
  if value <> '' then
  begin
    if FDiameter = nil then
      FDiameter := TFhirDecimal.create;
    FDiameter.value := value
  end
  else if FDiameter <> nil then
    FDiameter.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value; {L1134}
end;

procedure TFhirVisionPrescriptionLensSpecification.SetColor(value : TFhirString);
begin
  FColor.free;
  FColor := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetColorST : String;
begin
  if FColor = nil then
    result := ''
  else
    result := FColor.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetColorST(value : String);
begin
  if value <> '' then
  begin
    if FColor = nil then
      FColor := TFhirString.create;
    FColor.value := value
  end
  else if FColor <> nil then
    FColor.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBrand(value : TFhirString);
begin
  FBrand.free;
  FBrand := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecification.GetBrandST : String;
begin
  if FBrand = nil then
    result := ''
  else
    result := FBrand.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBrandST(value : String);
begin
  if value <> '' then
  begin
    if FBrand = nil then
      FBrand := TFhirString.create;
    FBrand.value := value
  end
  else if FBrand <> nil then
    FBrand.value := '';
end;

function TFhirVisionPrescriptionLensSpecification.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirVisionPrescriptionLensSpecification.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirVisionPrescriptionLensSpecification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('product');
  fields.add('eye');
  fields.add('sphere');
  fields.add('cylinder');
  fields.add('axis');
  fields.add('prism');
  fields.add('add');
  fields.add('power');
  fields.add('backCurve');
  fields.add('diameter');
  fields.add('duration');
  fields.add('color');
  fields.add('brand');
  fields.add('note');
end;

function TFhirVisionPrescriptionLensSpecification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProduct.sizeInBytes);
  inc(result, FEye.sizeInBytes);
  inc(result, FSphere.sizeInBytes);
  inc(result, FCylinder.sizeInBytes);
  inc(result, FAxis.sizeInBytes);
  inc(result, FprismList.sizeInBytes);
  inc(result, FAdd.sizeInBytes);
  inc(result, FPower.sizeInBytes);
  inc(result, FBackCurve.sizeInBytes);
  inc(result, FDiameter.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FColor.sizeInBytes);
  inc(result, FBrand.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirVisionPrescriptionLensSpecificationListEnumerator }

constructor TFhirVisionPrescriptionLensSpecificationListEnumerator.Create(list : TFhirVisionPrescriptionLensSpecificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionLensSpecificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.GetCurrent : TFhirVisionPrescriptionLensSpecification;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionLensSpecificationList }

procedure TFhirVisionPrescriptionLensSpecificationList.AddItem(value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionLensSpecification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionLensSpecification');
  add(value);
end;

function TFhirVisionPrescriptionLensSpecificationList.Append: TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionLensSpecificationList.GetEnumerator : TFhirVisionPrescriptionLensSpecificationListEnumerator;
begin
  result := TFhirVisionPrescriptionLensSpecificationListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionLensSpecificationList.Clone: TFhirVisionPrescriptionLensSpecificationList;
begin
  result := TFhirVisionPrescriptionLensSpecificationList(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionLensSpecificationList.GetItemN(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionLensSpecification;
end;
function TFhirVisionPrescriptionLensSpecificationList.IndexOf(value: TFhirVisionPrescriptionLensSpecification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionLensSpecificationList.Insert(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.InsertItem(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionLensSpecificationList.Item(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationList.Link: TFhirVisionPrescriptionLensSpecificationList;
begin
  result := TFhirVisionPrescriptionLensSpecificationList(inherited Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionLensSpecificationList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  FhirVisionPrescriptionLensSpecifications[index] := value;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.SetItemN(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescriptionLensSpecificationPrism }

constructor TFhirVisionPrescriptionLensSpecificationPrism.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionLensSpecificationPrism.Destroy;
begin
  FAmount.free;
  FBase.free;
  inherited;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.Assign(oSource : TFslObject);
begin
  inherited;
  amountElement := TFhirVisionPrescriptionLensSpecificationPrism(oSource).amountElement.Clone;
  baseElement := TFhirVisionPrescriptionLensSpecificationPrism(oSource).baseElement.Clone;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'amount', 'decimal', false, TFhirDecimal, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'base', 'code', false, TFhirEnum, FBase.Link)); {L1170}
end;

function TFhirVisionPrescriptionLensSpecificationPrism.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'amount') then
  begin
    AmountElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asEnum(SYSTEMS_TFhirVisionBaseEnum, CODES_TFhirVisionBaseEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'amount') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'base') then result := TFhirEnum.create(SYSTEMS_TFhirVisionBaseEnum[VisionBaseNull], CODES_TFhirVisionBaseEnum[VisionBaseNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'amount') then result := 'decimal'
  else if (propName = 'base') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'amount') then AmountElement := nil
  else if (propName = 'base') then BaseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'amount') then AmountElement := asDecimal(new) {L1222}
  else if (propName = 'base') then BaseElement := asEnum(SYSTEMS_TFhirVisionBaseEnum, CODES_TFhirVisionBaseEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.fhirType : string;
begin
  result := 'VisionPrescription.lensSpecification.prism';
end;

function TFhirVisionPrescriptionLensSpecificationPrism.Link : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(inherited Link);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.Clone : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionLensSpecificationPrism)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionLensSpecificationPrism(other);
    result := compareDeep(amountElement, o.amountElement, true) and compareDeep(baseElement, o.baseElement, true);
  end;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAmount) and isEmptyProp(FBase);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetAmount(value : TFhirDecimal);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

function TFhirVisionPrescriptionLensSpecificationPrism.GetAmountST : String;
begin
  if FAmount = nil then
    result := ''
  else
    result := FAmount.value;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetAmountST(value : String);
begin
  if value <> '' then
  begin
    if FAmount = nil then
      FAmount := TFhirDecimal.create;
    FAmount.value := value
  end
  else if FAmount <> nil then
    FAmount.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetBase(value : TFhirEnum);
begin
  FBase.free;
  FBase := value;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.GetBaseST : TFhirVisionBaseEnum;
begin
  if FBase = nil then
    result := TFhirVisionBaseEnum(0)
  else
    result := TFhirVisionBaseEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionBaseEnum, FBase.value));
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetBaseST(value : TFhirVisionBaseEnum);
begin
  if ord(value) = 0 then
    BaseElement := nil
  else
    BaseElement := TFhirEnum.create(SYSTEMS_TFhirVisionBaseEnum[value], CODES_TFhirVisionBaseEnum[value]);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('amount');
  fields.add('base');
end;

function TFhirVisionPrescriptionLensSpecificationPrism.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAmount.sizeInBytes);
  inc(result, FBase.sizeInBytes);
end;

{ TFhirVisionPrescriptionLensSpecificationPrismListEnumerator }

constructor TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Create(list : TFhirVisionPrescriptionLensSpecificationPrismList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.GetCurrent : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionLensSpecificationPrismList }

procedure TFhirVisionPrescriptionLensSpecificationPrismList.AddItem(value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionLensSpecificationPrism', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionLensSpecificationPrism');
  add(value);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Append: TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.GetEnumerator : TFhirVisionPrescriptionLensSpecificationPrismListEnumerator;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Clone: TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismList(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.GetItemN(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism;
end;
function TFhirVisionPrescriptionLensSpecificationPrismList.IndexOf(value: TFhirVisionPrescriptionLensSpecificationPrism): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Insert(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.InsertItem(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Item(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Link: TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismList(inherited Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  FhirVisionPrescriptionLensSpecificationPrisms[index] := value;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.SetItemN(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescription }

constructor TFhirVisionPrescription.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescription.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FPatient.free;
  FEncounter.free;
  FDateWritten.free;
  FPrescriber.free;
  FLensSpecificationList.Free;
  inherited;
end;

procedure TFhirVisionPrescription.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVisionPrescription(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirVisionPrescription(oSource).FIdentifierList);
  end;
  statusElement := TFhirVisionPrescription(oSource).statusElement.Clone;
  createdElement := TFhirVisionPrescription(oSource).createdElement.Clone;
  patient := TFhirVisionPrescription(oSource).patient.Clone;
  encounter := TFhirVisionPrescription(oSource).encounter.Clone;
  dateWrittenElement := TFhirVisionPrescription(oSource).dateWrittenElement.Clone;
  prescriber := TFhirVisionPrescription(oSource).prescriber.Clone;
  if (TFhirVisionPrescription(oSource).FLensSpecificationList = nil) then
  begin
    FLensSpecificationList.free;
    FLensSpecificationList := nil;
  end
  else
  begin
    if FLensSpecificationList = nil then
      FLensSpecificationList := TFhirVisionPrescriptionLensSpecificationList.Create;
    FLensSpecificationList.Assign(TFhirVisionPrescription(oSource).FLensSpecificationList);
  end;
end;

function TFhirVisionPrescription.GetResourceType : TFhirResourceType;
begin
  result := frtVisionPrescription;
end;

procedure TFhirVisionPrescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateWritten') Then
     list.add(self.link, 'dateWritten', FDateWritten.Link);
  if (child_name = 'prescriber') Then
     list.add(self.link, 'prescriber', FPrescriber.Link);
  if (child_name = 'lensSpecification') Then
    list.addAll(self, 'lensSpecification', FLensSpecificationList);
end;

procedure TFhirVisionPrescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateWritten', 'dateTime', false, TFhirDateTime, FDateWritten.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'prescriber', 'Reference', false, TFhirReference, FPrescriber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lensSpecification', 'BackboneElement', true, TFhirVisionPrescriptionLensSpecification, FLensSpecificationList.Link)) {L1039};
end;

function TFhirVisionPrescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'dateWritten') then
  begin
    DateWrittenElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'prescriber') then
  begin
    Prescriber := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'lensSpecification') then
  begin
    LensSpecificationList.add(propValue as TFhirVisionPrescriptionLensSpecification) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'lensSpecification') then LensSpecificationList.insertItem(index, propValue as TFhirVisionPrescriptionLensSpecification) {L1049}
  else inherited;
end;

function TFhirVisionPrescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'encounter') then result := TFhirReference.create() {L1203}
  else if (propName = 'dateWritten') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'prescriber') then result := TFhirReference.create() {L1203}
  else if (propName = 'lensSpecification') then result := LensSpecificationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateWritten') then result := 'dateTime'
  else if (propName = 'prescriber') then result := 'Reference'
  else if (propName = 'lensSpecification') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateWritten') then DateWrittenElement := nil
  else if (propName = 'prescriber') then PrescriberElement := nil
  else if (propName = 'lensSpecification') then deletePropertyValue('lensSpecification', LensSpecificationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference {L1195}
  else if (propName = 'dateWritten') then DateWrittenElement := asDateTime(new) {L1222}
  else if (propName = 'prescriber') then PrescriberElement := new as TFhirReference {L1195}
  else if (propName = 'lensSpecification') then replacePropertyValue('lensSpecification', LensSpecificationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'lensSpecification') then LensSpecificationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescription.fhirType : string;
begin
  result := 'VisionPrescription';
end;

function TFhirVisionPrescription.Link : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Link);
end;

function TFhirVisionPrescription.Clone : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Clone);
end;

function TFhirVisionPrescription.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescription)) then
    result := false
  else
  begin
    o := TFhirVisionPrescription(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateWrittenElement, o.dateWrittenElement, true) and 
      compareDeep(prescriberElement, o.prescriberElement, true) and compareDeep(lensSpecificationList, o.lensSpecificationList, true);
  end;
end;

function TFhirVisionPrescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateWritten) and isEmptyProp(FPrescriber) and isEmptyProp(FlensSpecificationList);
end;

function TFhirVisionPrescription.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirVisionPrescription.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirVisionPrescription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirVisionPrescription.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirVisionPrescription.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirVisionPrescription.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirVisionPrescription.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirVisionPrescription.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirVisionPrescription.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirVisionPrescription.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value; {L1134}
end;

procedure TFhirVisionPrescription.SetDateWritten(value : TFhirDateTime);
begin
  FDateWritten.free;
  FDateWritten := value; {L1134}
end;

function TFhirVisionPrescription.GetDateWrittenST : TFslDateTime;
begin
  if FDateWritten = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateWritten.value;
end;

procedure TFhirVisionPrescription.SetDateWrittenST(value : TFslDateTime);
begin
  if FDateWritten = nil then
    FDateWritten := TFhirDateTime.create;
  FDateWritten.value := value
end;

procedure TFhirVisionPrescription.SetPrescriber(value : TFhirReference);
begin
  FPrescriber.free;
  FPrescriber := value; {L1134}
end;

function TFhirVisionPrescription.GetLensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
begin
  if FLensSpecificationList = nil then
    FLensSpecificationList := TFhirVisionPrescriptionLensSpecificationList.Create;
  result := FLensSpecificationList;
end;

function TFhirVisionPrescription.GetHasLensSpecificationList : boolean;
begin
  result := (FLensSpecificationList <> nil) and (FLensSpecificationList.count > 0);
end;

procedure TFhirVisionPrescription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateWritten');
  fields.add('prescriber');
  fields.add('lensSpecification');
end;

function TFhirVisionPrescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateWritten.sizeInBytes);
  inc(result, FPrescriber.sizeInBytes);
  inc(result, FlensSpecificationList.sizeInBytes);
end;

{ TFhirVisionPrescriptionListEnumerator }

constructor TFhirVisionPrescriptionListEnumerator.Create(list : TFhirVisionPrescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionListEnumerator.GetCurrent : TFhirVisionPrescription;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionList }

procedure TFhirVisionPrescriptionList.AddItem(value: TFhirVisionPrescription);
begin
  assert(value.ClassName = 'TFhirVisionPrescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescription');
  add(value);
end;

function TFhirVisionPrescriptionList.Append: TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionList.GetEnumerator : TFhirVisionPrescriptionListEnumerator;
begin
  result := TFhirVisionPrescriptionListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionList.Clone: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Clone);
end;

function TFhirVisionPrescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionList.GetItemN(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescription;
end;
function TFhirVisionPrescriptionList.IndexOf(value: TFhirVisionPrescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionList.Insert(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.InsertItem(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionList.Item(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.Link: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Link);
end;

procedure TFhirVisionPrescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionList.SetItemByIndex(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  FhirVisionPrescriptions[index] := value;
end;

procedure TFhirVisionPrescriptionList.SetItemN(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}

end.

