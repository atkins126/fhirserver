unit fhir5_resources_medications;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Fri, Aug 21, 2020 11:27+1000 for FHIR v4.5.0

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base,
  fhir5_resources_canonical;

type
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  TFhirAdministrableProductDefinitionProperty = class;
  TFhirAdministrableProductDefinitionPropertyList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministration = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class;
  TFhirAdministrableProductDefinition = class;
  TFhirAdministrableProductDefinitionList = class;
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
  TFhirIngredientSubstance = class;
  TFhirIngredientSubstanceList = class;
  TFhirIngredientSubstanceStrength = class;
  TFhirIngredientSubstanceStrengthList = class;
  TFhirIngredientSubstanceStrengthReferenceStrength = class;
  TFhirIngredientSubstanceStrengthReferenceStrengthList = class;
  TFhirIngredientSpecifiedSubstance = class;
  TFhirIngredientSpecifiedSubstanceList = class;
  TFhirIngredient = class;
  TFhirIngredientList = class;
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  TFhirManufacturedItemDefinitionProperty = class;
  TFhirManufacturedItemDefinitionPropertyList = class;
  TFhirManufacturedItemDefinition = class;
  TFhirManufacturedItemDefinitionList = class;
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationIngredient = class;
  TFhirMedicationIngredientList = class;
  TFhirMedicationBatch = class;
  TFhirMedicationBatchList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class;
  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class;
  TFhirMedicationKnowledgeMonograph = class;
  TFhirMedicationKnowledgeMonographList = class;
  TFhirMedicationKnowledgeIngredient = class;
  TFhirMedicationKnowledgeIngredientList = class;
  TFhirMedicationKnowledgeCost = class;
  TFhirMedicationKnowledgeCostList = class;
  TFhirMedicationKnowledgeMonitoringProgram = class;
  TFhirMedicationKnowledgeMonitoringProgramList = class;
  TFhirMedicationKnowledgeAdministrationGuideline = class;
  TFhirMedicationKnowledgeAdministrationGuidelineList = class;
  TFhirMedicationKnowledgeAdministrationGuidelineDosage = class;
  TFhirMedicationKnowledgeAdministrationGuidelineDosageList = class;
  TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic = class;
  TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList = class;
  TFhirMedicationKnowledgeMedicineClassification = class;
  TFhirMedicationKnowledgeMedicineClassificationList = class;
  TFhirMedicationKnowledgePackaging = class;
  TFhirMedicationKnowledgePackagingList = class;
  TFhirMedicationKnowledgeDrugCharacteristic = class;
  TFhirMedicationKnowledgeDrugCharacteristicList = class;
  TFhirMedicationKnowledgeRegulatory = class;
  TFhirMedicationKnowledgeRegulatoryList = class;
  TFhirMedicationKnowledgeRegulatorySubstitution = class;
  TFhirMedicationKnowledgeRegulatorySubstitutionList = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class;
  TFhirMedicationKnowledgeKineticCharacteristic = class;
  TFhirMedicationKnowledgeKineticCharacteristicList = class;
  TFhirMedicationKnowledge = class;
  TFhirMedicationKnowledgeList = class;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  TFhirMedicinalProductDefinitionContact = class;
  TFhirMedicinalProductDefinitionContactList = class;
  TFhirMedicinalProductDefinitionName = class;
  TFhirMedicinalProductDefinitionNameList = class;
  TFhirMedicinalProductDefinitionNameNamePart = class;
  TFhirMedicinalProductDefinitionNameNamePartList = class;
  TFhirMedicinalProductDefinitionNameCountryLanguage = class;
  TFhirMedicinalProductDefinitionNameCountryLanguageList = class;
  TFhirMedicinalProductDefinitionCrossReference = class;
  TFhirMedicinalProductDefinitionCrossReferenceList = class;
  TFhirMedicinalProductDefinitionManufacturingBusinessOperation = class;
  TFhirMedicinalProductDefinitionManufacturingBusinessOperationList = class;
  TFhirMedicinalProductDefinition = class;
  TFhirMedicinalProductDefinitionList = class;
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  TFhirNutritionProductNutrient = class;
  TFhirNutritionProductNutrientList = class;
  TFhirNutritionProductIngredient = class;
  TFhirNutritionProductIngredientList = class;
  TFhirNutritionProductProductCharacteristic = class;
  TFhirNutritionProductProductCharacteristicList = class;
  TFhirNutritionProductInstance = class;
  TFhirNutritionProductInstanceList = class;
  TFhirNutritionProduct = class;
  TFhirNutritionProductList = class;
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  TFhirPackagedProductDefinitionBatchIdentifier = class;
  TFhirPackagedProductDefinitionBatchIdentifierList = class;
  TFhirPackagedProductDefinitionPackage = class;
  TFhirPackagedProductDefinitionPackageList = class;
  TFhirPackagedProductDefinitionPackageProperty = class;
  TFhirPackagedProductDefinitionPackagePropertyList = class;
  TFhirPackagedProductDefinitionPackageContainedItem = class;
  TFhirPackagedProductDefinitionPackageContainedItemList = class;
  TFhirPackagedProductDefinition = class;
  TFhirPackagedProductDefinitionList = class;
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  TFhirRegulatedAuthorizationRelatedDate = class;
  TFhirRegulatedAuthorizationRelatedDateList = class;
  TFhirRegulatedAuthorizationCase = class;
  TFhirRegulatedAuthorizationCaseList = class;
  TFhirRegulatedAuthorization = class;
  TFhirRegulatedAuthorizationList = class;
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  TFhirSubstanceInstance = class;
  TFhirSubstanceInstanceList = class;
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSubstance = class;
  TFhirSubstanceList = class;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  TFhirSubstanceDefinitionMoiety = class;
  TFhirSubstanceDefinitionMoietyList = class;
  TFhirSubstanceDefinitionProperty = class;
  TFhirSubstanceDefinitionPropertyList = class;
  TFhirSubstanceDefinitionStructure = class;
  TFhirSubstanceDefinitionStructureList = class;
  TFhirSubstanceDefinitionStructureIsotope = class;
  TFhirSubstanceDefinitionStructureIsotopeList = class;
  TFhirSubstanceDefinitionStructureIsotopeMolecularWeight = class;
  TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList = class;
  TFhirSubstanceDefinitionStructureRepresentation = class;
  TFhirSubstanceDefinitionStructureRepresentationList = class;
  TFhirSubstanceDefinitionCode = class;
  TFhirSubstanceDefinitionCodeList = class;
  TFhirSubstanceDefinitionName = class;
  TFhirSubstanceDefinitionNameList = class;
  TFhirSubstanceDefinitionNameOfficial = class;
  TFhirSubstanceDefinitionNameOfficialList = class;
  TFhirSubstanceDefinitionRelationship = class;
  TFhirSubstanceDefinitionRelationshipList = class;
  TFhirSubstanceDefinition = class;
  TFhirSubstanceDefinitionList = class;
{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  TFhirSubstanceNucleicAcidSubunit = class;
  TFhirSubstanceNucleicAcidSubunitList = class;
  TFhirSubstanceNucleicAcidSubunitLinkage = class;
  TFhirSubstanceNucleicAcidSubunitLinkageList = class;
  TFhirSubstanceNucleicAcidSubunitSugar = class;
  TFhirSubstanceNucleicAcidSubunitSugarList = class;
  TFhirSubstanceNucleicAcid = class;
  TFhirSubstanceNucleicAcidList = class;
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  TFhirSubstancePolymerMonomerSet = class;
  TFhirSubstancePolymerMonomerSetList = class;
  TFhirSubstancePolymerMonomerSetStartingMaterial = class;
  TFhirSubstancePolymerMonomerSetStartingMaterialList = class;
  TFhirSubstancePolymerRepeat = class;
  TFhirSubstancePolymerRepeatList = class;
  TFhirSubstancePolymerRepeatRepeatUnit = class;
  TFhirSubstancePolymerRepeatRepeatUnitList = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class;
  TFhirSubstancePolymer = class;
  TFhirSubstancePolymerList = class;
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  TFhirSubstanceProteinSubunit = class;
  TFhirSubstanceProteinSubunitList = class;
  TFhirSubstanceProtein = class;
  TFhirSubstanceProteinList = class;
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  TFhirSubstanceReferenceInformationGene = class;
  TFhirSubstanceReferenceInformationGeneList = class;
  TFhirSubstanceReferenceInformationGeneElement = class;
  TFhirSubstanceReferenceInformationGeneElementList = class;
  TFhirSubstanceReferenceInformationTarget = class;
  TFhirSubstanceReferenceInformationTargetList = class;
  TFhirSubstanceReferenceInformation = class;
  TFhirSubstanceReferenceInformationList = class;
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  TFhirSubstanceSourceMaterialFractionDescription = class;
  TFhirSubstanceSourceMaterialFractionDescriptionList = class;
  TFhirSubstanceSourceMaterialOrganism = class;
  TFhirSubstanceSourceMaterialOrganismList = class;
  TFhirSubstanceSourceMaterialOrganismAuthor = class;
  TFhirSubstanceSourceMaterialOrganismAuthorList = class;
  TFhirSubstanceSourceMaterialOrganismHybrid = class;
  TFhirSubstanceSourceMaterialOrganismHybridList = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class;
  TFhirSubstanceSourceMaterialPartDescription = class;
  TFhirSubstanceSourceMaterialPartDescriptionList = class;
  TFhirSubstanceSourceMaterial = class;
  TFhirSubstanceSourceMaterialList = class;
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}

{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  // Characteristics e.g. a products onset of action.
  TFhirAdministrableProductDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FStatus : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetStatus(value : TFhirCodeableConcept);

    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionProperty; overload;
    function Clone : TFhirAdministrableProductDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to The status of characteristic e.g. assigned or pending. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of characteristic e.g. assigned or pending.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

  end;

  TFhirAdministrableProductDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionPropertyList;
    function GetCurrent : TFhirAdministrableProductDefinitionProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionProperty read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionPropertyList; overload;
    function Clone : TFhirAdministrableProductDefinitionPropertyList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionProperty to the end of the list.
    function Append : TFhirAdministrableProductDefinitionProperty;
    
    // Add an already existing FhirAdministrableProductDefinitionProperty to the end of the list.
    procedure AddItem(value : TFhirAdministrableProductDefinitionProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionProperty) : Integer;
    
    // Insert FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // Insert an existing FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // Get the iIndexth FhirAdministrableProductDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionProperties[index : Integer] : TFhirAdministrableProductDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The path by which the pharmaceutical product is taken into or makes contact with the body.
  TFhirAdministrableProductDefinitionRouteOfAdministration = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FFirstDose : TFhirQuantity;
    FMaxSingleDose : TFhirQuantity;
    FMaxDosePerDay : TFhirQuantity;
    FMaxDosePerTreatmentPeriod : TFhirRatio;
    FMaxTreatmentPeriod : TFhirDuration;
    FtargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFirstDose(value : TFhirQuantity);
    procedure SetMaxSingleDose(value : TFhirQuantity);
    procedure SetMaxDosePerDay(value : TFhirQuantity);
    procedure SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
    procedure SetMaxTreatmentPeriod(value : TFhirDuration);
    function GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetHasTargetSpeciesList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the route. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the route.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The first dose (dose quantity) administered in humans can be specified, for a product under investigation, using a numerical value and its unit of measurement. (defined for API consistency)
    property firstDose : TFhirQuantity read FFirstDose write SetFirstDose;
    // The first dose (dose quantity) administered in humans can be specified, for a product under investigation, using a numerical value and its unit of measurement.
    property firstDoseElement : TFhirQuantity read FFirstDose write SetFirstDose;

    // Typed access to The maximum single dose that can be administered as per the protocol of a clinical trial can be specified using a numerical value and its unit of measurement. (defined for API consistency)
    property maxSingleDose : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;
    // The maximum single dose that can be administered as per the protocol of a clinical trial can be specified using a numerical value and its unit of measurement.
    property maxSingleDoseElement : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;

    // Typed access to The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxDosePerDay : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;
    // The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxDosePerDayElement : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;

    // Typed access to The maximum dose per treatment period that can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxDosePerTreatmentPeriod : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;
    // The maximum dose per treatment period that can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxDosePerTreatmentPeriodElement : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;

    // Typed access to The maximum treatment period during which an Investigational Medicinal Product can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxTreatmentPeriod : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;
    // The maximum treatment period during which an Investigational Medicinal Product can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxTreatmentPeriodElement : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;

    // A species for which this route applies.
    property targetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList read GetTargetSpeciesList;
    property hasTargetSpeciesList : boolean read GetHasTargetSpeciesList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministration read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    procedure AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministration); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministration) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrations[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministration read GetItemN write SetItemN; default;
  End;

  // A species for which this route applies.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FwithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetHasWithdrawalPeriodList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the species. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the species.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A species specific time during which consumption of animal product is not appropriate.
    property withdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList read GetWithdrawalPeriodList;
    property hasWithdrawalPeriodList : boolean read GetHasWithdrawalPeriodList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    procedure AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetItemN write SetItemN; default;
  End;

  // A species specific time during which consumption of animal product is not appropriate.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class (TFhirBackboneElement)
  protected
    FTissue : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FSupportingInformation : TFhirString;
    procedure SetTissue(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirQuantity);
    procedure SetSupportingInformation(value : TFhirString);
    function GetSupportingInformationST : String;
    procedure SetSupportingInformationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk. (defined for API consistency)
    property tissue : TFhirCodeableConcept read FTissue write SetTissue;
    // Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk.
    property tissueElement : TFhirCodeableConcept read FTissue write SetTissue;

    // Typed access to A value for the time. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // A value for the time.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to Extra information about the withdrawal period.
    property supportingInformation : String read GetSupportingInformationST write SetSupportingInformationST;
    // Extra information about the withdrawal period.
    property supportingInformationElement : TFhirString read FSupportingInformation write SetSupportingInformation;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    procedure AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetItemN write SetItemN; default;
  End;

  // A pharmaceutical product described in terms of its composition and dose form.
  TFhirAdministrableProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FsubjectList : TFhirReferenceList;
    FAdministrableDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FproducedFromList : TFhirReferenceList;
    FingredientList : TFhirReferenceList;
    FdeviceList : TFhirReferenceList;
    Fproperty_List : TFhirAdministrableProductDefinitionPropertyList;
    FrouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetAdministrableDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetProducedFromList : TFhirReferenceList;
    function GetHasProducedFromList : Boolean;
    function GetIngredientList : TFhirReferenceList;
    function GetHasIngredientList : Boolean;
    function GetDeviceList : TFhirReferenceList;
    function GetHasDeviceList : Boolean;
    function GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetHasRouteOfAdministrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinition; overload;
    function Clone : TFhirAdministrableProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for the pharmaceutical medicinal product.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The product that this is a pharmaceutical product of.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The administrable dose form, after necessary reconstitution. (defined for API consistency)
    property administrableDoseForm : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;
    // The administrable dose form, after necessary reconstitution.
    property administrableDoseFormElement : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;

    // Typed access to Todo. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // Todo.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // The manufactured item(s) that this administrable product is produced from. Either a single item, or several that are mixed before administration (e.g. a power item and a solution item). Note that these are not raw ingredients.
    property producedFromList : TFhirReferenceList read GetProducedFromList;
    property hasProducedFromList : boolean read GetHasProducedFromList;

    // The ingredients of this administrable pharmaceutical product.
    property ingredientList : TFhirReferenceList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Accompanying device.
    property deviceList : TFhirReferenceList read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Characteristics e.g. a products onset of action.
    property property_List : TFhirAdministrableProductDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The path by which the pharmaceutical product is taken into or makes contact with the body.
    property routeOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList read GetRouteOfAdministrationList;
    property hasRouteOfAdministrationList : boolean read GetHasRouteOfAdministrationList;

  end;

  TFhirAdministrableProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionList;
    function GetCurrent : TFhirAdministrableProductDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinition read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionList; overload;
    function Clone : TFhirAdministrableProductDefinitionList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
    
    //  Add a FhirAdministrableProductDefinition to the end of the list.
    function Append : TFhirAdministrableProductDefinition;
    
    // Add an already existing FhirAdministrableProductDefinition to the end of the list.
    procedure AddItem(value : TFhirAdministrableProductDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinition) : Integer;
    
    // Insert FhirAdministrableProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinition;
    
    // Insert an existing FhirAdministrableProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // Get the iIndexth FhirAdministrableProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitions[index : Integer] : TFhirAdministrableProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
  // The substance that comprises this ingredient.
  TFhirIngredientSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirDataType;
    FstrengthList : TFhirIngredientSubstanceStrengthList;
    procedure SetCode(value : TFhirDataType);
    function GetStrengthList : TFhirIngredientSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstance; overload;
    function Clone : TFhirIngredientSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or full resource that represents the ingredient substance. (defined for API consistency)
    property code : TFhirDataType read FCode write SetCode;
    // A code or full resource that represents the ingredient substance.
    property codeElement : TFhirDataType read FCode write SetCode;

    // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
    property strengthList : TFhirIngredientSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirIngredientSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceList;
    function GetCurrent : TFhirIngredientSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstance read GetCurrent;
  end;

  TFhirIngredientSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstance;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceList; overload;
    function Clone : TFhirIngredientSubstanceList; overload;
    function GetEnumerator : TFhirIngredientSubstanceListEnumerator;
    
    //  Add a FhirIngredientSubstance to the end of the list.
    function Append : TFhirIngredientSubstance;
    
    // Add an already existing FhirIngredientSubstance to the end of the list.
    procedure AddItem(value : TFhirIngredientSubstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstance) : Integer;
    
    // Insert FhirIngredientSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstance;
    
    // Insert an existing FhirIngredientSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstance);
    
    // Get the iIndexth FhirIngredientSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstances[index : Integer] : TFhirIngredientSubstance read GetItemN write SetItemN; default;
  End;

  // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
  TFhirIngredientSubstanceStrength = class (TFhirBackboneElement)
  protected
    FPresentation : TFhirRatio;
    FPresentationHighLimit : TFhirRatio;
    FPresentationText : TFhirString;
    FConcentration : TFhirRatio;
    FConcentrationHighLimit : TFhirRatio;
    FConcentrationText : TFhirString;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    FreferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    procedure SetPresentation(value : TFhirRatio);
    procedure SetPresentationHighLimit(value : TFhirRatio);
    procedure SetPresentationText(value : TFhirString);
    function GetPresentationTextST : String;
    procedure SetPresentationTextST(value : String);
    procedure SetConcentration(value : TFhirRatio);
    procedure SetConcentrationHighLimit(value : TFhirRatio);
    procedure SetConcentrationText(value : TFhirString);
    function GetConcentrationTextST : String;
    procedure SetConcentrationTextST(value : String);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
    function GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetHasReferenceStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. (defined for API consistency)
    property presentation : TFhirRatio read FPresentation write SetPresentation;
    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item.
    property presentationElement : TFhirRatio read FPresentation write SetPresentation;

    // Typed access to An upper limit for the quantity of substance in the unit of presentation. For use when there is a range of strengths, this is the high limit, with the presentation attribute becoming the lower limit. (defined for API consistency)
    property presentationHighLimit : TFhirRatio read FPresentationHighLimit write SetPresentationHighLimit;
    // An upper limit for the quantity of substance in the unit of presentation. For use when there is a range of strengths, this is the high limit, with the presentation attribute becoming the lower limit.
    property presentationHighLimitElement : TFhirRatio read FPresentationHighLimit write SetPresentationHighLimit;

    // Typed access to A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property presentationText : String read GetPresentationTextST write SetPresentationTextST;
    // A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property presentationTextElement : TFhirString read FPresentationText write SetPresentationText;

    // Typed access to The strength per unitary volume (or mass). (defined for API consistency)
    property concentration : TFhirRatio read FConcentration write SetConcentration;
    // The strength per unitary volume (or mass).
    property concentrationElement : TFhirRatio read FConcentration write SetConcentration;

    // Typed access to An upper limit for the strength per unitary volume (or mass), for when there is a range. The concentration attribute then becomes the lower limit. (defined for API consistency)
    property concentrationHighLimit : TFhirRatio read FConcentrationHighLimit write SetConcentrationHighLimit;
    // An upper limit for the strength per unitary volume (or mass), for when there is a range. The concentration attribute then becomes the lower limit.
    property concentrationHighLimitElement : TFhirRatio read FConcentrationHighLimit write SetConcentrationHighLimit;

    // Typed access to A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property concentrationText : String read GetConcentrationTextST write SetConcentrationTextST;
    // A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property concentrationTextElement : TFhirString read FConcentrationText write SetConcentrationText;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

    // Strength expressed in terms of a reference substance.
    property referenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList read GetReferenceStrengthList;
    property hasReferenceStrengthList : boolean read GetHasReferenceStrengthList;

  end;

  TFhirIngredientSubstanceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrength;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrength to the end of the list.
    procedure AddItem(value : TFhirIngredientSubstanceStrength); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengths[index : Integer] : TFhirIngredientSubstanceStrength read GetItemN write SetItemN; default;
  End;

  // Strength expressed in terms of a reference substance.
  TFhirIngredientSubstanceStrengthReferenceStrength = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirDataType;
    FStrength : TFhirRatio;
    FStrengthHighLimit : TFhirRatio;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    procedure SetSubstance(value : TFhirDataType);
    procedure SetStrength(value : TFhirRatio);
    procedure SetStrengthHighLimit(value : TFhirRatio);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Relevant reference substance. (defined for API consistency)
    property substance : TFhirDataType read FSubstance write SetSubstance;
    // Relevant reference substance.
    property substanceElement : TFhirDataType read FSubstance write SetSubstance;

    // Typed access to Strength expressed in terms of a reference substance. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Strength expressed in terms of a reference substance.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

    // Typed access to Strength expressed in terms of a reference substance, upper limit. (defined for API consistency)
    property strengthHighLimit : TFhirRatio read FStrengthHighLimit write SetStrengthHighLimit;
    // Strength expressed in terms of a reference substance, upper limit.
    property strengthHighLimitElement : TFhirRatio read FStrengthHighLimit write SetStrengthHighLimit;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrengthReferenceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    procedure AddItem(value : TFhirIngredientSubstanceStrengthReferenceStrength); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrengthReferenceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrengthReferenceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengthReferenceStrengths[index : Integer] : TFhirIngredientSubstanceStrengthReferenceStrength read GetItemN write SetItemN; default;
  End;

  // A specified substance that comprises this ingredient.
  TFhirIngredientSpecifiedSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirDataType;
    FGroup : TFhirCodeableConcept;
    FConfidentiality : TFhirCodeableConcept;
    FstrengthList : TFhirIngredientSubstanceStrengthList;
    procedure SetCode(value : TFhirDataType);
    procedure SetGroup(value : TFhirCodeableConcept);
    procedure SetConfidentiality(value : TFhirCodeableConcept);
    function GetStrengthList : TFhirIngredientSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSpecifiedSubstance; overload;
    function Clone : TFhirIngredientSpecifiedSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Substance as a 'specified substance', implying extra substance related characteristics. (defined for API consistency)
    property code : TFhirDataType read FCode write SetCode;
    // Substance as a 'specified substance', implying extra substance related characteristics.
    property codeElement : TFhirDataType read FCode write SetCode;

    // Typed access to The group of specified substance, e.g. group 1 to 4. (defined for API consistency)
    property group : TFhirCodeableConcept read FGroup write SetGroup;
    // The group of specified substance, e.g. group 1 to 4.
    property groupElement : TFhirCodeableConcept read FGroup write SetGroup;

    // Typed access to Confidentiality level of the specified substance as the ingredient. (defined for API consistency)
    property confidentiality : TFhirCodeableConcept read FConfidentiality write SetConfidentiality;
    // Confidentiality level of the specified substance as the ingredient.
    property confidentialityElement : TFhirCodeableConcept read FConfidentiality write SetConfidentiality;

    // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
    property strengthList : TFhirIngredientSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirIngredientSpecifiedSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSpecifiedSubstanceList;
    function GetCurrent : TFhirIngredientSpecifiedSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSpecifiedSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSpecifiedSubstance read GetCurrent;
  end;

  TFhirIngredientSpecifiedSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSpecifiedSubstance;
    procedure SetItemN(index : Integer; value : TFhirIngredientSpecifiedSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSpecifiedSubstanceList; overload;
    function Clone : TFhirIngredientSpecifiedSubstanceList; overload;
    function GetEnumerator : TFhirIngredientSpecifiedSubstanceListEnumerator;
    
    //  Add a FhirIngredientSpecifiedSubstance to the end of the list.
    function Append : TFhirIngredientSpecifiedSubstance;
    
    // Add an already existing FhirIngredientSpecifiedSubstance to the end of the list.
    procedure AddItem(value : TFhirIngredientSpecifiedSubstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSpecifiedSubstance) : Integer;
    
    // Insert FhirIngredientSpecifiedSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSpecifiedSubstance;
    
    // Insert an existing FhirIngredientSpecifiedSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSpecifiedSubstance);
    
    // Get the iIndexth FhirIngredientSpecifiedSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSpecifiedSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSpecifiedSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSpecifiedSubstances[index : Integer] : TFhirIngredientSpecifiedSubstance read GetItemN write SetItemN; default;
  End;

  // An ingredient of a manufactured item or pharmaceutical product.
  TFhirIngredient = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FRole : TFhirCodeableConcept;
    Ffunction_List : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FAllergenicIndicator : TFhirBoolean;
    FmanufacturerList : TFhirReferenceList;
    FSubstance : TFhirIngredientSubstance;
    FspecifiedSubstanceList : TFhirIngredientSpecifiedSubstanceList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetRole(value : TFhirCodeableConcept);
    function GetFunction_List : TFhirCodeableConceptList;
    function GetHasFunction_List : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    procedure SetSubstance(value : TFhirIngredientSubstance);
    function GetSpecifiedSubstanceList : TFhirIngredientSpecifiedSubstanceList;
    function GetHasSpecifiedSubstanceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredient; overload;
    function Clone : TFhirIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Ingredient role within a drug product e.g. Active ingredient, Excipient. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Ingredient role within a drug product e.g. Active ingredient, Excipient.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: Antioxidant, Alkalizing Agent.
    property function_List : TFhirCodeableConceptList read GetFunction_List;
    property hasFunction_List : boolean read GetHasFunction_List;

    // Typed access to A general description of the ingredient, or any supporting text. May be used for an unstructured list of excipients.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A general description of the ingredient, or any supporting text. May be used for an unstructured list of excipients.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to If the ingredient is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // If the ingredient is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

    // The organization that manufactures this ingredient.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to The substance that comprises this ingredient. (defined for API consistency)
    property substance : TFhirIngredientSubstance read FSubstance write SetSubstance;
    // The substance that comprises this ingredient.
    property substanceElement : TFhirIngredientSubstance read FSubstance write SetSubstance;

    // A specified substance that comprises this ingredient.
    property specifiedSubstanceList : TFhirIngredientSpecifiedSubstanceList read GetSpecifiedSubstanceList;
    property hasSpecifiedSubstanceList : boolean read GetHasSpecifiedSubstanceList;

  end;

  TFhirIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientList;
    function GetCurrent : TFhirIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredient read GetCurrent;
  end;

  TFhirIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredient;
    procedure SetItemN(index : Integer; value : TFhirIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientList; overload;
    function Clone : TFhirIngredientList; overload;
    function GetEnumerator : TFhirIngredientListEnumerator;
    
    //  Add a FhirIngredient to the end of the list.
    function Append : TFhirIngredient;
    
    // Add an already existing FhirIngredient to the end of the list.
    procedure AddItem(value : TFhirIngredient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredient) : Integer;
    
    // Insert FhirIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredient;
    
    // Insert an existing FhirIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredient);
    
    // Get the iIndexth FhirIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredients[index : Integer] : TFhirIngredient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  // General characteristics of this item.
  TFhirManufacturedItemDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinitionProperty; overload;
    function Clone : TFhirManufacturedItemDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirManufacturedItemDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionPropertyList;
    function GetCurrent : TFhirManufacturedItemDefinitionProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinitionProperty read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionPropertyList; overload;
    function Clone : TFhirManufacturedItemDefinitionPropertyList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
    
    //  Add a FhirManufacturedItemDefinitionProperty to the end of the list.
    function Append : TFhirManufacturedItemDefinitionProperty;
    
    // Add an already existing FhirManufacturedItemDefinitionProperty to the end of the list.
    procedure AddItem(value : TFhirManufacturedItemDefinitionProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinitionProperty) : Integer;
    
    // Insert FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // Insert an existing FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // Get the iIndexth FhirManufacturedItemDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitionProperties[index : Integer] : TFhirManufacturedItemDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The definition and characteristics of a medicinal manufactured item, such as a tablet or capsule, as contained in a packaged medicinal product.
  TFhirManufacturedItemDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FManufacturedDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList;
    FingredientList : TFhirReferenceList;
    Fproperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetManufacturedDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetIngredientList : TFhirReferenceList;
    function GetHasIngredientList : Boolean;
    function GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinition; overload;
    function Clone : TFhirManufacturedItemDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Dose form as manufactured and before any transformation into the pharmaceutical product. (defined for API consistency)
    property manufacturedDoseForm : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;
    // Dose form as manufactured and before any transformation into the pharmaceutical product.
    property manufacturedDoseFormElement : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;

    // Typed access to The “real world” units in which the quantity of the manufactured item is described. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The “real world” units in which the quantity of the manufactured item is described.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // The ingredients that make up this manufactured item.
    property ingredientList : TFhirReferenceList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // General characteristics of this item.
    property property_List : TFhirManufacturedItemDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

  end;

  TFhirManufacturedItemDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionList;
    function GetCurrent : TFhirManufacturedItemDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinition read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinition;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionList; overload;
    function Clone : TFhirManufacturedItemDefinitionList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
    
    //  Add a FhirManufacturedItemDefinition to the end of the list.
    function Append : TFhirManufacturedItemDefinition;
    
    // Add an already existing FhirManufacturedItemDefinition to the end of the list.
    procedure AddItem(value : TFhirManufacturedItemDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinition) : Integer;
    
    // Insert FhirManufacturedItemDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinition;
    
    // Insert an existing FhirManufacturedItemDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // Get the iIndexth FhirManufacturedItemDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitions[index : Integer] : TFhirManufacturedItemDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  // Identifies a particular constituent of interest in the product.
  TFhirMedicationIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FIsActive : TFhirBoolean;
    FStrength : TFhirDataType;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetIsActive(value : TFhirBoolean);
    function GetIsActiveST : Boolean;
    procedure SetIsActiveST(value : Boolean);
    procedure SetStrength(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationIngredient; overload;
    function Clone : TFhirMedicationIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ingredient (substance or medication) that the ingredient.strength relates to.  This is represented as a concept from a code system or described in another resource (Substance or Medication). (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The ingredient (substance or medication) that the ingredient.strength relates to.  This is represented as a concept from a code system or described in another resource (Substance or Medication).
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

  end;

  TFhirMedicationIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationIngredientList;
    function GetCurrent : TFhirMedicationIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationIngredient read GetCurrent;
  end;

  TFhirMedicationIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationIngredientList; overload;
    function Clone : TFhirMedicationIngredientList; overload;
    function GetEnumerator : TFhirMedicationIngredientListEnumerator;
    
    //  Add a FhirMedicationIngredient to the end of the list.
    function Append : TFhirMedicationIngredient;
    
    // Add an already existing FhirMedicationIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationIngredient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationIngredient) : Integer;
    
    // Insert FhirMedicationIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationIngredient;
    
    // Insert an existing FhirMedicationIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationIngredient);
    
    // Get the iIndexth FhirMedicationIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationIngredients[index : Integer] : TFhirMedicationIngredient read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationBatch; overload;
    function Clone : TFhirMedicationBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationBatchList;
    function GetCurrent : TFhirMedicationBatch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationBatch read GetCurrent;
  end;

  TFhirMedicationBatchList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationBatchList; overload;
    function Clone : TFhirMedicationBatchList; overload;
    function GetEnumerator : TFhirMedicationBatchListEnumerator;
    
    //  Add a FhirMedicationBatch to the end of the list.
    function Append : TFhirMedicationBatch;
    
    // Add an already existing FhirMedicationBatch to the end of the list.
    procedure AddItem(value : TFhirMedicationBatch); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationBatch) : Integer;
    
    // Insert FhirMedicationBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationBatch;
    
    // Insert an existing FhirMedicationBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationBatch);
    
    // Get the iIndexth FhirMedicationBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationBatch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationBatch;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationBatches[index : Integer] : TFhirMedicationBatch read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication, including ingredients, for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FManufacturer : TFhirReference;
    FDoseForm : TFhirCodeableConcept;
    FAmount : TFhirRatio;
    FingredientList : TFhirMedicationIngredientList;
    FBatch : TFhirMedicationBatch;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationStatusCodesEnum);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetDoseForm(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirRatio);
    function GetIngredientList : TFhirMedicationIngredientList;
    function GetHasIngredientList : Boolean;
    procedure SetBatch(value : TFhirMedicationBatch);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.
    property status : TFhirMedicationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirRatio read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirRatio read FAmount write SetAmount;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property batch : TFhirMedicationBatch read FBatch write SetBatch;
    // Information that only applies to packages (not products).
    property batchElement : TFhirMedicationBatch read FBatch write SetBatch;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationList; overload;
    function Clone : TFhirMedicationList; overload;
    function GetEnumerator : TFhirMedicationListEnumerator;
    
    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;
    
    // Add an already existing FhirMedication to the end of the list.
    procedure AddItem(value : TFhirMedication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;
    
    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;
    
    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);
    
    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  // Associated or related medications. For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor.
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FreferenceList : TFhirReferenceList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of the associated medication knowledge reference. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the associated medication knowledge reference.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Associated documentation about the associated medication knowledge.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledgeRelatedMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRelatedMedicationKnowledges[index : Integer] : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetItemN write SetItemN; default;
  End;

  // Associated documentation about the medication.
  TFhirMedicationKnowledgeMonograph = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonograph; overload;
    function Clone : TFhirMedicationKnowledgeMonograph; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of documentation about the medication. (e.g. professional monograph, patient education monograph). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of documentation about the medication. (e.g. professional monograph, patient education monograph).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Associated documentation about the medication. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Associated documentation about the medication.
    property sourceElement : TFhirReference read FSource write SetSource;

  end;

  TFhirMedicationKnowledgeMonographListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonographList;
    function GetCurrent : TFhirMedicationKnowledgeMonograph;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonographList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonograph read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonographList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonograph;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonograph);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonographList; overload;
    function Clone : TFhirMedicationKnowledgeMonographList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonograph to the end of the list.
    function Append : TFhirMedicationKnowledgeMonograph;
    
    // Add an already existing FhirMedicationKnowledgeMonograph to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMonograph); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonograph) : Integer;
    
    // Insert FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // Insert an existing FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // Get the iIndexth FhirMedicationKnowledgeMonograph. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonographs[index : Integer] : TFhirMedicationKnowledgeMonograph read GetItemN write SetItemN; default;
  End;

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationKnowledgeIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FIsActive : TFhirBoolean;
    FStrength : TFhirDataType;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetIsActive(value : TFhirBoolean);
    function GetIsActiveST : Boolean;
    procedure SetIsActiveST(value : Boolean);
    procedure SetStrength(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIngredient; overload;
    function Clone : TFhirMedicationKnowledgeIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet but can also be expressed a quantity when the denominator is assumed to be 1 tablet.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

  end;

  TFhirMedicationKnowledgeIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIngredientList;
    function GetCurrent : TFhirMedicationKnowledgeIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIngredient read GetCurrent;
  end;

  TFhirMedicationKnowledgeIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIngredientList; overload;
    function Clone : TFhirMedicationKnowledgeIngredientList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIngredient to the end of the list.
    function Append : TFhirMedicationKnowledgeIngredient;
    
    // Add an already existing FhirMedicationKnowledgeIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeIngredient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIngredient) : Integer;
    
    // Insert FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIngredient;
    
    // Insert an existing FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // Get the iIndexth FhirMedicationKnowledgeIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIngredients[index : Integer] : TFhirMedicationKnowledgeIngredient read GetItemN write SetItemN; default;
  End;

  // The price of the medication.
  TFhirMedicationKnowledgeCost = class (TFhirBackboneElement)
  protected
    FeffectiveDateList : TFhirPeriodList;
    FType_ : TFhirCodeableConcept;
    FSource : TFhirString;
    FCost : TFhirDataType;
    function GetEffectiveDateList : TFhirPeriodList;
    function GetHasEffectiveDateList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirString);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetCost(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeCost; overload;
    function Clone : TFhirMedicationKnowledgeCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The date range for which the cost information of the medication is effective.
    property effectiveDateList : TFhirPeriodList read GetEffectiveDateList;
    property hasEffectiveDateList : boolean read GetHasEffectiveDateList;

    // Typed access to The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The source or owner that assigns the price to the medication.
    property source : String read GetSourceST write SetSourceST;
    // The source or owner that assigns the price to the medication.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The price or representation of the cost (for example, Band A, Band B or $, $$) of the medication. (defined for API consistency)
    property cost : TFhirDataType read FCost write SetCost;
    // The price or representation of the cost (for example, Band A, Band B or $, $$) of the medication.
    property costElement : TFhirDataType read FCost write SetCost;

  end;

  TFhirMedicationKnowledgeCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeCostList;
    function GetCurrent : TFhirMedicationKnowledgeCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeCost read GetCurrent;
  end;

  TFhirMedicationKnowledgeCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeCost;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeCostList; overload;
    function Clone : TFhirMedicationKnowledgeCostList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
    
    //  Add a FhirMedicationKnowledgeCost to the end of the list.
    function Append : TFhirMedicationKnowledgeCost;
    
    // Add an already existing FhirMedicationKnowledgeCost to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeCost) : Integer;
    
    // Insert FhirMedicationKnowledgeCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // Insert an existing FhirMedicationKnowledgeCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // Get the iIndexth FhirMedicationKnowledgeCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeCosts[index : Integer] : TFhirMedicationKnowledgeCost read GetItemN write SetItemN; default;
  End;

  // The program under which the medication is reviewed.
  TFhirMedicationKnowledgeMonitoringProgram = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of program under which the medication is monitored. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of program under which the medication is monitored.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name of the reviewing program.
    property name : String read GetNameST write SetNameST;
    // Name of the reviewing program.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirMedicationKnowledgeMonitoringProgramListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonitoringProgram read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonitoringProgramList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function Append : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Add an already existing FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMonitoringProgram); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonitoringProgram) : Integer;
    
    // Insert FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Insert an existing FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // Get the iIndexth FhirMedicationKnowledgeMonitoringProgram. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonitoringPrograms[index : Integer] : TFhirMedicationKnowledgeMonitoringProgram read GetItemN write SetItemN; default;
  End;

  // Guidelines or protocols that are applicable for the administration of the medication.
  TFhirMedicationKnowledgeAdministrationGuideline = class (TFhirBackboneElement)
  protected
    FdosageList : TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
    FIndication : TFhirCodeableReference;
    FpatientCharacteristicList : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
    function GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
    function GetHasDosageList : Boolean;
    procedure SetIndication(value : TFhirCodeableReference);
    function GetPatientCharacteristicList : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
    function GetHasPatientCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuideline; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuideline; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirMedicationKnowledgeAdministrationGuidelineDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Typed access to Indication or reason for use of the medication that applies to the specific administration guidelines. (defined for API consistency)
    property indication : TFhirCodeableReference read FIndication write SetIndication;
    // Indication or reason for use of the medication that applies to the specific administration guidelines.
    property indicationElement : TFhirCodeableReference read FIndication write SetIndication;

    // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
    property patientCharacteristicList : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList read GetPatientCharacteristicList;
    property hasPatientCharacteristicList : boolean read GetHasPatientCharacteristicList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelineList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuideline;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelineList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuideline read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelineList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuideline;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuideline);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelineList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelineList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuideline to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuideline;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuideline to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuideline); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuideline) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuideline before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuideline;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuideline before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuideline);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuideline. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuideline);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuideline;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelines[index : Integer] : TFhirMedicationKnowledgeAdministrationGuideline read GetItemN write SetItemN; default;
  End;

  // Dosage for the medication for the specific guidelines.
  TFhirMedicationKnowledgeAdministrationGuidelineDosage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdosageList : TFhirDosageList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelineDosage; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelineDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type or category of dosage for a given medication (for example, prophylaxis, maintenance, therapeutic, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or category of dosage for a given medication (for example, prophylaxis, maintenance, therapeutic, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelineDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelineDosage read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelineDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelineDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelineDosageList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelineDosageList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuidelineDosage to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelineDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelineDosage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelineDosage) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuidelineDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelineDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelineDosage);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelineDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelineDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelineDosages[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelineDosage read GetItemN write SetItemN; default;
  End;

  // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
  TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The categorization of the specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The categorization of the specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The specific characteristic (e.g. height, weight, gender, etc.). (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The specific characteristic (e.g. height, weight, gender, etc.).
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristics[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic read GetItemN write SetItemN; default;
  End;

  // Categorization of the medication within a formulary or classification system.
  TFhirMedicationKnowledgeMedicineClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMedicineClassification; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Specific category assigned to the medication (e.g. anti-infective, anti-hypertensive, antibiotic, etc.).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

  end;

  TFhirMedicationKnowledgeMedicineClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMedicineClassification read GetCurrent;
  end;

  TFhirMedicationKnowledgeMedicineClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function Append : TFhirMedicationKnowledgeMedicineClassification;
    
    // Add an already existing FhirMedicationKnowledgeMedicineClassification to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMedicineClassification); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMedicineClassification) : Integer;
    
    // Insert FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // Insert an existing FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // Get the iIndexth FhirMedicationKnowledgeMedicineClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMedicineClassifications[index : Integer] : TFhirMedicationKnowledgeMedicineClassification read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationKnowledgePackaging = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCost : TFhirMedicationKnowledgeCost;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FDevice : TFhirReference;
    FMaterial : TFhirCodeableConcept;
    FpackagingList : TFhirMedicationKnowledgePackagingList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetCost(value : TFhirMedicationKnowledgeCost);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDevice(value : TFhirReference);
    procedure SetMaterial(value : TFhirCodeableConcept);
    function GetPackagingList : TFhirMedicationKnowledgePackagingList;
    function GetHasPackagingList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgePackaging; overload;
    function Clone : TFhirMedicationKnowledgePackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The business identifier of the packaged medication. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The business identifier of the packaged medication.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The cost of the packaged medication. (defined for API consistency)
    property cost : TFhirMedicationKnowledgeCost read FCost write SetCost;
    // The cost of the packaged medication.
    property costElement : TFhirMedicationKnowledgeCost read FCost write SetCost;

    // Typed access to A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The number of product units the package would contain if fully loaded. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of product units the package would contain if fully loaded.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The device used to administer the medication (e.g. scoop, applicator, syringe). (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The device used to administer the medication (e.g. scoop, applicator, syringe).
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to Material type of the package item. (defined for API consistency)
    property material : TFhirCodeableConcept read FMaterial write SetMaterial;
    // Material type of the package item.
    property materialElement : TFhirCodeableConcept read FMaterial write SetMaterial;

    // Allows packages within packages (e.g. blister packages within a box or vials of medications within a box).
    property packagingList : TFhirMedicationKnowledgePackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

  end;

  TFhirMedicationKnowledgePackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgePackagingList;
    function GetCurrent : TFhirMedicationKnowledgePackaging;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgePackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgePackaging read GetCurrent;
  end;

  TFhirMedicationKnowledgePackagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgePackaging;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgePackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgePackagingList; overload;
    function Clone : TFhirMedicationKnowledgePackagingList; overload;
    function GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
    
    //  Add a FhirMedicationKnowledgePackaging to the end of the list.
    function Append : TFhirMedicationKnowledgePackaging;
    
    // Add an already existing FhirMedicationKnowledgePackaging to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgePackaging); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgePackaging) : Integer;
    
    // Insert FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // Insert an existing FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // Get the iIndexth FhirMedicationKnowledgePackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgePackagings[index : Integer] : TFhirMedicationKnowledgePackaging read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
  TFhirMedicationKnowledgeDrugCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Description of the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Description of the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeDrugCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDrugCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeDrugCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeDrugCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeDrugCharacteristic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDrugCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeDrugCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeDrugCharacteristics[index : Integer] : TFhirMedicationKnowledgeDrugCharacteristic read GetItemN write SetItemN; default;
  End;

  // Regulatory information about a medication.
  TFhirMedicationKnowledgeRegulatory = class (TFhirBackboneElement)
  protected
    FRegulatoryAuthority : TFhirReference;
    FsubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    FscheduleList : TFhirCodeableConceptList;
    FMaxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetRegulatoryAuthority(value : TFhirReference);
    function GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetHasSubstitutionList : Boolean;
    function GetScheduleList : TFhirCodeableConceptList;
    function GetHasScheduleList : Boolean;
    procedure SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatory; overload;
    function Clone : TFhirMedicationKnowledgeRegulatory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The authority that is specifying the regulations. (defined for API consistency)
    property regulatoryAuthority : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;
    // The authority that is specifying the regulations.
    property regulatoryAuthorityElement : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;

    // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
    property substitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList read GetSubstitutionList;
    property hasSubstitutionList : boolean read GetHasSubstitutionList;

    // Specifies the schedule of a medication in jurisdiction.
    property scheduleList : TFhirCodeableConceptList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The maximum number of units of the medication that can be dispensed in a period. (defined for API consistency)
    property maxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;
    // The maximum number of units of the medication that can be dispensed in a period.
    property maxDispenseElement : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;

  end;

  TFhirMedicationKnowledgeRegulatoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatory read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatory to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatory;
    
    // Add an already existing FhirMedicationKnowledgeRegulatory to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatory); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatory) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // Insert an existing FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatories[index : Integer] : TFhirMedicationKnowledgeRegulatory read GetItemN write SetItemN; default;
  End;

  // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
  TFhirMedicationKnowledgeRegulatorySubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirBoolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirBoolean);
    function GetAllowedST : Boolean;
    procedure SetAllowedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies the type of substitution allowed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the type of substitution allowed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Specifies if regulation allows for changes in the medication when dispensing.
    property allowed : Boolean read GetAllowedST write SetAllowedST;
    // Specifies if regulation allows for changes in the medication when dispensing.
    property allowedElement : TFhirBoolean read FAllowed write SetAllowed;

  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySubstitution read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Add an already existing FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatorySubstitution); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySubstitution) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Insert an existing FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatorySubstitutions[index : Integer] : TFhirMedicationKnowledgeRegulatorySubstitution read GetItemN write SetItemN; default;
  End;

  // The maximum number of units of the medication that can be dispensed in a period.
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FPeriod : TFhirDuration;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetPeriod(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The maximum number of units of the medication that can be dispensed. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The maximum number of units of the medication that can be dispensed.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The period that applies to the maximum number of units. (defined for API consistency)
    property period : TFhirDuration read FPeriod write SetPeriod;
    // The period that applies to the maximum number of units.
    property periodElement : TFhirDuration read FPeriod write SetPeriod;

  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Add an already existing FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatoryMaxDispense); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Insert an existing FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatoryMaxDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatoryMaxDispenses[index : Integer] : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetItemN write SetItemN; default;
  End;

  // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
  TFhirMedicationKnowledgeKineticCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeKineticCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeKineticCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code specifying the type of kinetics (e.g. area under the curve, half life period, lethal dose 50.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code specifying the type of kinetics (e.g. area under the curve, half life period, lethal dose 50.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Description of the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Description of the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeKineticCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeKineticCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeKineticCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeKineticCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeKineticCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeKineticCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeKineticCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeKineticCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeKineticCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeKineticCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeKineticCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeKineticCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeKineticCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeKineticCharacteristic to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeKineticCharacteristic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeKineticCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeKineticCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeKineticCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeKineticCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeKineticCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeKineticCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeKineticCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeKineticCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeKineticCharacteristics[index : Integer] : TFhirMedicationKnowledgeKineticCharacteristic read GetItemN write SetItemN; default;
  End;

  // Information about a medication that is used to support knowledge.
  TFhirMedicationKnowledge = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FAuthor : TFhirReference;
    FManufacturer : TFhirReference;
    FDoseForm : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    FsynonymList : TFhirStringList;
    FrelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    FassociatedMedicationList : TFhirReferenceList;
    FAssociatedDefinition : TFhirReference;
    FproductTypeList : TFhirCodeableConceptList;
    FmonographList : TFhirMedicationKnowledgeMonographList;
    FingredientList : TFhirMedicationKnowledgeIngredientList;
    FdeviceList : TFhirReferenceList;
    FPreparationInstruction : TFhirMarkdown;
    FintendedRouteList : TFhirCodeableConceptList;
    FcostList : TFhirMedicationKnowledgeCostList;
    FmonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    FadministrationGuidelineList : TFhirMedicationKnowledgeAdministrationGuidelineList;
    FmedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    FpackagingList : TFhirMedicationKnowledgePackagingList;
    FdrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    FclinicalUseIssueList : TFhirReferenceList;
    FregulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    FkineticCharacteristicList : TFhirMedicationKnowledgeKineticCharacteristicList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
    procedure SetAuthor(value : TFhirReference);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetDoseForm(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
    function GetSynonymList : TFhirStringList;
    function GetHasSynonymList : Boolean;
    function GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetHasRelatedMedicationKnowledgeList : Boolean;
    function GetAssociatedMedicationList : TFhirReferenceList;
    function GetHasAssociatedMedicationList : Boolean;
    procedure SetAssociatedDefinition(value : TFhirReference);
    function GetProductTypeList : TFhirCodeableConceptList;
    function GetHasProductTypeList : Boolean;
    function GetMonographList : TFhirMedicationKnowledgeMonographList;
    function GetHasMonographList : Boolean;
    function GetIngredientList : TFhirMedicationKnowledgeIngredientList;
    function GetHasIngredientList : Boolean;
    function GetDeviceList : TFhirReferenceList;
    function GetHasDeviceList : Boolean;
    procedure SetPreparationInstruction(value : TFhirMarkdown);
    function GetPreparationInstructionST : String;
    procedure SetPreparationInstructionST(value : String);
    function GetIntendedRouteList : TFhirCodeableConceptList;
    function GetHasIntendedRouteList : Boolean;
    function GetCostList : TFhirMedicationKnowledgeCostList;
    function GetHasCostList : Boolean;
    function GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetHasMonitoringProgramList : Boolean;
    function GetAdministrationGuidelineList : TFhirMedicationKnowledgeAdministrationGuidelineList;
    function GetHasAdministrationGuidelineList : Boolean;
    function GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetHasMedicineClassificationList : Boolean;
    function GetPackagingList : TFhirMedicationKnowledgePackagingList;
    function GetHasPackagingList : Boolean;
    function GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetHasDrugCharacteristicList : Boolean;
    function GetClinicalUseIssueList : TFhirReferenceList;
    function GetHasClinicalUseIssueList : Boolean;
    function GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    function GetHasRegulatoryList : Boolean;
    function GetKineticCharacteristicList : TFhirMedicationKnowledgeKineticCharacteristicList;
    function GetHasKineticCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.  The status refers to the validity about the information of the medication and not to its medicinal properties.
    property status : TFhirMedicationKnowledgeStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The creator or owner of the knowledge or information about the medication. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The creator or owner of the knowledge or information about the medication.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Additional names for a medication, for example, the name(s) given to a medication in different countries.  For example, acetaminophen and paracetamol or salbutamol and albuterol.
    property synonymList : TFhirStringList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // Associated or related medications. For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor.
    property relatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList read GetRelatedMedicationKnowledgeList;
    property hasRelatedMedicationKnowledgeList : boolean read GetHasRelatedMedicationKnowledgeList;

    // Links to associated medications that could be prescribed, dispensed or administered.
    property associatedMedicationList : TFhirReferenceList read GetAssociatedMedicationList;
    property hasAssociatedMedicationList : boolean read GetHasAssociatedMedicationList;

    // Typed access to Associated definitions for this medication. (defined for API consistency)
    property associatedDefinition : TFhirReference read FAssociatedDefinition write SetAssociatedDefinition;
    // Associated definitions for this medication.
    property associatedDefinitionElement : TFhirReference read FAssociatedDefinition write SetAssociatedDefinition;

    // Category of the medication or product (e.g. branded product, therapeutic moeity, generic product, innovator product, etc.).
    property productTypeList : TFhirCodeableConceptList read GetProductTypeList;
    property hasProductTypeList : boolean read GetHasProductTypeList;

    // Associated documentation about the medication.
    property monographList : TFhirMedicationKnowledgeMonographList read GetMonographList;
    property hasMonographList : boolean read GetHasMonographList;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationKnowledgeIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // A device associated with the medication (for example, a drug coated catheter or a drug impregnated dressing).
    property deviceList : TFhirReferenceList read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Typed access to The instructions for preparing the medication.
    property preparationInstruction : String read GetPreparationInstructionST write SetPreparationInstructionST;
    // The instructions for preparing the medication.
    property preparationInstructionElement : TFhirMarkdown read FPreparationInstruction write SetPreparationInstruction;

    // The intended or approved route of administration.
    property intendedRouteList : TFhirCodeableConceptList read GetIntendedRouteList;
    property hasIntendedRouteList : boolean read GetHasIntendedRouteList;

    // The price of the medication.
    property costList : TFhirMedicationKnowledgeCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

    // The program under which the medication is reviewed.
    property monitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList read GetMonitoringProgramList;
    property hasMonitoringProgramList : boolean read GetHasMonitoringProgramList;

    // Guidelines or protocols that are applicable for the administration of the medication.
    property administrationGuidelineList : TFhirMedicationKnowledgeAdministrationGuidelineList read GetAdministrationGuidelineList;
    property hasAdministrationGuidelineList : boolean read GetHasAdministrationGuidelineList;

    // Categorization of the medication within a formulary or classification system.
    property medicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList read GetMedicineClassificationList;
    property hasMedicineClassificationList : boolean read GetHasMedicineClassificationList;

    // Information that only applies to packages (not products).
    property packagingList : TFhirMedicationKnowledgePackagingList read GetPackagingList;
    property hasPackagingList : boolean read GetHasPackagingList;

    // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
    property drugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList read GetDrugCharacteristicList;
    property hasDrugCharacteristicList : boolean read GetHasDrugCharacteristicList;

    // Potential clinical issue with or between medication(s) (for example, drug-drug interaction, drug-disease contraindication, drug-allergy interaction, etc.).
    property clinicalUseIssueList : TFhirReferenceList read GetClinicalUseIssueList;
    property hasClinicalUseIssueList : boolean read GetHasClinicalUseIssueList;

    // Regulatory information about a medication.
    property regulatoryList : TFhirMedicationKnowledgeRegulatoryList read GetRegulatoryList;
    property hasRegulatoryList : boolean read GetHasRegulatoryList;

    // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
    property kineticCharacteristicList : TFhirMedicationKnowledgeKineticCharacteristicList read GetKineticCharacteristicList;
    property hasKineticCharacteristicList : boolean read GetHasKineticCharacteristicList;

  end;

  TFhirMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledge;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledge to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledge); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledges[index : Integer] : TFhirMedicationKnowledge read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  // A product specific contact, person (in a role), or an organization.
  TFhirMedicinalProductDefinitionContact = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FContact : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetContact(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionContact; overload;
    function Clone : TFhirMedicinalProductDefinitionContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Allows the contact to be classified, for example QPPV, Pharmacovigilence Enquiry Information. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Allows the contact to be classified, for example QPPV, Pharmacovigilence Enquiry Information.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A product specific contact, person (in a role), or an organization. (defined for API consistency)
    property contact : TFhirReference read FContact write SetContact;
    // A product specific contact, person (in a role), or an organization.
    property contactElement : TFhirReference read FContact write SetContact;

  end;

  TFhirMedicinalProductDefinitionContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionContactList;
    function GetCurrent : TFhirMedicinalProductDefinitionContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionContact read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionContact;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionContactList; overload;
    function Clone : TFhirMedicinalProductDefinitionContactList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionContact to the end of the list.
    function Append : TFhirMedicinalProductDefinitionContact;
    
    // Add an already existing FhirMedicinalProductDefinitionContact to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionContact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionContact) : Integer;
    
    // Insert FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // Insert an existing FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // Get the iIndexth FhirMedicinalProductDefinitionContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionContacts[index : Integer] : TFhirMedicinalProductDefinitionContact read GetItemN write SetItemN; default;
  End;

  // The product's name, including full name and possibly coded parts.
  TFhirMedicinalProductDefinitionName = class (TFhirBackboneElement)
  protected
    FProductName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FnamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
    FcountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    procedure SetProductName(value : TFhirString);
    function GetProductNameST : String;
    procedure SetProductNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
    function GetHasNamePartList : Boolean;
    function GetCountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    function GetHasCountryLanguageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionName; overload;
    function Clone : TFhirMedicinalProductDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The full product name.
    property productName : String read GetProductNameST write SetProductNameST;
    // The full product name.
    property productNameElement : TFhirString read FProductName write SetProductName;

    // Typed access to Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Coding words or phrases of the name.
    property namePartList : TFhirMedicinalProductDefinitionNameNamePartList read GetNamePartList;
    property hasNamePartList : boolean read GetHasNamePartList;

    // Country where the name applies.
    property countryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList read GetCountryLanguageList;
    property hasCountryLanguageList : boolean read GetHasCountryLanguageList;

  end;

  TFhirMedicinalProductDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameList;
    function GetCurrent : TFhirMedicinalProductDefinitionName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionName read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionName to the end of the list.
    function Append : TFhirMedicinalProductDefinitionName;
    
    // Add an already existing FhirMedicinalProductDefinitionName to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionName); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionName) : Integer;
    
    // Insert FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // Insert an existing FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // Get the iIndexth FhirMedicinalProductDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNames[index : Integer] : TFhirMedicinalProductDefinitionName read GetItemN write SetItemN; default;
  End;

  // Coding words or phrases of the name.
  TFhirMedicinalProductDefinitionNameNamePart = class (TFhirBackboneElement)
  protected
    FPart : TFhirString;
    FType_ : TFhirCodeableConcept;
    procedure SetPart(value : TFhirString);
    function GetPartST : String;
    procedure SetPartST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNameNamePart; overload;
    function Clone : TFhirMedicinalProductDefinitionNameNamePart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A fragment of a product name.
    property part : String read GetPartST write SetPartST;
    // A fragment of a product name.
    property partElement : TFhirString read FPart write SetPart;

    // Typed access to Idenifying type for this part of the name (e.g. strength part). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Idenifying type for this part of the name (e.g. strength part).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionNameNamePartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameNamePartList;
    function GetCurrent : TFhirMedicinalProductDefinitionNameNamePart;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameNamePartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNameNamePart read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameNamePartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameNamePartList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameNamePartList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameNamePartListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNameNamePart to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNameNamePart;
    
    // Add an already existing FhirMedicinalProductDefinitionNameNamePart to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionNameNamePart); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNameNamePart) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNameNamePart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    
    // Insert an existing FhirMedicinalProductDefinitionNameNamePart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNameNamePart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameNameParts[index : Integer] : TFhirMedicinalProductDefinitionNameNamePart read GetItemN write SetItemN; default;
  End;

  // Country where the name applies.
  TFhirMedicinalProductDefinitionNameCountryLanguage = class (TFhirBackboneElement)
  protected
    FCountry : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    procedure SetCountry(value : TFhirCodeableConcept);
    procedure SetJurisdiction(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNameCountryLanguage; overload;
    function Clone : TFhirMedicinalProductDefinitionNameCountryLanguage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Country code for where this name applies. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // Country code for where this name applies.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Typed access to Jurisdiction code for where this name applies. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // Jurisdiction code for where this name applies.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

    // Typed access to Language code for this name. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Language code for this name.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    function GetCurrent : TFhirMedicinalProductDefinitionNameCountryLanguage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameCountryLanguageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNameCountryLanguage read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameCountryLanguageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameCountryLanguageList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameCountryLanguageList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNameCountryLanguage to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // Add an already existing FhirMedicinalProductDefinitionNameCountryLanguage to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionNameCountryLanguage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNameCountryLanguage) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNameCountryLanguage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // Insert an existing FhirMedicinalProductDefinitionNameCountryLanguage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNameCountryLanguage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameCountryLanguages[index : Integer] : TFhirMedicinalProductDefinitionNameCountryLanguage read GetItemN write SetItemN; default;
  End;

  // Reference to another product, e.g. for linking authorised to investigational product.
  TFhirMedicinalProductDefinitionCrossReference = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableReference;
    FType_ : TFhirCodeableConcept;
    procedure SetProduct(value : TFhirCodeableReference);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionCrossReference; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to another product, e.g. for linking authorised to investigational product. (defined for API consistency)
    property product : TFhirCodeableReference read FProduct write SetProduct;
    // Reference to another product, e.g. for linking authorised to investigational product.
    property productElement : TFhirCodeableReference read FProduct write SetProduct;

    // Typed access to The type of relationship, for instance branded to generic, product to development product (investigational), parallel import version. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of relationship, for instance branded to generic, product to development product (investigational), parallel import version.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionCrossReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionCrossReference read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionCrossReferenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionCrossReference to the end of the list.
    function Append : TFhirMedicinalProductDefinitionCrossReference;
    
    // Add an already existing FhirMedicinalProductDefinitionCrossReference to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionCrossReference); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionCrossReference) : Integer;
    
    // Insert FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // Insert an existing FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // Get the iIndexth FhirMedicinalProductDefinitionCrossReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionCrossReferences[index : Integer] : TFhirMedicinalProductDefinitionCrossReference read GetItemN write SetItemN; default;
  End;

  // An operation applied to the product, for manufacturing or adminsitrative purpose.
  TFhirMedicinalProductDefinitionManufacturingBusinessOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableReference;
    FEffectiveDate : TFhirPeriod;
    FmanufacturerList : TFhirReferenceList;
    FAuthorization : TFhirReference;
    FConfidentialityIndicator : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableReference);
    procedure SetEffectiveDate(value : TFhirPeriod);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    procedure SetAuthorization(value : TFhirReference);
    procedure SetConfidentialityIndicator(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionManufacturingBusinessOperation; overload;
    function Clone : TFhirMedicinalProductDefinitionManufacturingBusinessOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of manufacturing operation e.g. manufacturing itself, re-packaging. This may be a subtype of some other wider scope of authorized operation, referenced by the authorization attribute. (defined for API consistency)
    property type_ : TFhirCodeableReference read FType_ write SetType_;
    // The type of manufacturing operation e.g. manufacturing itself, re-packaging. This may be a subtype of some other wider scope of authorized operation, referenced by the authorization attribute.
    property type_Element : TFhirCodeableReference read FType_ write SetType_;

    // Typed access to Date range of applicability. (defined for API consistency)
    property effectiveDate : TFhirPeriod read FEffectiveDate write SetEffectiveDate;
    // Date range of applicability.
    property effectiveDateElement : TFhirPeriod read FEffectiveDate write SetEffectiveDate;

    // The manufacturer or establishment associated with the process.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to An authorization for this process, either as a logical reference, holding just an identifier, or a full refererence to a resource that captures the details. The authorization mayu possibly apply to several products or a wider scope of process of which this is a part. (defined for API consistency)
    property authorization : TFhirReference read FAuthorization write SetAuthorization;
    // An authorization for this process, either as a logical reference, holding just an identifier, or a full refererence to a resource that captures the details. The authorization mayu possibly apply to several products or a wider scope of process of which this is a part.
    property authorizationElement : TFhirReference read FAuthorization write SetAuthorization;

    // Typed access to To indicate if this proces is commercially confidential. (defined for API consistency)
    property confidentialityIndicator : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;
    // To indicate if this proces is commercially confidential.
    property confidentialityIndicatorElement : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;

  end;

  TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
    function GetCurrent : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionManufacturingBusinessOperation read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionManufacturingBusinessOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList; overload;
    function Clone : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionManufacturingBusinessOperation to the end of the list.
    function Append : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
    
    // Add an already existing FhirMedicinalProductDefinitionManufacturingBusinessOperation to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinitionManufacturingBusinessOperation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionManufacturingBusinessOperation) : Integer;
    
    // Insert FhirMedicinalProductDefinitionManufacturingBusinessOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
    
    // Insert an existing FhirMedicinalProductDefinitionManufacturingBusinessOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
    
    // Get the iIndexth FhirMedicinalProductDefinitionManufacturingBusinessOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionManufacturingBusinessOperations[index : Integer] : TFhirMedicinalProductDefinitionManufacturingBusinessOperation read GetItemN write SetItemN; default;
  End;

  // Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use).
  TFhirMedicinalProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FDomain : TFhirCodeableConcept;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FDescription : TFhirMarkdown;
    FCombinedPharmaceuticalDoseForm : TFhirCodeableConcept;
    FIndication : TFhirMarkdown;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FAdditionalMonitoringIndicator : TFhirCodeableConcept;
    FspecialMeasuresList : TFhirCodeableConceptList;
    FPaediatricUseIndicator : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FcharacteristicList : TFhirCodeableConceptList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FpharmaceuticalProductList : TFhirReferenceList;
    FpackagedMedicinalProductList : TFhirReferenceList;
    FingredientList : TFhirReferenceList;
    FimpurityList : TFhirReferenceList;
    FattachedDocumentList : TFhirReferenceList;
    FmasterFileList : TFhirReferenceList;
    FcontactList : TFhirMedicinalProductDefinitionContactList;
    FclinicalTrialList : TFhirReferenceList;
    FnameList : TFhirMedicinalProductDefinitionNameList;
    FcrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    FmanufacturingBusinessOperationList : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDomain(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
    procedure SetIndication(value : TFhirMarkdown);
    function GetIndicationST : String;
    procedure SetIndicationST(value : String);
    procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    procedure SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
    function GetSpecialMeasuresList : TFhirCodeableConceptList;
    function GetHasSpecialMeasuresList : Boolean;
    procedure SetPaediatricUseIndicator(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetPharmaceuticalProductList : TFhirReferenceList;
    function GetHasPharmaceuticalProductList : Boolean;
    function GetPackagedMedicinalProductList : TFhirReferenceList;
    function GetHasPackagedMedicinalProductList : Boolean;
    function GetIngredientList : TFhirReferenceList;
    function GetHasIngredientList : Boolean;
    function GetImpurityList : TFhirReferenceList;
    function GetHasImpurityList : Boolean;
    function GetAttachedDocumentList : TFhirReferenceList;
    function GetHasAttachedDocumentList : Boolean;
    function GetMasterFileList : TFhirReferenceList;
    function GetHasMasterFileList : Boolean;
    function GetContactList : TFhirMedicinalProductDefinitionContactList;
    function GetHasContactList : Boolean;
    function GetClinicalTrialList : TFhirReferenceList;
    function GetHasClinicalTrialList : Boolean;
    function GetNameList : TFhirMedicinalProductDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetHasCrossReferenceList : Boolean;
    function GetManufacturingBusinessOperationList : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
    function GetHasManufacturingBusinessOperationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinition; overload;
    function Clone : TFhirMedicinalProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this product. Could be an MPID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Regulatory type, e.g. Investigational or Authorized. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Regulatory type, e.g. Investigational or Authorized.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to If this medicine applies to human or veterinary uses. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If this medicine applies to human or veterinary uses.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to A business level identifier of the product.
    property version : String read GetVersionST write SetVersionST;
    // A business level identifier of the product.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The status within the lifecycle of this product. A high level status, this is not intended to duplicate details carried elswhere such as legal status, or authorization status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this product. A high level status, this is not intended to duplicate details carried elswhere such as legal status, or authorization status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to General description of this product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of this product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to The dose form for a single part product, or combined form of a multiple part product. (defined for API consistency)
    property combinedPharmaceuticalDoseForm : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;
    // The dose form for a single part product, or combined form of a multiple part product.
    property combinedPharmaceuticalDoseFormElement : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;

    // Typed access to General combined description of indication(s) for this product, for use when a structured set is not available. See also the ClinicalUseIssue resource, which can be used for more structured indications, and can be made to reference to this resource.
    property indication : String read GetIndicationST write SetIndicationST;
    // General combined description of indication(s) for this product, for use when a structured set is not available. See also the ClinicalUseIssue resource, which can be used for more structured indications, and can be made to reference to this resource.
    property indicationElement : TFhirMarkdown read FIndication write SetIndication;

    // Typed access to The legal status of supply of the medicinal product as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the medicinal product as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Typed access to Whether the Medicinal Product is subject to additional monitoring for regulatory reasons. (defined for API consistency)
    property additionalMonitoringIndicator : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;
    // Whether the Medicinal Product is subject to additional monitoring for regulatory reasons.
    property additionalMonitoringIndicatorElement : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;

    // Whether the Medicinal Product is subject to special measures for regulatory reasons.
    property specialMeasuresList : TFhirCodeableConceptList read GetSpecialMeasuresList;
    property hasSpecialMeasuresList : boolean read GetHasSpecialMeasuresList;

    // Typed access to If authorised for use in children. (defined for API consistency)
    property paediatricUseIndicator : TFhirCodeableConcept read FPaediatricUseIndicator write SetPaediatricUseIndicator;
    // If authorised for use in children.
    property paediatricUseIndicatorElement : TFhirCodeableConcept read FPaediatricUseIndicator write SetPaediatricUseIndicator;

    // Allows the product to be classified by various systems.
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Allows the key product features to be recorded, such as "suger free", "modified release", "parallel import".
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Marketing status of the medicinal product, in contrast to marketing authorizaton.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Pharmaceutical aspects of product.
    property pharmaceuticalProductList : TFhirReferenceList read GetPharmaceuticalProductList;
    property hasPharmaceuticalProductList : boolean read GetHasPharmaceuticalProductList;

    // Package representation for the product.
    property packagedMedicinalProductList : TFhirReferenceList read GetPackagedMedicinalProductList;
    property hasPackagedMedicinalProductList : boolean read GetHasPackagedMedicinalProductList;

    // The ingredients of this medicinal product - when not specified elsewhere. This is only needed if the ingredients are not specified by the pharmaceuticalProduct or packagedMedicinalProduct references above. In cases where those levels of detail are not used, the ingredients may be specified directly here.
    property ingredientList : TFhirReferenceList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Any component of the drug product which is not the chemical entity defined as the drug substance or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
    property impurityList : TFhirReferenceList read GetImpurityList;
    property hasImpurityList : boolean read GetHasImpurityList;

    // Supporting documentation, typically for regulatory submission.
    property attachedDocumentList : TFhirReferenceList read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // A master file for to the medicinal product (e.g. Pharmacovigilance System Master File).
    property masterFileList : TFhirReferenceList read GetMasterFileList;
    property hasMasterFileList : boolean read GetHasMasterFileList;

    // A product specific contact, person (in a role), or an organization.
    property contactList : TFhirMedicinalProductDefinitionContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Clinical trials or studies that this product is involved in.
    property clinicalTrialList : TFhirReferenceList read GetClinicalTrialList;
    property hasClinicalTrialList : boolean read GetHasClinicalTrialList;

    // The product's name, including full name and possibly coded parts.
    property nameList : TFhirMedicinalProductDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // Reference to another product, e.g. for linking authorised to investigational product.
    property crossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList read GetCrossReferenceList;
    property hasCrossReferenceList : boolean read GetHasCrossReferenceList;

    // An operation applied to the product, for manufacturing or adminsitrative purpose.
    property manufacturingBusinessOperationList : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList read GetManufacturingBusinessOperationList;
    property hasManufacturingBusinessOperationList : boolean read GetHasManufacturingBusinessOperationList;

  end;

  TFhirMedicinalProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionList;
    function GetCurrent : TFhirMedicinalProductDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinition read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionList; overload;
    function Clone : TFhirMedicinalProductDefinitionList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
    
    //  Add a FhirMedicinalProductDefinition to the end of the list.
    function Append : TFhirMedicinalProductDefinition;
    
    // Add an already existing FhirMedicinalProductDefinition to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinition) : Integer;
    
    // Insert FhirMedicinalProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinition;
    
    // Insert an existing FhirMedicinalProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // Get the iIndexth FhirMedicinalProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitions[index : Integer] : TFhirMedicinalProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  // The product's nutritional information expressed by the nutrients.
  TFhirNutritionProductNutrient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductNutrient; overload;
    function Clone : TFhirNutritionProductNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The (relevant) nutrients in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The (relevant) nutrients in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of nutrient expressed in one or more units: X per pack / per serving / per dose.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductNutrientList;
    function GetCurrent : TFhirNutritionProductNutrient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductNutrient read GetCurrent;
  end;

  TFhirNutritionProductNutrientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductNutrientList; overload;
    function Clone : TFhirNutritionProductNutrientList; overload;
    function GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
    
    //  Add a FhirNutritionProductNutrient to the end of the list.
    function Append : TFhirNutritionProductNutrient;
    
    // Add an already existing FhirNutritionProductNutrient to the end of the list.
    procedure AddItem(value : TFhirNutritionProductNutrient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductNutrient) : Integer;
    
    // Insert FhirNutritionProductNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductNutrient;
    
    // Insert an existing FhirNutritionProductNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductNutrient);
    
    // Get the iIndexth FhirNutritionProductNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductNutrient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductNutrient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductNutrients[index : Integer] : TFhirNutritionProductNutrient read GetItemN write SetItemN; default;
  End;

  // Ingredients contained in this product.
  TFhirNutritionProductIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductIngredient; overload;
    function Clone : TFhirNutritionProductIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ingredient contained in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The ingredient contained in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of ingredient that is in the product.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductIngredientList;
    function GetCurrent : TFhirNutritionProductIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductIngredient read GetCurrent;
  end;

  TFhirNutritionProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductIngredientList; overload;
    function Clone : TFhirNutritionProductIngredientList; overload;
    function GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
    
    //  Add a FhirNutritionProductIngredient to the end of the list.
    function Append : TFhirNutritionProductIngredient;
    
    // Add an already existing FhirNutritionProductIngredient to the end of the list.
    procedure AddItem(value : TFhirNutritionProductIngredient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductIngredient) : Integer;
    
    // Insert FhirNutritionProductIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductIngredient;
    
    // Insert an existing FhirNutritionProductIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductIngredient);
    
    // Get the iIndexth FhirNutritionProductIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductIngredients[index : Integer] : TFhirNutritionProductIngredient read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the nutrition product.
  TFhirNutritionProductProductCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductProductCharacteristic; overload;
    function Clone : TFhirNutritionProductProductCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the product is being described (for example, colour, shape). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the product is being described (for example, colour, shape).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The actual characteristic value corresponding to the type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The actual characteristic value corresponding to the type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirNutritionProductProductCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductProductCharacteristicList;
    function GetCurrent : TFhirNutritionProductProductCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductProductCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductProductCharacteristic read GetCurrent;
  end;

  TFhirNutritionProductProductCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductProductCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductProductCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductProductCharacteristicList; overload;
    function Clone : TFhirNutritionProductProductCharacteristicList; overload;
    function GetEnumerator : TFhirNutritionProductProductCharacteristicListEnumerator;
    
    //  Add a FhirNutritionProductProductCharacteristic to the end of the list.
    function Append : TFhirNutritionProductProductCharacteristic;
    
    // Add an already existing FhirNutritionProductProductCharacteristic to the end of the list.
    procedure AddItem(value : TFhirNutritionProductProductCharacteristic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductProductCharacteristic) : Integer;
    
    // Insert FhirNutritionProductProductCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductProductCharacteristic;
    
    // Insert an existing FhirNutritionProductProductCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductProductCharacteristic);
    
    // Get the iIndexth FhirNutritionProductProductCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductProductCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductProductCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductProductCharacteristics[index : Integer] : TFhirNutritionProductProductCharacteristic read GetItemN write SetItemN; default;
  End;

  // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
  TFhirNutritionProductInstance = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FidentifierList : TFhirIdentifierList;
    FLotNumber : TFhirString;
    FExpiry : TFhirDateTime;
    FUseBy : TFhirDateTime;
    procedure SetQuantity(value : TFhirQuantity);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetUseBy(value : TFhirDateTime);
    function GetUseByST : TFslDateTime;
    procedure SetUseByST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductInstance; overload;
    function Clone : TFhirNutritionProductInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of items or instances that the resource considers, for instance when referring to 2 identical units together. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of items or instances that the resource considers, for instance when referring to 2 identical units together.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The identifier for the physical instance, typically a serial number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identification of the batch or lot of the product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The identification of the batch or lot of the product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useBy : TFslDateTime read GetUseByST write SetUseByST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useByElement : TFhirDateTime read FUseBy write SetUseBy;

  end;

  TFhirNutritionProductInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductInstanceList;
    function GetCurrent : TFhirNutritionProductInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductInstance read GetCurrent;
  end;

  TFhirNutritionProductInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductInstance;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductInstanceList; overload;
    function Clone : TFhirNutritionProductInstanceList; overload;
    function GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
    
    //  Add a FhirNutritionProductInstance to the end of the list.
    function Append : TFhirNutritionProductInstance;
    
    // Add an already existing FhirNutritionProductInstance to the end of the list.
    procedure AddItem(value : TFhirNutritionProductInstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductInstance) : Integer;
    
    // Insert FhirNutritionProductInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductInstance;
    
    // Insert an existing FhirNutritionProductInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductInstance);
    
    // Get the iIndexth FhirNutritionProductInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductInstances[index : Integer] : TFhirNutritionProductInstance read GetItemN write SetItemN; default;
  End;

  // A food or fluid product that is consumed by patients.
  TFhirNutritionProduct = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList;
    FnutrientList : TFhirNutritionProductNutrientList;
    FingredientList : TFhirNutritionProductIngredientList;
    FknownAllergenList : TFhirCodeableReferenceList;
    FproductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
    FInstance : TFhirNutritionProductInstance;
    FnoteList : TFhirAnnotationList;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirNutritionProductStatusEnum;
    procedure SetStatusST(value : TFhirNutritionProductStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetNutrientList : TFhirNutritionProductNutrientList;
    function GetHasNutrientList : Boolean;
    function GetIngredientList : TFhirNutritionProductIngredientList;
    function GetHasIngredientList : Boolean;
    function GetKnownAllergenList : TFhirCodeableReferenceList;
    function GetHasKnownAllergenList : Boolean;
    function GetProductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
    function GetHasProductCharacteristicList : Boolean;
    procedure SetInstance(value : TFhirNutritionProductInstance);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProduct; overload;
    function Clone : TFhirNutritionProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The current state of the product.
    property status : TFhirNutritionProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Nutrition products can have different classifications - according to its nutritional properties, preparation methods, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The code assigned to the product, for example a manufacturer number or other terminology. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code assigned to the product, for example a manufacturer number or other terminology.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The organisation (manufacturer, representative or legal authorisation holder) that is responsible for the device.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // The product's nutritional information expressed by the nutrients.
    property nutrientList : TFhirNutritionProductNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Ingredients contained in this product.
    property ingredientList : TFhirNutritionProductIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Allergens that are known or suspected to be a part of this nutrition product.
    property knownAllergenList : TFhirCodeableReferenceList read GetKnownAllergenList;
    property hasKnownAllergenList : boolean read GetHasKnownAllergenList;

    // Specifies descriptive properties of the nutrition product.
    property productCharacteristicList : TFhirNutritionProductProductCharacteristicList read GetProductCharacteristicList;
    property hasProductCharacteristicList : boolean read GetHasProductCharacteristicList;

    // Typed access to Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product. (defined for API consistency)
    property instance : TFhirNutritionProductInstance read FInstance write SetInstance;
    // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
    property instanceElement : TFhirNutritionProductInstance read FInstance write SetInstance;

    // Comments made about the product.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductList;
    function GetCurrent : TFhirNutritionProduct;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProduct read GetCurrent;
  end;

  TFhirNutritionProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProduct;
    procedure SetItemN(index : Integer; value : TFhirNutritionProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductList; overload;
    function Clone : TFhirNutritionProductList; overload;
    function GetEnumerator : TFhirNutritionProductListEnumerator;
    
    //  Add a FhirNutritionProduct to the end of the list.
    function Append : TFhirNutritionProduct;
    
    // Add an already existing FhirNutritionProduct to the end of the list.
    procedure AddItem(value : TFhirNutritionProduct); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProduct) : Integer;
    
    // Insert FhirNutritionProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProduct;
    
    // Insert an existing FhirNutritionProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProduct);
    
    // Get the iIndexth FhirNutritionProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProduct;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProducts[index : Integer] : TFhirNutritionProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  // Batch numbering.
  TFhirPackagedProductDefinitionBatchIdentifier = class (TFhirBackboneElement)
  protected
    FOuterPackaging : TFhirIdentifier;
    FImmediatePackaging : TFhirIdentifier;
    procedure SetOuterPackaging(value : TFhirIdentifier);
    procedure SetImmediatePackaging(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionBatchIdentifier; overload;
    function Clone : TFhirPackagedProductDefinitionBatchIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number appearing on the outer packaging of a specific batch. (defined for API consistency)
    property outerPackaging : TFhirIdentifier read FOuterPackaging write SetOuterPackaging;
    // A number appearing on the outer packaging of a specific batch.
    property outerPackagingElement : TFhirIdentifier read FOuterPackaging write SetOuterPackaging;

    // Typed access to A number appearing on the immediate packaging (and not the outer packaging). (defined for API consistency)
    property immediatePackaging : TFhirIdentifier read FImmediatePackaging write SetImmediatePackaging;
    // A number appearing on the immediate packaging (and not the outer packaging).
    property immediatePackagingElement : TFhirIdentifier read FImmediatePackaging write SetImmediatePackaging;

  end;

  TFhirPackagedProductDefinitionBatchIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionBatchIdentifierList;
    function GetCurrent : TFhirPackagedProductDefinitionBatchIdentifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionBatchIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionBatchIdentifier read GetCurrent;
  end;

  TFhirPackagedProductDefinitionBatchIdentifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionBatchIdentifier;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionBatchIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionBatchIdentifierList; overload;
    function Clone : TFhirPackagedProductDefinitionBatchIdentifierList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionBatchIdentifierListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionBatchIdentifier to the end of the list.
    function Append : TFhirPackagedProductDefinitionBatchIdentifier;
    
    // Add an already existing FhirPackagedProductDefinitionBatchIdentifier to the end of the list.
    procedure AddItem(value : TFhirPackagedProductDefinitionBatchIdentifier); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionBatchIdentifier) : Integer;
    
    // Insert FhirPackagedProductDefinitionBatchIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionBatchIdentifier;
    
    // Insert an existing FhirPackagedProductDefinitionBatchIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionBatchIdentifier);
    
    // Get the iIndexth FhirPackagedProductDefinitionBatchIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionBatchIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionBatchIdentifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionBatchIdentifiers[index : Integer] : TFhirPackagedProductDefinitionBatchIdentifier read GetItemN write SetItemN; default;
  End;

  // A packaging item, as a container for medically related items, possibly with other packaging items within.
  TFhirPackagedProductDefinitionPackage = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirInteger;
    FmaterialList : TFhirCodeableConceptList;
    FalternateMaterialList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FmanufacturerList : TFhirReferenceList;
    Fproperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
    FcontainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
    FpackageList : TFhirPackagedProductDefinitionPackageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirInteger);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    function GetMaterialList : TFhirCodeableConceptList;
    function GetHasMaterialList : Boolean;
    function GetAlternateMaterialList : TFhirCodeableConceptList;
    function GetHasAlternateMaterialList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetProperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
    function GetHasProperty_List : Boolean;
    function GetContainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
    function GetHasContainedItemList : Boolean;
    function GetPackageList : TFhirPackagedProductDefinitionPackageList;
    function GetHasPackageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackage; overload;
    function Clone : TFhirPackagedProductDefinitionPackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Including possibly Data Carrier Identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The physical type of the container of the items. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The physical type of the container of the items.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of this level of packaging in the package that contains it. If specified, the outermost level is always 1.
    property quantity : String read GetQuantityST write SetQuantityST;
    // The quantity of this level of packaging in the package that contains it. If specified, the outermost level is always 1.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Material type of the package item.
    property materialList : TFhirCodeableConceptList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

    // A possible alternate material for the packaging.
    property alternateMaterialList : TFhirCodeableConceptList read GetAlternateMaterialList;
    property hasAlternateMaterialList : boolean read GetHasAlternateMaterialList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Manufacturer of this package Item.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // General characteristics of this item.
    property property_List : TFhirPackagedProductDefinitionPackagePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The item(s) within the packaging.
    property containedItemList : TFhirPackagedProductDefinitionPackageContainedItemList read GetContainedItemList;
    property hasContainedItemList : boolean read GetHasContainedItemList;

    // Allows containers within containers.
    property packageList : TFhirPackagedProductDefinitionPackageList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

  end;

  TFhirPackagedProductDefinitionPackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackageList;
    function GetCurrent : TFhirPackagedProductDefinitionPackage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackage read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackage;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackageList; overload;
    function Clone : TFhirPackagedProductDefinitionPackageList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackageListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackage to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackage;
    
    // Add an already existing FhirPackagedProductDefinitionPackage to the end of the list.
    procedure AddItem(value : TFhirPackagedProductDefinitionPackage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackage) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackage;
    
    // Insert an existing FhirPackagedProductDefinitionPackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackage);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackages[index : Integer] : TFhirPackagedProductDefinitionPackage read GetItemN write SetItemN; default;
  End;

  // General characteristics of this item.
  TFhirPackagedProductDefinitionPackageProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackageProperty; overload;
    function Clone : TFhirPackagedProductDefinitionPackageProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirPackagedProductDefinitionPackagePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackagePropertyList;
    function GetCurrent : TFhirPackagedProductDefinitionPackageProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackagePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackageProperty read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackagePropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackagePropertyList; overload;
    function Clone : TFhirPackagedProductDefinitionPackagePropertyList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackagePropertyListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackageProperty to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackageProperty;
    
    // Add an already existing FhirPackagedProductDefinitionPackageProperty to the end of the list.
    procedure AddItem(value : TFhirPackagedProductDefinitionPackageProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackageProperty) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackageProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    
    // Insert an existing FhirPackagedProductDefinitionPackageProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackageProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackageProperties[index : Integer] : TFhirPackagedProductDefinitionPackageProperty read GetItemN write SetItemN; default;
  End;

  // The item(s) within the packaging.
  TFhirPackagedProductDefinitionPackageContainedItem = class (TFhirBackboneElement)
  protected
    FitemList : TFhirReferenceList;
    FAmount : TFhirDataType;
    function GetItemList : TFhirReferenceList;
    function GetHasItemList : Boolean;
    procedure SetAmount(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackageContainedItem; overload;
    function Clone : TFhirPackagedProductDefinitionPackageContainedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package.
    property itemList : TFhirReferenceList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Typed access to The number of this type of item within this packaging. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // The number of this type of item within this packaging.
    property amountElement : TFhirDataType read FAmount write SetAmount;

  end;

  TFhirPackagedProductDefinitionPackageContainedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackageContainedItemList;
    function GetCurrent : TFhirPackagedProductDefinitionPackageContainedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackageContainedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackageContainedItem read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackageContainedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackageContainedItemList; overload;
    function Clone : TFhirPackagedProductDefinitionPackageContainedItemList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackageContainedItemListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackageContainedItem to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // Add an already existing FhirPackagedProductDefinitionPackageContainedItem to the end of the list.
    procedure AddItem(value : TFhirPackagedProductDefinitionPackageContainedItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackageContainedItem) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackageContainedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // Insert an existing FhirPackagedProductDefinitionPackageContainedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackageContainedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackageContainedItems[index : Integer] : TFhirPackagedProductDefinitionPackageContainedItem read GetItemN write SetItemN; default;
  End;

  // A medically related item or items, in a container or package.
  TFhirPackagedProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FsubjectList : TFhirReferenceList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FDescription : TFhirMarkdown;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FmarketingStatusList : TFhirMarketingStatusList;
    FcharacteristicList : TFhirCodeableConceptList;
    FCopackagedIndicator : TFhirBoolean;
    FMarketingAuthorization : TFhirReference;
    FmanufacturerList : TFhirReferenceList;
    FbatchIdentifierList : TFhirPackagedProductDefinitionBatchIdentifierList;
    FpackageList : TFhirPackagedProductDefinitionPackageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    procedure SetCopackagedIndicator(value : TFhirBoolean);
    function GetCopackagedIndicatorST : Boolean;
    procedure SetCopackagedIndicatorST(value : Boolean);
    procedure SetMarketingAuthorization(value : TFhirReference);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetBatchIdentifierList : TFhirPackagedProductDefinitionBatchIdentifierList;
    function GetHasBatchIdentifierList : Boolean;
    function GetPackageList : TFhirPackagedProductDefinitionPackageList;
    function GetHasPackageList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinition; overload;
    function Clone : TFhirPackagedProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property name : String read GetNameST write SetNameST;
    // A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A high level category e.g. medicinal product, raw material, shipping/transport container, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The product that this is a pack for.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to Textual description. Note that this is not the name of the package or product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description. Note that this is not the name of the package or product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to The legal status of supply of the packaged item as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the packaged item as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Marketing information.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Typed access to States whether a drug product is supplied with another item such as a diluent or adjuvant.
    property copackagedIndicator : Boolean read GetCopackagedIndicatorST write SetCopackagedIndicatorST;
    // States whether a drug product is supplied with another item such as a diluent or adjuvant.
    property copackagedIndicatorElement : TFhirBoolean read FCopackagedIndicator write SetCopackagedIndicator;

    // Typed access to An authorization for this package type. (defined for API consistency)
    property marketingAuthorization : TFhirReference read FMarketingAuthorization write SetMarketingAuthorization;
    // An authorization for this package type.
    property marketingAuthorizationElement : TFhirReference read FMarketingAuthorization write SetMarketingAuthorization;

    // Manufacturer of this package type.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Batch numbering.
    property batchIdentifierList : TFhirPackagedProductDefinitionBatchIdentifierList read GetBatchIdentifierList;
    property hasBatchIdentifierList : boolean read GetHasBatchIdentifierList;

    // A packaging item, as a container for medically related items, possibly with other packaging items within.
    property packageList : TFhirPackagedProductDefinitionPackageList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

  end;

  TFhirPackagedProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionList;
    function GetCurrent : TFhirPackagedProductDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinition read GetCurrent;
  end;

  TFhirPackagedProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionList; overload;
    function Clone : TFhirPackagedProductDefinitionList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
    
    //  Add a FhirPackagedProductDefinition to the end of the list.
    function Append : TFhirPackagedProductDefinition;
    
    // Add an already existing FhirPackagedProductDefinition to the end of the list.
    procedure AddItem(value : TFhirPackagedProductDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinition) : Integer;
    
    // Insert FhirPackagedProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinition;
    
    // Insert an existing FhirPackagedProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinition);
    
    // Get the iIndexth FhirPackagedProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitions[index : Integer] : TFhirPackagedProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  // Other dates associated with the authorization. It is common for an authorization to have renewal dates, initial time limited phases and so on.
  TFhirRegulatedAuthorizationRelatedDate = class (TFhirBackboneElement)
  protected
    FDate : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    procedure SetDate(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorizationRelatedDate; overload;
    function Clone : TFhirRegulatedAuthorizationRelatedDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Another date associated with the authorization. (defined for API consistency)
    property date : TFhirDataType read FDate write SetDate;
    // Another date associated with the authorization.
    property dateElement : TFhirDataType read FDate write SetDate;

    // Typed access to Type of this date, for example the data exclusitity period for a medicinal product. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of this date, for example the data exclusitity period for a medicinal product.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirRegulatedAuthorizationRelatedDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationRelatedDateList;
    function GetCurrent : TFhirRegulatedAuthorizationRelatedDate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationRelatedDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorizationRelatedDate read GetCurrent;
  end;

  TFhirRegulatedAuthorizationRelatedDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorizationRelatedDate;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorizationRelatedDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationRelatedDateList; overload;
    function Clone : TFhirRegulatedAuthorizationRelatedDateList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationRelatedDateListEnumerator;
    
    //  Add a FhirRegulatedAuthorizationRelatedDate to the end of the list.
    function Append : TFhirRegulatedAuthorizationRelatedDate;
    
    // Add an already existing FhirRegulatedAuthorizationRelatedDate to the end of the list.
    procedure AddItem(value : TFhirRegulatedAuthorizationRelatedDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorizationRelatedDate) : Integer;
    
    // Insert FhirRegulatedAuthorizationRelatedDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorizationRelatedDate;
    
    // Insert an existing FhirRegulatedAuthorizationRelatedDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorizationRelatedDate);
    
    // Get the iIndexth FhirRegulatedAuthorizationRelatedDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorizationRelatedDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorizationRelatedDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizationRelatedDates[index : Integer] : TFhirRegulatedAuthorizationRelatedDate read GetItemN write SetItemN; default;
  End;

  // The case or regulatory procedure for granting or amending a marketing authorization.
  TFhirRegulatedAuthorizationCase = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDataType;
    FapplicationList : TFhirRegulatedAuthorizationCaseList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDataType);
    function GetApplicationList : TFhirRegulatedAuthorizationCaseList;
    function GetHasApplicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorizationCase; overload;
    function Clone : TFhirRegulatedAuthorizationCase; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier by which this case can be referenced. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this case can be referenced.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The defining type of case. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The defining type of case.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status associated with the case. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status associated with the case.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Relevant date for this of case. (defined for API consistency)
    property date : TFhirDataType read FDate write SetDate;
    // Relevant date for this of case.
    property dateElement : TFhirDataType read FDate write SetDate;

    // Applcations submitted to obtain a marketing authorization. Steps within the longer running case or procedure.
    property applicationList : TFhirRegulatedAuthorizationCaseList read GetApplicationList;
    property hasApplicationList : boolean read GetHasApplicationList;

  end;

  TFhirRegulatedAuthorizationCaseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationCaseList;
    function GetCurrent : TFhirRegulatedAuthorizationCase;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationCaseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorizationCase read GetCurrent;
  end;

  TFhirRegulatedAuthorizationCaseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorizationCase;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorizationCase);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationCaseList; overload;
    function Clone : TFhirRegulatedAuthorizationCaseList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
    
    //  Add a FhirRegulatedAuthorizationCase to the end of the list.
    function Append : TFhirRegulatedAuthorizationCase;
    
    // Add an already existing FhirRegulatedAuthorizationCase to the end of the list.
    procedure AddItem(value : TFhirRegulatedAuthorizationCase); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorizationCase) : Integer;
    
    // Insert FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // Insert an existing FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // Get the iIndexth FhirRegulatedAuthorizationCase. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizationCases[index : Integer] : TFhirRegulatedAuthorizationCase read GetItemN write SetItemN; default;
  End;

  // The regulatory authorization of a medicinal product, device or process.
  TFhirRegulatedAuthorization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FregionList : TFhirCodeableConceptList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FValidityPeriod : TFhirPeriod;
    FIndication : TFhirDataType;
    FIntendedUse : TFhirCodeableConcept;
    FbasisList : TFhirCodeableConceptList;
    FrelatedDateList : TFhirRegulatedAuthorizationRelatedDateList;
    FjurisdictionalAuthorizationList : TFhirReferenceList;
    FHolder : TFhirReference;
    FRegulator : TFhirReference;
    FCase_ : TFhirRegulatedAuthorizationCase;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetRegionList : TFhirCodeableConceptList;
    function GetHasRegionList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetValidityPeriod(value : TFhirPeriod);
    procedure SetIndication(value : TFhirDataType);
    procedure SetIntendedUse(value : TFhirCodeableConcept);
    function GetBasisList : TFhirCodeableConceptList;
    function GetHasBasisList : Boolean;
    function GetRelatedDateList : TFhirRegulatedAuthorizationRelatedDateList;
    function GetHasRelatedDateList : Boolean;
    function GetJurisdictionalAuthorizationList : TFhirReferenceList;
    function GetHasJurisdictionalAuthorizationList : Boolean;
    procedure SetHolder(value : TFhirReference);
    procedure SetRegulator(value : TFhirReference);
    procedure SetCase_(value : TFhirRegulatedAuthorizationCase);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorization; overload;
    function Clone : TFhirRegulatedAuthorization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for the authorization, typically assigned by the authorizing body.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of product or service that is being authorized. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The type of product or service that is being authorized.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Overall type of this authorization, for example drug marketing approval, orphan drug designation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Overall type of this authorization, for example drug marketing approval, orphan drug designation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to General textual supporting information.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General textual supporting information.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The region (country, jurisdiction etc.) in which the marketing authorization has been granted.
    property regionList : TFhirCodeableConceptList read GetRegionList;
    property hasRegionList : boolean read GetHasRegionList;

    // Typed access to The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to The beginning of the time period in which the marketing authorization is in the specific status shall be specified A complete date consisting of day, month and year shall be specified using the ISO 8601 date format. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The beginning of the time period in which the marketing authorization is in the specific status shall be specified A complete date consisting of day, month and year shall be specified using the ISO 8601 date format.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to Condition for which the medicinal use applies. (defined for API consistency)
    property indication : TFhirDataType read FIndication write SetIndication;
    // Condition for which the medicinal use applies.
    property indicationElement : TFhirDataType read FIndication write SetIndication;

    // Typed access to The intended use of the product, e.g. prevention, treatment. (defined for API consistency)
    property intendedUse : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;
    // The intended use of the product, e.g. prevention, treatment.
    property intendedUseElement : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;

    // The legal or regulatory framework against which this authorization is granted, or other reasons for it.
    property basisList : TFhirCodeableConceptList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Other dates associated with the authorization. It is common for an authorization to have renewal dates, initial time limited phases and so on.
    property relatedDateList : TFhirRegulatedAuthorizationRelatedDateList read GetRelatedDateList;
    property hasRelatedDateList : boolean read GetHasRelatedDateList;

    // Authorization in areas within a country.
    property jurisdictionalAuthorizationList : TFhirReferenceList read GetJurisdictionalAuthorizationList;
    property hasJurisdictionalAuthorizationList : boolean read GetHasJurisdictionalAuthorizationList;

    // Typed access to The organization that holds the granted authorization. (defined for API consistency)
    property holder : TFhirReference read FHolder write SetHolder;
    // The organization that holds the granted authorization.
    property holderElement : TFhirReference read FHolder write SetHolder;

    // Typed access to Medicines Regulatory Agency. (defined for API consistency)
    property regulator : TFhirReference read FRegulator write SetRegulator;
    // Medicines Regulatory Agency.
    property regulatorElement : TFhirReference read FRegulator write SetRegulator;

    // Typed access to The case or regulatory procedure for granting or amending a marketing authorization. (defined for API consistency)
    property case_ : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;
    // The case or regulatory procedure for granting or amending a marketing authorization.
    property case_Element : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;

  end;

  TFhirRegulatedAuthorizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationList;
    function GetCurrent : TFhirRegulatedAuthorization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorization read GetCurrent;
  end;

  TFhirRegulatedAuthorizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorization;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationList; overload;
    function Clone : TFhirRegulatedAuthorizationList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
    
    //  Add a FhirRegulatedAuthorization to the end of the list.
    function Append : TFhirRegulatedAuthorization;
    
    // Add an already existing FhirRegulatedAuthorization to the end of the list.
    procedure AddItem(value : TFhirRegulatedAuthorization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorization) : Integer;
    
    // Insert FhirRegulatedAuthorization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorization;
    
    // Insert an existing FhirRegulatedAuthorization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorization);
    
    // Get the iIndexth FhirRegulatedAuthorization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizations[index : Integer] : TFhirRegulatedAuthorization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
  TFhirSubstanceInstance = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetQuantity(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceInstance; overload;
    function Clone : TFhirSubstanceInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier associated with the package/container (usually a label affixed directly). (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier associated with the package/container (usually a label affixed directly).
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The amount of the substance. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the substance.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

  end;

  TFhirSubstanceInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceInstanceList;
    function GetCurrent : TFhirSubstanceInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceInstance read GetCurrent;
  end;

  TFhirSubstanceInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceInstance;
    procedure SetItemN(index : Integer; value : TFhirSubstanceInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceInstanceList; overload;
    function Clone : TFhirSubstanceInstanceList; overload;
    function GetEnumerator : TFhirSubstanceInstanceListEnumerator;
    
    //  Add a FhirSubstanceInstance to the end of the list.
    function Append : TFhirSubstanceInstance;
    
    // Add an already existing FhirSubstanceInstance to the end of the list.
    procedure AddItem(value : TFhirSubstanceInstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceInstance) : Integer;
    
    // Insert FhirSubstanceInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceInstance;
    
    // Insert an existing FhirSubstanceInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceInstance);
    
    // Get the iIndexth FhirSubstanceInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceInstances[index : Integer] : TFhirSubstanceInstance read GetItemN write SetItemN; default;
  End;

  // A substance can be composed of other substances.
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirRatio;
    FSubstance : TFhirDataType;
    procedure SetQuantity(value : TFhirRatio);
    procedure SetSubstance(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of the ingredient in the substance - a concentration ratio. (defined for API consistency)
    property quantity : TFhirRatio read FQuantity write SetQuantity;
    // The amount of the ingredient in the substance - a concentration ratio.
    property quantityElement : TFhirRatio read FQuantity write SetQuantity;

    // Typed access to Another substance that is a component of this substance. (defined for API consistency)
    property substance : TFhirDataType read FSubstance write SetSubstance;
    // Another substance that is a component of this substance.
    property substanceElement : TFhirDataType read FSubstance write SetSubstance;

  end;

  TFhirSubstanceIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceIngredientList;
    function GetCurrent : TFhirSubstanceIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceIngredient read GetCurrent;
  end;

  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceIngredientList; overload;
    function Clone : TFhirSubstanceIngredientList; overload;
    function GetEnumerator : TFhirSubstanceIngredientListEnumerator;
    
    //  Add a FhirSubstanceIngredient to the end of the list.
    function Append : TFhirSubstanceIngredient;
    
    // Add an already existing FhirSubstanceIngredient to the end of the list.
    procedure AddItem(value : TFhirSubstanceIngredient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    
    // Insert FhirSubstanceIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    
    // Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    // Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;

  // A homogeneous material with a definite composition.
  TFhirSubstance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FinstanceList : TFhirSubstanceInstanceList;
    FingredientList : TFhirSubstanceIngredientList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRSubstanceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetInstanceList : TFhirSubstanceInstanceList;
    function GetHasInstanceList : Boolean;
    function GetIngredientList : TFhirSubstanceIngredientList;
    function GetHasIngredientList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstance; overload;
    function Clone : TFhirSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for the substance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code to indicate if the substance is actively used.
    property status : TFhirFHIRSubstanceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of substance.  This is used  for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code (or set of codes) that identify this substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that identify this substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A description of the substance - its appearance, handling requirements, and other usage notes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the substance - its appearance, handling requirements, and other usage notes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
    property instanceList : TFhirSubstanceInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // A substance can be composed of other substances.
    property ingredientList : TFhirSubstanceIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

  end;

  TFhirSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceList;
    function GetCurrent : TFhirSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstance read GetCurrent;
  end;

  TFhirSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstance;
    procedure SetItemN(index : Integer; value : TFhirSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceList; overload;
    function Clone : TFhirSubstanceList; overload;
    function GetEnumerator : TFhirSubstanceListEnumerator;
    
    //  Add a FhirSubstance to the end of the list.
    function Append : TFhirSubstance;
    
    // Add an already existing FhirSubstance to the end of the list.
    procedure AddItem(value : TFhirSubstance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstance) : Integer;
    
    // Insert FhirSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstance;
    
    // Insert an existing FhirSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstance);
    
    // Get the iIndexth FhirSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstances[index : Integer] : TFhirSubstance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  // Moiety, for structural modifications.
  TFhirSubstanceDefinitionMoiety = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FAmount : TFhirDataType;
    FAmountType : TFhirCodeableConcept;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionMoiety; overload;
    function Clone : TFhirSubstanceDefinitionMoiety; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role that the moiety is playing. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that the moiety is playing.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Identifier by which this moiety substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this moiety substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Textual name for this moiety substance.
    property name : String read GetNameST write SetNameST;
    // Textual name for this moiety substance.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Quantitative value for this moiety. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Quantitative value for this moiety.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to The measurement type of the quantitative value. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // The measurement type of the quantitative value.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

  end;

  TFhirSubstanceDefinitionMoietyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionMoietyList;
    function GetCurrent : TFhirSubstanceDefinitionMoiety;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionMoietyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionMoiety read GetCurrent;
  end;

  TFhirSubstanceDefinitionMoietyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionMoiety;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionMoiety);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionMoietyList; overload;
    function Clone : TFhirSubstanceDefinitionMoietyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionMoiety to the end of the list.
    function Append : TFhirSubstanceDefinitionMoiety;
    
    // Add an already existing FhirSubstanceDefinitionMoiety to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionMoiety); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionMoiety) : Integer;
    
    // Insert FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // Insert an existing FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // Get the iIndexth FhirSubstanceDefinitionMoiety. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionMoieties[index : Integer] : TFhirSubstanceDefinitionMoiety read GetItemN write SetItemN; default;
  End;

  // General specifications for this substance, including how it is related to other substances.
  TFhirSubstanceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FParameters : TFhirString;
    FDefiningSubstance : TFhirCodeableReference;
    FAmount : TFhirDataType;
    FReferenceRange : TFhirRange;
    FsourceList : TFhirReferenceList;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetParameters(value : TFhirString);
    function GetParametersST : String;
    procedure SetParametersST(value : String);
    procedure SetDefiningSubstance(value : TFhirCodeableReference);
    procedure SetAmount(value : TFhirDataType);
    procedure SetReferenceRange(value : TFhirRange);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionProperty; overload;
    function Clone : TFhirSubstanceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A category for this property, e.g. Physical, Chemical, Enzymatic. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A category for this property, e.g. Physical, Chemical, Enzymatic.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Property type e.g. viscosity, pH, isoelectric point. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Property type e.g. viscosity, pH, isoelectric point.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
    property parameters : String read GetParametersST write SetParametersST;
    // Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
    property parametersElement : TFhirString read FParameters write SetParameters;

    // Typed access to A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol). (defined for API consistency)
    property definingSubstance : TFhirCodeableReference read FDefiningSubstance write SetDefiningSubstance;
    // A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
    property definingSubstanceElement : TFhirCodeableReference read FDefiningSubstance write SetDefiningSubstance;

    // Typed access to Quantitative value for this property. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Quantitative value for this property.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to Range of typical values. (defined for API consistency)
    property referenceRange : TFhirRange read FReferenceRange write SetReferenceRange;
    // Range of typical values.
    property referenceRangeElement : TFhirRange read FReferenceRange write SetReferenceRange;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionPropertyList;
    function GetCurrent : TFhirSubstanceDefinitionProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionProperty read GetCurrent;
  end;

  TFhirSubstanceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionPropertyList; overload;
    function Clone : TFhirSubstanceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionProperty to the end of the list.
    function Append : TFhirSubstanceDefinitionProperty;
    
    // Add an already existing FhirSubstanceDefinitionProperty to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionProperty) : Integer;
    
    // Insert FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // Insert an existing FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // Get the iIndexth FhirSubstanceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionProperties[index : Integer] : TFhirSubstanceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // Structural information.
  TFhirSubstanceDefinitionStructure = class (TFhirBackboneElement)
  protected
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FMolecularFormulaByMoiety : TFhirString;
    FisotopeList : TFhirSubstanceDefinitionStructureIsotopeList;
    FMolecularWeight : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    FtechniqueList : TFhirCodeableConceptList;
    FsourceDocumentList : TFhirReferenceList;
    FrepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetMolecularFormulaByMoiety(value : TFhirString);
    function GetMolecularFormulaByMoietyST : String;
    procedure SetMolecularFormulaByMoietyST(value : String);
    function GetIsotopeList : TFhirSubstanceDefinitionStructureIsotopeList;
    function GetHasIsotopeList : Boolean;
    procedure SetMolecularWeight(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
    function GetTechniqueList : TFhirCodeableConceptList;
    function GetHasTechniqueList : Boolean;
    function GetSourceDocumentList : TFhirReferenceList;
    function GetHasSourceDocumentList : Boolean;
    function GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetHasRepresentationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructure; overload;
    function Clone : TFhirSubstanceDefinitionStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoiety : String read GetMolecularFormulaByMoietyST write SetMolecularFormulaByMoietyST;
    // Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoietyElement : TFhirString read FMolecularFormulaByMoiety write SetMolecularFormulaByMoiety;

    // Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
    property isotopeList : TFhirSubstanceDefinitionStructureIsotopeList read GetIsotopeList;
    property hasIsotopeList : boolean read GetHasIsotopeList;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;

    // The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.
    property techniqueList : TFhirCodeableConceptList read GetTechniqueList;
    property hasTechniqueList : boolean read GetHasTechniqueList;

    // Supporting literature about the source of information.
    property sourceDocumentList : TFhirReferenceList read GetSourceDocumentList;
    property hasSourceDocumentList : boolean read GetHasSourceDocumentList;

    // A depiction of the structure or characterization of the substance.
    property representationList : TFhirSubstanceDefinitionStructureRepresentationList read GetRepresentationList;
    property hasRepresentationList : boolean read GetHasRepresentationList;

  end;

  TFhirSubstanceDefinitionStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureList;
    function GetCurrent : TFhirSubstanceDefinitionStructure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructure read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructure;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureList; overload;
    function Clone : TFhirSubstanceDefinitionStructureList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructure to the end of the list.
    function Append : TFhirSubstanceDefinitionStructure;
    
    // Add an already existing FhirSubstanceDefinitionStructure to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionStructure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructure) : Integer;
    
    // Insert FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // Insert an existing FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // Get the iIndexth FhirSubstanceDefinitionStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructures[index : Integer] : TFhirSubstanceDefinitionStructure read GetItemN write SetItemN; default;
  End;

  // Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
  TFhirSubstanceDefinitionStructureIsotope = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirCodeableConcept;
    FSubstitution : TFhirCodeableConcept;
    FHalfLife : TFhirQuantity;
    FMolecularWeight : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirCodeableConcept);
    procedure SetSubstitution(value : TFhirCodeableConcept);
    procedure SetHalfLife(value : TFhirQuantity);
    procedure SetMolecularWeight(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructureIsotope; overload;
    function Clone : TFhirSubstanceDefinitionStructureIsotope; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Substance identifier for each non-natural or radioisotope. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Substance identifier for each non-natural or radioisotope.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Substance name for each non-natural or radioisotope. (defined for API consistency)
    property name : TFhirCodeableConcept read FName write SetName;
    // Substance name for each non-natural or radioisotope.
    property nameElement : TFhirCodeableConcept read FName write SetName;

    // Typed access to The type of isotopic substitution present in a single substance. (defined for API consistency)
    property substitution : TFhirCodeableConcept read FSubstitution write SetSubstitution;
    // The type of isotopic substitution present in a single substance.
    property substitutionElement : TFhirCodeableConcept read FSubstitution write SetSubstitution;

    // Typed access to Half life - for a non-natural nuclide. (defined for API consistency)
    property halfLife : TFhirQuantity read FHalfLife write SetHalfLife;
    // Half life - for a non-natural nuclide.
    property halfLifeElement : TFhirQuantity read FHalfLife write SetHalfLife;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;

  end;

  TFhirSubstanceDefinitionStructureIsotopeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureIsotopeList;
    function GetCurrent : TFhirSubstanceDefinitionStructureIsotope;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureIsotopeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructureIsotope read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureIsotopeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructureIsotope;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructureIsotope);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureIsotopeList; overload;
    function Clone : TFhirSubstanceDefinitionStructureIsotopeList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureIsotopeListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructureIsotope to the end of the list.
    function Append : TFhirSubstanceDefinitionStructureIsotope;
    
    // Add an already existing FhirSubstanceDefinitionStructureIsotope to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionStructureIsotope); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructureIsotope) : Integer;
    
    // Insert FhirSubstanceDefinitionStructureIsotope before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructureIsotope;
    
    // Insert an existing FhirSubstanceDefinitionStructureIsotope before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructureIsotope);
    
    // Get the iIndexth FhirSubstanceDefinitionStructureIsotope. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructureIsotope);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructureIsotope;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructureIsotopes[index : Integer] : TFhirSubstanceDefinitionStructureIsotope read GetItemN write SetItemN; default;
  End;

  // The molecular weight or weight range (for proteins, polymers or nucleic acids).
  TFhirSubstanceDefinitionStructureIsotopeMolecularWeight = class (TFhirBackboneElement)
  protected
    FMethod : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight; overload;
    function Clone : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The method by which the molecular weight was determined. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The method by which the molecular weight was determined.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Type of molecular weight such as exact, average (also known as. number average), weight average. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of molecular weight such as exact, average (also known as. number average), weight average.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
    function GetCurrent : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList; overload;
    function Clone : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructureIsotopeMolecularWeight to the end of the list.
    function Append : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    
    // Add an already existing FhirSubstanceDefinitionStructureIsotopeMolecularWeight to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight) : Integer;
    
    // Insert FhirSubstanceDefinitionStructureIsotopeMolecularWeight before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    
    // Insert an existing FhirSubstanceDefinitionStructureIsotopeMolecularWeight before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
    
    // Get the iIndexth FhirSubstanceDefinitionStructureIsotopeMolecularWeight. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructureIsotopeMolecularWeights[index : Integer] : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight read GetItemN write SetItemN; default;
  End;

  // A depiction of the structure or characterization of the substance.
  TFhirSubstanceDefinitionStructureRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FFormat : TFhirCodeableConcept;
    FDocument : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRepresentation(value : TFhirString);
    function GetRepresentationST : String;
    procedure SetRepresentationST(value : String);
    procedure SetFormat(value : TFhirCodeableConcept);
    procedure SetDocument(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of structural representation (e.g. full, partial) or the technique used to derive the analytical characterization of the substance (e.g. x-ray, HPLC, NMR, peptide mapping, ligand binding assay, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of structural representation (e.g. full, partial) or the technique used to derive the analytical characterization of the substance (e.g. x-ray, HPLC, NMR, peptide mapping, ligand binding assay, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation or characterization as a text string in a standard format.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation or characterization as a text string in a standard format.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document. (defined for API consistency)
    property format : TFhirCodeableConcept read FFormat write SetFormat;
    // The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
    property formatElement : TFhirCodeableConcept read FFormat write SetFormat;

    // Typed access to An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file. (defined for API consistency)
    property document : TFhirReference read FDocument write SetDocument;
    // An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
    property documentElement : TFhirReference read FDocument write SetDocument;

  end;

  TFhirSubstanceDefinitionStructureRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructureRepresentation read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureRepresentationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    function Append : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Add an already existing FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionStructureRepresentation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructureRepresentation) : Integer;
    
    // Insert FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Insert an existing FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // Get the iIndexth FhirSubstanceDefinitionStructureRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructureRepresentations[index : Integer] : TFhirSubstanceDefinitionStructureRepresentation read GetItemN write SetItemN; default;
  End;

  // Codes associated with the substance.
  TFhirSubstanceDefinitionCode = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FsourceList : TFhirReferenceList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionCode; overload;
    function Clone : TFhirSubstanceDefinitionCode; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Status of the code assignment, for example 'provisional', 'approved'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of the code assignment, for example 'provisional', 'approved'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the code status is changed as part of the terminology maintenance.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the code status is changed as part of the terminology maintenance.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Any comment can be provided in this field, if necessary.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionCodeList;
    function GetCurrent : TFhirSubstanceDefinitionCode;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionCode read GetCurrent;
  end;

  TFhirSubstanceDefinitionCodeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionCode;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionCodeList; overload;
    function Clone : TFhirSubstanceDefinitionCodeList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
    
    //  Add a FhirSubstanceDefinitionCode to the end of the list.
    function Append : TFhirSubstanceDefinitionCode;
    
    // Add an already existing FhirSubstanceDefinitionCode to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionCode); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionCode) : Integer;
    
    // Insert FhirSubstanceDefinitionCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // Insert an existing FhirSubstanceDefinitionCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // Get the iIndexth FhirSubstanceDefinitionCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionCodes[index : Integer] : TFhirSubstanceDefinitionCode read GetItemN write SetItemN; default;
  End;

  // Names applicable to this substance.
  TFhirSubstanceDefinitionName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    FlanguageList : TFhirCodeableConceptList;
    FdomainList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FsynonymList : TFhirSubstanceDefinitionNameList;
    FtranslationList : TFhirSubstanceDefinitionNameList;
    FofficialList : TFhirSubstanceDefinitionNameOfficialList;
    FsourceList : TFhirReferenceList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
    function GetLanguageList : TFhirCodeableConceptList;
    function GetHasLanguageList : Boolean;
    function GetDomainList : TFhirCodeableConceptList;
    function GetHasDomainList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    function GetSynonymList : TFhirSubstanceDefinitionNameList;
    function GetHasSynonymList : Boolean;
    function GetTranslationList : TFhirSubstanceDefinitionNameList;
    function GetHasTranslationList : Boolean;
    function GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
    function GetHasOfficialList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionName; overload;
    function Clone : TFhirSubstanceDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual name.
    property name : String read GetNameST write SetNameST;
    // The actual name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name type, for example 'systematic',  'scientific, 'brand'. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Name type, for example 'systematic',  'scientific, 'brand'.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status of the name, for example 'current', 'proposed'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the name, for example 'current', 'proposed'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to If this is the preferred name for this substance.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // If this is the preferred name for this substance.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Human language that the name is written in.
    property languageList : TFhirCodeableConceptList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
    property domainList : TFhirCodeableConceptList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // The jurisdiction where this name applies.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // A synonym of this particular name, by which the substance is also known.
    property synonymList : TFhirSubstanceDefinitionNameList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // A translation for this name into another human language.
    property translationList : TFhirSubstanceDefinitionNameList read GetTranslationList;
    property hasTranslationList : boolean read GetHasTranslationList;

    // Details of the official nature of this name.
    property officialList : TFhirSubstanceDefinitionNameOfficialList read GetOfficialList;
    property hasOfficialList : boolean read GetHasOfficialList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameList;
    function GetCurrent : TFhirSubstanceDefinitionName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionName read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameList; overload;
    function Clone : TFhirSubstanceDefinitionNameList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
    
    //  Add a FhirSubstanceDefinitionName to the end of the list.
    function Append : TFhirSubstanceDefinitionName;
    
    // Add an already existing FhirSubstanceDefinitionName to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionName); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionName) : Integer;
    
    // Insert FhirSubstanceDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionName;
    
    // Insert an existing FhirSubstanceDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // Get the iIndexth FhirSubstanceDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNames[index : Integer] : TFhirSubstanceDefinitionName read GetItemN write SetItemN; default;
  End;

  // Details of the official nature of this name.
  TFhirSubstanceDefinitionNameOfficial = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    procedure SetAuthority(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionNameOfficial; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Which authority uses this official name. (defined for API consistency)
    property authority : TFhirCodeableConcept read FAuthority write SetAuthority;
    // Which authority uses this official name.
    property authorityElement : TFhirCodeableConcept read FAuthority write SetAuthority;

    // Typed access to The status of the official name, for example 'provisional', 'approved'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the official name, for example 'provisional', 'approved'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Date of official name change.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of official name change.
    property dateElement : TFhirDateTime read FDate write SetDate;

  end;

  TFhirSubstanceDefinitionNameOfficialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameOfficialList;
    function GetCurrent : TFhirSubstanceDefinitionNameOfficial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameOfficialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionNameOfficial read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameOfficialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameOfficialList; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficialList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
    
    //  Add a FhirSubstanceDefinitionNameOfficial to the end of the list.
    function Append : TFhirSubstanceDefinitionNameOfficial;
    
    // Add an already existing FhirSubstanceDefinitionNameOfficial to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionNameOfficial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionNameOfficial) : Integer;
    
    // Insert FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // Insert an existing FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // Get the iIndexth FhirSubstanceDefinitionNameOfficial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNameOfficials[index : Integer] : TFhirSubstanceDefinitionNameOfficial read GetItemN write SetItemN; default;
  End;

  // A link between this substance and another, with details of the relationship.
  TFhirSubstanceDefinitionRelationship = class (TFhirBackboneElement)
  protected
    FSubstanceDefinition : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirDataType;
    FAmountRatioHighLimit : TFhirRatio;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetSubstanceDefinition(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetIsDefining(value : TFhirBoolean);
    function GetIsDefiningST : Boolean;
    procedure SetIsDefiningST(value : Boolean);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountRatioHighLimit(value : TFhirRatio);
    procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionRelationship; overload;
    function Clone : TFhirSubstanceDefinitionRelationship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A pointer to another substance, as a resource or just a representational code. (defined for API consistency)
    property substanceDefinition : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;
    // A pointer to another substance, as a resource or just a representational code.
    property substanceDefinitionElement : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;

    // Typed access to For example "salt to parent", "active moiety", "starting material", "polymorph". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // For example "salt to parent", "active moiety", "starting material", "polymorph".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to For use when the numeric has an uncertain range. (defined for API consistency)
    property amountRatioHighLimit : TFhirRatio read FAmountRatioHighLimit write SetAmountRatioHighLimit;
    // For use when the numeric has an uncertain range.
    property amountRatioHighLimitElement : TFhirRatio read FAmountRatioHighLimit write SetAmountRatioHighLimit;

    // Typed access to An operator for the amount, for example "average", "approximately", "less than". (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // An operator for the amount, for example "average", "approximately", "less than".
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionRelationshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionRelationshipList;
    function GetCurrent : TFhirSubstanceDefinitionRelationship;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionRelationshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionRelationship read GetCurrent;
  end;

  TFhirSubstanceDefinitionRelationshipList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionRelationship;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionRelationship);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionRelationshipList; overload;
    function Clone : TFhirSubstanceDefinitionRelationshipList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
    
    //  Add a FhirSubstanceDefinitionRelationship to the end of the list.
    function Append : TFhirSubstanceDefinitionRelationship;
    
    // Add an already existing FhirSubstanceDefinitionRelationship to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinitionRelationship); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionRelationship) : Integer;
    
    // Insert FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // Insert an existing FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // Get the iIndexth FhirSubstanceDefinitionRelationship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionRelationships[index : Integer] : TFhirSubstanceDefinitionRelationship read GetItemN write SetItemN; default;
  End;

  // The detailed description of a substance, typically at a level beyond what is used for prescribing.
  TFhirSubstanceDefinition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FDomain : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FsourceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FmanufacturerList : TFhirReferenceList;
    FsupplierList : TFhirReferenceList;
    FmoietyList : TFhirSubstanceDefinitionMoietyList;
    Fproperty_List : TFhirSubstanceDefinitionPropertyList;
    FReferenceInformation : TFhirReference;
    FStructure : TFhirSubstanceDefinitionStructure;
    FcodeList : TFhirSubstanceDefinitionCodeList;
    FnameList : TFhirSubstanceDefinitionNameList;
    FmolecularWeightList : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
    FrelationshipList : TFhirSubstanceDefinitionRelationshipList;
    FNucleicAcid : TFhirReference;
    FPolymer : TFhirReference;
    FProtein : TFhirReference;
    FSourceMaterial : TFhirReference;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    procedure SetDomain(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetSupplierList : TFhirReferenceList;
    function GetHasSupplierList : Boolean;
    function GetMoietyList : TFhirSubstanceDefinitionMoietyList;
    function GetHasMoietyList : Boolean;
    function GetProperty_List : TFhirSubstanceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetReferenceInformation(value : TFhirReference);
    procedure SetStructure(value : TFhirSubstanceDefinitionStructure);
    function GetCodeList : TFhirSubstanceDefinitionCodeList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirSubstanceDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetMolecularWeightList : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
    function GetHasMolecularWeightList : Boolean;
    function GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
    function GetHasRelationshipList : Boolean;
    procedure SetNucleicAcid(value : TFhirReference);
    procedure SetPolymer(value : TFhirReference);
    procedure SetProtein(value : TFhirReference);
    procedure SetSourceMaterial(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinition; overload;
    function Clone : TFhirSubstanceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier by which this substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A business level identifier of the substance.
    property version : String read GetVersionST write SetVersionST;
    // A business level identifier of the substance.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Status of substance within the catalogue e.g. approved. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of substance within the catalogue e.g. approved.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to High level categorization, e.g. polymer or nucleic acid, or food, chemical, biological. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // High level categorization, e.g. polymer or nucleic acid, or food, chemical, biological.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // A lower level classification than category, such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Typed access to If the substance applies to only human or veterinary use. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If the substance applies to only human or veterinary use.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to Textual description of the substance.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the substance.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

    // Textual comment about this record of a substance.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A company that makes this substance.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // A company that supplies this substance.
    property supplierList : TFhirReferenceList read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // Moiety, for structural modifications.
    property moietyList : TFhirSubstanceDefinitionMoietyList read GetMoietyList;
    property hasMoietyList : boolean read GetHasMoietyList;

    // General specifications for this substance, including how it is related to other substances.
    property property_List : TFhirSubstanceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to General information detailing this substance. (defined for API consistency)
    property referenceInformation : TFhirReference read FReferenceInformation write SetReferenceInformation;
    // General information detailing this substance.
    property referenceInformationElement : TFhirReference read FReferenceInformation write SetReferenceInformation;

    // Typed access to Structural information. (defined for API consistency)
    property structure : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;
    // Structural information.
    property structureElement : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;

    // Codes associated with the substance.
    property codeList : TFhirSubstanceDefinitionCodeList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Names applicable to this substance.
    property nameList : TFhirSubstanceDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightList : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList read GetMolecularWeightList;
    property hasMolecularWeightList : boolean read GetHasMolecularWeightList;

    // A link between this substance and another, with details of the relationship.
    property relationshipList : TFhirSubstanceDefinitionRelationshipList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to Data items specific to nucleic acids. (defined for API consistency)
    property nucleicAcid : TFhirReference read FNucleicAcid write SetNucleicAcid;
    // Data items specific to nucleic acids.
    property nucleicAcidElement : TFhirReference read FNucleicAcid write SetNucleicAcid;

    // Typed access to Data items specific to polymers. (defined for API consistency)
    property polymer : TFhirReference read FPolymer write SetPolymer;
    // Data items specific to polymers.
    property polymerElement : TFhirReference read FPolymer write SetPolymer;

    // Typed access to Data items specific to proteins. (defined for API consistency)
    property protein : TFhirReference read FProtein write SetProtein;
    // Data items specific to proteins.
    property proteinElement : TFhirReference read FProtein write SetProtein;

    // Typed access to Material or taxonomic/anatomical source for the substance. (defined for API consistency)
    property sourceMaterial : TFhirReference read FSourceMaterial write SetSourceMaterial;
    // Material or taxonomic/anatomical source for the substance.
    property sourceMaterialElement : TFhirReference read FSourceMaterial write SetSourceMaterial;

  end;

  TFhirSubstanceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionList;
    function GetCurrent : TFhirSubstanceDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinition read GetCurrent;
  end;

  TFhirSubstanceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinition;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionList; overload;
    function Clone : TFhirSubstanceDefinitionList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
    
    //  Add a FhirSubstanceDefinition to the end of the list.
    function Append : TFhirSubstanceDefinition;
    
    // Add an already existing FhirSubstanceDefinition to the end of the list.
    procedure AddItem(value : TFhirSubstanceDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinition) : Integer;
    
    // Insert FhirSubstanceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinition;
    
    // Insert an existing FhirSubstanceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinition);
    
    // Get the iIndexth FhirSubstanceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitions[index : Integer] : TFhirSubstanceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceNucleicAcidSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FFivePrime : TFhirCodeableConcept;
    FThreePrime : TFhirCodeableConcept;
    FlinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    FsugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    procedure SetSubunit(value : TFhirInteger);
    function GetSubunitST : String;
    procedure SetSubunitST(value : String);
    procedure SetSequence(value : TFhirString);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetSequenceAttachment(value : TFhirAttachment);
    procedure SetFivePrime(value : TFhirCodeableConcept);
    procedure SetThreePrime(value : TFhirCodeableConcept);
    function GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetHasLinkageList : Boolean;
    function GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetHasSugarList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunit; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to The length of the sequence shall be captured.
    property length : String read GetLengthST write SetLengthST;
    // The length of the sequence shall be captured.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to (TBC). (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // (TBC).
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to The nucleotide present at the 5’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property fivePrime : TFhirCodeableConcept read FFivePrime write SetFivePrime;
    // The nucleotide present at the 5’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
    property fivePrimeElement : TFhirCodeableConcept read FFivePrime write SetFivePrime;

    // Typed access to The nucleotide present at the 3’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property threePrime : TFhirCodeableConcept read FThreePrime write SetThreePrime;
    // The nucleotide present at the 3’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
    property threePrimeElement : TFhirCodeableConcept read FThreePrime write SetThreePrime;

    // The linkages between sugar residues will also be captured.
    property linkageList : TFhirSubstanceNucleicAcidSubunitLinkageList read GetLinkageList;
    property hasLinkageList : boolean read GetHasLinkageList;

    // 5.3.6.8.1 Sugar ID (Mandatory).
    property sugarList : TFhirSubstanceNucleicAcidSubunitSugarList read GetSugarList;
    property hasSugarList : boolean read GetHasSugarList;

  end;

  TFhirSubstanceNucleicAcidSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunit read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunit to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunit;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunit to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunit) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunits[index : Integer] : TFhirSubstanceNucleicAcidSubunit read GetItemN write SetItemN; default;
  End;

  // The linkages between sugar residues will also be captured.
  TFhirSubstanceNucleicAcidSubunitLinkage = class (TFhirBackboneElement)
  protected
    FConnectivity : TFhirString;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    procedure SetConnectivity(value : TFhirString);
    function GetConnectivityST : String;
    procedure SetConnectivityST(value : String);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetResidueSite(value : TFhirString);
    function GetResidueSiteST : String;
    procedure SetResidueSiteST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or 5’-5’ this should be specified.
    property connectivity : String read GetConnectivityST write SetConnectivityST;
    // The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or 5’-5’ this should be specified.
    property connectivityElement : TFhirString read FConnectivity write SetConnectivity;

    // Typed access to Each linkage will be registered as a fragment and have an ID. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Each linkage will be registered as a fragment and have an ID.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property name : String read GetNameST write SetNameST;
    // Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Residues shall be captured as described in 5.3.6.8.3.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // Residues shall be captured as described in 5.3.6.8.3.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitLinkage read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitLinkageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitLinkageList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkageList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunitLinkage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitLinkage) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunitLinkages[index : Integer] : TFhirSubstanceNucleicAcidSubunitLinkage read GetItemN write SetItemN; default;
  End;

  // 5.3.6.8.1 Sugar ID (Mandatory).
  TFhirSubstanceNucleicAcidSubunitSugar = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetResidueSite(value : TFhirString);
    function GetResidueSiteST : String;
    procedure SetResidueSiteST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The Substance ID of the sugar or sugar-like component that make up the nucleotide. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The Substance ID of the sugar or sugar-like component that make up the nucleotide.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The name of the sugar or sugar-like component that make up the nucleotide.
    property name : String read GetNameST write SetNameST;
    // The name of the sugar or sugar-like component that make up the nucleotide.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5‘-3‘direction consistent with the base sequences listed above.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5‘-3‘direction consistent with the base sequences listed above.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitSugarListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitSugar read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitSugarList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidSubunitSugarList; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugarList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // Add an already existing FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunitSugar); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitSugar) : Integer;
    
    // Insert FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // Insert an existing FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitSugar. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcidSubunitSugars[index : Integer] : TFhirSubstanceNucleicAcidSubunitSugar read GetItemN write SetItemN; default;
  End;

  // Nucleic acids are defined by three distinct elements: the base, sugar and linkage. Individual substance/moiety IDs will be created for each of these elements. The nucleotide sequence will be always entered in the 5’-3’ direction.
  TFhirSubstanceNucleicAcid = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FAreaOfHybridisation : TFhirString;
    FOligoNucleotideType : TFhirCodeableConcept;
    FsubunitList : TFhirSubstanceNucleicAcidSubunitList;
    procedure SetSequenceType(value : TFhirCodeableConcept);
    procedure SetNumberOfSubunits(value : TFhirInteger);
    function GetNumberOfSubunitsST : String;
    procedure SetNumberOfSubunitsST(value : String);
    procedure SetAreaOfHybridisation(value : TFhirString);
    function GetAreaOfHybridisationST : String;
    procedure SetAreaOfHybridisationST(value : String);
    procedure SetOligoNucleotideType(value : TFhirCodeableConcept);
    function GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcid; overload;
    function Clone : TFhirSubstanceNucleicAcid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the sequence shall be specified based on a controlled vocabulary. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The type of the sequence shall be specified based on a controlled vocabulary.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // Typed access to The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore “” shall be used as separator as follows: “Subunitnumber Residue”.
    property areaOfHybridisation : String read GetAreaOfHybridisationST write SetAreaOfHybridisationST;
    // The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore “” shall be used as separator as follows: “Subunitnumber Residue”.
    property areaOfHybridisationElement : TFhirString read FAreaOfHybridisation write SetAreaOfHybridisation;

    // Typed access to (TBC). (defined for API consistency)
    property oligoNucleotideType : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;
    // (TBC).
    property oligoNucleotideTypeElement : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;

    // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceNucleicAcidSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceNucleicAcidListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidList;
    function GetCurrent : TFhirSubstanceNucleicAcid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcid read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcid);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceNucleicAcidList; overload;
    function Clone : TFhirSubstanceNucleicAcidList; overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
    
    //  Add a FhirSubstanceNucleicAcid to the end of the list.
    function Append : TFhirSubstanceNucleicAcid;
    
    // Add an already existing FhirSubstanceNucleicAcid to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcid); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcid) : Integer;
    
    // Insert FhirSubstanceNucleicAcid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcid;
    
    // Insert an existing FhirSubstanceNucleicAcid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // Get the iIndexth FhirSubstanceNucleicAcid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcid;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceNucleicAcids[index : Integer] : TFhirSubstanceNucleicAcid read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  // Todo.
  TFhirSubstancePolymerMonomerSet = class (TFhirBackboneElement)
  protected
    FRatioType : TFhirCodeableConcept;
    FstartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    procedure SetRatioType(value : TFhirCodeableConcept);
    function GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetHasStartingMaterialList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSet; overload;
    function Clone : TFhirSubstancePolymerMonomerSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio. (defined for API consistency)
    property ratioType : TFhirCodeableConcept read FRatioType write SetRatioType;
    // Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
    property ratioTypeElement : TFhirCodeableConcept read FRatioType write SetRatioType;

    // The starting materials - monomer(s) used in the synthesis of the polymer.
    property startingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList read GetStartingMaterialList;
    property hasStartingMaterialList : boolean read GetHasStartingMaterialList;

  end;

  TFhirSubstancePolymerMonomerSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetList;
    function GetCurrent : TFhirSubstancePolymerMonomerSet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSet read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSet;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerMonomerSetList; overload;
    function Clone : TFhirSubstancePolymerMonomerSetList; overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
    
    //  Add a FhirSubstancePolymerMonomerSet to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSet;
    
    // Add an already existing FhirSubstancePolymerMonomerSet to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerMonomerSet); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSet) : Integer;
    
    // Insert FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSet;
    
    // Insert an existing FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSet;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerMonomerSets[index : Integer] : TFhirSubstancePolymerMonomerSet read GetItemN write SetItemN; default;
  End;

  // The starting materials - monomer(s) used in the synthesis of the polymer.
  TFhirSubstancePolymerMonomerSetStartingMaterial = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirQuantity;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetIsDefining(value : TFhirBoolean);
    function GetIsDefiningST : Boolean;
    procedure SetIsDefiningST(value : Boolean);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of substance for this starting material. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of substance for this starting material.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Substance high level category, e.g. chemical substance. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Substance high level category, e.g. chemical substance.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A percentage. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // A percentage.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSetStartingMaterial read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerMonomerSetStartingMaterialList; overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterialList; overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
    
    //  Add a FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // Add an already existing FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerMonomerSetStartingMaterial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSetStartingMaterial) : Integer;
    
    // Insert FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // Insert an existing FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSetStartingMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerMonomerSetStartingMaterials[index : Integer] : TFhirSubstancePolymerMonomerSetStartingMaterial read GetItemN write SetItemN; default;
  End;

  // Specifies and quantifies the repeated units and their configuration.
  TFhirSubstancePolymerRepeat = class (TFhirBackboneElement)
  protected
    FAverageMolecularFormula : TFhirString;
    FRepeatUnitAmountType : TFhirCodeableConcept;
    FrepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    procedure SetAverageMolecularFormula(value : TFhirString);
    function GetAverageMolecularFormulaST : String;
    procedure SetAverageMolecularFormulaST(value : String);
    procedure SetRepeatUnitAmountType(value : TFhirCodeableConcept);
    function GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetHasRepeatUnitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeat; overload;
    function Clone : TFhirSubstancePolymerRepeat; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A representation of an (average) molecular formula from a polymer.
    property averageMolecularFormula : String read GetAverageMolecularFormulaST write SetAverageMolecularFormulaST;
    // A representation of an (average) molecular formula from a polymer.
    property averageMolecularFormulaElement : TFhirString read FAverageMolecularFormula write SetAverageMolecularFormula;

    // Typed access to How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average). (defined for API consistency)
    property repeatUnitAmountType : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;
    // How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
    property repeatUnitAmountTypeElement : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;

    // An SRU - Structural Repeat Unit.
    property repeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList read GetRepeatUnitList;
    property hasRepeatUnitList : boolean read GetHasRepeatUnitList;

  end;

  TFhirSubstancePolymerRepeatListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatList;
    function GetCurrent : TFhirSubstancePolymerRepeat;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeat read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeat;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeat);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatList; overload;
    function Clone : TFhirSubstancePolymerRepeatList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeat to the end of the list.
    function Append : TFhirSubstancePolymerRepeat;
    
    // Add an already existing FhirSubstancePolymerRepeat to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeat); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeat) : Integer;
    
    // Insert FhirSubstancePolymerRepeat before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeat;
    
    // Insert an existing FhirSubstancePolymerRepeat before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // Get the iIndexth FhirSubstancePolymerRepeat. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeat;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeats[index : Integer] : TFhirSubstancePolymerRepeat read GetItemN write SetItemN; default;
  End;

  // An SRU - Structural Repeat Unit.
  TFhirSubstancePolymerRepeatRepeatUnit = class (TFhirBackboneElement)
  protected
    FUnit_ : TFhirString;
    FOrientation : TFhirCodeableConcept;
    FAmount : TFhirInteger;
    FdegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    FstructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    procedure SetUnit_(value : TFhirString);
    function GetUnit_ST : String;
    procedure SetUnit_ST(value : String);
    procedure SetOrientation(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirInteger);
    function GetAmountST : String;
    procedure SetAmountST(value : String);
    function GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetHasDegreeOfPolymerisationList : Boolean;
    function GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetHasStructuralRepresentationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural repeat units are essential elements for defining polymers.
    property unit_ : String read GetUnit_ST write SetUnit_ST;
    // Structural repeat units are essential elements for defining polymers.
    property unit_Element : TFhirString read FUnit_ write SetUnit_;

    // Typed access to The orientation of the polymerisation, e.g. head-tail, head-head, random. (defined for API consistency)
    property orientation : TFhirCodeableConcept read FOrientation write SetOrientation;
    // The orientation of the polymerisation, e.g. head-tail, head-head, random.
    property orientationElement : TFhirCodeableConcept read FOrientation write SetOrientation;

    // Typed access to Number of repeats of this unit.
    property amount : String read GetAmountST write SetAmountST;
    // Number of repeats of this unit.
    property amountElement : TFhirInteger read FAmount write SetAmount;

    // Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
    property degreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList read GetDegreeOfPolymerisationList;
    property hasDegreeOfPolymerisationList : boolean read GetHasDegreeOfPolymerisationList;

    // A graphical structure for this SRU.
    property structuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList read GetStructuralRepresentationList;
    property hasStructuralRepresentationList : boolean read GetHasStructuralRepresentationList;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnit read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnit) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnits[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnit read GetItemN write SetItemN; default;
  End;

  // Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAverage : TFhirInteger;
    FLow : TFhirInteger;
    FHigh : TFhirInteger;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAverage(value : TFhirInteger);
    function GetAverageST : String;
    procedure SetAverageST(value : String);
    procedure SetLow(value : TFhirInteger);
    function GetLowST : String;
    procedure SetLowST(value : String);
    procedure SetHigh(value : TFhirInteger);
    function GetHighST : String;
    procedure SetHighST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to An average amount of polymerisation.
    property average : String read GetAverageST write SetAverageST;
    // An average amount of polymerisation.
    property averageElement : TFhirInteger read FAverage write SetAverage;

    // Typed access to A low expected limit of the amount.
    property low : String read GetLowST write SetLowST;
    // A low expected limit of the amount.
    property lowElement : TFhirInteger read FLow write SetLow;

    // Typed access to A high expected limit of the amount.
    property high : String read GetHighST write SetHighST;
    // A high expected limit of the amount.
    property highElement : TFhirInteger read FHigh write SetHigh;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetItemN write SetItemN; default;
  End;

  // A graphical structure for this SRU.
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FFormat : TFhirCodeableConcept;
    FAttachment : TFhirAttachment;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRepresentation(value : TFhirString);
    function GetRepresentationST : String;
    procedure SetRepresentationST(value : String);
    procedure SetFormat(value : TFhirCodeableConcept);
    procedure SetAttachment(value : TFhirAttachment);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of structure (e.g. Full, Partial, Representative). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of structure (e.g. Full, Partial, Representative).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. (defined for API consistency)
    property format : TFhirCodeableConcept read FFormat write SetFormat;
    // The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
    property formatElement : TFhirCodeableConcept read FFormat write SetFormat;

    // Typed access to An attached file with the structural representation. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // An attached file with the structural representation.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
    
    //  Add a FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) : Integer;
    
    // Insert FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetItemN write SetItemN; default;
  End;

  // Properties of a substance specific to it being a polymer.
  TFhirSubstancePolymer = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FClass_ : TFhirCodeableConcept;
    FGeometry : TFhirCodeableConcept;
    FcopolymerConnectivityList : TFhirCodeableConceptList;
    FModification : TFhirString;
    FmonomerSetList : TFhirSubstancePolymerMonomerSetList;
    Frepeat_List : TFhirSubstancePolymerRepeatList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetClass_(value : TFhirCodeableConcept);
    procedure SetGeometry(value : TFhirCodeableConcept);
    function GetCopolymerConnectivityList : TFhirCodeableConceptList;
    function GetHasCopolymerConnectivityList : Boolean;
    procedure SetModification(value : TFhirString);
    function GetModificationST : String;
    procedure SetModificationST(value : String);
    function GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
    function GetHasMonomerSetList : Boolean;
    function GetRepeat_List : TFhirSubstancePolymerRepeatList;
    function GetHasRepeat_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymer; overload;
    function Clone : TFhirSubstancePolymer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Overall type of the polymer. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // Overall type of the polymer.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic. (defined for API consistency)
    property geometry : TFhirCodeableConcept read FGeometry write SetGeometry;
    // Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
    property geometryElement : TFhirCodeableConcept read FGeometry write SetGeometry;

    // Descrtibes the copolymer sequence type (polymer connectivity).
    property copolymerConnectivityList : TFhirCodeableConceptList read GetCopolymerConnectivityList;
    property hasCopolymerConnectivityList : boolean read GetHasCopolymerConnectivityList;

    // Typed access to Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
    property modification : String read GetModificationST write SetModificationST;
    // Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
    property modificationElement : TFhirString read FModification write SetModification;

    // Todo.
    property monomerSetList : TFhirSubstancePolymerMonomerSetList read GetMonomerSetList;
    property hasMonomerSetList : boolean read GetHasMonomerSetList;

    // Specifies and quantifies the repeated units and their configuration.
    property repeat_List : TFhirSubstancePolymerRepeatList read GetRepeat_List;
    property hasRepeat_List : boolean read GetHasRepeat_List;

  end;

  TFhirSubstancePolymerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerList;
    function GetCurrent : TFhirSubstancePolymer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymer read GetCurrent;
  end;

  TFhirSubstancePolymerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstancePolymer;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstancePolymerList; overload;
    function Clone : TFhirSubstancePolymerList; overload;
    function GetEnumerator : TFhirSubstancePolymerListEnumerator;
    
    //  Add a FhirSubstancePolymer to the end of the list.
    function Append : TFhirSubstancePolymer;
    
    // Add an already existing FhirSubstancePolymer to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymer) : Integer;
    
    // Insert FhirSubstancePolymer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymer;
    
    // Insert an existing FhirSubstancePolymer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymer);
    
    // Get the iIndexth FhirSubstancePolymer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstancePolymers[index : Integer] : TFhirSubstancePolymer read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceProteinSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FNTerminalModificationId : TFhirIdentifier;
    FNTerminalModification : TFhirString;
    FCTerminalModificationId : TFhirIdentifier;
    FCTerminalModification : TFhirString;
    procedure SetSubunit(value : TFhirInteger);
    function GetSubunitST : String;
    procedure SetSubunitST(value : String);
    procedure SetSequence(value : TFhirString);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetSequenceAttachment(value : TFhirAttachment);
    procedure SetNTerminalModificationId(value : TFhirIdentifier);
    procedure SetNTerminalModification(value : TFhirString);
    function GetNTerminalModificationST : String;
    procedure SetNTerminalModificationST(value : String);
    procedure SetCTerminalModificationId(value : TFhirIdentifier);
    procedure SetCTerminalModification(value : TFhirString);
    function GetCTerminalModificationST : String;
    procedure SetCTerminalModificationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProteinSubunit; overload;
    function Clone : TFhirSubstanceProteinSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequence : String read GetSequenceST write SetSequenceST;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to Length of linear sequences of amino acids contained in the subunit.
    property length : String read GetLengthST write SetLengthST;
    // Length of linear sequences of amino acids contained in the subunit.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence. (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property nTerminalModificationId : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property nTerminalModificationIdElement : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;

    // Typed access to The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModification : String read GetNTerminalModificationST write SetNTerminalModificationST;
    // The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModificationElement : TFhirString read FNTerminalModification write SetNTerminalModification;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property cTerminalModificationId : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property cTerminalModificationIdElement : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;

    // Typed access to The modification at the C-terminal shall be specified.
    property cTerminalModification : String read GetCTerminalModificationST write SetCTerminalModificationST;
    // The modification at the C-terminal shall be specified.
    property cTerminalModificationElement : TFhirString read FCTerminalModification write SetCTerminalModification;

  end;

  TFhirSubstanceProteinSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinSubunitList;
    function GetCurrent : TFhirSubstanceProteinSubunit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProteinSubunit read GetCurrent;
  end;

  TFhirSubstanceProteinSubunitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceProteinSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProteinSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceProteinSubunitList; overload;
    function Clone : TFhirSubstanceProteinSubunitList; overload;
    function GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
    
    //  Add a FhirSubstanceProteinSubunit to the end of the list.
    function Append : TFhirSubstanceProteinSubunit;
    
    // Add an already existing FhirSubstanceProteinSubunit to the end of the list.
    procedure AddItem(value : TFhirSubstanceProteinSubunit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProteinSubunit) : Integer;
    
    // Insert FhirSubstanceProteinSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProteinSubunit;
    
    // Insert an existing FhirSubstanceProteinSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // Get the iIndexth FhirSubstanceProteinSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProteinSubunit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceProteinSubunits[index : Integer] : TFhirSubstanceProteinSubunit read GetItemN write SetItemN; default;
  End;

  // A SubstanceProtein is defined as a single unit of a linear amino acid sequence, or a combination of subunits that are either covalently linked or have a defined invariant stoichiometric relationship. This includes all synthetic, recombinant and purified SubstanceProteins of defined sequence, whether the use is therapeutic or prophylactic. This set of elements will be used to describe albumins, coagulation factors, cytokines, growth factors, peptide/SubstanceProtein hormones, enzymes, toxins, toxoids, recombinant vaccines, and immunomodulators.
  TFhirSubstanceProtein = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FdisulfideLinkageList : TFhirStringList;
    FsubunitList : TFhirSubstanceProteinSubunitList;
    procedure SetSequenceType(value : TFhirCodeableConcept);
    procedure SetNumberOfSubunits(value : TFhirInteger);
    function GetNumberOfSubunitsST : String;
    procedure SetNumberOfSubunitsST(value : String);
    function GetDisulfideLinkageList : TFhirStringList;
    function GetHasDisulfideLinkageList : Boolean;
    function GetSubunitList : TFhirSubstanceProteinSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProtein; overload;
    function Clone : TFhirSubstanceProtein; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
    property disulfideLinkageList : TFhirStringList read GetDisulfideLinkageList;
    property hasDisulfideLinkageList : boolean read GetHasDisulfideLinkageList;

    // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceProteinSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceProteinListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinList;
    function GetCurrent : TFhirSubstanceProtein;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProtein read GetCurrent;
  end;

  TFhirSubstanceProteinList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceProtein;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProtein);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceProteinList; overload;
    function Clone : TFhirSubstanceProteinList; overload;
    function GetEnumerator : TFhirSubstanceProteinListEnumerator;
    
    //  Add a FhirSubstanceProtein to the end of the list.
    function Append : TFhirSubstanceProtein;
    
    // Add an already existing FhirSubstanceProtein to the end of the list.
    procedure AddItem(value : TFhirSubstanceProtein); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProtein) : Integer;
    
    // Insert FhirSubstanceProtein before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProtein;
    
    // Insert an existing FhirSubstanceProtein before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProtein);
    
    // Get the iIndexth FhirSubstanceProtein. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProtein);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProtein;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceProteins[index : Integer] : TFhirSubstanceProtein read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  // Todo.
  TFhirSubstanceReferenceInformationGene = class (TFhirBackboneElement)
  protected
    FGeneSequenceOrigin : TFhirCodeableConcept;
    FGene : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetGeneSequenceOrigin(value : TFhirCodeableConcept);
    procedure SetGene(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGene; overload;
    function Clone : TFhirSubstanceReferenceInformationGene; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property geneSequenceOrigin : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;
    // Todo.
    property geneSequenceOriginElement : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;

    // Typed access to Todo. (defined for API consistency)
    property gene : TFhirCodeableConcept read FGene write SetGene;
    // Todo.
    property geneElement : TFhirCodeableConcept read FGene write SetGene;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneList;
    function GetCurrent : TFhirSubstanceReferenceInformationGene;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGene read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGene;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGene);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationGeneList; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationGene to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGene;
    
    // Add an already existing FhirSubstanceReferenceInformationGene to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationGene); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGene) : Integer;
    
    // Insert FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGene;
    
    // Insert an existing FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGene. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGene;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationGenes[index : Integer] : TFhirSubstanceReferenceInformationGene read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationGeneElement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FElement : TFhirIdentifier;
    FsourceList : TFhirReferenceList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetElement(value : TFhirIdentifier);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGeneElement; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property element : TFhirIdentifier read FElement write SetElement;
    // Todo.
    property elementElement : TFhirIdentifier read FElement write SetElement;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGeneElement read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneElementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationGeneElementList; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElementList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationGeneElement to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGeneElement;
    
    // Add an already existing FhirSubstanceReferenceInformationGeneElement to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationGeneElement); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGeneElement) : Integer;
    
    // Insert FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    
    // Insert an existing FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGeneElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationGeneElements[index : Integer] : TFhirSubstanceReferenceInformationGeneElement read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationTarget = class (TFhirBackboneElement)
  protected
    FTarget : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FInteraction : TFhirCodeableConcept;
    FOrganism : TFhirCodeableConcept;
    FOrganismType : TFhirCodeableConcept;
    FAmount : TFhirDataType;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetTarget(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetInteraction(value : TFhirCodeableConcept);
    procedure SetOrganism(value : TFhirCodeableConcept);
    procedure SetOrganismType(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationTarget; overload;
    function Clone : TFhirSubstanceReferenceInformationTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property target : TFhirIdentifier read FTarget write SetTarget;
    // Todo.
    property targetElement : TFhirIdentifier read FTarget write SetTarget;

    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property interaction : TFhirCodeableConcept read FInteraction write SetInteraction;
    // Todo.
    property interactionElement : TFhirCodeableConcept read FInteraction write SetInteraction;

    // Typed access to Todo. (defined for API consistency)
    property organism : TFhirCodeableConcept read FOrganism write SetOrganism;
    // Todo.
    property organismElement : TFhirCodeableConcept read FOrganism write SetOrganism;

    // Typed access to Todo. (defined for API consistency)
    property organismType : TFhirCodeableConcept read FOrganismType write SetOrganismType;
    // Todo.
    property organismTypeElement : TFhirCodeableConcept read FOrganismType write SetOrganismType;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to Todo. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // Todo.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Todo.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationTargetList;
    function GetCurrent : TFhirSubstanceReferenceInformationTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationTarget read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationTargetList; overload;
    function Clone : TFhirSubstanceReferenceInformationTargetList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformationTarget to the end of the list.
    function Append : TFhirSubstanceReferenceInformationTarget;
    
    // Add an already existing FhirSubstanceReferenceInformationTarget to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationTarget); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationTarget) : Integer;
    
    // Insert FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    
    // Insert an existing FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // Get the iIndexth FhirSubstanceReferenceInformationTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformationTargets[index : Integer] : TFhirSubstanceReferenceInformationTarget read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformation = class (TFhirDomainResource)
  protected
    FComment : TFhirString;
    FgeneList : TFhirSubstanceReferenceInformationGeneList;
    FgeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    FtargetList : TFhirSubstanceReferenceInformationTargetList;
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    function GetGeneList : TFhirSubstanceReferenceInformationGeneList;
    function GetHasGeneList : Boolean;
    function GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetHasGeneElementList : Boolean;
    function GetTargetList : TFhirSubstanceReferenceInformationTargetList;
    function GetHasTargetList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformation; overload;
    function Clone : TFhirSubstanceReferenceInformation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Todo.
    property comment : String read GetCommentST write SetCommentST;
    // Todo.
    property commentElement : TFhirString read FComment write SetComment;

    // Todo.
    property geneList : TFhirSubstanceReferenceInformationGeneList read GetGeneList;
    property hasGeneList : boolean read GetHasGeneList;

    // Todo.
    property geneElementList : TFhirSubstanceReferenceInformationGeneElementList read GetGeneElementList;
    property hasGeneElementList : boolean read GetHasGeneElementList;

    // Todo.
    property targetList : TFhirSubstanceReferenceInformationTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirSubstanceReferenceInformationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationList;
    function GetCurrent : TFhirSubstanceReferenceInformation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformation read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceReferenceInformationList; overload;
    function Clone : TFhirSubstanceReferenceInformationList; overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
    
    //  Add a FhirSubstanceReferenceInformation to the end of the list.
    function Append : TFhirSubstanceReferenceInformation;
    
    // Add an already existing FhirSubstanceReferenceInformation to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformation) : Integer;
    
    // Insert FhirSubstanceReferenceInformation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformation;
    
    // Insert an existing FhirSubstanceReferenceInformation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // Get the iIndexth FhirSubstanceReferenceInformation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceReferenceInformations[index : Integer] : TFhirSubstanceReferenceInformation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  TFhirSubstanceSourceMaterialFractionDescription = class (TFhirBackboneElement)
  protected
    FFraction : TFhirString;
    FMaterialType : TFhirCodeableConcept;
    procedure SetFraction(value : TFhirString);
    function GetFractionST : String;
    procedure SetFractionST(value : String);
    procedure SetMaterialType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fraction : String read GetFractionST write SetFractionST;
    // This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fractionElement : TFhirString read FFraction write SetFraction;

    // Typed access to The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1. (defined for API consistency)
    property materialType : TFhirCodeableConcept read FMaterialType write SetMaterialType;
    // The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
    property materialTypeElement : TFhirCodeableConcept read FMaterialType write SetMaterialType;

  end;

  TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialFractionDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialFractionDescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialFractionDescriptionList; overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescriptionList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialFractionDescription;
    
    // Add an already existing FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialFractionDescription); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialFractionDescription) : Integer;
    
    // Insert FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    
    // Insert an existing FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialFractionDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialFractionDescriptions[index : Integer] : TFhirSubstanceSourceMaterialFractionDescription read GetItemN write SetItemN; default;
  End;

  // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  TFhirSubstanceSourceMaterialOrganism = class (TFhirBackboneElement)
  protected
    FFamily : TFhirCodeableConcept;
    FGenus : TFhirCodeableConcept;
    FSpecies : TFhirCodeableConcept;
    FIntraspecificType : TFhirCodeableConcept;
    FIntraspecificDescription : TFhirString;
    FauthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    FHybrid : TFhirSubstanceSourceMaterialOrganismHybrid;
    FOrganismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    procedure SetFamily(value : TFhirCodeableConcept);
    procedure SetGenus(value : TFhirCodeableConcept);
    procedure SetSpecies(value : TFhirCodeableConcept);
    procedure SetIntraspecificType(value : TFhirCodeableConcept);
    procedure SetIntraspecificDescription(value : TFhirString);
    function GetIntraspecificDescriptionST : String;
    procedure SetIntraspecificDescriptionST(value : String);
    function GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetHasAuthorList : Boolean;
    procedure SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
    procedure SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganism; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganism; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The family of an organism shall be specified. (defined for API consistency)
    property family : TFhirCodeableConcept read FFamily write SetFamily;
    // The family of an organism shall be specified.
    property familyElement : TFhirCodeableConcept read FFamily write SetFamily;

    // Typed access to The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies. (defined for API consistency)
    property genus : TFhirCodeableConcept read FGenus write SetGenus;
    // The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
    property genusElement : TFhirCodeableConcept read FGenus write SetGenus;

    // Typed access to The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

    // Typed access to The Intraspecific type of an organism shall be specified. (defined for API consistency)
    property intraspecificType : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;
    // The Intraspecific type of an organism shall be specified.
    property intraspecificTypeElement : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;

    // Typed access to The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescription : String read GetIntraspecificDescriptionST write SetIntraspecificDescriptionST;
    // The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescriptionElement : TFhirString read FIntraspecificDescription write SetIntraspecificDescription;

    // 4.9.13.6.1 Author type (Conditional).
    property authorList : TFhirSubstanceSourceMaterialOrganismAuthorList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to 4.9.13.8.1 Hybrid species maternal organism ID (Optional). (defined for API consistency)
    property hybrid : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;
    // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
    property hybridElement : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;

    // Typed access to 4.9.13.7.1 Kingdom (Conditional). (defined for API consistency)
    property organismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;
    // 4.9.13.7.1 Kingdom (Conditional).
    property organismGeneralElement : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;

  end;

  TFhirSubstanceSourceMaterialOrganismListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganism;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganism read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganism to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganism;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganism to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganism); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganism) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganism. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganisms[index : Integer] : TFhirSubstanceSourceMaterialOrganism read GetItemN write SetItemN; default;
  End;

  // 4.9.13.6.1 Author type (Conditional).
  TFhirSubstanceSourceMaterialOrganismAuthor = class (TFhirBackboneElement)
  protected
    FAuthorType : TFhirCodeableConcept;
    FAuthorDescription : TFhirString;
    procedure SetAuthorType(value : TFhirCodeableConcept);
    procedure SetAuthorDescription(value : TFhirString);
    function GetAuthorDescriptionST : String;
    procedure SetAuthorDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who {$IFNDEF FPC}published{$ENDIF} the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly {$IFNDEF FPC}published{$ENDIF} the plant/animal name. (defined for API consistency)
    property authorType : TFhirCodeableConcept read FAuthorType write SetAuthorType;
    // The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who {$IFNDEF FPC}published{$ENDIF} the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly {$IFNDEF FPC}published{$ENDIF} the plant/animal name.
    property authorTypeElement : TFhirCodeableConcept read FAuthorType write SetAuthorType;

    // Typed access to The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) {$IFNDEF FPC}published{$ENDIF} the infraspecific plant/animal name (of any rank).
    property authorDescription : String read GetAuthorDescriptionST write SetAuthorDescriptionST;
    // The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) {$IFNDEF FPC}published{$ENDIF} the infraspecific plant/animal name (of any rank).
    property authorDescriptionElement : TFhirString read FAuthorDescription write SetAuthorDescription;

  end;

  TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismAuthor read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismAuthorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismAuthorList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthorList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismAuthor); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismAuthor) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismAuthor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismAuthors[index : Integer] : TFhirSubstanceSourceMaterialOrganismAuthor read GetItemN write SetItemN; default;
  End;

  // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  TFhirSubstanceSourceMaterialOrganismHybrid = class (TFhirBackboneElement)
  protected
    FMaternalOrganismId : TFhirString;
    FMaternalOrganismName : TFhirString;
    FPaternalOrganismId : TFhirString;
    FPaternalOrganismName : TFhirString;
    FHybridType : TFhirCodeableConcept;
    procedure SetMaternalOrganismId(value : TFhirString);
    function GetMaternalOrganismIdST : String;
    procedure SetMaternalOrganismIdST(value : String);
    procedure SetMaternalOrganismName(value : TFhirString);
    function GetMaternalOrganismNameST : String;
    procedure SetMaternalOrganismNameST(value : String);
    procedure SetPaternalOrganismId(value : TFhirString);
    function GetPaternalOrganismIdST : String;
    procedure SetPaternalOrganismIdST(value : String);
    procedure SetPaternalOrganismName(value : TFhirString);
    function GetPaternalOrganismNameST : String;
    procedure SetPaternalOrganismNameST(value : String);
    procedure SetHybridType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismId : String read GetMaternalOrganismIdST write SetMaternalOrganismIdST;
    // The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismIdElement : TFhirString read FMaternalOrganismId write SetMaternalOrganismId;

    // Typed access to The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismName : String read GetMaternalOrganismNameST write SetMaternalOrganismNameST;
    // The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren’t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismNameElement : TFhirString read FMaternalOrganismName write SetMaternalOrganismName;

    // Typed access to The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismId : String read GetPaternalOrganismIdST write SetPaternalOrganismIdST;
    // The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismIdElement : TFhirString read FPaternalOrganismId write SetPaternalOrganismId;

    // Typed access to The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismName : String read GetPaternalOrganismNameST write SetPaternalOrganismNameST;
    // The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismNameElement : TFhirString read FPaternalOrganismName write SetPaternalOrganismName;

    // Typed access to The hybrid type of an organism shall be specified. (defined for API consistency)
    property hybridType : TFhirCodeableConcept read FHybridType write SetHybridType;
    // The hybrid type of an organism shall be specified.
    property hybridTypeElement : TFhirCodeableConcept read FHybridType write SetHybridType;

  end;

  TFhirSubstanceSourceMaterialOrganismHybridListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismHybridList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismHybrid read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismHybridList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismHybridList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybridList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismHybrid); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismHybrid) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismHybrid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismHybrids[index : Integer] : TFhirSubstanceSourceMaterialOrganismHybrid read GetItemN write SetItemN; default;
  End;

  // 4.9.13.7.1 Kingdom (Conditional).
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class (TFhirBackboneElement)
  protected
    FKingdom : TFhirCodeableConcept;
    FPhylum : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FOrder : TFhirCodeableConcept;
    procedure SetKingdom(value : TFhirCodeableConcept);
    procedure SetPhylum(value : TFhirCodeableConcept);
    procedure SetClass_(value : TFhirCodeableConcept);
    procedure SetOrder(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kingdom of an organism shall be specified. (defined for API consistency)
    property kingdom : TFhirCodeableConcept read FKingdom write SetKingdom;
    // The kingdom of an organism shall be specified.
    property kingdomElement : TFhirCodeableConcept read FKingdom write SetKingdom;

    // Typed access to The phylum of an organism shall be specified. (defined for API consistency)
    property phylum : TFhirCodeableConcept read FPhylum write SetPhylum;
    // The phylum of an organism shall be specified.
    property phylumElement : TFhirCodeableConcept read FPhylum write SetPhylum;

    // Typed access to The class of an organism shall be specified. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // The class of an organism shall be specified.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to The order of an organism shall be specified,. (defined for API consistency)
    property order : TFhirCodeableConcept read FOrder write SetOrder;
    // The order of an organism shall be specified,.
    property orderElement : TFhirCodeableConcept read FOrder write SetOrder;

  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // Add an already existing FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral) : Integer;
    
    // Insert FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // Insert an existing FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismOrganismGeneral. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialOrganismOrganismGenerals[index : Integer] : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetItemN write SetItemN; default;
  End;

  // To do.
  TFhirSubstanceSourceMaterialPartDescription = class (TFhirBackboneElement)
  protected
    FPart : TFhirCodeableConcept;
    FPartLocation : TFhirCodeableConcept;
    procedure SetPart(value : TFhirCodeableConcept);
    procedure SetPartLocation(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialPartDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Entity of anatomical origin of source material within an organism. (defined for API consistency)
    property part : TFhirCodeableConcept read FPart write SetPart;
    // Entity of anatomical origin of source material within an organism.
    property partElement : TFhirCodeableConcept read FPart write SetPart;

    // Typed access to The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply. (defined for API consistency)
    property partLocation : TFhirCodeableConcept read FPartLocation write SetPartLocation;
    // The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
    property partLocationElement : TFhirCodeableConcept read FPartLocation write SetPartLocation;

  end;

  TFhirSubstanceSourceMaterialPartDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialPartDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialPartDescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialPartDescriptionList; overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescriptionList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterialPartDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialPartDescription;
    
    // Add an already existing FhirSubstanceSourceMaterialPartDescription to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialPartDescription); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialPartDescription) : Integer;
    
    // Insert FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    
    // Insert an existing FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialPartDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterialPartDescriptions[index : Integer] : TFhirSubstanceSourceMaterialPartDescription read GetItemN write SetItemN; default;
  End;

  // Source material shall capture information on the taxonomic and anatomical origins as well as the fraction of a material that can result in or can be modified to form a substance. This set of data elements shall be used to define polymer substances isolated from biological matrices. Taxonomic and anatomical origins shall be described using a controlled vocabulary as required. This information is captured for naturally derived polymers ( . starch) and structurally diverse substances. For Organisms belonging to the Kingdom Plantae the Substance level defines the fresh material of a single species or infraspecies, the Herbal Drug and the Herbal preparation. For Herbal preparations, the fraction information will be captured at the Substance information level and additional information for herbal extracts will be captured at the Specified Substance Group 1 information level. See for further explanation the Substance Class: Structurally Diverse and the herbal annex.
  TFhirSubstanceSourceMaterial = class (TFhirDomainResource)
  protected
    FSourceMaterialClass : TFhirCodeableConcept;
    FSourceMaterialType : TFhirCodeableConcept;
    FSourceMaterialState : TFhirCodeableConcept;
    FOrganismId : TFhirIdentifier;
    FOrganismName : TFhirString;
    FparentSubstanceIdList : TFhirIdentifierList;
    FparentSubstanceNameList : TFhirStringList;
    FcountryOfOriginList : TFhirCodeableConceptList;
    FgeographicalLocationList : TFhirStringList;
    FDevelopmentStage : TFhirCodeableConcept;
    FfractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    FOrganism : TFhirSubstanceSourceMaterialOrganism;
    FpartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    procedure SetSourceMaterialClass(value : TFhirCodeableConcept);
    procedure SetSourceMaterialType(value : TFhirCodeableConcept);
    procedure SetSourceMaterialState(value : TFhirCodeableConcept);
    procedure SetOrganismId(value : TFhirIdentifier);
    procedure SetOrganismName(value : TFhirString);
    function GetOrganismNameST : String;
    procedure SetOrganismNameST(value : String);
    function GetParentSubstanceIdList : TFhirIdentifierList;
    function GetHasParentSubstanceIdList : Boolean;
    function GetParentSubstanceNameList : TFhirStringList;
    function GetHasParentSubstanceNameList : Boolean;
    function GetCountryOfOriginList : TFhirCodeableConceptList;
    function GetHasCountryOfOriginList : Boolean;
    function GetGeographicalLocationList : TFhirStringList;
    function GetHasGeographicalLocationList : Boolean;
    procedure SetDevelopmentStage(value : TFhirCodeableConcept);
    function GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetHasFractionDescriptionList : Boolean;
    procedure SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
    function GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetHasPartDescriptionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterial; overload;
    function Clone : TFhirSubstanceSourceMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to General high level classification of the source material specific to the origin of the material. (defined for API consistency)
    property sourceMaterialClass : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;
    // General high level classification of the source material specific to the origin of the material.
    property sourceMaterialClassElement : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;

    // Typed access to The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent. (defined for API consistency)
    property sourceMaterialType : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;
    // The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
    property sourceMaterialTypeElement : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;

    // Typed access to The state of the source material when extracted. (defined for API consistency)
    property sourceMaterialState : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;
    // The state of the source material when extracted.
    property sourceMaterialStateElement : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;

    // Typed access to The unique identifier associated with the source material parent organism shall be specified. (defined for API consistency)
    property organismId : TFhirIdentifier read FOrganismId write SetOrganismId;
    // The unique identifier associated with the source material parent organism shall be specified.
    property organismIdElement : TFhirIdentifier read FOrganismId write SetOrganismId;

    // Typed access to The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismName : String read GetOrganismNameST write SetOrganismNameST;
    // The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismNameElement : TFhirString read FOrganismName write SetOrganismName;

    // The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
    property parentSubstanceIdList : TFhirIdentifierList read GetParentSubstanceIdList;
    property hasParentSubstanceIdList : boolean read GetHasParentSubstanceIdList;

    // The parent substance of the Herbal Drug, or Herbal preparation.
    property parentSubstanceNameList : TFhirStringList read GetParentSubstanceNameList;
    property hasParentSubstanceNameList : boolean read GetHasParentSubstanceNameList;

    // The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For “Plasma-derived substances” the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
    property countryOfOriginList : TFhirCodeableConceptList read GetCountryOfOriginList;
    property hasCountryOfOriginList : boolean read GetHasCountryOfOriginList;

    // The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
    property geographicalLocationList : TFhirStringList read GetGeographicalLocationList;
    property hasGeographicalLocationList : boolean read GetHasGeographicalLocationList;

    // Typed access to Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum). (defined for API consistency)
    property developmentStage : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;
    // Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
    property developmentStageElement : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;

    // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
    property fractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList read GetFractionDescriptionList;
    property hasFractionDescriptionList : boolean read GetHasFractionDescriptionList;

    // Typed access to This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf. (defined for API consistency)
    property organism : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;
    // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
    property organismElement : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;

    // To do.
    property partDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList read GetPartDescriptionList;
    property hasPartDescriptionList : boolean read GetHasPartDescriptionList;

  end;

  TFhirSubstanceSourceMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialList;
    function GetCurrent : TFhirSubstanceSourceMaterial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterial read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceSourceMaterialList; overload;
    function Clone : TFhirSubstanceSourceMaterialList; overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
    
    //  Add a FhirSubstanceSourceMaterial to the end of the list.
    function Append : TFhirSubstanceSourceMaterial;
    
    // Add an already existing FhirSubstanceSourceMaterial to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterial) : Integer;
    
    // Insert FhirSubstanceSourceMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterial;
    
    // Insert an existing FhirSubstanceSourceMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // Get the iIndexth FhirSubstanceSourceMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceSourceMaterials[index : Integer] : TFhirSubstanceSourceMaterial read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}

implementation

uses
  fhir5_utilities;

{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{ TFhirAdministrableProductDefinitionProperty }

constructor TFhirAdministrableProductDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  FStatus.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAdministrableProductDefinitionProperty(oSource).type_.Clone;
  value := TFhirAdministrableProductDefinitionProperty(oSource).value.Clone;
  status := TFhirAdministrableProductDefinitionProperty(oSource).status.Clone;
end;

procedure TFhirAdministrableProductDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirAdministrableProductDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
end;

function TFhirAdministrableProductDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else if (propName = 'status') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil {L1189}
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionProperty.fhirType : string;
begin
  result := 'AdministrableProductDefinition.property';
end;

function TFhirAdministrableProductDefinitionProperty.Link : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Link);
end;

function TFhirAdministrableProductDefinitionProperty.Clone : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Clone);
end;

function TFhirAdministrableProductDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FStatus);
end;

procedure TFhirAdministrableProductDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionProperty.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('status');
end;

function TFhirAdministrableProductDefinitionProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionPropertyListEnumerator }

constructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(list : TFhirAdministrableProductDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionPropertyList }

procedure TFhirAdministrableProductDefinitionPropertyList.AddItem(value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionProperty');
  add(value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Append: TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionPropertyList.Clone: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionProperty;
end;
function TFhirAdministrableProductDefinitionPropertyList.IndexOf(value: TFhirAdministrableProductDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Insert(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Item(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.Link: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  FhirAdministrableProductDefinitionProperties[index] := value;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministration }

constructor TFhirAdministrableProductDefinitionRouteOfAdministration.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministration.Destroy;
begin
  FCode.free;
  FFirstDose.free;
  FMaxSingleDose.free;
  FMaxDosePerDay.free;
  FMaxDosePerTreatmentPeriod.free;
  FMaxTreatmentPeriod.free;
  FTargetSpeciesList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).code.Clone;
  firstDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).firstDose.Clone;
  maxSingleDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxSingleDose.Clone;
  maxDosePerDay := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerDay.Clone;
  maxDosePerTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerTreatmentPeriod.Clone;
  maxTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxTreatmentPeriod.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList = nil) then
  begin
    FTargetSpeciesList.free;
    FTargetSpeciesList := nil;
  end
  else
  begin
    if FTargetSpeciesList = nil then
      FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
    FTargetSpeciesList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'firstDose') Then
     list.add(self.link, 'firstDose', FFirstDose.Link);
  if (child_name = 'maxSingleDose') Then
     list.add(self.link, 'maxSingleDose', FMaxSingleDose.Link);
  if (child_name = 'maxDosePerDay') Then
     list.add(self.link, 'maxDosePerDay', FMaxDosePerDay.Link);
  if (child_name = 'maxDosePerTreatmentPeriod') Then
     list.add(self.link, 'maxDosePerTreatmentPeriod', FMaxDosePerTreatmentPeriod.Link);
  if (child_name = 'maxTreatmentPeriod') Then
     list.add(self.link, 'maxTreatmentPeriod', FMaxTreatmentPeriod.Link);
  if (child_name = 'targetSpecies') Then
    list.addAll(self, 'targetSpecies', FTargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'firstDose', 'Quantity', false, TFhirQuantity, FFirstDose.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'maxSingleDose', 'Quantity', false, TFhirQuantity, FMaxSingleDose.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'maxDosePerDay', 'Quantity', false, TFhirQuantity, FMaxDosePerDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'maxDosePerTreatmentPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerTreatmentPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'maxTreatmentPeriod', 'Duration', false, TFhirDuration, FMaxTreatmentPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'targetSpecies', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies, FTargetSpeciesList.Link)) {L1039};
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'firstDose') then
  begin
    FirstDose := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'maxSingleDose') then
  begin
    MaxSingleDose := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'maxDosePerDay') then
  begin
    MaxDosePerDay := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'maxDosePerTreatmentPeriod') then
  begin
    MaxDosePerTreatmentPeriod := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'maxTreatmentPeriod') then
  begin
    MaxTreatmentPeriod := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'targetSpecies') then
  begin
    TargetSpeciesList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) {L1049}
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'firstDose') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'maxSingleDose') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'maxDosePerDay') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'maxDosePerTreatmentPeriod') then result := TFhirRatio.create() {L1203}
  else if (propName = 'maxTreatmentPeriod') then result := TFhirDuration.create() {L1203}
  else if (propName = 'targetSpecies') then result := TargetSpeciesList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'firstDose') then result := 'Quantity'
  else if (propName = 'maxSingleDose') then result := 'Quantity'
  else if (propName = 'maxDosePerDay') then result := 'Quantity'
  else if (propName = 'maxDosePerTreatmentPeriod') then result := 'Ratio'
  else if (propName = 'maxTreatmentPeriod') then result := 'Duration'
  else if (propName = 'targetSpecies') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'firstDose') then FirstDoseElement := nil
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := nil
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := nil
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := nil
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := nil
  else if (propName = 'targetSpecies') then deletePropertyValue('targetSpecies', TargetSpeciesList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'firstDose') then FirstDoseElement := new as TFhirQuantity {L1195}
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := new as TFhirQuantity {L1195}
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := new as TFhirQuantity {L1195}
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := new as TFhirRatio {L1195}
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := new as TFhirDuration {L1195}
  else if (propName = 'targetSpecies') then replacePropertyValue('targetSpecies', TargetSpeciesList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Link : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Clone : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministration)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministration(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(firstDoseElement, o.firstDoseElement, true) and 
      compareDeep(maxSingleDoseElement, o.maxSingleDoseElement, true) and compareDeep(maxDosePerDayElement, o.maxDosePerDayElement, true) and 
      compareDeep(maxDosePerTreatmentPeriodElement, o.maxDosePerTreatmentPeriodElement, true) and 
      compareDeep(maxTreatmentPeriodElement, o.maxTreatmentPeriodElement, true) and 
      compareDeep(targetSpeciesList, o.targetSpeciesList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FFirstDose) and isEmptyProp(FMaxSingleDose) and isEmptyProp(FMaxDosePerDay) and isEmptyProp(FMaxDosePerTreatmentPeriod) and isEmptyProp(FMaxTreatmentPeriod) and isEmptyProp(FtargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetFirstDose(value : TFhirQuantity);
begin
  FFirstDose.free;
  FFirstDose := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxSingleDose(value : TFhirQuantity);
begin
  FMaxSingleDose.free;
  FMaxSingleDose := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerDay(value : TFhirQuantity);
begin
  FMaxDosePerDay.free;
  FMaxDosePerDay := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
begin
  FMaxDosePerTreatmentPeriod.free;
  FMaxDosePerTreatmentPeriod := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxTreatmentPeriod(value : TFhirDuration);
begin
  FMaxTreatmentPeriod.free;
  FMaxTreatmentPeriod := value; {L1134}
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  if FTargetSpeciesList = nil then
    FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
  result := FTargetSpeciesList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetHasTargetSpeciesList : boolean;
begin
  result := (FTargetSpeciesList <> nil) and (FTargetSpeciesList.count > 0);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('firstDose');
  fields.add('maxSingleDose');
  fields.add('maxDosePerDay');
  fields.add('maxDosePerTreatmentPeriod');
  fields.add('maxTreatmentPeriod');
  fields.add('targetSpecies');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FFirstDose.sizeInBytes);
  inc(result, FMaxSingleDose.sizeInBytes);
  inc(result, FMaxDosePerDay.sizeInBytes);
  inc(result, FMaxDosePerTreatmentPeriod.sizeInBytes);
  inc(result, FMaxTreatmentPeriod.sizeInBytes);
  inc(result, FtargetSpeciesList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationList }

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministration');
  add(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Append: TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  FhirAdministrableProductDefinitionRouteOfAdministrations[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Destroy;
begin
  FCode.free;
  FWithdrawalPeriodList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).code.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList = nil) then
  begin
    FWithdrawalPeriodList.free;
    FWithdrawalPeriodList := nil;
  end
  else
  begin
    if FWithdrawalPeriodList = nil then
      FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
    FWithdrawalPeriodList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'withdrawalPeriod') Then
    list.addAll(self, 'withdrawalPeriod', FWithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'withdrawalPeriod', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod, FWithdrawalPeriodList.Link)) {L1039};
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'withdrawalPeriod') then
  begin
    WithdrawalPeriodList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) {L1049}
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'withdrawalPeriod') then result := WithdrawalPeriodList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'withdrawalPeriod') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'withdrawalPeriod') then deletePropertyValue('withdrawalPeriod', WithdrawalPeriodList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'withdrawalPeriod') then replacePropertyValue('withdrawalPeriod', WithdrawalPeriodList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(withdrawalPeriodList, o.withdrawalPeriodList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FwithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  if FWithdrawalPeriodList = nil then
    FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
  result := FWithdrawalPeriodList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetHasWithdrawalPeriodList : boolean;
begin
  result := (FWithdrawalPeriodList <> nil) and (FWithdrawalPeriodList.count > 0);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('withdrawalPeriod');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FwithdrawalPeriodList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList }

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies');
  add(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Destroy;
begin
  FTissue.free;
  FValue.free;
  FSupportingInformation.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Assign(oSource : TFslObject);
begin
  inherited;
  tissue := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).tissue.Clone;
  value := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).value.Clone;
  supportingInformationElement := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).supportingInformationElement.Clone;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'tissue') Then
     list.add(self.link, 'tissue', FTissue.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'supportingInformation') Then
     list.add(self.link, 'supportingInformation', FSupportingInformation.Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'tissue', 'CodeableConcept', false, TFhirCodeableConcept, FTissue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'string', false, TFhirString, FSupportingInformation.Link)); {L1172}
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'tissue') then
  begin
    Tissue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'tissue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'value') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'supportingInformation') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'tissue') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'supportingInformation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'supportingInformation') then SupportingInformationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'value') then ValueElement := new as TFhirQuantity {L1195}
  else if (propName = 'supportingInformation') then SupportingInformationElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(other);
    result := compareDeep(tissueElement, o.tissueElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(supportingInformationElement, o.supportingInformationElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTissue) and isEmptyProp(FValue) and isEmptyProp(FSupportingInformation);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetTissue(value : TFhirCodeableConcept);
begin
  FTissue.free;
  FTissue := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformation(value : TFhirString);
begin
  FSupportingInformation.free;
  FSupportingInformation := value; {L1134}
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetSupportingInformationST : String;
begin
  if FSupportingInformation = nil then
    result := ''
  else
    result := FSupportingInformation.value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformationST(value : String);
begin
  if value <> '' then
  begin
    if FSupportingInformation = nil then
      FSupportingInformation := TFhirString.create;
    FSupportingInformation.value := value
  end
  else if FSupportingInformation <> nil then
    FSupportingInformation.value := '';
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('tissue');
  fields.add('value');
  fields.add('supportingInformation');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTissue.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FSupportingInformation.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList }

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod');
  add(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinition }

constructor TFhirAdministrableProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FSubjectList.Free;
  FAdministrableDoseForm.free;
  FUnitOfPresentation.free;
  FProducedFromList.Free;
  FIngredientList.Free;
  FDeviceList.Free;
  FProperty_List.Free;
  FRouteOfAdministrationList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAdministrableProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAdministrableProductDefinition(oSource).FIdentifierList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirAdministrableProductDefinition(oSource).FSubjectList);
  end;
  administrableDoseForm := TFhirAdministrableProductDefinition(oSource).administrableDoseForm.Clone;
  unitOfPresentation := TFhirAdministrableProductDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FProducedFromList = nil) then
  begin
    FProducedFromList.free;
    FProducedFromList := nil;
  end
  else
  begin
    if FProducedFromList = nil then
      FProducedFromList := TFhirReferenceList.Create;
    FProducedFromList.Assign(TFhirAdministrableProductDefinition(oSource).FProducedFromList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirReferenceList.Create;
    FIngredientList.Assign(TFhirAdministrableProductDefinition(oSource).FIngredientList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList.Create;
    FDeviceList.Assign(TFhirAdministrableProductDefinition(oSource).FDeviceList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirAdministrableProductDefinition(oSource).FProperty_List);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList = nil) then
  begin
    FRouteOfAdministrationList.free;
    FRouteOfAdministrationList := nil;
  end
  else
  begin
    if FRouteOfAdministrationList = nil then
      FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
    FRouteOfAdministrationList.Assign(TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList);
  end;
end;

function TFhirAdministrableProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtAdministrableProductDefinition;
end;

procedure TFhirAdministrableProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'administrableDoseForm') Then
     list.add(self.link, 'administrableDoseForm', FAdministrableDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'producedFrom') Then
    list.addAll(self, 'producedFrom', FProducedFromList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'routeOfAdministration') Then
    list.addAll(self, 'routeOfAdministration', FRouteOfAdministrationList);
end;

procedure TFhirAdministrableProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'administrableDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FAdministrableDoseForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'producedFrom', 'Reference', true, TFhirReference, FProducedFromList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'Reference', true, TFhirReference, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', true, TFhirReference, FDeviceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirAdministrableProductDefinitionProperty, FProperty_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'routeOfAdministration', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministration, FRouteOfAdministrationList.Link)) {L1039};
end;

function TFhirAdministrableProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'administrableDoseForm') then
  begin
    AdministrableDoseForm := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'producedFrom') then
  begin
    ProducedFromList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirAdministrableProductDefinitionProperty) {L1048};
    result := propValue;
  end
  else if (propName = 'routeOfAdministration') then
  begin
    RouteOfAdministrationList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministration) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'producedFrom') then ProducedFromList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirAdministrableProductDefinitionProperty) {L1049}
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministration) {L1049}
  else inherited;
end;

function TFhirAdministrableProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'subject') then result := SubjectList.new() {L1053}
  else if (propName = 'administrableDoseForm') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'producedFrom') then result := ProducedFromList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'device') then result := DeviceList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else if (propName = 'routeOfAdministration') then result := RouteOfAdministrationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'administrableDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'producedFrom') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'routeOfAdministration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {L1054}
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'producedFrom') then deletePropertyValue('producedFrom', ProducedFromList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else if (propName = 'routeOfAdministration') then deletePropertyValue('routeOfAdministration', RouteOfAdministrationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {L1055}
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'producedFrom') then replacePropertyValue('producedFrom', ProducedFromList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else if (propName = 'routeOfAdministration') then replacePropertyValue('routeOfAdministration', RouteOfAdministrationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'subject') then SubjectList.move(source, destination) {L1050}
  else if (propName = 'producedFrom') then ProducedFromList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else if (propName = 'device') then DeviceList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinition.fhirType : string;
begin
  result := 'AdministrableProductDefinition';
end;

function TFhirAdministrableProductDefinition.Link : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Link);
end;

function TFhirAdministrableProductDefinition.Clone : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Clone);
end;

function TFhirAdministrableProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinition)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(administrableDoseFormElement, o.administrableDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(producedFromList, o.producedFromList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(deviceList, o.deviceList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(routeOfAdministrationList, o.routeOfAdministrationList, true);
  end;
end;

function TFhirAdministrableProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FsubjectList) and isEmptyProp(FAdministrableDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FproducedFromList) and isEmptyProp(FingredientList) and isEmptyProp(FdeviceList) and isEmptyProp(Fproperty_List) and isEmptyProp(FrouteOfAdministrationList);
end;

function TFhirAdministrableProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAdministrableProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirAdministrableProductDefinition.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetAdministrableDoseForm(value : TFhirCodeableConcept);
begin
  FAdministrableDoseForm.free;
  FAdministrableDoseForm := value; {L1134}
end;

procedure TFhirAdministrableProductDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value; {L1134}
end;

function TFhirAdministrableProductDefinition.GetProducedFromList : TFhirReferenceList;
begin
  if FProducedFromList = nil then
    FProducedFromList := TFhirReferenceList.Create;
  result := FProducedFromList;
end;

function TFhirAdministrableProductDefinition.GetHasProducedFromList : boolean;
begin
  result := (FProducedFromList <> nil) and (FProducedFromList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetIngredientList : TFhirReferenceList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirReferenceList.Create;
  result := FIngredientList;
end;

function TFhirAdministrableProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetDeviceList : TFhirReferenceList;
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList.Create;
  result := FDeviceList;
end;

function TFhirAdministrableProductDefinition.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirAdministrableProductDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirAdministrableProductDefinition.GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  if FRouteOfAdministrationList = nil then
    FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
  result := FRouteOfAdministrationList;
end;

function TFhirAdministrableProductDefinition.GetHasRouteOfAdministrationList : boolean;
begin
  result := (FRouteOfAdministrationList <> nil) and (FRouteOfAdministrationList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('administrableDoseForm');
  fields.add('unitOfPresentation');
  fields.add('producedFrom');
  fields.add('ingredient');
  fields.add('device');
  fields.add('property');
  fields.add('routeOfAdministration');
end;

function TFhirAdministrableProductDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FAdministrableDoseForm.sizeInBytes);
  inc(result, FUnitOfPresentation.sizeInBytes);
  inc(result, FproducedFromList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FrouteOfAdministrationList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionListEnumerator }

constructor TFhirAdministrableProductDefinitionListEnumerator.Create(list : TFhirAdministrableProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionListEnumerator.GetCurrent : TFhirAdministrableProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdministrableProductDefinitionList }

procedure TFhirAdministrableProductDefinitionList.AddItem(value: TFhirAdministrableProductDefinition);
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinition');
  add(value);
end;

function TFhirAdministrableProductDefinitionList.Append: TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionList.GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionList.Clone: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionList.GetItemN(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinition;
end;
function TFhirAdministrableProductDefinitionList.IndexOf(value: TFhirAdministrableProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionList.Insert(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionList.Item(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.Link: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  FhirAdministrableProductDefinitions[index] := value;
end;

procedure TFhirAdministrableProductDefinitionList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
{ TFhirIngredientSubstance }

constructor TFhirIngredientSubstance.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstance.Destroy;
begin
  FCode.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirIngredientSubstance(oSource).code.Clone;
  if (TFhirIngredientSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirIngredientSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirIngredientSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code[x]') or (child_name = 'code') Then
     list.add(self.link, 'code[x]', FCode.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirIngredientSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code[x]', 'CodeableConcept|Reference', false, TFhirDataType, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strength', 'BackboneElement', true, TFhirIngredientSubstanceStrength, FStrengthList.Link)) {L1039};
end;

function TFhirIngredientSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then
  begin
    Code := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirIngredientSubstanceStrength) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrength) {L1049}
  else inherited;
end;

function TFhirIngredientSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Code') {L1191}
  else if (propName = 'strength') then result := StrengthList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'strength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then CodeElement := nil {L1189}
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then CodeElement := new as TFhirDataType {L1190}
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstance.fhirType : string;
begin
  result := 'Ingredient.substance';
end;

function TFhirIngredientSubstance.Link : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Link);
end;

function TFhirIngredientSubstance.Clone : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Clone);
end;

function TFhirIngredientSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstance)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirIngredientSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FstrengthList);
end;

procedure TFhirIngredientSubstance.SetCode(value : TFhirDataType);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirIngredientSubstance.GetStrengthList : TFhirIngredientSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
  result := FStrengthList;
end;

function TFhirIngredientSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

procedure TFhirIngredientSubstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code[x]');
  fields.add('strength');
end;

function TFhirIngredientSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FstrengthList.sizeInBytes);
end;

{ TFhirIngredientSubstanceListEnumerator }

constructor TFhirIngredientSubstanceListEnumerator.Create(list : TFhirIngredientSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceListEnumerator.GetCurrent : TFhirIngredientSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIngredientSubstanceList }

procedure TFhirIngredientSubstanceList.AddItem(value: TFhirIngredientSubstance);
begin
  assert(value.ClassName = 'TFhirIngredientSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstance');
  add(value);
end;

function TFhirIngredientSubstanceList.Append: TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceList.GetEnumerator : TFhirIngredientSubstanceListEnumerator;
begin
  result := TFhirIngredientSubstanceListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceList.Clone: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Clone);
end;

function TFhirIngredientSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceList.GetItemN(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstance;
end;
function TFhirIngredientSubstanceList.IndexOf(value: TFhirIngredientSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceList.Insert(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.InsertItem(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceList.Item(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.Link: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Link);
end;

procedure TFhirIngredientSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  FhirIngredientSubstances[index] := value;
end;

procedure TFhirIngredientSubstanceList.SetItemN(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrength }

constructor TFhirIngredientSubstanceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrength.Destroy;
begin
  FPresentation.free;
  FPresentationHighLimit.free;
  FPresentationText.free;
  FConcentration.free;
  FConcentrationHighLimit.free;
  FConcentrationText.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  FReferenceStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  presentation := TFhirIngredientSubstanceStrength(oSource).presentation.Clone;
  presentationHighLimit := TFhirIngredientSubstanceStrength(oSource).presentationHighLimit.Clone;
  presentationTextElement := TFhirIngredientSubstanceStrength(oSource).presentationTextElement.Clone;
  concentration := TFhirIngredientSubstanceStrength(oSource).concentration.Clone;
  concentrationHighLimit := TFhirIngredientSubstanceStrength(oSource).concentrationHighLimit.Clone;
  concentrationTextElement := TFhirIngredientSubstanceStrength(oSource).concentrationTextElement.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrength(oSource).FCountryList);
  end;
  if (TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList = nil) then
  begin
    FReferenceStrengthList.free;
    FReferenceStrengthList := nil;
  end
  else
  begin
    if FReferenceStrengthList = nil then
      FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
    FReferenceStrengthList.Assign(TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList);
  end;
end;

procedure TFhirIngredientSubstanceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'presentation') Then
     list.add(self.link, 'presentation', FPresentation.Link);
  if (child_name = 'presentationHighLimit') Then
     list.add(self.link, 'presentationHighLimit', FPresentationHighLimit.Link);
  if (child_name = 'presentationText') Then
     list.add(self.link, 'presentationText', FPresentationText.Link);
  if (child_name = 'concentration') Then
     list.add(self.link, 'concentration', FConcentration.Link);
  if (child_name = 'concentrationHighLimit') Then
     list.add(self.link, 'concentrationHighLimit', FConcentrationHighLimit.Link);
  if (child_name = 'concentrationText') Then
     list.add(self.link, 'concentrationText', FConcentrationText.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
  if (child_name = 'referenceStrength') Then
    list.addAll(self, 'referenceStrength', FReferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'presentation', 'Ratio', false, TFhirRatio, FPresentation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'presentationHighLimit', 'Ratio', false, TFhirRatio, FPresentationHighLimit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'presentationText', 'string', false, TFhirString, FPresentationText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'concentration', 'Ratio', false, TFhirRatio, FConcentration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'concentrationHighLimit', 'Ratio', false, TFhirRatio, FConcentrationHighLimit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'concentrationText', 'string', false, TFhirString, FConcentrationText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'referenceStrength', 'BackboneElement', true, TFhirIngredientSubstanceStrengthReferenceStrength, FReferenceStrengthList.Link)) {L1039};
end;

function TFhirIngredientSubstanceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'presentation') then
  begin
    Presentation := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'presentationHighLimit') then
  begin
    PresentationHighLimit := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'presentationText') then
  begin
    PresentationTextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'concentration') then
  begin
    Concentration := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'concentrationHighLimit') then
  begin
    ConcentrationHighLimit := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'concentrationText') then
  begin
    ConcentrationTextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'referenceStrength') then
  begin
    ReferenceStrengthList.add(propValue as TFhirIngredientSubstanceStrengthReferenceStrength) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'referenceStrength') then ReferenceStrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrengthReferenceStrength) {L1049}
  else inherited;
end;

function TFhirIngredientSubstanceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'presentation') then result := TFhirRatio.create() {L1203}
  else if (propName = 'presentationHighLimit') then result := TFhirRatio.create() {L1203}
  else if (propName = 'presentationText') then result := TFhirString.create() {L1223}
  else if (propName = 'concentration') then result := TFhirRatio.create() {L1203}
  else if (propName = 'concentrationHighLimit') then result := TFhirRatio.create() {L1203}
  else if (propName = 'concentrationText') then result := TFhirString.create() {L1223}
  else if (propName = 'measurementPoint') then result := TFhirString.create() {L1223}
  else if (propName = 'country') then result := CountryList.new() {L1053}
  else if (propName = 'referenceStrength') then result := ReferenceStrengthList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'presentation') then result := 'Ratio'
  else if (propName = 'presentationHighLimit') then result := 'Ratio'
  else if (propName = 'presentationText') then result := 'string'
  else if (propName = 'concentration') then result := 'Ratio'
  else if (propName = 'concentrationHighLimit') then result := 'Ratio'
  else if (propName = 'concentrationText') then result := 'string'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'referenceStrength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'presentation') then PresentationElement := nil
  else if (propName = 'presentationHighLimit') then PresentationHighLimitElement := nil
  else if (propName = 'presentationText') then PresentationTextElement := nil
  else if (propName = 'concentration') then ConcentrationElement := nil
  else if (propName = 'concentrationHighLimit') then ConcentrationHighLimitElement := nil
  else if (propName = 'concentrationText') then ConcentrationTextElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value) {L1054}
  else if (propName = 'referenceStrength') then deletePropertyValue('referenceStrength', ReferenceStrengthList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'presentation') then PresentationElement := new as TFhirRatio {L1195}
  else if (propName = 'presentationHighLimit') then PresentationHighLimitElement := new as TFhirRatio {L1195}
  else if (propName = 'presentationText') then PresentationTextElement := asString(new) {L1222}
  else if (propName = 'concentration') then ConcentrationElement := new as TFhirRatio {L1195}
  else if (propName = 'concentrationHighLimit') then ConcentrationHighLimitElement := new as TFhirRatio {L1195}
  else if (propName = 'concentrationText') then ConcentrationTextElement := asString(new) {L1222}
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new) {L1222}
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new) {L1055}
  else if (propName = 'referenceStrength') then replacePropertyValue('referenceStrength', ReferenceStrengthList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination) {L1050}
  else if (propName = 'referenceStrength') then ReferenceStrengthList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength';
end;

function TFhirIngredientSubstanceStrength.Link : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrength.Clone : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrength(other);
    result := compareDeep(presentationElement, o.presentationElement, true) and 
      compareDeep(presentationHighLimitElement, o.presentationHighLimitElement, true) and 
      compareDeep(presentationTextElement, o.presentationTextElement, true) and compareDeep(concentrationElement, o.concentrationElement, true) and 
      compareDeep(concentrationHighLimitElement, o.concentrationHighLimitElement, true) and 
      compareDeep(concentrationTextElement, o.concentrationTextElement, true) and compareDeep(measurementPointElement, o.measurementPointElement, true) and 
      compareDeep(countryList, o.countryList, true) and compareDeep(referenceStrengthList, o.referenceStrengthList, true);
  end;
end;

function TFhirIngredientSubstanceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPresentation) and isEmptyProp(FPresentationHighLimit) and isEmptyProp(FPresentationText) and isEmptyProp(FConcentration) and isEmptyProp(FConcentrationHighLimit) and isEmptyProp(FConcentrationText) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList) and isEmptyProp(FreferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.SetPresentation(value : TFhirRatio);
begin
  FPresentation.free;
  FPresentation := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrength.SetPresentationHighLimit(value : TFhirRatio);
begin
  FPresentationHighLimit.free;
  FPresentationHighLimit := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrength.SetPresentationText(value : TFhirString);
begin
  FPresentationText.free;
  FPresentationText := value; {L1134}
end;

function TFhirIngredientSubstanceStrength.GetPresentationTextST : String;
begin
  if FPresentationText = nil then
    result := ''
  else
    result := FPresentationText.value;
end;

procedure TFhirIngredientSubstanceStrength.SetPresentationTextST(value : String);
begin
  if value <> '' then
  begin
    if FPresentationText = nil then
      FPresentationText := TFhirString.create;
    FPresentationText.value := value
  end
  else if FPresentationText <> nil then
    FPresentationText.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetConcentration(value : TFhirRatio);
begin
  FConcentration.free;
  FConcentration := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrength.SetConcentrationHighLimit(value : TFhirRatio);
begin
  FConcentrationHighLimit.free;
  FConcentrationHighLimit := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrength.SetConcentrationText(value : TFhirString);
begin
  FConcentrationText.free;
  FConcentrationText := value; {L1134}
end;

function TFhirIngredientSubstanceStrength.GetConcentrationTextST : String;
begin
  if FConcentrationText = nil then
    result := ''
  else
    result := FConcentrationText.value;
end;

procedure TFhirIngredientSubstanceStrength.SetConcentrationTextST(value : String);
begin
  if value <> '' then
  begin
    if FConcentrationText = nil then
      FConcentrationText := TFhirString.create;
    FConcentrationText.value := value
  end
  else if FConcentrationText <> nil then
    FConcentrationText.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value; {L1134}
end;

function TFhirIngredientSubstanceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

function TFhirIngredientSubstanceStrength.GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  if FReferenceStrengthList = nil then
    FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
  result := FReferenceStrengthList;
end;

function TFhirIngredientSubstanceStrength.GetHasReferenceStrengthList : boolean;
begin
  result := (FReferenceStrengthList <> nil) and (FReferenceStrengthList.count > 0);
end;

procedure TFhirIngredientSubstanceStrength.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('presentation');
  fields.add('presentationHighLimit');
  fields.add('presentationText');
  fields.add('concentration');
  fields.add('concentrationHighLimit');
  fields.add('concentrationText');
  fields.add('measurementPoint');
  fields.add('country');
  fields.add('referenceStrength');
end;

function TFhirIngredientSubstanceStrength.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPresentation.sizeInBytes);
  inc(result, FPresentationHighLimit.sizeInBytes);
  inc(result, FPresentationText.sizeInBytes);
  inc(result, FConcentration.sizeInBytes);
  inc(result, FConcentrationHighLimit.sizeInBytes);
  inc(result, FConcentrationText.sizeInBytes);
  inc(result, FMeasurementPoint.sizeInBytes);
  inc(result, FcountryList.sizeInBytes);
  inc(result, FreferenceStrengthList.sizeInBytes);
end;

{ TFhirIngredientSubstanceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIngredientSubstanceStrengthList }

procedure TFhirIngredientSubstanceStrengthList.AddItem(value: TFhirIngredientSubstanceStrength);
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrength');
  add(value);
end;

function TFhirIngredientSubstanceStrengthList.Append: TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthList.Clone: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrength;
end;
function TFhirIngredientSubstanceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.Link: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  FhirIngredientSubstanceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrengthReferenceStrength }

constructor TFhirIngredientSubstanceStrengthReferenceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrength.Destroy;
begin
  FSubstance.free;
  FStrength.free;
  FStrengthHighLimit.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).substance.Clone;
  strength := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).strength.Clone;
  strengthHighLimit := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).strengthHighLimit.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList);
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'strengthHighLimit') Then
     list.add(self.link, 'strengthHighLimit', FStrengthHighLimit.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strengthHighLimit', 'Ratio', false, TFhirRatio, FStrengthHighLimit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link)) {L1039};
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then
  begin
    Substance := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'strengthHighLimit') then
  begin
    StrengthHighLimit := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Substance') {L1191}
  else if (propName = 'strength') then result := TFhirRatio.create() {L1203}
  else if (propName = 'strengthHighLimit') then result := TFhirRatio.create() {L1203}
  else if (propName = 'measurementPoint') then result := TFhirString.create() {L1223}
  else if (propName = 'country') then result := CountryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'strength') then result := 'Ratio'
  else if (propName = 'strengthHighLimit') then result := 'Ratio'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := nil {L1189}
  else if (propName = 'strength') then StrengthElement := nil
  else if (propName = 'strengthHighLimit') then StrengthHighLimitElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := new as TFhirDataType {L1190}
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio {L1195}
  else if (propName = 'strengthHighLimit') then StrengthHighLimitElement := new as TFhirRatio {L1195}
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new) {L1222}
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength.referenceStrength';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Link : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Clone : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrengthReferenceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrengthReferenceStrength(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(strengthElement, o.strengthElement, true) and 
      compareDeep(strengthHighLimitElement, o.strengthHighLimitElement, true) and compareDeep(measurementPointElement, o.measurementPointElement, true) and 
      compareDeep(countryList, o.countryList, true);
  end;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FStrength) and isEmptyProp(FStrengthHighLimit) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetSubstance(value : TFhirDataType);
begin
  FSubstance.free;
  FSubstance := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetStrengthHighLimit(value : TFhirRatio);
begin
  FStrengthHighLimit.free;
  FStrengthHighLimit := value; {L1134}
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value; {L1134}
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance[x]');
  fields.add('strength');
  fields.add('strengthHighLimit');
  fields.add('measurementPoint');
  fields.add('country');
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
  inc(result, FStrengthHighLimit.sizeInBytes);
  inc(result, FMeasurementPoint.sizeInBytes);
  inc(result, FcountryList.sizeInBytes);
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthList }

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.AddItem(value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrengthReferenceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrengthReferenceStrength');
  add(value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Append: TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Clone: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength;
end;
function TFhirIngredientSubstanceStrengthReferenceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrengthReferenceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Link: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  FhirIngredientSubstanceStrengthReferenceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSpecifiedSubstance }

constructor TFhirIngredientSpecifiedSubstance.Create;
begin
  inherited;
end;

destructor TFhirIngredientSpecifiedSubstance.Destroy;
begin
  FCode.free;
  FGroup.free;
  FConfidentiality.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSpecifiedSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirIngredientSpecifiedSubstance(oSource).code.Clone;
  group := TFhirIngredientSpecifiedSubstance(oSource).group.Clone;
  confidentiality := TFhirIngredientSpecifiedSubstance(oSource).confidentiality.Clone;
  if (TFhirIngredientSpecifiedSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirIngredientSpecifiedSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirIngredientSpecifiedSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code[x]') or (child_name = 'code') Then
     list.add(self.link, 'code[x]', FCode.Link);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirIngredientSpecifiedSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code[x]', 'CodeableConcept|Reference', false, TFhirDataType, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'group', 'CodeableConcept', false, TFhirCodeableConcept, FGroup.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentiality.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strength', '', true, TFhirIngredientSubstanceStrength, FStrengthList.Link)) {L1039};
end;

function TFhirIngredientSpecifiedSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then
  begin
    Code := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    Group := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'confidentiality') then
  begin
    Confidentiality := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirIngredientSubstanceStrength) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSpecifiedSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrength) {L1049}
  else inherited;
end;

function TFhirIngredientSpecifiedSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Code') {L1191}
  else if (propName = 'group') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'confidentiality') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'strength') then result := StrengthList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSpecifiedSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'group') then result := 'CodeableConcept'
  else if (propName = 'confidentiality') then result := 'CodeableConcept'
  else if (propName = 'strength') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSpecifiedSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then CodeElement := nil {L1189}
  else if (propName = 'group') then GroupElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSpecifiedSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'code', ['CodeableConcept', 'Reference'])) then CodeElement := new as TFhirDataType {L1190}
  else if (propName = 'group') then GroupElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'confidentiality') then ConfidentialityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSpecifiedSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSpecifiedSubstance.fhirType : string;
begin
  result := 'Ingredient.specifiedSubstance';
end;

function TFhirIngredientSpecifiedSubstance.Link : TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance(inherited Link);
end;

function TFhirIngredientSpecifiedSubstance.Clone : TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance(inherited Clone);
end;

function TFhirIngredientSpecifiedSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSpecifiedSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSpecifiedSubstance)) then
    result := false
  else
  begin
    o := TFhirIngredientSpecifiedSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(groupElement, o.groupElement, true) and 
      compareDeep(confidentialityElement, o.confidentialityElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirIngredientSpecifiedSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FGroup) and isEmptyProp(FConfidentiality) and isEmptyProp(FstrengthList);
end;

procedure TFhirIngredientSpecifiedSubstance.SetCode(value : TFhirDataType);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirIngredientSpecifiedSubstance.SetGroup(value : TFhirCodeableConcept);
begin
  FGroup.free;
  FGroup := value; {L1134}
end;

procedure TFhirIngredientSpecifiedSubstance.SetConfidentiality(value : TFhirCodeableConcept);
begin
  FConfidentiality.free;
  FConfidentiality := value; {L1134}
end;

function TFhirIngredientSpecifiedSubstance.GetStrengthList : TFhirIngredientSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
  result := FStrengthList;
end;

function TFhirIngredientSpecifiedSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

procedure TFhirIngredientSpecifiedSubstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code[x]');
  fields.add('group');
  fields.add('confidentiality');
  fields.add('strength');
end;

function TFhirIngredientSpecifiedSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FGroup.sizeInBytes);
  inc(result, FConfidentiality.sizeInBytes);
  inc(result, FstrengthList.sizeInBytes);
end;

{ TFhirIngredientSpecifiedSubstanceListEnumerator }

constructor TFhirIngredientSpecifiedSubstanceListEnumerator.Create(list : TFhirIngredientSpecifiedSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSpecifiedSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSpecifiedSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSpecifiedSubstanceListEnumerator.GetCurrent : TFhirIngredientSpecifiedSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSpecifiedSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIngredientSpecifiedSubstanceList }

procedure TFhirIngredientSpecifiedSubstanceList.AddItem(value: TFhirIngredientSpecifiedSubstance);
begin
  assert(value.ClassName = 'TFhirIngredientSpecifiedSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSpecifiedSubstance');
  add(value);
end;

function TFhirIngredientSpecifiedSubstanceList.Append: TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSpecifiedSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSpecifiedSubstanceList.GetEnumerator : TFhirIngredientSpecifiedSubstanceListEnumerator;
begin
  result := TFhirIngredientSpecifiedSubstanceListEnumerator.Create(self.link);
end;

function TFhirIngredientSpecifiedSubstanceList.Clone: TFhirIngredientSpecifiedSubstanceList;
begin
  result := TFhirIngredientSpecifiedSubstanceList(inherited Clone);
end;

function TFhirIngredientSpecifiedSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSpecifiedSubstanceList.GetItemN(index: Integer): TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSpecifiedSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSpecifiedSubstance;
end;
function TFhirIngredientSpecifiedSubstanceList.IndexOf(value: TFhirIngredientSpecifiedSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSpecifiedSubstanceList.Insert(index: Integer): TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSpecifiedSubstanceList.InsertItem(index: Integer; value: TFhirIngredientSpecifiedSubstance);
begin
  assert(value is TFhirIngredientSpecifiedSubstance);
  Inherited Insert(index, value);
end;

function TFhirIngredientSpecifiedSubstanceList.Item(index: Integer): TFhirIngredientSpecifiedSubstance;
begin
  result := TFhirIngredientSpecifiedSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSpecifiedSubstanceList.Link: TFhirIngredientSpecifiedSubstanceList;
begin
  result := TFhirIngredientSpecifiedSubstanceList(inherited Link);
end;

procedure TFhirIngredientSpecifiedSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSpecifiedSubstanceList.SetItemByIndex(index: Integer; value: TFhirIngredientSpecifiedSubstance);
begin
  assert(value is TFhirIngredientSpecifiedSubstance);
  FhirIngredientSpecifiedSubstances[index] := value;
end;

procedure TFhirIngredientSpecifiedSubstanceList.SetItemN(index: Integer; value: TFhirIngredientSpecifiedSubstance);
begin
  assert(value is TFhirIngredientSpecifiedSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredient }

constructor TFhirIngredient.Create;
begin
  inherited;
end;

destructor TFhirIngredient.Destroy;
begin
  FIdentifier.free;
  FRole.free;
  FFunction_List.Free;
  FDescription.free;
  FAllergenicIndicator.free;
  FManufacturerList.Free;
  FSubstance.free;
  FSpecifiedSubstanceList.Free;
  inherited;
end;

procedure TFhirIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirIngredient(oSource).identifier.Clone;
  role := TFhirIngredient(oSource).role.Clone;
  if (TFhirIngredient(oSource).FFunction_List = nil) then
  begin
    FFunction_List.free;
    FFunction_List := nil;
  end
  else
  begin
    if FFunction_List = nil then
      FFunction_List := TFhirCodeableConceptList.Create;
    FFunction_List.Assign(TFhirIngredient(oSource).FFunction_List);
  end;
  descriptionElement := TFhirIngredient(oSource).descriptionElement.Clone;
  allergenicIndicatorElement := TFhirIngredient(oSource).allergenicIndicatorElement.Clone;
  if (TFhirIngredient(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirIngredient(oSource).FManufacturerList);
  end;
  substance := TFhirIngredient(oSource).substance.Clone;
  if (TFhirIngredient(oSource).FSpecifiedSubstanceList = nil) then
  begin
    FSpecifiedSubstanceList.free;
    FSpecifiedSubstanceList := nil;
  end
  else
  begin
    if FSpecifiedSubstanceList = nil then
      FSpecifiedSubstanceList := TFhirIngredientSpecifiedSubstanceList.Create;
    FSpecifiedSubstanceList.Assign(TFhirIngredient(oSource).FSpecifiedSubstanceList);
  end;
end;

function TFhirIngredient.GetResourceType : TFhirResourceType;
begin
  result := frtIngredient;
end;

procedure TFhirIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
    list.addAll(self, 'function', FFunction_List);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'specifiedSubstance') Then
    list.addAll(self, 'specifiedSubstance', FSpecifiedSubstanceList);
end;

procedure TFhirIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', true, TFhirCodeableConcept, FFunction_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'substance', 'BackboneElement', false, TFhirIngredientSubstance, FSubstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specifiedSubstance', 'BackboneElement', true, TFhirIngredientSpecifiedSubstance, FSpecifiedSubstanceList.Link)) {L1039};
end;

function TFhirIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'substance') then
  begin
    Substance := propValue as TFhirIngredientSubstance {L1199};
    result := propValue;
  end
  else if (propName = 'specifiedSubstance') then
  begin
    SpecifiedSubstanceList.add(propValue as TFhirIngredientSpecifiedSubstance) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'function') then Function_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'specifiedSubstance') then SpecifiedSubstanceList.insertItem(index, propValue as TFhirIngredientSpecifiedSubstance) {L1049}
  else inherited;
end;

function TFhirIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'function') then result := Function_List.new() {L1053}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'substance') then result := TFhirIngredientSubstance.create() {L1203}
  else if (propName = 'specifiedSubstance') then result := SpecifiedSubstanceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'substance') then result := 'BackboneElement'
  else if (propName = 'specifiedSubstance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then deletePropertyValue('function', Function_List, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'specifiedSubstance') then deletePropertyValue('specifiedSubstance', SpecifiedSubstanceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'function') then replacePropertyValue('function', Function_List, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new) {L1222}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'substance') then SubstanceElement := new as TFhirIngredientSubstance {L1195}
  else if (propName = 'specifiedSubstance') then replacePropertyValue('specifiedSubstance', SpecifiedSubstanceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'function') then Function_List.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'specifiedSubstance') then SpecifiedSubstanceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredient.fhirType : string;
begin
  result := 'Ingredient';
end;

function TFhirIngredient.Link : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Link);
end;

function TFhirIngredient.Clone : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Clone);
end;

function TFhirIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredient)) then
    result := false
  else
  begin
    o := TFhirIngredient(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(function_List, o.function_List, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(substanceElement, o.substanceElement, true) and 
      compareDeep(specifiedSubstanceList, o.specifiedSubstanceList, true);
  end;
end;

function TFhirIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRole) and isEmptyProp(Ffunction_List) and isEmptyProp(FDescription) and isEmptyProp(FAllergenicIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FSubstance) and isEmptyProp(FspecifiedSubstanceList);
end;

procedure TFhirIngredient.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirIngredient.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

function TFhirIngredient.GetFunction_List : TFhirCodeableConceptList;
begin
  if FFunction_List = nil then
    FFunction_List := TFhirCodeableConceptList.Create;
  result := FFunction_List;
end;

function TFhirIngredient.GetHasFunction_List : boolean;
begin
  result := (FFunction_List <> nil) and (FFunction_List.count > 0);
end;

procedure TFhirIngredient.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirIngredient.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirIngredient.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirIngredient.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value; {L1134}
end;

function TFhirIngredient.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirIngredient.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

function TFhirIngredient.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirIngredient.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

procedure TFhirIngredient.SetSubstance(value : TFhirIngredientSubstance);
begin
  FSubstance.free;
  FSubstance := value; {L1134}
end;

function TFhirIngredient.GetSpecifiedSubstanceList : TFhirIngredientSpecifiedSubstanceList;
begin
  if FSpecifiedSubstanceList = nil then
    FSpecifiedSubstanceList := TFhirIngredientSpecifiedSubstanceList.Create;
  result := FSpecifiedSubstanceList;
end;

function TFhirIngredient.GetHasSpecifiedSubstanceList : boolean;
begin
  result := (FSpecifiedSubstanceList <> nil) and (FSpecifiedSubstanceList.count > 0);
end;

procedure TFhirIngredient.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('role');
  fields.add('function');
  fields.add('description');
  fields.add('allergenicIndicator');
  fields.add('manufacturer');
  fields.add('substance');
  fields.add('specifiedSubstance');
end;

function TFhirIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, Ffunction_List.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAllergenicIndicator.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FSubstance.sizeInBytes);
  inc(result, FspecifiedSubstanceList.sizeInBytes);
end;

{ TFhirIngredientListEnumerator }

constructor TFhirIngredientListEnumerator.Create(list : TFhirIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientListEnumerator.GetCurrent : TFhirIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIngredientList }

procedure TFhirIngredientList.AddItem(value: TFhirIngredient);
begin
  assert(value.ClassName = 'TFhirIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredient');
  add(value);
end;

function TFhirIngredientList.Append: TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientList.GetEnumerator : TFhirIngredientListEnumerator;
begin
  result := TFhirIngredientListEnumerator.Create(self.link);
end;

function TFhirIngredientList.Clone: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Clone);
end;

function TFhirIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientList.GetItemN(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredient;
end;
function TFhirIngredientList.IndexOf(value: TFhirIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientList.Insert(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.InsertItem(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  Inherited Insert(index, value);
end;

function TFhirIngredientList.Item(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.Link: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Link);
end;

procedure TFhirIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientList.SetItemByIndex(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  FhirIngredients[index] := value;
end;

procedure TFhirIngredientList.SetItemN(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
{ TFhirManufacturedItemDefinitionProperty }

constructor TFhirManufacturedItemDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirManufacturedItemDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirManufacturedItemDefinitionProperty(oSource).type_.Clone;
  value := TFhirManufacturedItemDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirManufacturedItemDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirManufacturedItemDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirManufacturedItemDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirManufacturedItemDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinitionProperty.fhirType : string;
begin
  result := 'ManufacturedItemDefinition.property';
end;

function TFhirManufacturedItemDefinitionProperty.Link : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Link);
end;

function TFhirManufacturedItemDefinitionProperty.Clone : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Clone);
end;

function TFhirManufacturedItemDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirManufacturedItemDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirManufacturedItemDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirManufacturedItemDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirManufacturedItemDefinitionProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirManufacturedItemDefinitionPropertyListEnumerator }

constructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(list : TFhirManufacturedItemDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.GetCurrent : TFhirManufacturedItemDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirManufacturedItemDefinitionPropertyList }

procedure TFhirManufacturedItemDefinitionPropertyList.AddItem(value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinitionProperty');
  add(value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Append: TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionPropertyList.Clone: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetItemN(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinitionProperty;
end;
function TFhirManufacturedItemDefinitionPropertyList.IndexOf(value: TFhirManufacturedItemDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Insert(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Item(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.Link: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  FhirManufacturedItemDefinitionProperties[index] := value;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirManufacturedItemDefinition }

constructor TFhirManufacturedItemDefinition.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinition.Destroy;
begin
  FIdentifierList.Free;
  FManufacturedDoseForm.free;
  FUnitOfPresentation.free;
  FManufacturerList.Free;
  FIngredientList.Free;
  FProperty_List.Free;
  inherited;
end;

procedure TFhirManufacturedItemDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirManufacturedItemDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirManufacturedItemDefinition(oSource).FIdentifierList);
  end;
  manufacturedDoseForm := TFhirManufacturedItemDefinition(oSource).manufacturedDoseForm.Clone;
  unitOfPresentation := TFhirManufacturedItemDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirManufacturedItemDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirManufacturedItemDefinition(oSource).FManufacturerList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirReferenceList.Create;
    FIngredientList.Assign(TFhirManufacturedItemDefinition(oSource).FIngredientList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirManufacturedItemDefinition(oSource).FProperty_List);
  end;
end;

function TFhirManufacturedItemDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtManufacturedItemDefinition;
end;

procedure TFhirManufacturedItemDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'manufacturedDoseForm') Then
     list.add(self.link, 'manufacturedDoseForm', FManufacturedDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
end;

procedure TFhirManufacturedItemDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manufacturedDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FManufacturedDoseForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'Reference', true, TFhirReference, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirManufacturedItemDefinitionProperty, FProperty_List.Link)) {L1039};
end;

function TFhirManufacturedItemDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'manufacturedDoseForm') then
  begin
    ManufacturedDoseForm := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirManufacturedItemDefinitionProperty) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirManufacturedItemDefinitionProperty) {L1049}
  else inherited;
end;

function TFhirManufacturedItemDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'manufacturedDoseForm') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'manufacturedDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinition.fhirType : string;
begin
  result := 'ManufacturedItemDefinition';
end;

function TFhirManufacturedItemDefinition.Link : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Link);
end;

function TFhirManufacturedItemDefinition.Clone : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Clone);
end;

function TFhirManufacturedItemDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinition)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(manufacturedDoseFormElement, o.manufacturedDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(property_List, o.property_List, true);
  end;
end;

function TFhirManufacturedItemDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FManufacturedDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FmanufacturerList) and isEmptyProp(FingredientList) and isEmptyProp(Fproperty_List);
end;

function TFhirManufacturedItemDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirManufacturedItemDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirManufacturedItemDefinition.SetManufacturedDoseForm(value : TFhirCodeableConcept);
begin
  FManufacturedDoseForm.free;
  FManufacturedDoseForm := value; {L1134}
end;

procedure TFhirManufacturedItemDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value; {L1134}
end;

function TFhirManufacturedItemDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirManufacturedItemDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetIngredientList : TFhirReferenceList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirReferenceList.Create;
  result := FIngredientList;
end;

function TFhirManufacturedItemDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirManufacturedItemDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirManufacturedItemDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('manufacturedDoseForm');
  fields.add('unitOfPresentation');
  fields.add('manufacturer');
  fields.add('ingredient');
  fields.add('property');
end;

function TFhirManufacturedItemDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FManufacturedDoseForm.sizeInBytes);
  inc(result, FUnitOfPresentation.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
end;

{ TFhirManufacturedItemDefinitionListEnumerator }

constructor TFhirManufacturedItemDefinitionListEnumerator.Create(list : TFhirManufacturedItemDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionListEnumerator.GetCurrent : TFhirManufacturedItemDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirManufacturedItemDefinitionList }

procedure TFhirManufacturedItemDefinitionList.AddItem(value: TFhirManufacturedItemDefinition);
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinition');
  add(value);
end;

function TFhirManufacturedItemDefinitionList.Append: TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionList.GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionList.Clone: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionList.GetItemN(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinition;
end;
function TFhirManufacturedItemDefinitionList.IndexOf(value: TFhirManufacturedItemDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionList.Insert(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionList.Item(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.Link: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  FhirManufacturedItemDefinitions[index] := value;
end;

procedure TFhirManufacturedItemDefinitionList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
{ TFhirMedicationIngredient }

constructor TFhirMedicationIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
end;

procedure TFhirMedicationIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|CodeableConcept|Quantity', false, TFhirDataType, FStrength.Link)); {L1172}
end;

function TFhirMedicationIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then
  begin
    Strength := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'isActive') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Strength') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength[x]') then result := 'Ratio|CodeableConcept|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationIngredient.fhirType : string;
begin
  result := 'Medication.ingredient';
end;

function TFhirMedicationIngredient.Link : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Link);
end;

function TFhirMedicationIngredient.Clone : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Clone);
end;

function TFhirMedicationIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirMedicationIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value; {L1134}
end;

function TFhirMedicationIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

procedure TFhirMedicationIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

procedure TFhirMedicationIngredient.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value; {L1134}
end;

procedure TFhirMedicationIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('isActive');
  fields.add('strength[x]');
end;

function TFhirMedicationIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FIsActive.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
end;

{ TFhirMedicationIngredientListEnumerator }

constructor TFhirMedicationIngredientListEnumerator.Create(list : TFhirMedicationIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationIngredientListEnumerator.GetCurrent : TFhirMedicationIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationIngredientList }

procedure TFhirMedicationIngredientList.AddItem(value: TFhirMedicationIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationIngredient');
  add(value);
end;

function TFhirMedicationIngredientList.Append: TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationIngredientList.GetEnumerator : TFhirMedicationIngredientListEnumerator;
begin
  result := TFhirMedicationIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationIngredientList.Clone: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Clone);
end;

function TFhirMedicationIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationIngredientList.GetItemN(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationIngredient;
end;
function TFhirMedicationIngredientList.IndexOf(value: TFhirMedicationIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationIngredientList.Insert(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.InsertItem(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationIngredientList.Item(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.Link: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Link);
end;

procedure TFhirMedicationIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  FhirMedicationIngredients[index] := value;
end;

procedure TFhirMedicationIngredientList.SetItemN(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationBatch }

constructor TFhirMedicationBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link)); {L1172}
end;

function TFhirMedicationBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'expirationDate') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new) {L1222}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationBatch.fhirType : string;
begin
  result := 'Medication.batch';
end;

function TFhirMedicationBatch.Link : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Link);
end;

function TFhirMedicationBatch.Clone : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Clone);
end;

function TFhirMedicationBatch.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value; {L1134}
end;

function TFhirMedicationBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirMedicationBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirMedicationBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value; {L1134}
end;

function TFhirMedicationBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirMedicationBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

procedure TFhirMedicationBatch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

function TFhirMedicationBatch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
end;

{ TFhirMedicationBatchListEnumerator }

constructor TFhirMedicationBatchListEnumerator.Create(list : TFhirMedicationBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationBatchListEnumerator.GetCurrent : TFhirMedicationBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationBatchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationBatchList }

procedure TFhirMedicationBatchList.AddItem(value: TFhirMedicationBatch);
begin
  assert(value.ClassName = 'TFhirMedicationBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationBatch');
  add(value);
end;

function TFhirMedicationBatchList.Append: TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationBatchList.GetEnumerator : TFhirMedicationBatchListEnumerator;
begin
  result := TFhirMedicationBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationBatchList.Clone: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Clone);
end;

function TFhirMedicationBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationBatchList.GetItemN(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationBatch;
end;
function TFhirMedicationBatchList.IndexOf(value: TFhirMedicationBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationBatchList.Insert(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.InsertItem(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationBatchList.Item(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.Link: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Link);
end;

procedure TFhirMedicationBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  FhirMedicationBatches[index] := value;
end;

procedure TFhirMedicationBatchList.SetItemN(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  FManufacturer.free;
  FDoseForm.free;
  FAmount.free;
  FIngredientList.Free;
  FBatch.free;
  inherited;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedication(oSource).FIdentifierList);
  end;
  code := TFhirMedication(oSource).code.Clone;
  statusElement := TFhirMedication(oSource).statusElement.Clone;
  manufacturer := TFhirMedication(oSource).manufacturer.Clone;
  doseForm := TFhirMedication(oSource).doseForm.Clone;
  amount := TFhirMedication(oSource).amount.Clone;
  if (TFhirMedication(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationIngredientList.Create;
    FIngredientList.Assign(TFhirMedication(oSource).FIngredientList);
  end;
  batch := TFhirMedication(oSource).batch.Clone;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'batch') Then
     list.add(self.link, 'batch', FBatch.Link);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', false, TFhirRatio, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationIngredient, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'batch', 'BackboneElement', false, TFhirMedicationBatch, FBatch.Link)); {L1172}
end;

function TFhirMedication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationIngredient) {L1048};
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    Batch := propValue as TFhirMedicationBatch {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationIngredient) {L1049}
  else inherited;
end;

function TFhirMedication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull], CODES_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull])  {L1211}
  else if (propName = 'manufacturer') then result := TFhirReference.create() {L1203}
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirRatio.create() {L1203}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'batch') then result := TFhirMedicationBatch.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Ratio'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'batch') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'batch') then BatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, new) {L1210}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference {L1195}
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirRatio {L1195}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'batch') then BatchElement := new as TFhirMedicationBatch {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

function TFhirMedication.equals(other : TObject) : boolean; 
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(doseFormElement, o.doseFormElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(batchElement, o.batchElement, true);
  end;
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FManufacturer) and isEmptyProp(FDoseForm) and isEmptyProp(FAmount) and isEmptyProp(FingredientList) and isEmptyProp(FBatch);
end;

function TFhirMedication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirMedication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedication.GetStatusST : TFhirMedicationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusCodesEnum(0)
  else
    result := TFhirMedicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedication.SetStatusST(value : TFhirMedicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[value], CODES_TFhirMedicationStatusCodesEnum[value]);
end;

procedure TFhirMedication.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value; {L1134}
end;

procedure TFhirMedication.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value; {L1134}
end;

procedure TFhirMedication.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

function TFhirMedication.GetIngredientList : TFhirMedicationIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedication.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirMedication.SetBatch(value : TFhirMedicationBatch);
begin
  FBatch.free;
  FBatch := value; {L1134}
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('manufacturer');
  fields.add('doseForm');
  fields.add('amount');
  fields.add('ingredient');
  fields.add('batch');
end;

function TFhirMedication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FDoseForm.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FBatch.sizeInBytes);
end;

{ TFhirMedicationListEnumerator }

constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationList }

procedure TFhirMedicationList.AddItem(value: TFhirMedication);
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
{ TFhirMedicationKnowledgeRelatedMedicationKnowledge }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Destroy;
begin
  FType_.free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList);
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link)) {L1039};
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reference') then result := ReferenceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge.relatedMedicationKnowledge';
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRelatedMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRelatedMedicationKnowledge(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(referenceList, o.referenceList, true);
  end;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FreferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('reference');
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FreferenceList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeList }

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRelatedMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRelatedMedicationKnowledge');
  add(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Append: TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge;
end;
function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Link: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  FhirMedicationKnowledgeRelatedMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonograph }

constructor TFhirMedicationKnowledgeMonograph.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonograph.Destroy;
begin
  FType_.free;
  FSource.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonograph.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonograph(oSource).type_.Clone;
  source := TFhirMedicationKnowledgeMonograph(oSource).source.Clone;
end;

procedure TFhirMedicationKnowledgeMonograph.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
end;

procedure TFhirMedicationKnowledgeMonograph.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link)); {L1172}
end;

function TFhirMedicationKnowledgeMonograph.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonograph.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonograph.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonograph.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonograph.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonograph.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then SourceElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonograph.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonograph.fhirType : string;
begin
  result := 'MedicationKnowledge.monograph';
end;

function TFhirMedicationKnowledgeMonograph.Link : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Link);
end;

function TFhirMedicationKnowledgeMonograph.Clone : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Clone);
end;

function TFhirMedicationKnowledgeMonograph.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonograph;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonograph)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonograph(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonograph.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource);
end;

procedure TFhirMedicationKnowledgeMonograph.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeMonograph.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value; {L1134}
end;

procedure TFhirMedicationKnowledgeMonograph.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
end;

function TFhirMedicationKnowledgeMonograph.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FSource.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonographListEnumerator }

constructor TFhirMedicationKnowledgeMonographListEnumerator.Create(list : TFhirMedicationKnowledgeMonographList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonographListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonograph;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonographListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonographList }

procedure TFhirMedicationKnowledgeMonographList.AddItem(value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonograph', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonograph');
  add(value);
end;

function TFhirMedicationKnowledgeMonographList.Append: TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonographList.GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonographListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonographList.Clone: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonographList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonographList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonograph;
end;
function TFhirMedicationKnowledgeMonographList.IndexOf(value: TFhirMedicationKnowledgeMonograph): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonographList.Insert(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonographList.Item(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.Link: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonographList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  FhirMedicationKnowledgeMonographs[index] := value;
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIngredient }

constructor TFhirMedicationKnowledgeIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationKnowledgeIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationKnowledgeIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationKnowledgeIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationKnowledgeIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
end;

procedure TFhirMedicationKnowledgeIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|CodeableConcept|Quantity', false, TFhirDataType, FStrength.Link)); {L1172}
end;

function TFhirMedicationKnowledgeIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then
  begin
    Strength := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'isActive') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Strength') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength[x]') then result := 'Ratio|CodeableConcept|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'strength', ['Ratio', 'CodeableConcept', 'Quantity'])) then StrengthElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIngredient.fhirType : string;
begin
  result := 'MedicationKnowledge.ingredient';
end;

function TFhirMedicationKnowledgeIngredient.Link : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Link);
end;

function TFhirMedicationKnowledgeIngredient.Clone : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationKnowledgeIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationKnowledgeIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

procedure TFhirMedicationKnowledgeIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value; {L1134}
end;

function TFhirMedicationKnowledgeIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

procedure TFhirMedicationKnowledgeIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

procedure TFhirMedicationKnowledgeIngredient.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value; {L1134}
end;

procedure TFhirMedicationKnowledgeIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('isActive');
  fields.add('strength[x]');
end;

function TFhirMedicationKnowledgeIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FIsActive.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
end;

{ TFhirMedicationKnowledgeIngredientListEnumerator }

constructor TFhirMedicationKnowledgeIngredientListEnumerator.Create(list : TFhirMedicationKnowledgeIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.GetCurrent : TFhirMedicationKnowledgeIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeIngredientList }

procedure TFhirMedicationKnowledgeIngredientList.AddItem(value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIngredient');
  add(value);
end;

function TFhirMedicationKnowledgeIngredientList.Append: TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIngredientList.GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
begin
  result := TFhirMedicationKnowledgeIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIngredientList.Clone: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIngredientList.GetItemN(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIngredient;
end;
function TFhirMedicationKnowledgeIngredientList.IndexOf(value: TFhirMedicationKnowledgeIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIngredientList.Insert(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIngredientList.Item(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.Link: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  FhirMedicationKnowledgeIngredients[index] := value;
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeCost }

constructor TFhirMedicationKnowledgeCost.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeCost.Destroy;
begin
  FEffectiveDateList.Free;
  FType_.free;
  FSource.free;
  FCost.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeCost.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeCost(oSource).FEffectiveDateList = nil) then
  begin
    FEffectiveDateList.free;
    FEffectiveDateList := nil;
  end
  else
  begin
    if FEffectiveDateList = nil then
      FEffectiveDateList := TFhirPeriodList.Create;
    FEffectiveDateList.Assign(TFhirMedicationKnowledgeCost(oSource).FEffectiveDateList);
  end;
  type_ := TFhirMedicationKnowledgeCost(oSource).type_.Clone;
  sourceElement := TFhirMedicationKnowledgeCost(oSource).sourceElement.Clone;
  cost := TFhirMedicationKnowledgeCost(oSource).cost.Clone;
end;

procedure TFhirMedicationKnowledgeCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'effectiveDate') Then
    list.addAll(self, 'effectiveDate', FEffectiveDateList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'cost[x]') or (child_name = 'cost') Then
     list.add(self.link, 'cost[x]', FCost.Link);
end;

procedure TFhirMedicationKnowledgeCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'Period', true, TFhirPeriod, FEffectiveDateList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cost[x]', 'Money|CodeableConcept', false, TFhirDataType, FCost.Link)); {L1172}
end;

function TFhirMedicationKnowledgeCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'effectiveDate') then
  begin
    EffectiveDateList.add(propValue as TFhirPeriod) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then
  begin
    Cost := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'effectiveDate') then EffectiveDateList.insertItem(index, propValue as TFhirPeriod) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'effectiveDate') then result := EffectiveDateList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := TFhirString.create() {L1223}
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Cost') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'effectiveDate') then result := 'Period'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'string'
  else if (propName = 'cost[x]') then result := 'Money|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'effectiveDate') then deletePropertyValue('effectiveDate', EffectiveDateList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then CostElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'effectiveDate') then replacePropertyValue('effectiveDate', EffectiveDateList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then SourceElement := asString(new) {L1222}
  else if (isMatchingName(propName, 'cost', ['Money', 'CodeableConcept'])) then CostElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'effectiveDate') then EffectiveDateList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeCost.fhirType : string;
begin
  result := 'MedicationKnowledge.cost';
end;

function TFhirMedicationKnowledgeCost.Link : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Link);
end;

function TFhirMedicationKnowledgeCost.Clone : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Clone);
end;

function TFhirMedicationKnowledgeCost.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeCost)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeCost(other);
    result := compareDeep(effectiveDateList, o.effectiveDateList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(costElement, o.costElement, true);
  end;
end;

function TFhirMedicationKnowledgeCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FeffectiveDateList) and isEmptyProp(FType_) and isEmptyProp(FSource) and isEmptyProp(FCost);
end;

function TFhirMedicationKnowledgeCost.GetEffectiveDateList : TFhirPeriodList;
begin
  if FEffectiveDateList = nil then
    FEffectiveDateList := TFhirPeriodList.Create;
  result := FEffectiveDateList;
end;

function TFhirMedicationKnowledgeCost.GetHasEffectiveDateList : boolean;
begin
  result := (FEffectiveDateList <> nil) and (FEffectiveDateList.count > 0);
end;

procedure TFhirMedicationKnowledgeCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeCost.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value; {L1134}
end;

function TFhirMedicationKnowledgeCost.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirMedicationKnowledgeCost.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirMedicationKnowledgeCost.SetCost(value : TFhirDataType);
begin
  FCost.free;
  FCost := value; {L1134}
end;

procedure TFhirMedicationKnowledgeCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('effectiveDate');
  fields.add('type');
  fields.add('source');
  fields.add('cost[x]');
end;

function TFhirMedicationKnowledgeCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FeffectiveDateList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FCost.sizeInBytes);
end;

{ TFhirMedicationKnowledgeCostListEnumerator }

constructor TFhirMedicationKnowledgeCostListEnumerator.Create(list : TFhirMedicationKnowledgeCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeCostListEnumerator.GetCurrent : TFhirMedicationKnowledgeCost;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeCostList }

procedure TFhirMedicationKnowledgeCostList.AddItem(value: TFhirMedicationKnowledgeCost);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeCost');
  add(value);
end;

function TFhirMedicationKnowledgeCostList.Append: TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeCostList.GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
begin
  result := TFhirMedicationKnowledgeCostListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeCostList.Clone: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Clone);
end;

function TFhirMedicationKnowledgeCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeCostList.GetItemN(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeCost;
end;
function TFhirMedicationKnowledgeCostList.IndexOf(value: TFhirMedicationKnowledgeCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeCostList.Insert(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeCostList.Item(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.Link: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Link);
end;

procedure TFhirMedicationKnowledgeCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeCostList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  FhirMedicationKnowledgeCosts[index] := value;
end;

procedure TFhirMedicationKnowledgeCostList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonitoringProgram }

constructor TFhirMedicationKnowledgeMonitoringProgram.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonitoringProgram.Destroy;
begin
  FType_.free;
  FName.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonitoringProgram(oSource).type_.Clone;
  nameElement := TFhirMedicationKnowledgeMonitoringProgram(oSource).nameElement.Clone;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
end;

function TFhirMedicationKnowledgeMonitoringProgram.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgram.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonitoringProgram.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonitoringProgram.fhirType : string;
begin
  result := 'MedicationKnowledge.monitoringProgram';
end;

function TFhirMedicationKnowledgeMonitoringProgram.Link : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Link);
end;

function TFhirMedicationKnowledgeMonitoringProgram.Clone : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgram.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonitoringProgram)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonitoringProgram(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonitoringProgram.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirMedicationKnowledgeMonitoringProgram.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
end;

function TFhirMedicationKnowledgeMonitoringProgram.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonitoringProgramListEnumerator }

constructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonitoringProgramList }

procedure TFhirMedicationKnowledgeMonitoringProgramList.AddItem(value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonitoringProgram', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonitoringProgram');
  add(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Append: TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Clone: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram;
end;
function TFhirMedicationKnowledgeMonitoringProgramList.IndexOf(value: TFhirMedicationKnowledgeMonitoringProgram): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Insert(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Item(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Link: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  FhirMedicationKnowledgeMonitoringPrograms[index] := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuideline }

constructor TFhirMedicationKnowledgeAdministrationGuideline.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuideline.Destroy;
begin
  FDosageList.Free;
  FIndication.free;
  FPatientCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeAdministrationGuideline(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuideline(oSource).FDosageList);
  end;
  indication := TFhirMedicationKnowledgeAdministrationGuideline(oSource).indication.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuideline(oSource).FPatientCharacteristicList = nil) then
  begin
    FPatientCharacteristicList.free;
    FPatientCharacteristicList := nil;
  end
  else
  begin
    if FPatientCharacteristicList = nil then
      FPatientCharacteristicList := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Create;
    FPatientCharacteristicList.Assign(TFhirMedicationKnowledgeAdministrationGuideline(oSource).FPatientCharacteristicList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'patientCharacteristic') Then
    list.addAll(self, 'patientCharacteristic', FPatientCharacteristicList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'dosage', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuidelineDosage, FDosageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableReference', false, TFhirCodeableReference, FIndication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patientCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic, FPatientCharacteristicList.Link)) {L1039};
end;

function TFhirMedicationKnowledgeAdministrationGuideline.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelineDosage) {L1048};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    Indication := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'patientCharacteristic') then
  begin
    PatientCharacteristicList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelineDosage) {L1049}
  else if (propName = 'patientCharacteristic') then PatientCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuideline.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'dosage') then result := DosageList.new() {L1053}
  else if (propName = 'indication') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'patientCharacteristic') then result := PatientCharacteristicList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuideline.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'dosage') then result := 'BackboneElement'
  else if (propName = 'indication') then result := 'CodeableReference'
  else if (propName = 'patientCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {L1054}
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'patientCharacteristic') then deletePropertyValue('patientCharacteristic', PatientCharacteristicList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {L1055}
  else if (propName = 'indication') then IndicationElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'patientCharacteristic') then replacePropertyValue('patientCharacteristic', PatientCharacteristicList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination) {L1050}
  else if (propName = 'patientCharacteristic') then PatientCharacteristicList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuideline.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuideline';
end;

function TFhirMedicationKnowledgeAdministrationGuideline.Link : TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuideline.Clone : TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuideline.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuideline;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuideline)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuideline(other);
    result := compareDeep(dosageList, o.dosageList, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(patientCharacteristicList, o.patientCharacteristicList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuideline.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdosageList) and isEmptyProp(FIndication) and isEmptyProp(FpatientCharacteristicList);
end;

function TFhirMedicationKnowledgeAdministrationGuideline.GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeAdministrationGuideline.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.SetIndication(value : TFhirCodeableReference);
begin
  FIndication.free;
  FIndication := value; {L1134}
end;

function TFhirMedicationKnowledgeAdministrationGuideline.GetPatientCharacteristicList : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
begin
  if FPatientCharacteristicList = nil then
    FPatientCharacteristicList := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Create;
  result := FPatientCharacteristicList;
end;

function TFhirMedicationKnowledgeAdministrationGuideline.GetHasPatientCharacteristicList : boolean;
begin
  result := (FPatientCharacteristicList <> nil) and (FPatientCharacteristicList.count > 0);
end;

procedure TFhirMedicationKnowledgeAdministrationGuideline.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('dosage');
  fields.add('indication');
  fields.add('patientCharacteristic');
end;

function TFhirMedicationKnowledgeAdministrationGuideline.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FdosageList.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FpatientCharacteristicList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelineList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuideline;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelineList }

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuideline);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuideline', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuideline');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Append: TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Clone: TFhirMedicationKnowledgeAdministrationGuidelineList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline;
end;
function TFhirMedicationKnowledgeAdministrationGuidelineList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuideline): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuideline);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuideline;
begin
  result := TFhirMedicationKnowledgeAdministrationGuideline(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineList.Link: TFhirMedicationKnowledgeAdministrationGuidelineList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuideline);
  FhirMedicationKnowledgeAdministrationGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuideline);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuideline);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelineDosage }

constructor TFhirMedicationKnowledgeAdministrationGuidelineDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelineDosage.Destroy;
begin
  FType_.free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeAdministrationGuidelineDosage(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelineDosage(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuidelineDosage(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link)) {L1039};
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'dosage') then result := DosageList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuideline.dosage';
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.Link : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.Clone : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelineDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelineDosage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('dosage');
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelineDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelineDosageList }

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelineDosage);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelineDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelineDosage');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Append: TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Clone: TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosageList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage;
end;
function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelineDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelineDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelineDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Link: TFhirMedicationKnowledgeAdministrationGuidelineDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelineDosageList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelineDosage);
  FhirMedicationKnowledgeAdministrationGuidelineDosages[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelineDosageList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelineDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelineDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic }

constructor TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuideline.patientCharacteristic';
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.Link : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.Clone : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList }

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Append: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Link: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
  FhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinePatientCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMedicineClassification }

constructor TFhirMedicationKnowledgeMedicineClassification.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMedicineClassification.Destroy;
begin
  FType_.free;
  FClassificationList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMedicineClassification(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList);
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link)) {L1039};
end;

function TFhirMedicationKnowledgeMedicineClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeMedicineClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'classification') then result := ClassificationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMedicineClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classification') then ClassificationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMedicineClassification.fhirType : string;
begin
  result := 'MedicationKnowledge.medicineClassification';
end;

function TFhirMedicationKnowledgeMedicineClassification.Link : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Link);
end;

function TFhirMedicationKnowledgeMedicineClassification.Clone : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassification.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMedicineClassification)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMedicineClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(classificationList, o.classificationList, true);
  end;
end;

function TFhirMedicationKnowledgeMedicineClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FclassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirMedicationKnowledgeMedicineClassification.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicationKnowledgeMedicineClassification.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('classification');
end;

function TFhirMedicationKnowledgeMedicineClassification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FclassificationList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMedicineClassificationListEnumerator }

constructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMedicineClassificationList }

procedure TFhirMedicationKnowledgeMedicineClassificationList.AddItem(value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMedicineClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMedicineClassification');
  add(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Append: TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Clone: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetItemN(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMedicineClassification;
end;
function TFhirMedicationKnowledgeMedicineClassificationList.IndexOf(value: TFhirMedicationKnowledgeMedicineClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Insert(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Item(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Link: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  FhirMedicationKnowledgeMedicineClassifications[index] := value;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgePackaging }

constructor TFhirMedicationKnowledgePackaging.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgePackaging.Destroy;
begin
  FIdentifier.free;
  FCost.free;
  FType_.free;
  FQuantity.free;
  FDevice.free;
  FMaterial.free;
  FPackagingList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgePackaging.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMedicationKnowledgePackaging(oSource).identifier.Clone;
  cost := TFhirMedicationKnowledgePackaging(oSource).cost.Clone;
  type_ := TFhirMedicationKnowledgePackaging(oSource).type_.Clone;
  quantity := TFhirMedicationKnowledgePackaging(oSource).quantity.Clone;
  device := TFhirMedicationKnowledgePackaging(oSource).device.Clone;
  material := TFhirMedicationKnowledgePackaging(oSource).material.Clone;
  if (TFhirMedicationKnowledgePackaging(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
    FPackagingList.Assign(TFhirMedicationKnowledgePackaging(oSource).FPackagingList);
  end;
end;

procedure TFhirMedicationKnowledgePackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'material') Then
     list.add(self.link, 'material', FMaterial.Link);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
end;

procedure TFhirMedicationKnowledgePackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cost', '', false, TFhirMedicationKnowledgeCost, FCost.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', false, TFhirCodeableConcept, FMaterial.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'packaging', '', true, TFhirMedicationKnowledgePackaging, FPackagingList.Link)) {L1039};
end;

function TFhirMedicationKnowledgePackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMedicationKnowledgeCost {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    Material := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirMedicationKnowledgePackaging) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgePackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirMedicationKnowledgePackaging) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgePackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'cost') then result := TFhirMedicationKnowledgeCost.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'device') then result := TFhirReference.create() {L1203}
  else if (propName = 'material') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'packaging') then result := PackagingList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgePackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'cost') then result := ''
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'packaging') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgePackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'cost') then CostElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'material') then MaterialElement := nil
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgePackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'cost') then CostElement := new as TFhirMedicationKnowledgeCost {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'device') then DeviceElement := new as TFhirReference {L1195}
  else if (propName = 'material') then MaterialElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgePackaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'packaging') then PackagingList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgePackaging.fhirType : string;
begin
  result := 'MedicationKnowledge.packaging';
end;

function TFhirMedicationKnowledgePackaging.Link : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Link);
end;

function TFhirMedicationKnowledgePackaging.Clone : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Clone);
end;

function TFhirMedicationKnowledgePackaging.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgePackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgePackaging)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgePackaging(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(costElement, o.costElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(materialElement, o.materialElement, true) and 
      compareDeep(packagingList, o.packagingList, true);
  end;
end;

function TFhirMedicationKnowledgePackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCost) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FDevice) and isEmptyProp(FMaterial) and isEmptyProp(FpackagingList);
end;

procedure TFhirMedicationKnowledgePackaging.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirMedicationKnowledgePackaging.SetCost(value : TFhirMedicationKnowledgeCost);
begin
  FCost.free;
  FCost := value; {L1134}
end;

procedure TFhirMedicationKnowledgePackaging.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgePackaging.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMedicationKnowledgePackaging.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value; {L1134}
end;

procedure TFhirMedicationKnowledgePackaging.SetMaterial(value : TFhirCodeableConcept);
begin
  FMaterial.free;
  FMaterial := value; {L1134}
end;

function TFhirMedicationKnowledgePackaging.GetPackagingList : TFhirMedicationKnowledgePackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
  result := FPackagingList;
end;

function TFhirMedicationKnowledgePackaging.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

procedure TFhirMedicationKnowledgePackaging.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('cost');
  fields.add('type');
  fields.add('quantity');
  fields.add('device');
  fields.add('material');
  fields.add('packaging');
end;

function TFhirMedicationKnowledgePackaging.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCost.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FMaterial.sizeInBytes);
  inc(result, FpackagingList.sizeInBytes);
end;

{ TFhirMedicationKnowledgePackagingListEnumerator }

constructor TFhirMedicationKnowledgePackagingListEnumerator.Create(list : TFhirMedicationKnowledgePackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgePackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.GetCurrent : TFhirMedicationKnowledgePackaging;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgePackagingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgePackagingList }

procedure TFhirMedicationKnowledgePackagingList.AddItem(value: TFhirMedicationKnowledgePackaging);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgePackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgePackaging');
  add(value);
end;

function TFhirMedicationKnowledgePackagingList.Append: TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgePackagingList.GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
begin
  result := TFhirMedicationKnowledgePackagingListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgePackagingList.Clone: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Clone);
end;

function TFhirMedicationKnowledgePackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgePackagingList.GetItemN(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgePackaging;
end;
function TFhirMedicationKnowledgePackagingList.IndexOf(value: TFhirMedicationKnowledgePackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgePackagingList.Insert(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.InsertItem(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgePackagingList.Item(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.Link: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Link);
end;

procedure TFhirMedicationKnowledgePackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  FhirMedicationKnowledgePackagings[index] := value;
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemN(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDrugCharacteristic }

constructor TFhirMedicationKnowledgeDrugCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeDrugCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeDrugCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirMedicationKnowledgeDrugCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.drugCharacteristic';
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Link : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Clone : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDrugCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDrugCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeDrugCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirMedicationKnowledgeDrugCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeDrugCharacteristicList }

procedure TFhirMedicationKnowledgeDrugCharacteristicList.AddItem(value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDrugCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDrugCharacteristic');
  add(value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Append: TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Clone: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic;
end;
function TFhirMedicationKnowledgeDrugCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeDrugCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Link: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  FhirMedicationKnowledgeDrugCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatory }

constructor TFhirMedicationKnowledgeRegulatory.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatory.Destroy;
begin
  FRegulatoryAuthority.free;
  FSubstitutionList.Free;
  FScheduleList.Free;
  FMaxDispense.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatory.Assign(oSource : TFslObject);
begin
  inherited;
  regulatoryAuthority := TFhirMedicationKnowledgeRegulatory(oSource).regulatoryAuthority.Clone;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList = nil) then
  begin
    FSubstitutionList.free;
    FSubstitutionList := nil;
  end
  else
  begin
    if FSubstitutionList = nil then
      FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
    FSubstitutionList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList);
  end;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirCodeableConceptList.Create;
    FScheduleList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList);
  end;
  maxDispense := TFhirMedicationKnowledgeRegulatory(oSource).maxDispense.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'regulatoryAuthority') Then
     list.add(self.link, 'regulatoryAuthority', FRegulatoryAuthority.Link);
  if (child_name = 'substitution') Then
    list.addAll(self, 'substitution', FSubstitutionList);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'maxDispense') Then
     list.add(self.link, 'maxDispense', FMaxDispense.Link);
end;

procedure TFhirMedicationKnowledgeRegulatory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'regulatoryAuthority', 'Reference', false, TFhirReference, FRegulatoryAuthority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatorySubstitution, FSubstitutionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'schedule', 'CodeableConcept', true, TFhirCodeableConcept, FScheduleList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'maxDispense', 'BackboneElement', false, TFhirMedicationKnowledgeRegulatoryMaxDispense, FMaxDispense.Link)); {L1172}
end;

function TFhirMedicationKnowledgeRegulatory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then
  begin
    RegulatoryAuthority := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    SubstitutionList.add(propValue as TFhirMedicationKnowledgeRegulatorySubstitution) {L1048};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'maxDispense') then
  begin
    MaxDispense := propValue as TFhirMedicationKnowledgeRegulatoryMaxDispense {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'substitution') then SubstitutionList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySubstitution) {L1049}
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledgeRegulatory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then result := TFhirReference.create() {L1203}
  else if (propName = 'substitution') then result := SubstitutionList.new() {L1053}
  else if (propName = 'schedule') then result := ScheduleList.new() {L1053}
  else if (propName = 'maxDispense') then result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'regulatoryAuthority') then result := 'Reference'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'schedule') then result := 'CodeableConcept'
  else if (propName = 'maxDispense') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := nil
  else if (propName = 'substitution') then deletePropertyValue('substitution', SubstitutionList, value) {L1054}
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {L1054}
  else if (propName = 'maxDispense') then MaxDispenseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := new as TFhirReference {L1195}
  else if (propName = 'substitution') then replacePropertyValue('substitution', SubstitutionList, existing, new) {L1055}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {L1055}
  else if (propName = 'maxDispense') then MaxDispenseElement := new as TFhirMedicationKnowledgeRegulatoryMaxDispense {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'substitution') then SubstitutionList.move(source, destination) {L1050}
  else if (propName = 'schedule') then ScheduleList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatory.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory';
end;

function TFhirMedicationKnowledgeRegulatory.Link : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatory.Clone : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatory.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatory)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatory(other);
    result := compareDeep(regulatoryAuthorityElement, o.regulatoryAuthorityElement, true) and 
      compareDeep(substitutionList, o.substitutionList, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(maxDispenseElement, o.maxDispenseElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRegulatoryAuthority) and isEmptyProp(FsubstitutionList) and isEmptyProp(FscheduleList) and isEmptyProp(FMaxDispense);
end;

procedure TFhirMedicationKnowledgeRegulatory.SetRegulatoryAuthority(value : TFhirReference);
begin
  FRegulatoryAuthority.free;
  FRegulatoryAuthority := value; {L1134}
end;

function TFhirMedicationKnowledgeRegulatory.GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  if FSubstitutionList = nil then
    FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
  result := FSubstitutionList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasSubstitutionList : boolean;
begin
  result := (FSubstitutionList <> nil) and (FSubstitutionList.count > 0);
end;

function TFhirMedicationKnowledgeRegulatory.GetScheduleList : TFhirCodeableConceptList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirCodeableConceptList.Create;
  result := FScheduleList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

procedure TFhirMedicationKnowledgeRegulatory.SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  FMaxDispense.free;
  FMaxDispense := value; {L1134}
end;

procedure TFhirMedicationKnowledgeRegulatory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('regulatoryAuthority');
  fields.add('substitution');
  fields.add('schedule');
  fields.add('maxDispense');
end;

function TFhirMedicationKnowledgeRegulatory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRegulatoryAuthority.sizeInBytes);
  inc(result, FsubstitutionList.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FMaxDispense.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatory;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryList }

procedure TFhirMedicationKnowledgeRegulatoryList.AddItem(value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatory');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Append: TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryList.Clone: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatory;
end;
function TFhirMedicationKnowledgeRegulatoryList.IndexOf(value: TFhirMedicationKnowledgeRegulatory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Item(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.Link: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  FhirMedicationKnowledgeRegulatories[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySubstitution }

constructor TFhirMedicationKnowledgeRegulatorySubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitution.Destroy;
begin
  FType_.free;
  FAllowed.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).type_.Clone;
  allowedElement := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).allowedElement.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed') Then
     list.add(self.link, 'allowed', FAllowed.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allowed', 'boolean', false, TFhirBoolean, FAllowed.Link)); {L1172}
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'allowed') then
  begin
    AllowedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'allowed') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'allowed') then AllowedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'allowed') then AllowedElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.substitution';
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Link : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Clone : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowed(value : TFhirBoolean);
begin
  FAllowed.free;
  FAllowed := value; {L1134}
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.GetAllowedST : Boolean;
begin
  if FAllowed = nil then
    result := false
  else
    result := FAllowed.value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowedST(value : Boolean);
begin
  if FAllowed = nil then
    FAllowed := TFhirBoolean.create;
  FAllowed.value := value
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed');
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator }

constructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionList }

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.AddItem(value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySubstitution');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Append: TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Clone: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution;
end;
function TFhirMedicationKnowledgeRegulatorySubstitutionList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Link: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  FhirMedicationKnowledgeRegulatorySubstitutions[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispense }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Destroy;
begin
  FQuantity.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).quantity.Clone;
  period := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).period.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Duration', false, TFhirDuration, FPeriod.Link)); {L1172}
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'period') then result := TFhirDuration.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'period') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirDuration {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.maxDispense';
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Link : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatoryMaxDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatoryMaxDispense(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FPeriod);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetPeriod(value : TFhirDuration);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('period');
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseList }

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.AddItem(value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatoryMaxDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatoryMaxDispense');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Append: TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Clone: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense;
end;
function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.IndexOf(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Item(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Link: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  FhirMedicationKnowledgeRegulatoryMaxDispenses[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeKineticCharacteristic }

constructor TFhirMedicationKnowledgeKineticCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeKineticCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeKineticCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeKineticCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|Duration', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirMedicationKnowledgeKineticCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'Duration'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeKineticCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Duration'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeKineticCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'Duration'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Duration'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeKineticCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.kineticCharacteristic';
end;

function TFhirMedicationKnowledgeKineticCharacteristic.Link : TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeKineticCharacteristic.Clone : TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeKineticCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeKineticCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeKineticCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeKineticCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeKineticCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirMedicationKnowledgeKineticCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeKineticCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirMedicationKnowledgeKineticCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeKineticCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeKineticCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeKineticCharacteristicList }

procedure TFhirMedicationKnowledgeKineticCharacteristicList.AddItem(value: TFhirMedicationKnowledgeKineticCharacteristic);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeKineticCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeKineticCharacteristic');
  add(value);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Append: TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeKineticCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Clone: TFhirMedicationKnowledgeKineticCharacteristicList;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic;
end;
function TFhirMedicationKnowledgeKineticCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeKineticCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeKineticCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeKineticCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeKineticCharacteristic;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticCharacteristicList.Link: TFhirMedicationKnowledgeKineticCharacteristicList;
begin
  result := TFhirMedicationKnowledgeKineticCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeKineticCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeKineticCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeKineticCharacteristic);
  FhirMedicationKnowledgeKineticCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeKineticCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeKineticCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeKineticCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledge }

constructor TFhirMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledge.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  FAuthor.free;
  FManufacturer.free;
  FDoseForm.free;
  FAmount.free;
  FSynonymList.Free;
  FRelatedMedicationKnowledgeList.Free;
  FAssociatedMedicationList.Free;
  FAssociatedDefinition.free;
  FProductTypeList.Free;
  FMonographList.Free;
  FIngredientList.Free;
  FDeviceList.Free;
  FPreparationInstruction.free;
  FIntendedRouteList.Free;
  FCostList.Free;
  FMonitoringProgramList.Free;
  FAdministrationGuidelineList.Free;
  FMedicineClassificationList.Free;
  FPackagingList.Free;
  FDrugCharacteristicList.Free;
  FClinicalUseIssueList.Free;
  FRegulatoryList.Free;
  FKineticCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledge(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationKnowledge(oSource).FIdentifierList);
  end;
  code := TFhirMedicationKnowledge(oSource).code.Clone;
  statusElement := TFhirMedicationKnowledge(oSource).statusElement.Clone;
  author := TFhirMedicationKnowledge(oSource).author.Clone;
  manufacturer := TFhirMedicationKnowledge(oSource).manufacturer.Clone;
  doseForm := TFhirMedicationKnowledge(oSource).doseForm.Clone;
  amount := TFhirMedicationKnowledge(oSource).amount.Clone;
  if (TFhirMedicationKnowledge(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirStringList.Create;
    FSynonymList.Assign(TFhirMedicationKnowledge(oSource).FSynonymList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList = nil) then
  begin
    FRelatedMedicationKnowledgeList.free;
    FRelatedMedicationKnowledgeList := nil;
  end
  else
  begin
    if FRelatedMedicationKnowledgeList = nil then
      FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
    FRelatedMedicationKnowledgeList.Assign(TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAssociatedMedicationList = nil) then
  begin
    FAssociatedMedicationList.free;
    FAssociatedMedicationList := nil;
  end
  else
  begin
    if FAssociatedMedicationList = nil then
      FAssociatedMedicationList := TFhirReferenceList.Create;
    FAssociatedMedicationList.Assign(TFhirMedicationKnowledge(oSource).FAssociatedMedicationList);
  end;
  associatedDefinition := TFhirMedicationKnowledge(oSource).associatedDefinition.Clone;
  if (TFhirMedicationKnowledge(oSource).FProductTypeList = nil) then
  begin
    FProductTypeList.free;
    FProductTypeList := nil;
  end
  else
  begin
    if FProductTypeList = nil then
      FProductTypeList := TFhirCodeableConceptList.Create;
    FProductTypeList.Assign(TFhirMedicationKnowledge(oSource).FProductTypeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonographList = nil) then
  begin
    FMonographList.free;
    FMonographList := nil;
  end
  else
  begin
    if FMonographList = nil then
      FMonographList := TFhirMedicationKnowledgeMonographList.Create;
    FMonographList.Assign(TFhirMedicationKnowledge(oSource).FMonographList);
  end;
  if (TFhirMedicationKnowledge(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
    FIngredientList.Assign(TFhirMedicationKnowledge(oSource).FIngredientList);
  end;
  if (TFhirMedicationKnowledge(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList.Create;
    FDeviceList.Assign(TFhirMedicationKnowledge(oSource).FDeviceList);
  end;
  preparationInstructionElement := TFhirMedicationKnowledge(oSource).preparationInstructionElement.Clone;
  if (TFhirMedicationKnowledge(oSource).FIntendedRouteList = nil) then
  begin
    FIntendedRouteList.free;
    FIntendedRouteList := nil;
  end
  else
  begin
    if FIntendedRouteList = nil then
      FIntendedRouteList := TFhirCodeableConceptList.Create;
    FIntendedRouteList.Assign(TFhirMedicationKnowledge(oSource).FIntendedRouteList);
  end;
  if (TFhirMedicationKnowledge(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirMedicationKnowledgeCostList.Create;
    FCostList.Assign(TFhirMedicationKnowledge(oSource).FCostList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonitoringProgramList = nil) then
  begin
    FMonitoringProgramList.free;
    FMonitoringProgramList := nil;
  end
  else
  begin
    if FMonitoringProgramList = nil then
      FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
    FMonitoringProgramList.Assign(TFhirMedicationKnowledge(oSource).FMonitoringProgramList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAdministrationGuidelineList = nil) then
  begin
    FAdministrationGuidelineList.free;
    FAdministrationGuidelineList := nil;
  end
  else
  begin
    if FAdministrationGuidelineList = nil then
      FAdministrationGuidelineList := TFhirMedicationKnowledgeAdministrationGuidelineList.Create;
    FAdministrationGuidelineList.Assign(TFhirMedicationKnowledge(oSource).FAdministrationGuidelineList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMedicineClassificationList = nil) then
  begin
    FMedicineClassificationList.free;
    FMedicineClassificationList := nil;
  end
  else
  begin
    if FMedicineClassificationList = nil then
      FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
    FMedicineClassificationList.Assign(TFhirMedicationKnowledge(oSource).FMedicineClassificationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FPackagingList = nil) then
  begin
    FPackagingList.free;
    FPackagingList := nil;
  end
  else
  begin
    if FPackagingList = nil then
      FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
    FPackagingList.Assign(TFhirMedicationKnowledge(oSource).FPackagingList);
  end;
  if (TFhirMedicationKnowledge(oSource).FDrugCharacteristicList = nil) then
  begin
    FDrugCharacteristicList.free;
    FDrugCharacteristicList := nil;
  end
  else
  begin
    if FDrugCharacteristicList = nil then
      FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
    FDrugCharacteristicList.Assign(TFhirMedicationKnowledge(oSource).FDrugCharacteristicList);
  end;
  if (TFhirMedicationKnowledge(oSource).FClinicalUseIssueList = nil) then
  begin
    FClinicalUseIssueList.free;
    FClinicalUseIssueList := nil;
  end
  else
  begin
    if FClinicalUseIssueList = nil then
      FClinicalUseIssueList := TFhirReferenceList.Create;
    FClinicalUseIssueList.Assign(TFhirMedicationKnowledge(oSource).FClinicalUseIssueList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRegulatoryList = nil) then
  begin
    FRegulatoryList.free;
    FRegulatoryList := nil;
  end
  else
  begin
    if FRegulatoryList = nil then
      FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
    FRegulatoryList.Assign(TFhirMedicationKnowledge(oSource).FRegulatoryList);
  end;
  if (TFhirMedicationKnowledge(oSource).FKineticCharacteristicList = nil) then
  begin
    FKineticCharacteristicList.free;
    FKineticCharacteristicList := nil;
  end
  else
  begin
    if FKineticCharacteristicList = nil then
      FKineticCharacteristicList := TFhirMedicationKnowledgeKineticCharacteristicList.Create;
    FKineticCharacteristicList.Assign(TFhirMedicationKnowledge(oSource).FKineticCharacteristicList);
  end;
end;

function TFhirMedicationKnowledge.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationKnowledge;
end;

procedure TFhirMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'relatedMedicationKnowledge') Then
    list.addAll(self, 'relatedMedicationKnowledge', FRelatedMedicationKnowledgeList);
  if (child_name = 'associatedMedication') Then
    list.addAll(self, 'associatedMedication', FAssociatedMedicationList);
  if (child_name = 'associatedDefinition') Then
     list.add(self.link, 'associatedDefinition', FAssociatedDefinition.Link);
  if (child_name = 'productType') Then
    list.addAll(self, 'productType', FProductTypeList);
  if (child_name = 'monograph') Then
    list.addAll(self, 'monograph', FMonographList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'preparationInstruction') Then
     list.add(self.link, 'preparationInstruction', FPreparationInstruction.Link);
  if (child_name = 'intendedRoute') Then
    list.addAll(self, 'intendedRoute', FIntendedRouteList);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
  if (child_name = 'monitoringProgram') Then
    list.addAll(self, 'monitoringProgram', FMonitoringProgramList);
  if (child_name = 'administrationGuideline') Then
    list.addAll(self, 'administrationGuideline', FAdministrationGuidelineList);
  if (child_name = 'medicineClassification') Then
    list.addAll(self, 'medicineClassification', FMedicineClassificationList);
  if (child_name = 'packaging') Then
    list.addAll(self, 'packaging', FPackagingList);
  if (child_name = 'drugCharacteristic') Then
    list.addAll(self, 'drugCharacteristic', FDrugCharacteristicList);
  if (child_name = 'clinicalUseIssue') Then
    list.addAll(self, 'clinicalUseIssue', FClinicalUseIssueList);
  if (child_name = 'regulatory') Then
    list.addAll(self, 'regulatory', FRegulatoryList);
  if (child_name = 'kineticCharacteristic') Then
    list.addAll(self, 'kineticCharacteristic', FKineticCharacteristicList);
end;

procedure TFhirMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', true, TFhirString, FSynonymList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'relatedMedicationKnowledge', 'BackboneElement', true, TFhirMedicationKnowledgeRelatedMedicationKnowledge, FRelatedMedicationKnowledgeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'associatedMedication', 'Reference', true, TFhirReference, FAssociatedMedicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'associatedDefinition', 'Reference', false, TFhirReference, FAssociatedDefinition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productType', 'CodeableConcept', true, TFhirCodeableConcept, FProductTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'monograph', 'BackboneElement', true, TFhirMedicationKnowledgeMonograph, FMonographList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationKnowledgeIngredient, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', true, TFhirReference, FDeviceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'preparationInstruction', 'markdown', false, TFhirMarkdown, FPreparationInstruction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'intendedRoute', 'CodeableConcept', true, TFhirCodeableConcept, FIntendedRouteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'cost', 'BackboneElement', true, TFhirMedicationKnowledgeCost, FCostList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'monitoringProgram', 'BackboneElement', true, TFhirMedicationKnowledgeMonitoringProgram, FMonitoringProgramList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'administrationGuideline', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuideline, FAdministrationGuidelineList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'medicineClassification', 'BackboneElement', true, TFhirMedicationKnowledgeMedicineClassification, FMedicineClassificationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'packaging', 'BackboneElement', true, TFhirMedicationKnowledgePackaging, FPackagingList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'drugCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeDrugCharacteristic, FDrugCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'clinicalUseIssue', 'Reference', true, TFhirReference, FClinicalUseIssueList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'regulatory', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatory, FRegulatoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'kineticCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeKineticCharacteristic, FKineticCharacteristicList.Link)) {L1039};
end;

function TFhirMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, CODES_TFhirMedicationKnowledgeStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'relatedMedicationKnowledge') then
  begin
    RelatedMedicationKnowledgeList.add(propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge) {L1048};
    result := propValue;
  end
  else if (propName = 'associatedMedication') then
  begin
    AssociatedMedicationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'associatedDefinition') then
  begin
    AssociatedDefinition := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'productType') then
  begin
    ProductTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'monograph') then
  begin
    MonographList.add(propValue as TFhirMedicationKnowledgeMonograph) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationKnowledgeIngredient) {L1048};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'preparationInstruction') then
  begin
    PreparationInstructionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'intendedRoute') then
  begin
    IntendedRouteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirMedicationKnowledgeCost) {L1048};
    result := propValue;
  end
  else if (propName = 'monitoringProgram') then
  begin
    MonitoringProgramList.add(propValue as TFhirMedicationKnowledgeMonitoringProgram) {L1048};
    result := propValue;
  end
  else if (propName = 'administrationGuideline') then
  begin
    AdministrationGuidelineList.add(propValue as TFhirMedicationKnowledgeAdministrationGuideline) {L1048};
    result := propValue;
  end
  else if (propName = 'medicineClassification') then
  begin
    MedicineClassificationList.add(propValue as TFhirMedicationKnowledgeMedicineClassification) {L1048};
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    PackagingList.add(propValue as TFhirMedicationKnowledgePackaging) {L1048};
    result := propValue;
  end
  else if (propName = 'drugCharacteristic') then
  begin
    DrugCharacteristicList.add(propValue as TFhirMedicationKnowledgeDrugCharacteristic) {L1048};
    result := propValue;
  end
  else if (propName = 'clinicalUseIssue') then
  begin
    ClinicalUseIssueList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'regulatory') then
  begin
    RegulatoryList.add(propValue as TFhirMedicationKnowledgeRegulatory) {L1048};
    result := propValue;
  end
  else if (propName = 'kineticCharacteristic') then
  begin
    KineticCharacteristicList.add(propValue as TFhirMedicationKnowledgeKineticCharacteristic) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'synonym') then SynonymList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.insertItem(index, propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge) {L1049}
  else if (propName = 'associatedMedication') then AssociatedMedicationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'productType') then ProductTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'monograph') then MonographList.insertItem(index, propValue as TFhirMedicationKnowledgeMonograph) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationKnowledgeIngredient) {L1049}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'intendedRoute') then IntendedRouteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirMedicationKnowledgeCost) {L1049}
  else if (propName = 'monitoringProgram') then MonitoringProgramList.insertItem(index, propValue as TFhirMedicationKnowledgeMonitoringProgram) {L1049}
  else if (propName = 'administrationGuideline') then AdministrationGuidelineList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuideline) {L1049}
  else if (propName = 'medicineClassification') then MedicineClassificationList.insertItem(index, propValue as TFhirMedicationKnowledgeMedicineClassification) {L1049}
  else if (propName = 'packaging') then PackagingList.insertItem(index, propValue as TFhirMedicationKnowledgePackaging) {L1049}
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeDrugCharacteristic) {L1049}
  else if (propName = 'clinicalUseIssue') then ClinicalUseIssueList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'regulatory') then RegulatoryList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatory) {L1049}
  else if (propName = 'kineticCharacteristic') then KineticCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeKineticCharacteristic) {L1049}
  else inherited;
end;

function TFhirMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum[MedicationKnowledgeStatusCodesNull], CODES_TFhirMedicationKnowledgeStatusCodesEnum[MedicationKnowledgeStatusCodesNull])  {L1211}
  else if (propName = 'author') then result := TFhirReference.create() {L1203}
  else if (propName = 'manufacturer') then result := TFhirReference.create() {L1203}
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'synonym') then result := SynonymList.new() {L1053}
  else if (propName = 'relatedMedicationKnowledge') then result := RelatedMedicationKnowledgeList.new() {L1053}
  else if (propName = 'associatedMedication') then result := AssociatedMedicationList.new() {L1053}
  else if (propName = 'associatedDefinition') then result := TFhirReference.create() {L1203}
  else if (propName = 'productType') then result := ProductTypeList.new() {L1053}
  else if (propName = 'monograph') then result := MonographList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'device') then result := DeviceList.new() {L1053}
  else if (propName = 'preparationInstruction') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'intendedRoute') then result := IntendedRouteList.new() {L1053}
  else if (propName = 'cost') then result := CostList.new() {L1053}
  else if (propName = 'monitoringProgram') then result := MonitoringProgramList.new() {L1053}
  else if (propName = 'administrationGuideline') then result := AdministrationGuidelineList.new() {L1053}
  else if (propName = 'medicineClassification') then result := MedicineClassificationList.new() {L1053}
  else if (propName = 'packaging') then result := PackagingList.new() {L1053}
  else if (propName = 'drugCharacteristic') then result := DrugCharacteristicList.new() {L1053}
  else if (propName = 'clinicalUseIssue') then result := ClinicalUseIssueList.new() {L1053}
  else if (propName = 'regulatory') then result := RegulatoryList.new() {L1053}
  else if (propName = 'kineticCharacteristic') then result := KineticCharacteristicList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'synonym') then result := 'string'
  else if (propName = 'relatedMedicationKnowledge') then result := 'BackboneElement'
  else if (propName = 'associatedMedication') then result := 'Reference'
  else if (propName = 'associatedDefinition') then result := 'Reference'
  else if (propName = 'productType') then result := 'CodeableConcept'
  else if (propName = 'monograph') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'preparationInstruction') then result := 'markdown'
  else if (propName = 'intendedRoute') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := 'BackboneElement'
  else if (propName = 'monitoringProgram') then result := 'BackboneElement'
  else if (propName = 'administrationGuideline') then result := 'BackboneElement'
  else if (propName = 'medicineClassification') then result := 'BackboneElement'
  else if (propName = 'packaging') then result := 'BackboneElement'
  else if (propName = 'drugCharacteristic') then result := 'BackboneElement'
  else if (propName = 'clinicalUseIssue') then result := 'Reference'
  else if (propName = 'regulatory') then result := 'BackboneElement'
  else if (propName = 'kineticCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value) {L1054}
  else if (propName = 'relatedMedicationKnowledge') then deletePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, value) {L1054}
  else if (propName = 'associatedMedication') then deletePropertyValue('associatedMedication', AssociatedMedicationList, value) {L1054}
  else if (propName = 'associatedDefinition') then AssociatedDefinitionElement := nil
  else if (propName = 'productType') then deletePropertyValue('productType', ProductTypeList, value) {L1054}
  else if (propName = 'monograph') then deletePropertyValue('monograph', MonographList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {L1054}
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := nil
  else if (propName = 'intendedRoute') then deletePropertyValue('intendedRoute', IntendedRouteList, value) {L1054}
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value) {L1054}
  else if (propName = 'monitoringProgram') then deletePropertyValue('monitoringProgram', MonitoringProgramList, value) {L1054}
  else if (propName = 'administrationGuideline') then deletePropertyValue('administrationGuideline', AdministrationGuidelineList, value) {L1054}
  else if (propName = 'medicineClassification') then deletePropertyValue('medicineClassification', MedicineClassificationList, value) {L1054}
  else if (propName = 'packaging') then deletePropertyValue('packaging', PackagingList, value) {L1054}
  else if (propName = 'drugCharacteristic') then deletePropertyValue('drugCharacteristic', DrugCharacteristicList, value) {L1054}
  else if (propName = 'clinicalUseIssue') then deletePropertyValue('clinicalUseIssue', ClinicalUseIssueList, value) {L1054}
  else if (propName = 'regulatory') then deletePropertyValue('regulatory', RegulatoryList, value) {L1054}
  else if (propName = 'kineticCharacteristic') then deletePropertyValue('kineticCharacteristic', KineticCharacteristicList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, CODES_TFhirMedicationKnowledgeStatusCodesEnum, new) {L1210}
  else if (propName = 'author') then AuthorElement := new as TFhirReference {L1195}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference {L1195}
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new) {L1055}
  else if (propName = 'relatedMedicationKnowledge') then replacePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, existing, new) {L1055}
  else if (propName = 'associatedMedication') then replacePropertyValue('associatedMedication', AssociatedMedicationList, existing, new) {L1055}
  else if (propName = 'associatedDefinition') then AssociatedDefinitionElement := new as TFhirReference {L1195}
  else if (propName = 'productType') then replacePropertyValue('productType', ProductTypeList, existing, new) {L1055}
  else if (propName = 'monograph') then replacePropertyValue('monograph', MonographList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {L1055}
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := asMarkdown(new) {L1222}
  else if (propName = 'intendedRoute') then replacePropertyValue('intendedRoute', IntendedRouteList, existing, new) {L1055}
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new) {L1055}
  else if (propName = 'monitoringProgram') then replacePropertyValue('monitoringProgram', MonitoringProgramList, existing, new) {L1055}
  else if (propName = 'administrationGuideline') then replacePropertyValue('administrationGuideline', AdministrationGuidelineList, existing, new) {L1055}
  else if (propName = 'medicineClassification') then replacePropertyValue('medicineClassification', MedicineClassificationList, existing, new) {L1055}
  else if (propName = 'packaging') then replacePropertyValue('packaging', PackagingList, existing, new) {L1055}
  else if (propName = 'drugCharacteristic') then replacePropertyValue('drugCharacteristic', DrugCharacteristicList, existing, new) {L1055}
  else if (propName = 'clinicalUseIssue') then replacePropertyValue('clinicalUseIssue', ClinicalUseIssueList, existing, new) {L1055}
  else if (propName = 'regulatory') then replacePropertyValue('regulatory', RegulatoryList, existing, new) {L1055}
  else if (propName = 'kineticCharacteristic') then replacePropertyValue('kineticCharacteristic', KineticCharacteristicList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'synonym') then SynonymList.move(source, destination) {L1046}
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.move(source, destination) {L1050}
  else if (propName = 'associatedMedication') then AssociatedMedicationList.move(source, destination) {L1050}
  else if (propName = 'productType') then ProductTypeList.move(source, destination) {L1050}
  else if (propName = 'monograph') then MonographList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else if (propName = 'device') then DeviceList.move(source, destination) {L1050}
  else if (propName = 'intendedRoute') then IntendedRouteList.move(source, destination) {L1050}
  else if (propName = 'cost') then CostList.move(source, destination) {L1050}
  else if (propName = 'monitoringProgram') then MonitoringProgramList.move(source, destination) {L1050}
  else if (propName = 'administrationGuideline') then AdministrationGuidelineList.move(source, destination) {L1050}
  else if (propName = 'medicineClassification') then MedicineClassificationList.move(source, destination) {L1050}
  else if (propName = 'packaging') then PackagingList.move(source, destination) {L1050}
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.move(source, destination) {L1050}
  else if (propName = 'clinicalUseIssue') then ClinicalUseIssueList.move(source, destination) {L1050}
  else if (propName = 'regulatory') then RegulatoryList.move(source, destination) {L1050}
  else if (propName = 'kineticCharacteristic') then KineticCharacteristicList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge';
end;

function TFhirMedicationKnowledge.Link : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledge.Clone : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledge(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(doseFormElement, o.doseFormElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(relatedMedicationKnowledgeList, o.relatedMedicationKnowledgeList, true) and 
      compareDeep(associatedMedicationList, o.associatedMedicationList, true) and compareDeep(associatedDefinitionElement, o.associatedDefinitionElement, true) and 
      compareDeep(productTypeList, o.productTypeList, true) and compareDeep(monographList, o.monographList, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(deviceList, o.deviceList, true) and 
      compareDeep(preparationInstructionElement, o.preparationInstructionElement, true) and 
      compareDeep(intendedRouteList, o.intendedRouteList, true) and compareDeep(costList, o.costList, true) and 
      compareDeep(monitoringProgramList, o.monitoringProgramList, true) and compareDeep(administrationGuidelineList, o.administrationGuidelineList, true) and 
      compareDeep(medicineClassificationList, o.medicineClassificationList, true) and 
      compareDeep(packagingList, o.packagingList, true) and compareDeep(drugCharacteristicList, o.drugCharacteristicList, true) and 
      compareDeep(clinicalUseIssueList, o.clinicalUseIssueList, true) and compareDeep(regulatoryList, o.regulatoryList, true) and 
      compareDeep(kineticCharacteristicList, o.kineticCharacteristicList, true);
  end;
end;

function TFhirMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FAuthor) and isEmptyProp(FManufacturer) and isEmptyProp(FDoseForm) and isEmptyProp(FAmount) and isEmptyProp(FsynonymList) and isEmptyProp(FrelatedMedicationKnowledgeList) and isEmptyProp(FassociatedMedicationList) and isEmptyProp(FAssociatedDefinition) and isEmptyProp(FproductTypeList) and isEmptyProp(FmonographList) and isEmptyProp(FingredientList) and isEmptyProp(FdeviceList) and isEmptyProp(FPreparationInstruction) and isEmptyProp(FintendedRouteList) and isEmptyProp(FcostList) and isEmptyProp(FmonitoringProgramList) and isEmptyProp(FadministrationGuidelineList) and isEmptyProp(FmedicineClassificationList) and isEmptyProp(FpackagingList) and isEmptyProp(FdrugCharacteristicList) and isEmptyProp(FclinicalUseIssueList) and isEmptyProp(FregulatoryList) and isEmptyProp(FkineticCharacteristicList);
end;

function TFhirMedicationKnowledge.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationKnowledge.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirMedicationKnowledge.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationKnowledge.GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationKnowledgeStatusCodesEnum(0)
  else
    result := TFhirMedicationKnowledgeStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationKnowledgeStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationKnowledge.SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum[value], CODES_TFhirMedicationKnowledgeStatusCodesEnum[value]);
end;

procedure TFhirMedicationKnowledge.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value; {L1134}
end;

procedure TFhirMedicationKnowledge.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value; {L1134}
end;

procedure TFhirMedicationKnowledge.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value; {L1134}
end;

procedure TFhirMedicationKnowledge.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

function TFhirMedicationKnowledge.GetSynonymList : TFhirStringList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirStringList.Create;
  result := FSynonymList;
end;

function TFhirMedicationKnowledge.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

function TFhirMedicationKnowledge.GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  if FRelatedMedicationKnowledgeList = nil then
    FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
  result := FRelatedMedicationKnowledgeList;
end;

function TFhirMedicationKnowledge.GetHasRelatedMedicationKnowledgeList : boolean;
begin
  result := (FRelatedMedicationKnowledgeList <> nil) and (FRelatedMedicationKnowledgeList.count > 0);
end;

function TFhirMedicationKnowledge.GetAssociatedMedicationList : TFhirReferenceList;
begin
  if FAssociatedMedicationList = nil then
    FAssociatedMedicationList := TFhirReferenceList.Create;
  result := FAssociatedMedicationList;
end;

function TFhirMedicationKnowledge.GetHasAssociatedMedicationList : boolean;
begin
  result := (FAssociatedMedicationList <> nil) and (FAssociatedMedicationList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetAssociatedDefinition(value : TFhirReference);
begin
  FAssociatedDefinition.free;
  FAssociatedDefinition := value; {L1134}
end;

function TFhirMedicationKnowledge.GetProductTypeList : TFhirCodeableConceptList;
begin
  if FProductTypeList = nil then
    FProductTypeList := TFhirCodeableConceptList.Create;
  result := FProductTypeList;
end;

function TFhirMedicationKnowledge.GetHasProductTypeList : boolean;
begin
  result := (FProductTypeList <> nil) and (FProductTypeList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonographList : TFhirMedicationKnowledgeMonographList;
begin
  if FMonographList = nil then
    FMonographList := TFhirMedicationKnowledgeMonographList.Create;
  result := FMonographList;
end;

function TFhirMedicationKnowledge.GetHasMonographList : boolean;
begin
  result := (FMonographList <> nil) and (FMonographList.count > 0);
end;

function TFhirMedicationKnowledge.GetIngredientList : TFhirMedicationKnowledgeIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedicationKnowledge.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirMedicationKnowledge.GetDeviceList : TFhirReferenceList;
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList.Create;
  result := FDeviceList;
end;

function TFhirMedicationKnowledge.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetPreparationInstruction(value : TFhirMarkdown);
begin
  FPreparationInstruction.free;
  FPreparationInstruction := value; {L1134}
end;

function TFhirMedicationKnowledge.GetPreparationInstructionST : String;
begin
  if FPreparationInstruction = nil then
    result := ''
  else
    result := FPreparationInstruction.value;
end;

procedure TFhirMedicationKnowledge.SetPreparationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPreparationInstruction = nil then
      FPreparationInstruction := TFhirMarkdown.create;
    FPreparationInstruction.value := value
  end
  else if FPreparationInstruction <> nil then
    FPreparationInstruction.value := '';
end;

function TFhirMedicationKnowledge.GetIntendedRouteList : TFhirCodeableConceptList;
begin
  if FIntendedRouteList = nil then
    FIntendedRouteList := TFhirCodeableConceptList.Create;
  result := FIntendedRouteList;
end;

function TFhirMedicationKnowledge.GetHasIntendedRouteList : boolean;
begin
  result := (FIntendedRouteList <> nil) and (FIntendedRouteList.count > 0);
end;

function TFhirMedicationKnowledge.GetCostList : TFhirMedicationKnowledgeCostList;
begin
  if FCostList = nil then
    FCostList := TFhirMedicationKnowledgeCostList.Create;
  result := FCostList;
end;

function TFhirMedicationKnowledge.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
begin
  if FMonitoringProgramList = nil then
    FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
  result := FMonitoringProgramList;
end;

function TFhirMedicationKnowledge.GetHasMonitoringProgramList : boolean;
begin
  result := (FMonitoringProgramList <> nil) and (FMonitoringProgramList.count > 0);
end;

function TFhirMedicationKnowledge.GetAdministrationGuidelineList : TFhirMedicationKnowledgeAdministrationGuidelineList;
begin
  if FAdministrationGuidelineList = nil then
    FAdministrationGuidelineList := TFhirMedicationKnowledgeAdministrationGuidelineList.Create;
  result := FAdministrationGuidelineList;
end;

function TFhirMedicationKnowledge.GetHasAdministrationGuidelineList : boolean;
begin
  result := (FAdministrationGuidelineList <> nil) and (FAdministrationGuidelineList.count > 0);
end;

function TFhirMedicationKnowledge.GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
begin
  if FMedicineClassificationList = nil then
    FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
  result := FMedicineClassificationList;
end;

function TFhirMedicationKnowledge.GetHasMedicineClassificationList : boolean;
begin
  result := (FMedicineClassificationList <> nil) and (FMedicineClassificationList.count > 0);
end;

function TFhirMedicationKnowledge.GetPackagingList : TFhirMedicationKnowledgePackagingList;
begin
  if FPackagingList = nil then
    FPackagingList := TFhirMedicationKnowledgePackagingList.Create;
  result := FPackagingList;
end;

function TFhirMedicationKnowledge.GetHasPackagingList : boolean;
begin
  result := (FPackagingList <> nil) and (FPackagingList.count > 0);
end;

function TFhirMedicationKnowledge.GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  if FDrugCharacteristicList = nil then
    FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
  result := FDrugCharacteristicList;
end;

function TFhirMedicationKnowledge.GetHasDrugCharacteristicList : boolean;
begin
  result := (FDrugCharacteristicList <> nil) and (FDrugCharacteristicList.count > 0);
end;

function TFhirMedicationKnowledge.GetClinicalUseIssueList : TFhirReferenceList;
begin
  if FClinicalUseIssueList = nil then
    FClinicalUseIssueList := TFhirReferenceList.Create;
  result := FClinicalUseIssueList;
end;

function TFhirMedicationKnowledge.GetHasClinicalUseIssueList : boolean;
begin
  result := (FClinicalUseIssueList <> nil) and (FClinicalUseIssueList.count > 0);
end;

function TFhirMedicationKnowledge.GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
begin
  if FRegulatoryList = nil then
    FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
  result := FRegulatoryList;
end;

function TFhirMedicationKnowledge.GetHasRegulatoryList : boolean;
begin
  result := (FRegulatoryList <> nil) and (FRegulatoryList.count > 0);
end;

function TFhirMedicationKnowledge.GetKineticCharacteristicList : TFhirMedicationKnowledgeKineticCharacteristicList;
begin
  if FKineticCharacteristicList = nil then
    FKineticCharacteristicList := TFhirMedicationKnowledgeKineticCharacteristicList.Create;
  result := FKineticCharacteristicList;
end;

function TFhirMedicationKnowledge.GetHasKineticCharacteristicList : boolean;
begin
  result := (FKineticCharacteristicList <> nil) and (FKineticCharacteristicList.count > 0);
end;

procedure TFhirMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('author');
  fields.add('manufacturer');
  fields.add('doseForm');
  fields.add('amount');
  fields.add('synonym');
  fields.add('relatedMedicationKnowledge');
  fields.add('associatedMedication');
  fields.add('associatedDefinition');
  fields.add('productType');
  fields.add('monograph');
  fields.add('ingredient');
  fields.add('device');
  fields.add('preparationInstruction');
  fields.add('intendedRoute');
  fields.add('cost');
  fields.add('monitoringProgram');
  fields.add('administrationGuideline');
  fields.add('medicineClassification');
  fields.add('packaging');
  fields.add('drugCharacteristic');
  fields.add('clinicalUseIssue');
  fields.add('regulatory');
  fields.add('kineticCharacteristic');
end;

function TFhirMedicationKnowledge.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FDoseForm.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FsynonymList.sizeInBytes);
  inc(result, FrelatedMedicationKnowledgeList.sizeInBytes);
  inc(result, FassociatedMedicationList.sizeInBytes);
  inc(result, FAssociatedDefinition.sizeInBytes);
  inc(result, FproductTypeList.sizeInBytes);
  inc(result, FmonographList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FPreparationInstruction.sizeInBytes);
  inc(result, FintendedRouteList.sizeInBytes);
  inc(result, FcostList.sizeInBytes);
  inc(result, FmonitoringProgramList.sizeInBytes);
  inc(result, FadministrationGuidelineList.sizeInBytes);
  inc(result, FmedicineClassificationList.sizeInBytes);
  inc(result, FpackagingList.sizeInBytes);
  inc(result, FdrugCharacteristicList.sizeInBytes);
  inc(result, FclinicalUseIssueList.sizeInBytes);
  inc(result, FregulatoryList.sizeInBytes);
  inc(result, FkineticCharacteristicList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeList }

procedure TFhirMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledge);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledge');
  add(value);
end;

function TFhirMedicationKnowledgeList.Append: TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledge;
end;
function TFhirMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.Link: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  FhirMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
{ TFhirMedicinalProductDefinitionContact }

constructor TFhirMedicinalProductDefinitionContact.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionContact.Destroy;
begin
  FType_.free;
  FContact.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionContact.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionContact(oSource).type_.Clone;
  contact := TFhirMedicinalProductDefinitionContact(oSource).contact.Clone;
end;

procedure TFhirMedicinalProductDefinitionContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
end;

procedure TFhirMedicinalProductDefinitionContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contact', 'Reference', false, TFhirReference, FContact.Link)); {L1172}
end;

function TFhirMedicinalProductDefinitionContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'contact') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'contact') then ContactElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'contact') then ContactElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionContact.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionContact.fhirType : string;
begin
  result := 'MedicinalProductDefinition.contact';
end;

function TFhirMedicinalProductDefinitionContact.Link : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Link);
end;

function TFhirMedicinalProductDefinitionContact.Clone : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContact.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionContact)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionContact(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(contactElement, o.contactElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FContact);
end;

procedure TFhirMedicinalProductDefinitionContact.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionContact.SetContact(value : TFhirReference);
begin
  FContact.free;
  FContact := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('contact');
end;

function TFhirMedicinalProductDefinitionContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FContact.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionContactListEnumerator }

constructor TFhirMedicinalProductDefinitionContactListEnumerator.Create(list : TFhirMedicinalProductDefinitionContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionContact;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionContactList }

procedure TFhirMedicinalProductDefinitionContactList.AddItem(value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionContact');
  add(value);
end;

function TFhirMedicinalProductDefinitionContactList.Append: TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionContactList.GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionContactListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionContactList.Clone: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionContactList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionContact;
end;
function TFhirMedicinalProductDefinitionContactList.IndexOf(value: TFhirMedicinalProductDefinitionContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionContactList.Insert(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionContactList.Item(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.Link: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  FhirMedicinalProductDefinitionContacts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionName }

constructor TFhirMedicinalProductDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionName.Destroy;
begin
  FProductName.free;
  FType_.free;
  FNamePartList.Free;
  FCountryLanguageList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  productNameElement := TFhirMedicinalProductDefinitionName(oSource).productNameElement.Clone;
  type_ := TFhirMedicinalProductDefinitionName(oSource).type_.Clone;
  if (TFhirMedicinalProductDefinitionName(oSource).FNamePartList = nil) then
  begin
    FNamePartList.free;
    FNamePartList := nil;
  end
  else
  begin
    if FNamePartList = nil then
      FNamePartList := TFhirMedicinalProductDefinitionNameNamePartList.Create;
    FNamePartList.Assign(TFhirMedicinalProductDefinitionName(oSource).FNamePartList);
  end;
  if (TFhirMedicinalProductDefinitionName(oSource).FCountryLanguageList = nil) then
  begin
    FCountryLanguageList.free;
    FCountryLanguageList := nil;
  end
  else
  begin
    if FCountryLanguageList = nil then
      FCountryLanguageList := TFhirMedicinalProductDefinitionNameCountryLanguageList.Create;
    FCountryLanguageList.Assign(TFhirMedicinalProductDefinitionName(oSource).FCountryLanguageList);
  end;
end;

procedure TFhirMedicinalProductDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'namePart') Then
    list.addAll(self, 'namePart', FNamePartList);
  if (child_name = 'countryLanguage') Then
    list.addAll(self, 'countryLanguage', FCountryLanguageList);
end;

procedure TFhirMedicinalProductDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'namePart', 'BackboneElement', true, TFhirMedicinalProductDefinitionNameNamePart, FNamePartList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'countryLanguage', 'BackboneElement', true, TFhirMedicinalProductDefinitionNameCountryLanguage, FCountryLanguageList.Link)) {L1039};
end;

function TFhirMedicinalProductDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'namePart') then
  begin
    NamePartList.add(propValue as TFhirMedicinalProductDefinitionNameNamePart) {L1048};
    result := propValue;
  end
  else if (propName = 'countryLanguage') then
  begin
    CountryLanguageList.add(propValue as TFhirMedicinalProductDefinitionNameCountryLanguage) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'namePart') then NamePartList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNameNamePart) {L1049}
  else if (propName = 'countryLanguage') then CountryLanguageList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNameCountryLanguage) {L1049}
  else inherited;
end;

function TFhirMedicinalProductDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productName') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'namePart') then result := NamePartList.new() {L1053}
  else if (propName = 'countryLanguage') then result := CountryLanguageList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productName') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'namePart') then result := 'BackboneElement'
  else if (propName = 'countryLanguage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'namePart') then deletePropertyValue('namePart', NamePartList, value) {L1054}
  else if (propName = 'countryLanguage') then deletePropertyValue('countryLanguage', CountryLanguageList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'namePart') then replacePropertyValue('namePart', NamePartList, existing, new) {L1055}
  else if (propName = 'countryLanguage') then replacePropertyValue('countryLanguage', CountryLanguageList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'namePart') then NamePartList.move(source, destination) {L1050}
  else if (propName = 'countryLanguage') then CountryLanguageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionName.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name';
end;

function TFhirMedicinalProductDefinitionName.Link : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Link);
end;

function TFhirMedicinalProductDefinitionName.Clone : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Clone);
end;

function TFhirMedicinalProductDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionName)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionName(other);
    result := compareDeep(productNameElement, o.productNameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(namePartList, o.namePartList, true) and compareDeep(countryLanguageList, o.countryLanguageList, true);
  end;
end;

function TFhirMedicinalProductDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductName) and isEmptyProp(FType_) and isEmptyProp(FnamePartList) and isEmptyProp(FcountryLanguageList);
end;

procedure TFhirMedicinalProductDefinitionName.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value; {L1134}
end;

function TFhirMedicinalProductDefinitionName.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

procedure TFhirMedicinalProductDefinitionName.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

procedure TFhirMedicinalProductDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirMedicinalProductDefinitionName.GetNamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
begin
  if FNamePartList = nil then
    FNamePartList := TFhirMedicinalProductDefinitionNameNamePartList.Create;
  result := FNamePartList;
end;

function TFhirMedicinalProductDefinitionName.GetHasNamePartList : boolean;
begin
  result := (FNamePartList <> nil) and (FNamePartList.count > 0);
end;

function TFhirMedicinalProductDefinitionName.GetCountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  if FCountryLanguageList = nil then
    FCountryLanguageList := TFhirMedicinalProductDefinitionNameCountryLanguageList.Create;
  result := FCountryLanguageList;
end;

function TFhirMedicinalProductDefinitionName.GetHasCountryLanguageList : boolean;
begin
  result := (FCountryLanguageList <> nil) and (FCountryLanguageList.count > 0);
end;

procedure TFhirMedicinalProductDefinitionName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productName');
  fields.add('type');
  fields.add('namePart');
  fields.add('countryLanguage');
end;

function TFhirMedicinalProductDefinitionName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FnamePartList.sizeInBytes);
  inc(result, FcountryLanguageList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameListEnumerator }

constructor TFhirMedicinalProductDefinitionNameListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameList }

procedure TFhirMedicinalProductDefinitionNameList.AddItem(value: TFhirMedicinalProductDefinitionName);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionName');
  add(value);
end;

function TFhirMedicinalProductDefinitionNameList.Append: TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameList.GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameList.Clone: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionName;
end;
function TFhirMedicinalProductDefinitionNameList.IndexOf(value: TFhirMedicinalProductDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameList.Insert(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameList.Item(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.Link: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  FhirMedicinalProductDefinitionNames[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNameNamePart }

constructor TFhirMedicinalProductDefinitionNameNamePart.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNameNamePart.Destroy;
begin
  FPart.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.Assign(oSource : TFslObject);
begin
  inherited;
  partElement := TFhirMedicinalProductDefinitionNameNamePart(oSource).partElement.Clone;
  type_ := TFhirMedicinalProductDefinitionNameNamePart(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'string', false, TFhirString, FPart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
end;

function TFhirMedicinalProductDefinitionNameNamePart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    PartElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNameNamePart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNameNamePart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNameNamePart.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.namePart';
end;

function TFhirMedicinalProductDefinitionNameNamePart.Link : TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(inherited Link);
end;

function TFhirMedicinalProductDefinitionNameNamePart.Clone : TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameNamePart.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNameNamePart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNameNamePart)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNameNamePart(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionNameNamePart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetPart(value : TFhirString);
begin
  FPart.free;
  FPart := value; {L1134}
end;

function TFhirMedicinalProductDefinitionNameNamePart.GetPartST : String;
begin
  if FPart = nil then
    result := ''
  else
    result := FPart.value;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetPartST(value : String);
begin
  if value <> '' then
  begin
    if FPart = nil then
      FPart := TFhirString.create;
    FPart.value := value
  end
  else if FPart <> nil then
    FPart.value := '';
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('part');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionNameNamePart.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPart.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameNamePartListEnumerator }

constructor TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameNamePartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNameNamePart;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameNamePartList }

procedure TFhirMedicinalProductDefinitionNameNamePartList.AddItem(value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNameNamePart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNameNamePart');
  add(value);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Append: TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameNamePartList.GetEnumerator : TFhirMedicinalProductDefinitionNameNamePartListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Clone: TFhirMedicinalProductDefinitionNameNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameNamePartList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart;
end;
function TFhirMedicinalProductDefinitionNameNamePartList.IndexOf(value: TFhirMedicinalProductDefinitionNameNamePart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Insert(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Item(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Link: TFhirMedicinalProductDefinitionNameNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  FhirMedicinalProductDefinitionNameNameParts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguage }

constructor TFhirMedicinalProductDefinitionNameCountryLanguage.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNameCountryLanguage.Destroy;
begin
  FCountry.free;
  FJurisdiction.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.Assign(oSource : TFslObject);
begin
  inherited;
  country := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).country.Clone;
  jurisdiction := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).jurisdiction.Clone;
  language := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).language.Clone;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'country') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.countryLanguage';
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.Link : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(inherited Link);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.Clone : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNameCountryLanguage)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNameCountryLanguage(other);
    result := compareDeep(countryElement, o.countryElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCountry) and isEmptyProp(FJurisdiction) and isEmptyProp(FLanguage);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('language');
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCountry.sizeInBytes);
  inc(result, FJurisdiction.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator }

constructor TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameCountryLanguageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguageList }

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.AddItem(value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNameCountryLanguage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNameCountryLanguage');
  add(value);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Append: TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.GetEnumerator : TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Clone: TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage;
end;
function TFhirMedicinalProductDefinitionNameCountryLanguageList.IndexOf(value: TFhirMedicinalProductDefinitionNameCountryLanguage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Insert(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Item(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Link: TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  FhirMedicinalProductDefinitionNameCountryLanguages[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionCrossReference }

constructor TFhirMedicinalProductDefinitionCrossReference.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionCrossReference.Destroy;
begin
  FProduct.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirMedicinalProductDefinitionCrossReference(oSource).product.Clone;
  type_ := TFhirMedicinalProductDefinitionCrossReference(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableReference', false, TFhirCodeableReference, FProduct.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
end;

function TFhirMedicinalProductDefinitionCrossReference.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReference.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionCrossReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableReference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionCrossReference.fhirType : string;
begin
  result := 'MedicinalProductDefinition.crossReference';
end;

function TFhirMedicinalProductDefinitionCrossReference.Link : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Link);
end;

function TFhirMedicinalProductDefinitionCrossReference.Clone : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReference.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionCrossReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionCrossReference)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionCrossReference(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionCrossReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetProduct(value : TFhirCodeableReference);
begin
  FProduct.free;
  FProduct := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionCrossReference.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('product');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionCrossReference.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProduct.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionCrossReferenceListEnumerator }

constructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionCrossReferenceList }

procedure TFhirMedicinalProductDefinitionCrossReferenceList.AddItem(value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionCrossReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionCrossReference');
  add(value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Append: TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Clone: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionCrossReference;
end;
function TFhirMedicinalProductDefinitionCrossReferenceList.IndexOf(value: TFhirMedicinalProductDefinitionCrossReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Insert(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Item(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Link: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  FhirMedicinalProductDefinitionCrossReferences[index] := value;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionManufacturingBusinessOperation }

constructor TFhirMedicinalProductDefinitionManufacturingBusinessOperation.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionManufacturingBusinessOperation.Destroy;
begin
  FType_.free;
  FEffectiveDate.free;
  FManufacturerList.Free;
  FAuthorization.free;
  FConfidentialityIndicator.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).type_.Clone;
  effectiveDate := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).effectiveDate.Clone;
  if (TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).FManufacturerList);
  end;
  authorization := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).authorization.Clone;
  confidentialityIndicator := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(oSource).confidentialityIndicator.Clone;
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effectiveDate') Then
     list.add(self.link, 'effectiveDate', FEffectiveDate.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'authorization') Then
     list.add(self.link, 'authorization', FAuthorization.Link);
  if (child_name = 'confidentialityIndicator') Then
     list.add(self.link, 'confidentialityIndicator', FConfidentialityIndicator.Link);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableReference', false, TFhirCodeableReference, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'Period', false, TFhirPeriod, FEffectiveDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'authorization', 'Reference', false, TFhirReference, FAuthorization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'confidentialityIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentialityIndicator.Link)); {L1172}
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'effectiveDate') then
  begin
    EffectiveDate := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'authorization') then
  begin
    Authorization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'confidentialityIndicator') then
  begin
    ConfidentialityIndicator := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'effectiveDate') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'authorization') then result := TFhirReference.create() {L1203}
  else if (propName = 'confidentialityIndicator') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableReference'
  else if (propName = 'effectiveDate') then result := 'Period'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'authorization') then result := 'Reference'
  else if (propName = 'confidentialityIndicator') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'effectiveDate') then EffectiveDateElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'authorization') then AuthorizationElement := nil
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableReference {L1195}
  else if (propName = 'effectiveDate') then EffectiveDateElement := new as TFhirPeriod {L1195}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'authorization') then AuthorizationElement := new as TFhirReference {L1195}
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.fhirType : string;
begin
  result := 'MedicinalProductDefinition.manufacturingBusinessOperation';
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.Link : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(inherited Link);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.Clone : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(inherited Clone);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionManufacturingBusinessOperation)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(effectiveDateElement, o.effectiveDateElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(authorizationElement, o.authorizationElement, true) and 
      compareDeep(confidentialityIndicatorElement, o.confidentialityIndicatorElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEffectiveDate) and isEmptyProp(FmanufacturerList) and isEmptyProp(FAuthorization) and isEmptyProp(FConfidentialityIndicator);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.SetType_(value : TFhirCodeableReference);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.SetEffectiveDate(value : TFhirPeriod);
begin
  FEffectiveDate.free;
  FEffectiveDate := value; {L1134}
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.SetAuthorization(value : TFhirReference);
begin
  FAuthorization.free;
  FAuthorization := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.SetConfidentialityIndicator(value : TFhirCodeableConcept);
begin
  FConfidentialityIndicator.free;
  FConfidentialityIndicator := value; {L1134}
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('effectiveDate');
  fields.add('manufacturer');
  fields.add('authorization');
  fields.add('confidentialityIndicator');
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FEffectiveDate.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FAuthorization.sizeInBytes);
  inc(result, FConfidentialityIndicator.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator }

constructor TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.Create(list : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionManufacturingBusinessOperationList }

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.AddItem(value: TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionManufacturingBusinessOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionManufacturingBusinessOperation');
  add(value);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Append: TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.GetEnumerator : TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Clone: TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperationList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
end;
function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.IndexOf(value: TFhirMedicinalProductDefinitionManufacturingBusinessOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Insert(index: Integer): TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Item(index: Integer): TFhirMedicinalProductDefinitionManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Link: TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
begin
  result := TFhirMedicinalProductDefinitionManufacturingBusinessOperationList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
  FhirMedicinalProductDefinitionManufacturingBusinessOperations[index] := value;
end;

procedure TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionManufacturingBusinessOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinition }

constructor TFhirMedicinalProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FDomain.free;
  FVersion.free;
  FStatus.free;
  FStatusDate.free;
  FDescription.free;
  FCombinedPharmaceuticalDoseForm.free;
  FIndication.free;
  FLegalStatusOfSupply.free;
  FAdditionalMonitoringIndicator.free;
  FSpecialMeasuresList.Free;
  FPaediatricUseIndicator.free;
  FClassificationList.Free;
  FCharacteristicList.Free;
  FMarketingStatusList.Free;
  FPharmaceuticalProductList.Free;
  FPackagedMedicinalProductList.Free;
  FIngredientList.Free;
  FImpurityList.Free;
  FAttachedDocumentList.Free;
  FMasterFileList.Free;
  FContactList.Free;
  FClinicalTrialList.Free;
  FNameList.Free;
  FCrossReferenceList.Free;
  FManufacturingBusinessOperationList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductDefinition(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProductDefinition(oSource).type_.Clone;
  domain := TFhirMedicinalProductDefinition(oSource).domain.Clone;
  versionElement := TFhirMedicinalProductDefinition(oSource).versionElement.Clone;
  status := TFhirMedicinalProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirMedicinalProductDefinition(oSource).statusDateElement.Clone;
  descriptionElement := TFhirMedicinalProductDefinition(oSource).descriptionElement.Clone;
  combinedPharmaceuticalDoseForm := TFhirMedicinalProductDefinition(oSource).combinedPharmaceuticalDoseForm.Clone;
  indicationElement := TFhirMedicinalProductDefinition(oSource).indicationElement.Clone;
  legalStatusOfSupply := TFhirMedicinalProductDefinition(oSource).legalStatusOfSupply.Clone;
  additionalMonitoringIndicator := TFhirMedicinalProductDefinition(oSource).additionalMonitoringIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList = nil) then
  begin
    FSpecialMeasuresList.free;
    FSpecialMeasuresList := nil;
  end
  else
  begin
    if FSpecialMeasuresList = nil then
      FSpecialMeasuresList := TFhirCodeableConceptList.Create;
    FSpecialMeasuresList.Assign(TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList);
  end;
  paediatricUseIndicator := TFhirMedicinalProductDefinition(oSource).paediatricUseIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicinalProductDefinition(oSource).FClassificationList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirMedicinalProductDefinition(oSource).FCharacteristicList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirMedicinalProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FPharmaceuticalProductList = nil) then
  begin
    FPharmaceuticalProductList.free;
    FPharmaceuticalProductList := nil;
  end
  else
  begin
    if FPharmaceuticalProductList = nil then
      FPharmaceuticalProductList := TFhirReferenceList.Create;
    FPharmaceuticalProductList.Assign(TFhirMedicinalProductDefinition(oSource).FPharmaceuticalProductList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList = nil) then
  begin
    FPackagedMedicinalProductList.free;
    FPackagedMedicinalProductList := nil;
  end
  else
  begin
    if FPackagedMedicinalProductList = nil then
      FPackagedMedicinalProductList := TFhirReferenceList.Create;
    FPackagedMedicinalProductList.Assign(TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirReferenceList.Create;
    FIngredientList.Assign(TFhirMedicinalProductDefinition(oSource).FIngredientList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FImpurityList = nil) then
  begin
    FImpurityList.free;
    FImpurityList := nil;
  end
  else
  begin
    if FImpurityList = nil then
      FImpurityList := TFhirReferenceList.Create;
    FImpurityList.Assign(TFhirMedicinalProductDefinition(oSource).FImpurityList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList.Create;
    FAttachedDocumentList.Assign(TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMasterFileList = nil) then
  begin
    FMasterFileList.free;
    FMasterFileList := nil;
  end
  else
  begin
    if FMasterFileList = nil then
      FMasterFileList := TFhirReferenceList.Create;
    FMasterFileList.Assign(TFhirMedicinalProductDefinition(oSource).FMasterFileList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirMedicinalProductDefinitionContactList.Create;
    FContactList.Assign(TFhirMedicinalProductDefinition(oSource).FContactList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FClinicalTrialList = nil) then
  begin
    FClinicalTrialList.free;
    FClinicalTrialList := nil;
  end
  else
  begin
    if FClinicalTrialList = nil then
      FClinicalTrialList := TFhirReferenceList.Create;
    FClinicalTrialList.Assign(TFhirMedicinalProductDefinition(oSource).FClinicalTrialList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirMedicinalProductDefinitionNameList.Create;
    FNameList.Assign(TFhirMedicinalProductDefinition(oSource).FNameList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCrossReferenceList = nil) then
  begin
    FCrossReferenceList.free;
    FCrossReferenceList := nil;
  end
  else
  begin
    if FCrossReferenceList = nil then
      FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
    FCrossReferenceList.Assign(TFhirMedicinalProductDefinition(oSource).FCrossReferenceList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FManufacturingBusinessOperationList = nil) then
  begin
    FManufacturingBusinessOperationList.free;
    FManufacturingBusinessOperationList := nil;
  end
  else
  begin
    if FManufacturingBusinessOperationList = nil then
      FManufacturingBusinessOperationList := TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Create;
    FManufacturingBusinessOperationList.Assign(TFhirMedicinalProductDefinition(oSource).FManufacturingBusinessOperationList);
  end;
end;

function TFhirMedicinalProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductDefinition;
end;

procedure TFhirMedicinalProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'combinedPharmaceuticalDoseForm') Then
     list.add(self.link, 'combinedPharmaceuticalDoseForm', FCombinedPharmaceuticalDoseForm.Link);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'additionalMonitoringIndicator') Then
     list.add(self.link, 'additionalMonitoringIndicator', FAdditionalMonitoringIndicator.Link);
  if (child_name = 'specialMeasures') Then
    list.addAll(self, 'specialMeasures', FSpecialMeasuresList);
  if (child_name = 'paediatricUseIndicator') Then
     list.add(self.link, 'paediatricUseIndicator', FPaediatricUseIndicator.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'pharmaceuticalProduct') Then
    list.addAll(self, 'pharmaceuticalProduct', FPharmaceuticalProductList);
  if (child_name = 'packagedMedicinalProduct') Then
    list.addAll(self, 'packagedMedicinalProduct', FPackagedMedicinalProductList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'impurity') Then
    list.addAll(self, 'impurity', FImpurityList);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'masterFile') Then
    list.addAll(self, 'masterFile', FMasterFileList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'clinicalTrial') Then
    list.addAll(self, 'clinicalTrial', FClinicalTrialList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'crossReference') Then
    list.addAll(self, 'crossReference', FCrossReferenceList);
  if (child_name = 'manufacturingBusinessOperation') Then
    list.addAll(self, 'manufacturingBusinessOperation', FManufacturingBusinessOperationList);
end;

procedure TFhirMedicinalProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'combinedPharmaceuticalDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FCombinedPharmaceuticalDoseForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'indication', 'markdown', false, TFhirMarkdown, FIndication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'additionalMonitoringIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalMonitoringIndicator.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specialMeasures', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialMeasuresList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'paediatricUseIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FPaediatricUseIndicator.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'pharmaceuticalProduct', 'Reference', true, TFhirReference, FPharmaceuticalProductList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'packagedMedicinalProduct', 'Reference', true, TFhirReference, FPackagedMedicinalProductList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'Reference', true, TFhirReference, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'impurity', 'Reference', true, TFhirReference, FImpurityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference', true, TFhirReference, FAttachedDocumentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'masterFile', 'Reference', true, TFhirReference, FMasterFileList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirMedicinalProductDefinitionContact, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'clinicalTrial', 'Reference', true, TFhirReference, FClinicalTrialList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirMedicinalProductDefinitionName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'crossReference', 'BackboneElement', true, TFhirMedicinalProductDefinitionCrossReference, FCrossReferenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manufacturingBusinessOperation', 'BackboneElement', true, TFhirMedicinalProductDefinitionManufacturingBusinessOperation, FManufacturingBusinessOperationList.Link)) {L1039};
end;

function TFhirMedicinalProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'combinedPharmaceuticalDoseForm') then
  begin
    CombinedPharmaceuticalDoseForm := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'additionalMonitoringIndicator') then
  begin
    AdditionalMonitoringIndicator := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'specialMeasures') then
  begin
    SpecialMeasuresList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'paediatricUseIndicator') then
  begin
    PaediatricUseIndicator := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus) {L1048};
    result := propValue;
  end
  else if (propName = 'pharmaceuticalProduct') then
  begin
    PharmaceuticalProductList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'packagedMedicinalProduct') then
  begin
    PackagedMedicinalProductList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'impurity') then
  begin
    ImpurityList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'masterFile') then
  begin
    MasterFileList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirMedicinalProductDefinitionContact) {L1048};
    result := propValue;
  end
  else if (propName = 'clinicalTrial') then
  begin
    ClinicalTrialList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirMedicinalProductDefinitionName) {L1048};
    result := propValue;
  end
  else if (propName = 'crossReference') then
  begin
    CrossReferenceList.add(propValue as TFhirMedicinalProductDefinitionCrossReference) {L1048};
    result := propValue;
  end
  else if (propName = 'manufacturingBusinessOperation') then
  begin
    ManufacturingBusinessOperationList.add(propValue as TFhirMedicinalProductDefinitionManufacturingBusinessOperation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'specialMeasures') then SpecialMeasuresList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus) {L1049}
  else if (propName = 'pharmaceuticalProduct') then PharmaceuticalProductList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'impurity') then ImpurityList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'masterFile') then MasterFileList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirMedicinalProductDefinitionContact) {L1049}
  else if (propName = 'clinicalTrial') then ClinicalTrialList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirMedicinalProductDefinitionName) {L1049}
  else if (propName = 'crossReference') then CrossReferenceList.insertItem(index, propValue as TFhirMedicinalProductDefinitionCrossReference) {L1049}
  else if (propName = 'manufacturingBusinessOperation') then ManufacturingBusinessOperationList.insertItem(index, propValue as TFhirMedicinalProductDefinitionManufacturingBusinessOperation) {L1049}
  else inherited;
end;

function TFhirMedicinalProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'domain') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'version') then result := TFhirString.create() {L1223}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'indication') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'additionalMonitoringIndicator') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'specialMeasures') then result := SpecialMeasuresList.new() {L1053}
  else if (propName = 'paediatricUseIndicator') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'classification') then result := ClassificationList.new() {L1053}
  else if (propName = 'characteristic') then result := CharacteristicList.new() {L1053}
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new() {L1053}
  else if (propName = 'pharmaceuticalProduct') then result := PharmaceuticalProductList.new() {L1053}
  else if (propName = 'packagedMedicinalProduct') then result := PackagedMedicinalProductList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'impurity') then result := ImpurityList.new() {L1053}
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new() {L1053}
  else if (propName = 'masterFile') then result := MasterFileList.new() {L1053}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'clinicalTrial') then result := ClinicalTrialList.new() {L1053}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'crossReference') then result := CrossReferenceList.new() {L1053}
  else if (propName = 'manufacturingBusinessOperation') then result := ManufacturingBusinessOperationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := 'CodeableConcept'
  else if (propName = 'indication') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'additionalMonitoringIndicator') then result := 'CodeableConcept'
  else if (propName = 'specialMeasures') then result := 'CodeableConcept'
  else if (propName = 'paediatricUseIndicator') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'pharmaceuticalProduct') then result := 'Reference'
  else if (propName = 'packagedMedicinalProduct') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'Reference'
  else if (propName = 'impurity') then result := 'Reference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'masterFile') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'clinicalTrial') then result := 'Reference'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'crossReference') then result := 'BackboneElement'
  else if (propName = 'manufacturingBusinessOperation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := nil
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := nil
  else if (propName = 'specialMeasures') then deletePropertyValue('specialMeasures', SpecialMeasuresList, value) {L1054}
  else if (propName = 'paediatricUseIndicator') then PaediatricUseIndicatorElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {L1054}
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {L1054}
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value) {L1054}
  else if (propName = 'pharmaceuticalProduct') then deletePropertyValue('pharmaceuticalProduct', PharmaceuticalProductList, value) {L1054}
  else if (propName = 'packagedMedicinalProduct') then deletePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'impurity') then deletePropertyValue('impurity', ImpurityList, value) {L1054}
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value) {L1054}
  else if (propName = 'masterFile') then deletePropertyValue('masterFile', MasterFileList, value) {L1054}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'clinicalTrial') then deletePropertyValue('clinicalTrial', ClinicalTrialList, value) {L1054}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'crossReference') then deletePropertyValue('crossReference', CrossReferenceList, value) {L1054}
  else if (propName = 'manufacturingBusinessOperation') then deletePropertyValue('manufacturingBusinessOperation', ManufacturingBusinessOperationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'version') then VersionElement := asString(new) {L1222}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'indication') then IndicationElement := asMarkdown(new) {L1222}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'specialMeasures') then replacePropertyValue('specialMeasures', SpecialMeasuresList, existing, new) {L1055}
  else if (propName = 'paediatricUseIndicator') then PaediatricUseIndicatorElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {L1055}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {L1055}
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new) {L1055}
  else if (propName = 'pharmaceuticalProduct') then replacePropertyValue('pharmaceuticalProduct', PharmaceuticalProductList, existing, new) {L1055}
  else if (propName = 'packagedMedicinalProduct') then replacePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'impurity') then replacePropertyValue('impurity', ImpurityList, existing, new) {L1055}
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new) {L1055}
  else if (propName = 'masterFile') then replacePropertyValue('masterFile', MasterFileList, existing, new) {L1055}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'clinicalTrial') then replacePropertyValue('clinicalTrial', ClinicalTrialList, existing, new) {L1055}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'crossReference') then replacePropertyValue('crossReference', CrossReferenceList, existing, new) {L1055}
  else if (propName = 'manufacturingBusinessOperation') then replacePropertyValue('manufacturingBusinessOperation', ManufacturingBusinessOperationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'specialMeasures') then SpecialMeasuresList.move(source, destination) {L1050}
  else if (propName = 'classification') then ClassificationList.move(source, destination) {L1050}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination) {L1050}
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination) {L1050}
  else if (propName = 'pharmaceuticalProduct') then PharmaceuticalProductList.move(source, destination) {L1050}
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else if (propName = 'impurity') then ImpurityList.move(source, destination) {L1050}
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination) {L1050}
  else if (propName = 'masterFile') then MasterFileList.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'clinicalTrial') then ClinicalTrialList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'crossReference') then CrossReferenceList.move(source, destination) {L1050}
  else if (propName = 'manufacturingBusinessOperation') then ManufacturingBusinessOperationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinition.fhirType : string;
begin
  result := 'MedicinalProductDefinition';
end;

function TFhirMedicinalProductDefinition.Link : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Link);
end;

function TFhirMedicinalProductDefinition.Clone : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Clone);
end;

function TFhirMedicinalProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinition)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(combinedPharmaceuticalDoseFormElement, o.combinedPharmaceuticalDoseFormElement, true) and 
      compareDeep(indicationElement, o.indicationElement, true) and compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(additionalMonitoringIndicatorElement, o.additionalMonitoringIndicatorElement, true) and 
      compareDeep(specialMeasuresList, o.specialMeasuresList, true) and compareDeep(paediatricUseIndicatorElement, o.paediatricUseIndicatorElement, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(pharmaceuticalProductList, o.pharmaceuticalProductList, true) and 
      compareDeep(packagedMedicinalProductList, o.packagedMedicinalProductList, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(impurityList, o.impurityList, true) and 
      compareDeep(attachedDocumentList, o.attachedDocumentList, true) and compareDeep(masterFileList, o.masterFileList, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(clinicalTrialList, o.clinicalTrialList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(crossReferenceList, o.crossReferenceList, true) and 
      compareDeep(manufacturingBusinessOperationList, o.manufacturingBusinessOperationList, true);
  end;
end;

function TFhirMedicinalProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FDomain) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FDescription) and isEmptyProp(FCombinedPharmaceuticalDoseForm) and isEmptyProp(FIndication) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FAdditionalMonitoringIndicator) and isEmptyProp(FspecialMeasuresList) and isEmptyProp(FPaediatricUseIndicator) and isEmptyProp(FclassificationList) and isEmptyProp(FcharacteristicList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FpharmaceuticalProductList) and isEmptyProp(FpackagedMedicinalProductList) and isEmptyProp(FingredientList) and isEmptyProp(FimpurityList) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FmasterFileList) and isEmptyProp(FcontactList) and isEmptyProp(FclinicalTrialList) and isEmptyProp(FnameList) and isEmptyProp(FcrossReferenceList) and isEmptyProp(FmanufacturingBusinessOperationList);
end;

function TFhirMedicinalProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicinalProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirMedicinalProductDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value; {L1134}
end;

procedure TFhirMedicinalProductDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMedicinalProductDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirMedicinalProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirMedicinalProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirMedicinalProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMedicinalProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
begin
  FCombinedPharmaceuticalDoseForm.free;
  FCombinedPharmaceuticalDoseForm := value; {L1134}
end;

procedure TFhirMedicinalProductDefinition.SetIndication(value : TFhirMarkdown);
begin
  FIndication.free;
  FIndication := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetIndicationST : String;
begin
  if FIndication = nil then
    result := ''
  else
    result := FIndication.value;
end;

procedure TFhirMedicinalProductDefinition.SetIndicationST(value : String);
begin
  if value <> '' then
  begin
    if FIndication = nil then
      FIndication := TFhirMarkdown.create;
    FIndication.value := value
  end
  else if FIndication <> nil then
    FIndication.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value; {L1134}
end;

procedure TFhirMedicinalProductDefinition.SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
begin
  FAdditionalMonitoringIndicator.free;
  FAdditionalMonitoringIndicator := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetSpecialMeasuresList : TFhirCodeableConceptList;
begin
  if FSpecialMeasuresList = nil then
    FSpecialMeasuresList := TFhirCodeableConceptList.Create;
  result := FSpecialMeasuresList;
end;

function TFhirMedicinalProductDefinition.GetHasSpecialMeasuresList : boolean;
begin
  result := (FSpecialMeasuresList <> nil) and (FSpecialMeasuresList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetPaediatricUseIndicator(value : TFhirCodeableConcept);
begin
  FPaediatricUseIndicator.free;
  FPaediatricUseIndicator := value; {L1134}
end;

function TFhirMedicinalProductDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicinalProductDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirMedicinalProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirMedicinalProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetPharmaceuticalProductList : TFhirReferenceList;
begin
  if FPharmaceuticalProductList = nil then
    FPharmaceuticalProductList := TFhirReferenceList.Create;
  result := FPharmaceuticalProductList;
end;

function TFhirMedicinalProductDefinition.GetHasPharmaceuticalProductList : boolean;
begin
  result := (FPharmaceuticalProductList <> nil) and (FPharmaceuticalProductList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetPackagedMedicinalProductList : TFhirReferenceList;
begin
  if FPackagedMedicinalProductList = nil then
    FPackagedMedicinalProductList := TFhirReferenceList.Create;
  result := FPackagedMedicinalProductList;
end;

function TFhirMedicinalProductDefinition.GetHasPackagedMedicinalProductList : boolean;
begin
  result := (FPackagedMedicinalProductList <> nil) and (FPackagedMedicinalProductList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetIngredientList : TFhirReferenceList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirReferenceList.Create;
  result := FIngredientList;
end;

function TFhirMedicinalProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetImpurityList : TFhirReferenceList;
begin
  if FImpurityList = nil then
    FImpurityList := TFhirReferenceList.Create;
  result := FImpurityList;
end;

function TFhirMedicinalProductDefinition.GetHasImpurityList : boolean;
begin
  result := (FImpurityList <> nil) and (FImpurityList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetAttachedDocumentList : TFhirReferenceList;
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList.Create;
  result := FAttachedDocumentList;
end;

function TFhirMedicinalProductDefinition.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMasterFileList : TFhirReferenceList;
begin
  if FMasterFileList = nil then
    FMasterFileList := TFhirReferenceList.Create;
  result := FMasterFileList;
end;

function TFhirMedicinalProductDefinition.GetHasMasterFileList : boolean;
begin
  result := (FMasterFileList <> nil) and (FMasterFileList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetContactList : TFhirMedicinalProductDefinitionContactList;
begin
  if FContactList = nil then
    FContactList := TFhirMedicinalProductDefinitionContactList.Create;
  result := FContactList;
end;

function TFhirMedicinalProductDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetClinicalTrialList : TFhirReferenceList;
begin
  if FClinicalTrialList = nil then
    FClinicalTrialList := TFhirReferenceList.Create;
  result := FClinicalTrialList;
end;

function TFhirMedicinalProductDefinition.GetHasClinicalTrialList : boolean;
begin
  result := (FClinicalTrialList <> nil) and (FClinicalTrialList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetNameList : TFhirMedicinalProductDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirMedicinalProductDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirMedicinalProductDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  if FCrossReferenceList = nil then
    FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
  result := FCrossReferenceList;
end;

function TFhirMedicinalProductDefinition.GetHasCrossReferenceList : boolean;
begin
  result := (FCrossReferenceList <> nil) and (FCrossReferenceList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetManufacturingBusinessOperationList : TFhirMedicinalProductDefinitionManufacturingBusinessOperationList;
begin
  if FManufacturingBusinessOperationList = nil then
    FManufacturingBusinessOperationList := TFhirMedicinalProductDefinitionManufacturingBusinessOperationList.Create;
  result := FManufacturingBusinessOperationList;
end;

function TFhirMedicinalProductDefinition.GetHasManufacturingBusinessOperationList : boolean;
begin
  result := (FManufacturingBusinessOperationList <> nil) and (FManufacturingBusinessOperationList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('domain');
  fields.add('version');
  fields.add('status');
  fields.add('statusDate');
  fields.add('description');
  fields.add('combinedPharmaceuticalDoseForm');
  fields.add('indication');
  fields.add('legalStatusOfSupply');
  fields.add('additionalMonitoringIndicator');
  fields.add('specialMeasures');
  fields.add('paediatricUseIndicator');
  fields.add('classification');
  fields.add('characteristic');
  fields.add('marketingStatus');
  fields.add('pharmaceuticalProduct');
  fields.add('packagedMedicinalProduct');
  fields.add('ingredient');
  fields.add('impurity');
  fields.add('attachedDocument');
  fields.add('masterFile');
  fields.add('contact');
  fields.add('clinicalTrial');
  fields.add('name');
  fields.add('crossReference');
  fields.add('manufacturingBusinessOperation');
end;

function TFhirMedicinalProductDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDomain.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FCombinedPharmaceuticalDoseForm.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FLegalStatusOfSupply.sizeInBytes);
  inc(result, FAdditionalMonitoringIndicator.sizeInBytes);
  inc(result, FspecialMeasuresList.sizeInBytes);
  inc(result, FPaediatricUseIndicator.sizeInBytes);
  inc(result, FclassificationList.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
  inc(result, FmarketingStatusList.sizeInBytes);
  inc(result, FpharmaceuticalProductList.sizeInBytes);
  inc(result, FpackagedMedicinalProductList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FimpurityList.sizeInBytes);
  inc(result, FattachedDocumentList.sizeInBytes);
  inc(result, FmasterFileList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FclinicalTrialList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FcrossReferenceList.sizeInBytes);
  inc(result, FmanufacturingBusinessOperationList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionListEnumerator }

constructor TFhirMedicinalProductDefinitionListEnumerator.Create(list : TFhirMedicinalProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionListEnumerator.GetCurrent : TFhirMedicinalProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductDefinitionList }

procedure TFhirMedicinalProductDefinitionList.AddItem(value: TFhirMedicinalProductDefinition);
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinition');
  add(value);
end;

function TFhirMedicinalProductDefinitionList.Append: TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionList.GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionList.Clone: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionList.GetItemN(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinition;
end;
function TFhirMedicinalProductDefinitionList.IndexOf(value: TFhirMedicinalProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionList.Insert(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionList.Item(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.Link: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  FhirMedicinalProductDefinitions[index] := value;
end;

procedure TFhirMedicinalProductDefinitionList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
{ TFhirNutritionProductNutrient }

constructor TFhirNutritionProductNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductNutrient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductNutrient(oSource).item.Clone;
  if (TFhirNutritionProductNutrient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductNutrient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link)) {L1039};
end;

function TFhirNutritionProductNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio) {L1049}
  else inherited;
end;

function TFhirNutritionProductNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'amount') then result := AmountList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductNutrient.fhirType : string;
begin
  result := 'NutritionProduct.nutrient';
end;

function TFhirNutritionProductNutrient.Link : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Link);
end;

function TFhirNutritionProductNutrient.Clone : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Clone);
end;

function TFhirNutritionProductNutrient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductNutrient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductNutrient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

function TFhirNutritionProductNutrient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductNutrient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

procedure TFhirNutritionProductNutrient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductNutrient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FamountList.sizeInBytes);
end;

{ TFhirNutritionProductNutrientListEnumerator }

constructor TFhirNutritionProductNutrientListEnumerator.Create(list : TFhirNutritionProductNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductNutrientListEnumerator.GetCurrent : TFhirNutritionProductNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductNutrientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionProductNutrientList }

procedure TFhirNutritionProductNutrientList.AddItem(value: TFhirNutritionProductNutrient);
begin
  assert(value.ClassName = 'TFhirNutritionProductNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductNutrient');
  add(value);
end;

function TFhirNutritionProductNutrientList.Append: TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductNutrientList.GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
begin
  result := TFhirNutritionProductNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductNutrientList.Clone: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Clone);
end;

function TFhirNutritionProductNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductNutrientList.GetItemN(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductNutrient;
end;
function TFhirNutritionProductNutrientList.IndexOf(value: TFhirNutritionProductNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductNutrientList.Insert(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.InsertItem(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductNutrientList.Item(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.Link: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Link);
end;

procedure TFhirNutritionProductNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  FhirNutritionProductNutrients[index] := value;
end;

procedure TFhirNutritionProductNutrientList.SetItemN(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductIngredient }

constructor TFhirNutritionProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductIngredient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductIngredient(oSource).item.Clone;
  if (TFhirNutritionProductIngredient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductIngredient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link)) {L1039};
end;

function TFhirNutritionProductIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio) {L1049}
  else inherited;
end;

function TFhirNutritionProductIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create() {L1203}
  else if (propName = 'amount') then result := AmountList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference {L1195}
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductIngredient.fhirType : string;
begin
  result := 'NutritionProduct.ingredient';
end;

function TFhirNutritionProductIngredient.Link : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Link);
end;

function TFhirNutritionProductIngredient.Clone : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Clone);
end;

function TFhirNutritionProductIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductIngredient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value; {L1134}
end;

function TFhirNutritionProductIngredient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductIngredient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

procedure TFhirNutritionProductIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FamountList.sizeInBytes);
end;

{ TFhirNutritionProductIngredientListEnumerator }

constructor TFhirNutritionProductIngredientListEnumerator.Create(list : TFhirNutritionProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductIngredientListEnumerator.GetCurrent : TFhirNutritionProductIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionProductIngredientList }

procedure TFhirNutritionProductIngredientList.AddItem(value: TFhirNutritionProductIngredient);
begin
  assert(value.ClassName = 'TFhirNutritionProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductIngredient');
  add(value);
end;

function TFhirNutritionProductIngredientList.Append: TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductIngredientList.GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
begin
  result := TFhirNutritionProductIngredientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductIngredientList.Clone: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Clone);
end;

function TFhirNutritionProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductIngredientList.GetItemN(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductIngredient;
end;
function TFhirNutritionProductIngredientList.IndexOf(value: TFhirNutritionProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductIngredientList.Insert(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.InsertItem(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductIngredientList.Item(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.Link: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Link);
end;

procedure TFhirNutritionProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductIngredientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  FhirNutritionProductIngredients[index] := value;
end;

procedure TFhirNutritionProductIngredientList.SetItemN(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductProductCharacteristic }

constructor TFhirNutritionProductProductCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductProductCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirNutritionProductProductCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionProductProductCharacteristic(oSource).type_.Clone;
  value := TFhirNutritionProductProductCharacteristic(oSource).value.Clone;
end;

procedure TFhirNutritionProductProductCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirNutritionProductProductCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirNutritionProductProductCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductProductCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionProductProductCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductProductCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductProductCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductProductCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductProductCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductProductCharacteristic.fhirType : string;
begin
  result := 'NutritionProduct.productCharacteristic';
end;

function TFhirNutritionProductProductCharacteristic.Link : TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(inherited Link);
end;

function TFhirNutritionProductProductCharacteristic.Clone : TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(inherited Clone);
end;

function TFhirNutritionProductProductCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductProductCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductProductCharacteristic)) then
    result := false
  else
  begin
    o := TFhirNutritionProductProductCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirNutritionProductProductCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirNutritionProductProductCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirNutritionProductProductCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirNutritionProductProductCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirNutritionProductProductCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirNutritionProductProductCharacteristicListEnumerator }

constructor TFhirNutritionProductProductCharacteristicListEnumerator.Create(list : TFhirNutritionProductProductCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductProductCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.GetCurrent : TFhirNutritionProductProductCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionProductProductCharacteristicList }

procedure TFhirNutritionProductProductCharacteristicList.AddItem(value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value.ClassName = 'TFhirNutritionProductProductCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductProductCharacteristic');
  add(value);
end;

function TFhirNutritionProductProductCharacteristicList.Append: TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductProductCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductProductCharacteristicList.GetEnumerator : TFhirNutritionProductProductCharacteristicListEnumerator;
begin
  result := TFhirNutritionProductProductCharacteristicListEnumerator.Create(self.link);
end;

function TFhirNutritionProductProductCharacteristicList.Clone: TFhirNutritionProductProductCharacteristicList;
begin
  result := TFhirNutritionProductProductCharacteristicList(inherited Clone);
end;

function TFhirNutritionProductProductCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductProductCharacteristicList.GetItemN(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductProductCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductProductCharacteristic;
end;
function TFhirNutritionProductProductCharacteristicList.IndexOf(value: TFhirNutritionProductProductCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductProductCharacteristicList.Insert(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductProductCharacteristicList.InsertItem(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductProductCharacteristicList.Item(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductProductCharacteristicList.Link: TFhirNutritionProductProductCharacteristicList;
begin
  result := TFhirNutritionProductProductCharacteristicList(inherited Link);
end;

procedure TFhirNutritionProductProductCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductProductCharacteristicList.SetItemByIndex(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  FhirNutritionProductProductCharacteristics[index] := value;
end;

procedure TFhirNutritionProductProductCharacteristicList.SetItemN(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductInstance }

constructor TFhirNutritionProductInstance.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductInstance.Destroy;
begin
  FQuantity.free;
  FIdentifierList.Free;
  FLotNumber.free;
  FExpiry.free;
  FUseBy.free;
  inherited;
end;

procedure TFhirNutritionProductInstance.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirNutritionProductInstance(oSource).quantity.Clone;
  if (TFhirNutritionProductInstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionProductInstance(oSource).FIdentifierList);
  end;
  lotNumberElement := TFhirNutritionProductInstance(oSource).lotNumberElement.Clone;
  expiryElement := TFhirNutritionProductInstance(oSource).expiryElement.Clone;
  useByElement := TFhirNutritionProductInstance(oSource).useByElement.Clone;
end;

procedure TFhirNutritionProductInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'useBy') Then
     list.add(self.link, 'useBy', FUseBy.Link);
end;

procedure TFhirNutritionProductInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'useBy', 'dateTime', false, TFhirDateTime, FUseBy.Link)); {L1172}
end;

function TFhirNutritionProductInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'useBy') then
  begin
    UseByElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirNutritionProductInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'lotNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'expiry') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'useBy') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'useBy') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'useBy') then UseByElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new) {L1222}
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new) {L1222}
  else if (propName = 'useBy') then UseByElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductInstance.fhirType : string;
begin
  result := 'NutritionProduct.instance';
end;

function TFhirNutritionProductInstance.Link : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Link);
end;

function TFhirNutritionProductInstance.Clone : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Clone);
end;

function TFhirNutritionProductInstance.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductInstance)) then
    result := false
  else
  begin
    o := TFhirNutritionProductInstance(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(useByElement, o.useByElement, true);
  end;
end;

function TFhirNutritionProductInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FidentifierList) and isEmptyProp(FLotNumber) and isEmptyProp(FExpiry) and isEmptyProp(FUseBy);
end;

procedure TFhirNutritionProductInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirNutritionProductInstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionProductInstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirNutritionProductInstance.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value; {L1134}
end;

function TFhirNutritionProductInstance.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirNutritionProductInstance.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirNutritionProductInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value; {L1134}
end;

function TFhirNutritionProductInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirNutritionProductInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirNutritionProductInstance.SetUseBy(value : TFhirDateTime);
begin
  FUseBy.free;
  FUseBy := value; {L1134}
end;

function TFhirNutritionProductInstance.GetUseByST : TFslDateTime;
begin
  if FUseBy = nil then
    result := TFslDateTime.makeNull
  else
    result := FUseBy.value;
end;

procedure TFhirNutritionProductInstance.SetUseByST(value : TFslDateTime);
begin
  if FUseBy = nil then
    FUseBy := TFhirDateTime.create;
  FUseBy.value := value
end;

procedure TFhirNutritionProductInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('identifier');
  fields.add('lotNumber');
  fields.add('expiry');
  fields.add('useBy');
end;

function TFhirNutritionProductInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpiry.sizeInBytes);
  inc(result, FUseBy.sizeInBytes);
end;

{ TFhirNutritionProductInstanceListEnumerator }

constructor TFhirNutritionProductInstanceListEnumerator.Create(list : TFhirNutritionProductInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductInstanceListEnumerator.GetCurrent : TFhirNutritionProductInstance;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionProductInstanceList }

procedure TFhirNutritionProductInstanceList.AddItem(value: TFhirNutritionProductInstance);
begin
  assert(value.ClassName = 'TFhirNutritionProductInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductInstance');
  add(value);
end;

function TFhirNutritionProductInstanceList.Append: TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductInstanceList.GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
begin
  result := TFhirNutritionProductInstanceListEnumerator.Create(self.link);
end;

function TFhirNutritionProductInstanceList.Clone: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Clone);
end;

function TFhirNutritionProductInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductInstanceList.GetItemN(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductInstance;
end;
function TFhirNutritionProductInstanceList.IndexOf(value: TFhirNutritionProductInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductInstanceList.Insert(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.InsertItem(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductInstanceList.Item(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.Link: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Link);
end;

procedure TFhirNutritionProductInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductInstanceList.SetItemByIndex(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  FhirNutritionProductInstances[index] := value;
end;

procedure TFhirNutritionProductInstanceList.SetItemN(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProduct }

constructor TFhirNutritionProduct.Create;
begin
  inherited;
end;

destructor TFhirNutritionProduct.Destroy;
begin
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FManufacturerList.Free;
  FNutrientList.Free;
  FIngredientList.Free;
  FKnownAllergenList.Free;
  FProductCharacteristicList.Free;
  FInstance.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionProduct.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirNutritionProduct(oSource).statusElement.Clone;
  if (TFhirNutritionProduct(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirNutritionProduct(oSource).FCategoryList);
  end;
  code := TFhirNutritionProduct(oSource).code.Clone;
  if (TFhirNutritionProduct(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirNutritionProduct(oSource).FManufacturerList);
  end;
  if (TFhirNutritionProduct(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionProductNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionProduct(oSource).FNutrientList);
  end;
  if (TFhirNutritionProduct(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirNutritionProductIngredientList.Create;
    FIngredientList.Assign(TFhirNutritionProduct(oSource).FIngredientList);
  end;
  if (TFhirNutritionProduct(oSource).FKnownAllergenList = nil) then
  begin
    FKnownAllergenList.free;
    FKnownAllergenList := nil;
  end
  else
  begin
    if FKnownAllergenList = nil then
      FKnownAllergenList := TFhirCodeableReferenceList.Create;
    FKnownAllergenList.Assign(TFhirNutritionProduct(oSource).FKnownAllergenList);
  end;
  if (TFhirNutritionProduct(oSource).FProductCharacteristicList = nil) then
  begin
    FProductCharacteristicList.free;
    FProductCharacteristicList := nil;
  end
  else
  begin
    if FProductCharacteristicList = nil then
      FProductCharacteristicList := TFhirNutritionProductProductCharacteristicList.Create;
    FProductCharacteristicList.Assign(TFhirNutritionProduct(oSource).FProductCharacteristicList);
  end;
  instance := TFhirNutritionProduct(oSource).instance.Clone;
  if (TFhirNutritionProduct(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionProduct(oSource).FNoteList);
  end;
end;

function TFhirNutritionProduct.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionProduct;
end;

procedure TFhirNutritionProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'knownAllergen') Then
    list.addAll(self, 'knownAllergen', FKnownAllergenList);
  if (child_name = 'productCharacteristic') Then
    list.addAll(self, 'productCharacteristic', FProductCharacteristicList);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'nutrient', 'BackboneElement', true, TFhirNutritionProductNutrient, FNutrientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirNutritionProductIngredient, FIngredientList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'knownAllergen', 'CodeableReference', true, TFhirCodeableReference, FKnownAllergenList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'productCharacteristic', 'BackboneElement', true, TFhirNutritionProductProductCharacteristic, FProductCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', false, TFhirNutritionProductInstance, FInstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirNutritionProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionProductNutrient) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirNutritionProductIngredient) {L1048};
    result := propValue;
  end
  else if (propName = 'knownAllergen') then
  begin
    KnownAllergenList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'productCharacteristic') then
  begin
    ProductCharacteristicList.add(propValue as TFhirNutritionProductProductCharacteristic) {L1048};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    Instance := propValue as TFhirNutritionProductInstance {L1199};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionProductNutrient) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirNutritionProductIngredient) {L1049}
  else if (propName = 'knownAllergen') then KnownAllergenList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'productCharacteristic') then ProductCharacteristicList.insertItem(index, propValue as TFhirNutritionProductProductCharacteristic) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirNutritionProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[NutritionProductStatusNull], CODES_TFhirNutritionProductStatusEnum[NutritionProductStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'nutrient') then result := NutrientList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else if (propName = 'knownAllergen') then result := KnownAllergenList.new() {L1053}
  else if (propName = 'productCharacteristic') then result := ProductCharacteristicList.new() {L1053}
  else if (propName = 'instance') then result := TFhirNutritionProductInstance.create() {L1203}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'nutrient') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'knownAllergen') then result := 'CodeableReference'
  else if (propName = 'productCharacteristic') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else if (propName = 'knownAllergen') then deletePropertyValue('knownAllergen', KnownAllergenList, value) {L1054}
  else if (propName = 'productCharacteristic') then deletePropertyValue('productCharacteristic', ProductCharacteristicList, value) {L1054}
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else if (propName = 'knownAllergen') then replacePropertyValue('knownAllergen', KnownAllergenList, existing, new) {L1055}
  else if (propName = 'productCharacteristic') then replacePropertyValue('productCharacteristic', ProductCharacteristicList, existing, new) {L1055}
  else if (propName = 'instance') then InstanceElement := new as TFhirNutritionProductInstance {L1195}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'nutrient') then NutrientList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else if (propName = 'knownAllergen') then KnownAllergenList.move(source, destination) {L1050}
  else if (propName = 'productCharacteristic') then ProductCharacteristicList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProduct.fhirType : string;
begin
  result := 'NutritionProduct';
end;

function TFhirNutritionProduct.Link : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Link);
end;

function TFhirNutritionProduct.Clone : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Clone);
end;

function TFhirNutritionProduct.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProduct)) then
    result := false
  else
  begin
    o := TFhirNutritionProduct(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(knownAllergenList, o.knownAllergenList, true) and compareDeep(productCharacteristicList, o.productCharacteristicList, true) and 
      compareDeep(instanceElement, o.instanceElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FmanufacturerList) and isEmptyProp(FnutrientList) and isEmptyProp(FingredientList) and isEmptyProp(FknownAllergenList) and isEmptyProp(FproductCharacteristicList) and isEmptyProp(FInstance) and isEmptyProp(FnoteList);
end;

procedure TFhirNutritionProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionProduct.GetStatusST : TFhirNutritionProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNutritionProductStatusEnum(0)
  else
    result := TFhirNutritionProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNutritionProductStatusEnum, FStatus.value));
end;

procedure TFhirNutritionProduct.SetStatusST(value : TFhirNutritionProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[value], CODES_TFhirNutritionProductStatusEnum[value]);
end;

function TFhirNutritionProduct.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirNutritionProduct.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirNutritionProduct.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirNutritionProduct.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirNutritionProduct.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirNutritionProduct.GetNutrientList : TFhirNutritionProductNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionProductNutrientList.Create;
  result := FNutrientList;
end;

function TFhirNutritionProduct.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

function TFhirNutritionProduct.GetIngredientList : TFhirNutritionProductIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirNutritionProductIngredientList.Create;
  result := FIngredientList;
end;

function TFhirNutritionProduct.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirNutritionProduct.GetKnownAllergenList : TFhirCodeableReferenceList;
begin
  if FKnownAllergenList = nil then
    FKnownAllergenList := TFhirCodeableReferenceList.Create;
  result := FKnownAllergenList;
end;

function TFhirNutritionProduct.GetHasKnownAllergenList : boolean;
begin
  result := (FKnownAllergenList <> nil) and (FKnownAllergenList.count > 0);
end;

function TFhirNutritionProduct.GetProductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
begin
  if FProductCharacteristicList = nil then
    FProductCharacteristicList := TFhirNutritionProductProductCharacteristicList.Create;
  result := FProductCharacteristicList;
end;

function TFhirNutritionProduct.GetHasProductCharacteristicList : boolean;
begin
  result := (FProductCharacteristicList <> nil) and (FProductCharacteristicList.count > 0);
end;

procedure TFhirNutritionProduct.SetInstance(value : TFhirNutritionProductInstance);
begin
  FInstance.free;
  FInstance := value; {L1134}
end;

function TFhirNutritionProduct.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionProduct.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirNutritionProduct.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('manufacturer');
  fields.add('nutrient');
  fields.add('ingredient');
  fields.add('knownAllergen');
  fields.add('productCharacteristic');
  fields.add('instance');
  fields.add('note');
end;

function TFhirNutritionProduct.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FnutrientList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FknownAllergenList.sizeInBytes);
  inc(result, FproductCharacteristicList.sizeInBytes);
  inc(result, FInstance.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirNutritionProductListEnumerator }

constructor TFhirNutritionProductListEnumerator.Create(list : TFhirNutritionProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductListEnumerator.GetCurrent : TFhirNutritionProduct;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionProductList }

procedure TFhirNutritionProductList.AddItem(value: TFhirNutritionProduct);
begin
  assert(value.ClassName = 'TFhirNutritionProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProduct');
  add(value);
end;

function TFhirNutritionProductList.Append: TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductList.GetEnumerator : TFhirNutritionProductListEnumerator;
begin
  result := TFhirNutritionProductListEnumerator.Create(self.link);
end;

function TFhirNutritionProductList.Clone: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Clone);
end;

function TFhirNutritionProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductList.GetItemN(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProduct;
end;
function TFhirNutritionProductList.IndexOf(value: TFhirNutritionProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductList.Insert(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.InsertItem(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductList.Item(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.Link: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Link);
end;

procedure TFhirNutritionProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductList.SetItemByIndex(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  FhirNutritionProducts[index] := value;
end;

procedure TFhirNutritionProductList.SetItemN(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
{ TFhirPackagedProductDefinitionBatchIdentifier }

constructor TFhirPackagedProductDefinitionBatchIdentifier.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionBatchIdentifier.Destroy;
begin
  FOuterPackaging.free;
  FImmediatePackaging.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  outerPackaging := TFhirPackagedProductDefinitionBatchIdentifier(oSource).outerPackaging.Clone;
  immediatePackaging := TFhirPackagedProductDefinitionBatchIdentifier(oSource).immediatePackaging.Clone;
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outerPackaging') Then
     list.add(self.link, 'outerPackaging', FOuterPackaging.Link);
  if (child_name = 'immediatePackaging') Then
     list.add(self.link, 'immediatePackaging', FImmediatePackaging.Link);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outerPackaging', 'Identifier', false, TFhirIdentifier, FOuterPackaging.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'immediatePackaging', 'Identifier', false, TFhirIdentifier, FImmediatePackaging.Link)); {L1172}
end;

function TFhirPackagedProductDefinitionBatchIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outerPackaging') then
  begin
    OuterPackaging := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'immediatePackaging') then
  begin
    ImmediatePackaging := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionBatchIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outerPackaging') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'immediatePackaging') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionBatchIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outerPackaging') then result := 'Identifier'
  else if (propName = 'immediatePackaging') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outerPackaging') then OuterPackagingElement := nil
  else if (propName = 'immediatePackaging') then ImmediatePackagingElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outerPackaging') then OuterPackagingElement := new as TFhirIdentifier {L1195}
  else if (propName = 'immediatePackaging') then ImmediatePackagingElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionBatchIdentifier.fhirType : string;
begin
  result := 'PackagedProductDefinition.batchIdentifier';
end;

function TFhirPackagedProductDefinitionBatchIdentifier.Link : TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier(inherited Link);
end;

function TFhirPackagedProductDefinitionBatchIdentifier.Clone : TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier(inherited Clone);
end;

function TFhirPackagedProductDefinitionBatchIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionBatchIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionBatchIdentifier)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionBatchIdentifier(other);
    result := compareDeep(outerPackagingElement, o.outerPackagingElement, true) and 
      compareDeep(immediatePackagingElement, o.immediatePackagingElement, true);
  end;
end;

function TFhirPackagedProductDefinitionBatchIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOuterPackaging) and isEmptyProp(FImmediatePackaging);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.SetOuterPackaging(value : TFhirIdentifier);
begin
  FOuterPackaging.free;
  FOuterPackaging := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.SetImmediatePackaging(value : TFhirIdentifier);
begin
  FImmediatePackaging.free;
  FImmediatePackaging := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionBatchIdentifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outerPackaging');
  fields.add('immediatePackaging');
end;

function TFhirPackagedProductDefinitionBatchIdentifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOuterPackaging.sizeInBytes);
  inc(result, FImmediatePackaging.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionBatchIdentifierListEnumerator }

constructor TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.Create(list : TFhirPackagedProductDefinitionBatchIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.GetCurrent : TFhirPackagedProductDefinitionBatchIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionBatchIdentifierList }

procedure TFhirPackagedProductDefinitionBatchIdentifierList.AddItem(value: TFhirPackagedProductDefinitionBatchIdentifier);
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionBatchIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionBatchIdentifier');
  add(value);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Append: TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionBatchIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.GetEnumerator : TFhirPackagedProductDefinitionBatchIdentifierListEnumerator;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifierListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Clone: TFhirPackagedProductDefinitionBatchIdentifierList;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifierList(inherited Clone);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.GetItemN(index: Integer): TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier;
end;
function TFhirPackagedProductDefinitionBatchIdentifierList.IndexOf(value: TFhirPackagedProductDefinitionBatchIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Insert(index: Integer): TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionBatchIdentifierList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionBatchIdentifier);
begin
  assert(value is TFhirPackagedProductDefinitionBatchIdentifier);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Item(index: Integer): TFhirPackagedProductDefinitionBatchIdentifier;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifier(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionBatchIdentifierList.Link: TFhirPackagedProductDefinitionBatchIdentifierList;
begin
  result := TFhirPackagedProductDefinitionBatchIdentifierList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionBatchIdentifierList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionBatchIdentifier);
begin
  assert(value is TFhirPackagedProductDefinitionBatchIdentifier);
  FhirPackagedProductDefinitionBatchIdentifiers[index] := value;
end;

procedure TFhirPackagedProductDefinitionBatchIdentifierList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionBatchIdentifier);
begin
  assert(value is TFhirPackagedProductDefinitionBatchIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackage }

constructor TFhirPackagedProductDefinitionPackage.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackage.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FQuantity.free;
  FMaterialList.Free;
  FAlternateMaterialList.Free;
  FShelfLifeStorageList.Free;
  FManufacturerList.Free;
  FProperty_List.Free;
  FContainedItemList.Free;
  FPackageList.Free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinitionPackage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FIdentifierList);
  end;
  type_ := TFhirPackagedProductDefinitionPackage(oSource).type_.Clone;
  quantityElement := TFhirPackagedProductDefinitionPackage(oSource).quantityElement.Clone;
  if (TFhirPackagedProductDefinitionPackage(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirCodeableConceptList.Create;
    FMaterialList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FAlternateMaterialList = nil) then
  begin
    FAlternateMaterialList.free;
    FAlternateMaterialList := nil;
  end
  else
  begin
    if FAlternateMaterialList = nil then
      FAlternateMaterialList := TFhirCodeableConceptList.Create;
    FAlternateMaterialList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FAlternateMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FShelfLifeStorageList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FManufacturerList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirPackagedProductDefinitionPackagePropertyList.Create;
    FProperty_List.Assign(TFhirPackagedProductDefinitionPackage(oSource).FProperty_List);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FContainedItemList = nil) then
  begin
    FContainedItemList.free;
    FContainedItemList := nil;
  end
  else
  begin
    if FContainedItemList = nil then
      FContainedItemList := TFhirPackagedProductDefinitionPackageContainedItemList.Create;
    FContainedItemList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FContainedItemList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
    FPackageList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FPackageList);
  end;
end;

procedure TFhirPackagedProductDefinitionPackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
  if (child_name = 'alternateMaterial') Then
    list.addAll(self, 'alternateMaterial', FAlternateMaterialList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'containedItem') Then
    list.addAll(self, 'containedItem', FContainedItemList);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
end;

procedure TFhirPackagedProductDefinitionPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', true, TFhirCodeableConcept, FMaterialList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'alternateMaterial', 'CodeableConcept', true, TFhirCodeableConcept, FAlternateMaterialList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirPackagedProductDefinitionPackageProperty, FProperty_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'containedItem', 'BackboneElement', true, TFhirPackagedProductDefinitionPackageContainedItem, FContainedItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'package', '', true, TFhirPackagedProductDefinitionPackage, FPackageList.Link)) {L1039};
end;

function TFhirPackagedProductDefinitionPackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'alternateMaterial') then
  begin
    AlternateMaterialList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife) {L1048};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirPackagedProductDefinitionPackageProperty) {L1048};
    result := propValue;
  end
  else if (propName = 'containedItem') then
  begin
    ContainedItemList.add(propValue as TFhirPackagedProductDefinitionPackageContainedItem) {L1048};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(propValue as TFhirPackagedProductDefinitionPackage) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'alternateMaterial') then AlternateMaterialList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirPackagedProductDefinitionPackageProperty) {L1049}
  else if (propName = 'containedItem') then ContainedItemList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackageContainedItem) {L1049}
  else if (propName = 'package') then PackageList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackage) {L1049}
  else inherited;
end;

function TFhirPackagedProductDefinitionPackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'quantity') then result := TFhirInteger.create() {L1223}
  else if (propName = 'material') then result := MaterialList.new() {L1053}
  else if (propName = 'alternateMaterial') then result := AlternateMaterialList.new() {L1053}
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new() {L1053}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else if (propName = 'containedItem') then result := ContainedItemList.new() {L1053}
  else if (propName = 'package') then result := PackageList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'alternateMaterial') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'containedItem') then result := 'BackboneElement'
  else if (propName = 'package') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value) {L1054}
  else if (propName = 'alternateMaterial') then deletePropertyValue('alternateMaterial', AlternateMaterialList, value) {L1054}
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value) {L1054}
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else if (propName = 'containedItem') then deletePropertyValue('containedItem', ContainedItemList, value) {L1054}
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'quantity') then QuantityElement := asInteger(new) {L1222}
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new) {L1055}
  else if (propName = 'alternateMaterial') then replacePropertyValue('alternateMaterial', AlternateMaterialList, existing, new) {L1055}
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new) {L1055}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else if (propName = 'containedItem') then replacePropertyValue('containedItem', ContainedItemList, existing, new) {L1055}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'material') then MaterialList.move(source, destination) {L1050}
  else if (propName = 'alternateMaterial') then AlternateMaterialList.move(source, destination) {L1050}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else if (propName = 'containedItem') then ContainedItemList.move(source, destination) {L1050}
  else if (propName = 'package') then PackageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackage.fhirType : string;
begin
  result := 'PackagedProductDefinition.package';
end;

function TFhirPackagedProductDefinitionPackage.Link : TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(inherited Link);
end;

function TFhirPackagedProductDefinitionPackage.Clone : TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackage.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackage)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(materialList, o.materialList, true) and 
      compareDeep(alternateMaterialList, o.alternateMaterialList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(containedItemList, o.containedItemList, true) and compareDeep(packageList, o.packageList, true);
  end;
end;

function TFhirPackagedProductDefinitionPackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FmaterialList) and isEmptyProp(FalternateMaterialList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FmanufacturerList) and isEmptyProp(Fproperty_List) and isEmptyProp(FcontainedItemList) and isEmptyProp(FpackageList);
end;

function TFhirPackagedProductDefinitionPackage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinitionPackage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionPackage.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirPackagedProductDefinitionPackage.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirPackagedProductDefinitionPackage.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

function TFhirPackagedProductDefinitionPackage.GetMaterialList : TFhirCodeableConceptList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirCodeableConceptList.Create;
  result := FMaterialList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetAlternateMaterialList : TFhirCodeableConceptList;
begin
  if FAlternateMaterialList = nil then
    FAlternateMaterialList := TFhirCodeableConceptList.Create;
  result := FAlternateMaterialList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasAlternateMaterialList : boolean;
begin
  result := (FAlternateMaterialList <> nil) and (FAlternateMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetProperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirPackagedProductDefinitionPackagePropertyList.Create;
  result := FProperty_List;
end;

function TFhirPackagedProductDefinitionPackage.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetContainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  if FContainedItemList = nil then
    FContainedItemList := TFhirPackagedProductDefinitionPackageContainedItemList.Create;
  result := FContainedItemList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasContainedItemList : boolean;
begin
  result := (FContainedItemList <> nil) and (FContainedItemList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetPackageList : TFhirPackagedProductDefinitionPackageList;
begin
  if FPackageList = nil then
    FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
  result := FPackageList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

procedure TFhirPackagedProductDefinitionPackage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('quantity');
  fields.add('material');
  fields.add('alternateMaterial');
  fields.add('shelfLifeStorage');
  fields.add('manufacturer');
  fields.add('property');
  fields.add('containedItem');
  fields.add('package');
end;

function TFhirPackagedProductDefinitionPackage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FmaterialList.sizeInBytes);
  inc(result, FalternateMaterialList.sizeInBytes);
  inc(result, FshelfLifeStorageList.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FcontainedItemList.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackageListEnumerator }

constructor TFhirPackagedProductDefinitionPackageListEnumerator.Create(list : TFhirPackagedProductDefinitionPackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackage;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackageList }

procedure TFhirPackagedProductDefinitionPackageList.AddItem(value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackage');
  add(value);
end;

function TFhirPackagedProductDefinitionPackageList.Append: TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackageList.GetEnumerator : TFhirPackagedProductDefinitionPackageListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackageListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackageList.Clone: TFhirPackagedProductDefinitionPackageList;
begin
  result := TFhirPackagedProductDefinitionPackageList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackageList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackage;
end;
function TFhirPackagedProductDefinitionPackageList.IndexOf(value: TFhirPackagedProductDefinitionPackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackageList.Insert(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackageList.Item(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageList.Link: TFhirPackagedProductDefinitionPackageList;
begin
  result := TFhirPackagedProductDefinitionPackageList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackageList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  FhirPackagedProductDefinitionPackages[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackageList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackageProperty }

constructor TFhirPackagedProductDefinitionPackageProperty.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackageProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackageProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPackagedProductDefinitionPackageProperty(oSource).type_.Clone;
  value := TFhirPackagedProductDefinitionPackageProperty(oSource).value.Clone;
end;

procedure TFhirPackagedProductDefinitionPackageProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link)); {L1172}
end;

function TFhirPackagedProductDefinitionPackageProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionPackageProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackageProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackageProperty.fhirType : string;
begin
  result := 'PackagedProductDefinition.package.property';
end;

function TFhirPackagedProductDefinitionPackageProperty.Link : TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(inherited Link);
end;

function TFhirPackagedProductDefinitionPackageProperty.Clone : TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageProperty.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackageProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackageProperty)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackageProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackageProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionPackageProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionPackageProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirPackagedProductDefinitionPackageProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackagePropertyListEnumerator }

constructor TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Create(list : TFhirPackagedProductDefinitionPackagePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackageProperty;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackagePropertyList }

procedure TFhirPackagedProductDefinitionPackagePropertyList.AddItem(value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackageProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackageProperty');
  add(value);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Append: TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackagePropertyList.GetEnumerator : TFhirPackagedProductDefinitionPackagePropertyListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Clone: TFhirPackagedProductDefinitionPackagePropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackagePropertyList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackageProperty;
end;
function TFhirPackagedProductDefinitionPackagePropertyList.IndexOf(value: TFhirPackagedProductDefinitionPackageProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Insert(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Item(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Link: TFhirPackagedProductDefinitionPackagePropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  FhirPackagedProductDefinitionPackageProperties[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackageContainedItem }

constructor TFhirPackagedProductDefinitionPackageContainedItem.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackageContainedItem.Destroy;
begin
  FItemList.Free;
  FAmount.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinitionPackageContainedItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirReferenceList.Create;
    FItemList.Assign(TFhirPackagedProductDefinitionPackageContainedItem(oSource).FItemList);
  end;
  amount := TFhirPackagedProductDefinitionPackageContainedItem(oSource).amount.Clone;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'Reference', true, TFhirReference, FItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|integer', false, TFhirDataType, FAmount.Link)); {L1172}
end;

function TFhirPackagedProductDefinitionPackageContainedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Integer'])) then
  begin
    Amount := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirPackagedProductDefinitionPackageContainedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := ItemList.new() {L1053}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Integer'])) then raise EFHIRException.create('Cannot make property Amount') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'Reference'
  else if (propName = 'amount[x]') then result := 'Quantity|integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Integer'])) then AmountElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Integer'])) then AmountElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.fhirType : string;
begin
  result := 'PackagedProductDefinition.package.containedItem';
end;

function TFhirPackagedProductDefinitionPackageContainedItem.Link : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(inherited Link);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.Clone : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackageContainedItem)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackageContainedItem(other);
    result := compareDeep(itemList, o.itemList, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackageContainedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemList) and isEmptyProp(FAmount);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.GetItemList : TFhirReferenceList;
begin
  if FItemList = nil then
    FItemList := TFhirReferenceList.Create;
  result := FItemList;
end;

function TFhirPackagedProductDefinitionPackageContainedItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount[x]');
end;

function TFhirPackagedProductDefinitionPackageContainedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FitemList.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackageContainedItemListEnumerator }

constructor TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Create(list : TFhirPackagedProductDefinitionPackageContainedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionPackageContainedItemList }

procedure TFhirPackagedProductDefinitionPackageContainedItemList.AddItem(value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackageContainedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackageContainedItem');
  add(value);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Append: TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.GetEnumerator : TFhirPackagedProductDefinitionPackageContainedItemListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Clone: TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem;
end;
function TFhirPackagedProductDefinitionPackageContainedItemList.IndexOf(value: TFhirPackagedProductDefinitionPackageContainedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Insert(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Item(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Link: TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  FhirPackagedProductDefinitionPackageContainedItems[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinition }

constructor TFhirPackagedProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FType_.free;
  FSubjectList.Free;
  FStatus.free;
  FStatusDate.free;
  FDescription.free;
  FLegalStatusOfSupply.free;
  FMarketingStatusList.Free;
  FCharacteristicList.Free;
  FCopackagedIndicator.free;
  FMarketingAuthorization.free;
  FManufacturerList.Free;
  FBatchIdentifierList.Free;
  FPackageList.Free;
  inherited;
end;

procedure TFhirPackagedProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinition(oSource).FIdentifierList);
  end;
  nameElement := TFhirPackagedProductDefinition(oSource).nameElement.Clone;
  type_ := TFhirPackagedProductDefinition(oSource).type_.Clone;
  if (TFhirPackagedProductDefinition(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirPackagedProductDefinition(oSource).FSubjectList);
  end;
  status := TFhirPackagedProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirPackagedProductDefinition(oSource).statusDateElement.Clone;
  descriptionElement := TFhirPackagedProductDefinition(oSource).descriptionElement.Clone;
  legalStatusOfSupply := TFhirPackagedProductDefinition(oSource).legalStatusOfSupply.Clone;
  if (TFhirPackagedProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirPackagedProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirPackagedProductDefinition(oSource).FCharacteristicList);
  end;
  copackagedIndicatorElement := TFhirPackagedProductDefinition(oSource).copackagedIndicatorElement.Clone;
  marketingAuthorization := TFhirPackagedProductDefinition(oSource).marketingAuthorization.Clone;
  if (TFhirPackagedProductDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinition(oSource).FManufacturerList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FBatchIdentifierList = nil) then
  begin
    FBatchIdentifierList.free;
    FBatchIdentifierList := nil;
  end
  else
  begin
    if FBatchIdentifierList = nil then
      FBatchIdentifierList := TFhirPackagedProductDefinitionBatchIdentifierList.Create;
    FBatchIdentifierList.Assign(TFhirPackagedProductDefinition(oSource).FBatchIdentifierList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
    FPackageList.Assign(TFhirPackagedProductDefinition(oSource).FPackageList);
  end;
end;

function TFhirPackagedProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPackagedProductDefinition;
end;

procedure TFhirPackagedProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'copackagedIndicator') Then
     list.add(self.link, 'copackagedIndicator', FCopackagedIndicator.Link);
  if (child_name = 'marketingAuthorization') Then
     list.add(self.link, 'marketingAuthorization', FMarketingAuthorization.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'batchIdentifier') Then
    list.addAll(self, 'batchIdentifier', FBatchIdentifierList);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
end;

procedure TFhirPackagedProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'copackagedIndicator', 'boolean', false, TFhirBoolean, FCopackagedIndicator.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'marketingAuthorization', 'Reference', false, TFhirReference, FMarketingAuthorization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'batchIdentifier', 'BackboneElement', true, TFhirPackagedProductDefinitionBatchIdentifier, FBatchIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'package', 'BackboneElement', true, TFhirPackagedProductDefinitionPackage, FPackageList.Link)) {L1039};
end;

function TFhirPackagedProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus) {L1048};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'copackagedIndicator') then
  begin
    CopackagedIndicatorElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'marketingAuthorization') then
  begin
    MarketingAuthorization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'batchIdentifier') then
  begin
    BatchIdentifierList.add(propValue as TFhirPackagedProductDefinitionBatchIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(propValue as TFhirPackagedProductDefinitionPackage) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus) {L1049}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'batchIdentifier') then BatchIdentifierList.insertItem(index, propValue as TFhirPackagedProductDefinitionBatchIdentifier) {L1049}
  else if (propName = 'package') then PackageList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackage) {L1049}
  else inherited;
end;

function TFhirPackagedProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := SubjectList.new() {L1053}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new() {L1053}
  else if (propName = 'characteristic') then result := CharacteristicList.new() {L1053}
  else if (propName = 'copackagedIndicator') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'marketingAuthorization') then result := TFhirReference.create() {L1203}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'batchIdentifier') then result := BatchIdentifierList.new() {L1053}
  else if (propName = 'package') then result := PackageList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'copackagedIndicator') then result := 'boolean'
  else if (propName = 'marketingAuthorization') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'batchIdentifier') then result := 'BackboneElement'
  else if (propName = 'package') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value) {L1054}
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {L1054}
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := nil
  else if (propName = 'marketingAuthorization') then MarketingAuthorizationElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'batchIdentifier') then deletePropertyValue('batchIdentifier', BatchIdentifierList, value) {L1054}
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new) {L1055}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {L1055}
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := asBoolean(new) {L1222}
  else if (propName = 'marketingAuthorization') then MarketingAuthorizationElement := new as TFhirReference {L1195}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'batchIdentifier') then replacePropertyValue('batchIdentifier', BatchIdentifierList, existing, new) {L1055}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'subject') then SubjectList.move(source, destination) {L1050}
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination) {L1050}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'batchIdentifier') then BatchIdentifierList.move(source, destination) {L1050}
  else if (propName = 'package') then PackageList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinition.fhirType : string;
begin
  result := 'PackagedProductDefinition';
end;

function TFhirPackagedProductDefinition.Link : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Link);
end;

function TFhirPackagedProductDefinition.Clone : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Clone);
end;

function TFhirPackagedProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinition)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(copackagedIndicatorElement, o.copackagedIndicatorElement, true) and 
      compareDeep(marketingAuthorizationElement, o.marketingAuthorizationElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(batchIdentifierList, o.batchIdentifierList, true) and 
      compareDeep(packageList, o.packageList, true);
  end;
end;

function TFhirPackagedProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FsubjectList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FDescription) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FcharacteristicList) and isEmptyProp(FCopackagedIndicator) and isEmptyProp(FMarketingAuthorization) and isEmptyProp(FmanufacturerList) and isEmptyProp(FbatchIdentifierList) and isEmptyProp(FpackageList);
end;

function TFhirPackagedProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirPackagedProductDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirPackagedProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirPackagedProductDefinition.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirPackagedProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirPackagedProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirPackagedProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPackagedProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirPackagedProductDefinition.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirPackagedProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirPackagedProductDefinition.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirPackagedProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicator(value : TFhirBoolean);
begin
  FCopackagedIndicator.free;
  FCopackagedIndicator := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetCopackagedIndicatorST : Boolean;
begin
  if FCopackagedIndicator = nil then
    result := false
  else
    result := FCopackagedIndicator.value;
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicatorST(value : Boolean);
begin
  if FCopackagedIndicator = nil then
    FCopackagedIndicator := TFhirBoolean.create;
  FCopackagedIndicator.value := value
end;

procedure TFhirPackagedProductDefinition.SetMarketingAuthorization(value : TFhirReference);
begin
  FMarketingAuthorization.free;
  FMarketingAuthorization := value; {L1134}
end;

function TFhirPackagedProductDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirPackagedProductDefinition.GetBatchIdentifierList : TFhirPackagedProductDefinitionBatchIdentifierList;
begin
  if FBatchIdentifierList = nil then
    FBatchIdentifierList := TFhirPackagedProductDefinitionBatchIdentifierList.Create;
  result := FBatchIdentifierList;
end;

function TFhirPackagedProductDefinition.GetHasBatchIdentifierList : boolean;
begin
  result := (FBatchIdentifierList <> nil) and (FBatchIdentifierList.count > 0);
end;

function TFhirPackagedProductDefinition.GetPackageList : TFhirPackagedProductDefinitionPackageList;
begin
  if FPackageList = nil then
    FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
  result := FPackageList;
end;

function TFhirPackagedProductDefinition.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

procedure TFhirPackagedProductDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('type');
  fields.add('subject');
  fields.add('status');
  fields.add('statusDate');
  fields.add('description');
  fields.add('legalStatusOfSupply');
  fields.add('marketingStatus');
  fields.add('characteristic');
  fields.add('copackagedIndicator');
  fields.add('marketingAuthorization');
  fields.add('manufacturer');
  fields.add('batchIdentifier');
  fields.add('package');
end;

function TFhirPackagedProductDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FLegalStatusOfSupply.sizeInBytes);
  inc(result, FmarketingStatusList.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
  inc(result, FCopackagedIndicator.sizeInBytes);
  inc(result, FMarketingAuthorization.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FbatchIdentifierList.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionListEnumerator }

constructor TFhirPackagedProductDefinitionListEnumerator.Create(list : TFhirPackagedProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionListEnumerator.GetCurrent : TFhirPackagedProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPackagedProductDefinitionList }

procedure TFhirPackagedProductDefinitionList.AddItem(value: TFhirPackagedProductDefinition);
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinition');
  add(value);
end;

function TFhirPackagedProductDefinitionList.Append: TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionList.GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
begin
  result := TFhirPackagedProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionList.Clone: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Clone);
end;

function TFhirPackagedProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionList.GetItemN(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinition;
end;
function TFhirPackagedProductDefinitionList.IndexOf(value: TFhirPackagedProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionList.Insert(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.InsertItem(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionList.Item(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.Link: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  FhirPackagedProductDefinitions[index] := value;
end;

procedure TFhirPackagedProductDefinitionList.SetItemN(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
{ TFhirRegulatedAuthorizationRelatedDate }

constructor TFhirRegulatedAuthorizationRelatedDate.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorizationRelatedDate.Destroy;
begin
  FDate.free;
  FType_.free;
  inherited;
end;

procedure TFhirRegulatedAuthorizationRelatedDate.Assign(oSource : TFslObject);
begin
  inherited;
  date := TFhirRegulatedAuthorizationRelatedDate(oSource).date.Clone;
  type_ := TFhirRegulatedAuthorizationRelatedDate(oSource).type_.Clone;
end;

procedure TFhirRegulatedAuthorizationRelatedDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date[x]') or (child_name = 'date') Then
     list.add(self.link, 'date[x]', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date[x]', 'Period|dateTime', false, TFhirDataType, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
end;

function TFhirRegulatedAuthorizationRelatedDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then
  begin
    Date := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRegulatedAuthorizationRelatedDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Date') {L1191}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorizationRelatedDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date[x]') then result := 'Period|dateTime'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := nil {L1189}
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := new as TFhirDataType {L1190}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorizationRelatedDate.fhirType : string;
begin
  result := 'RegulatedAuthorization.relatedDate';
end;

function TFhirRegulatedAuthorizationRelatedDate.Link : TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate(inherited Link);
end;

function TFhirRegulatedAuthorizationRelatedDate.Clone : TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate(inherited Clone);
end;

function TFhirRegulatedAuthorizationRelatedDate.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorizationRelatedDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorizationRelatedDate)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorizationRelatedDate(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirRegulatedAuthorizationRelatedDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_);
end;

procedure TFhirRegulatedAuthorizationRelatedDate.SetDate(value : TFhirDataType);
begin
  FDate.free;
  FDate := value; {L1134}
end;

procedure TFhirRegulatedAuthorizationRelatedDate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirRegulatedAuthorizationRelatedDate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date[x]');
  fields.add('type');
end;

function TFhirRegulatedAuthorizationRelatedDate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationRelatedDateListEnumerator }

constructor TFhirRegulatedAuthorizationRelatedDateListEnumerator.Create(list : TFhirRegulatedAuthorizationRelatedDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationRelatedDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationRelatedDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationRelatedDateListEnumerator.GetCurrent : TFhirRegulatedAuthorizationRelatedDate;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationRelatedDateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationRelatedDateList }

procedure TFhirRegulatedAuthorizationRelatedDateList.AddItem(value: TFhirRegulatedAuthorizationRelatedDate);
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorizationRelatedDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorizationRelatedDate');
  add(value);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Append: TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationRelatedDateList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationRelatedDateList.GetEnumerator : TFhirRegulatedAuthorizationRelatedDateListEnumerator;
begin
  result := TFhirRegulatedAuthorizationRelatedDateListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Clone: TFhirRegulatedAuthorizationRelatedDateList;
begin
  result := TFhirRegulatedAuthorizationRelatedDateList(inherited Clone);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationRelatedDateList.GetItemN(index: Integer): TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationRelatedDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorizationRelatedDate;
end;
function TFhirRegulatedAuthorizationRelatedDateList.IndexOf(value: TFhirRegulatedAuthorizationRelatedDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Insert(index: Integer): TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationRelatedDateList.InsertItem(index: Integer; value: TFhirRegulatedAuthorizationRelatedDate);
begin
  assert(value is TFhirRegulatedAuthorizationRelatedDate);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Item(index: Integer): TFhirRegulatedAuthorizationRelatedDate;
begin
  result := TFhirRegulatedAuthorizationRelatedDate(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationRelatedDateList.Link: TFhirRegulatedAuthorizationRelatedDateList;
begin
  result := TFhirRegulatedAuthorizationRelatedDateList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationRelatedDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationRelatedDateList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorizationRelatedDate);
begin
  assert(value is TFhirRegulatedAuthorizationRelatedDate);
  FhirRegulatedAuthorizationRelatedDates[index] := value;
end;

procedure TFhirRegulatedAuthorizationRelatedDateList.SetItemN(index: Integer; value: TFhirRegulatedAuthorizationRelatedDate);
begin
  assert(value is TFhirRegulatedAuthorizationRelatedDate);
  ObjectByIndex[index] := value;
end;

{ TFhirRegulatedAuthorizationCase }

constructor TFhirRegulatedAuthorizationCase.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorizationCase.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FStatus.free;
  FDate.free;
  FApplicationList.Free;
  inherited;
end;

procedure TFhirRegulatedAuthorizationCase.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirRegulatedAuthorizationCase(oSource).identifier.Clone;
  type_ := TFhirRegulatedAuthorizationCase(oSource).type_.Clone;
  status := TFhirRegulatedAuthorizationCase(oSource).status.Clone;
  date := TFhirRegulatedAuthorizationCase(oSource).date.Clone;
  if (TFhirRegulatedAuthorizationCase(oSource).FApplicationList = nil) then
  begin
    FApplicationList.free;
    FApplicationList := nil;
  end
  else
  begin
    if FApplicationList = nil then
      FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
    FApplicationList.Assign(TFhirRegulatedAuthorizationCase(oSource).FApplicationList);
  end;
end;

procedure TFhirRegulatedAuthorizationCase.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date[x]') or (child_name = 'date') Then
     list.add(self.link, 'date[x]', FDate.Link);
  if (child_name = 'application') Then
    list.addAll(self, 'application', FApplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date[x]', 'Period|dateTime', false, TFhirDataType, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'application', '', true, TFhirRegulatedAuthorizationCase, FApplicationList.Link)) {L1039};
end;

function TFhirRegulatedAuthorizationCase.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then
  begin
    Date := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'application') then
  begin
    ApplicationList.add(propValue as TFhirRegulatedAuthorizationCase) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorizationCase.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'application') then ApplicationList.insertItem(index, propValue as TFhirRegulatedAuthorizationCase) {L1049}
  else inherited;
end;

function TFhirRegulatedAuthorizationCase.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Date') {L1191}
  else if (propName = 'application') then result := ApplicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorizationCase.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date[x]') then result := 'Period|dateTime'
  else if (propName = 'application') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorizationCase.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := nil {L1189}
  else if (propName = 'application') then deletePropertyValue('application', ApplicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorizationCase.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := new as TFhirDataType {L1190}
  else if (propName = 'application') then replacePropertyValue('application', ApplicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorizationCase.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'application') then ApplicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorizationCase.fhirType : string;
begin
  result := 'RegulatedAuthorization.case';
end;

function TFhirRegulatedAuthorizationCase.Link : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Link);
end;

function TFhirRegulatedAuthorizationCase.Clone : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Clone);
end;

function TFhirRegulatedAuthorizationCase.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorizationCase;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorizationCase)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorizationCase(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(applicationList, o.applicationList, true);
  end;
end;

function TFhirRegulatedAuthorizationCase.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FapplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirRegulatedAuthorizationCase.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirRegulatedAuthorizationCase.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirRegulatedAuthorizationCase.SetDate(value : TFhirDataType);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirRegulatedAuthorizationCase.GetApplicationList : TFhirRegulatedAuthorizationCaseList;
begin
  if FApplicationList = nil then
    FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
  result := FApplicationList;
end;

function TFhirRegulatedAuthorizationCase.GetHasApplicationList : boolean;
begin
  result := (FApplicationList <> nil) and (FApplicationList.count > 0);
end;

procedure TFhirRegulatedAuthorizationCase.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('status');
  fields.add('date[x]');
  fields.add('application');
end;

function TFhirRegulatedAuthorizationCase.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FapplicationList.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationCaseListEnumerator }

constructor TFhirRegulatedAuthorizationCaseListEnumerator.Create(list : TFhirRegulatedAuthorizationCaseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationCaseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.GetCurrent : TFhirRegulatedAuthorizationCase;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationCaseList }

procedure TFhirRegulatedAuthorizationCaseList.AddItem(value: TFhirRegulatedAuthorizationCase);
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorizationCase', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorizationCase');
  add(value);
end;

function TFhirRegulatedAuthorizationCaseList.Append: TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationCaseList.GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
begin
  result := TFhirRegulatedAuthorizationCaseListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationCaseList.Clone: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Clone);
end;

function TFhirRegulatedAuthorizationCaseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationCaseList.GetItemN(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorizationCase;
end;
function TFhirRegulatedAuthorizationCaseList.IndexOf(value: TFhirRegulatedAuthorizationCase): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationCaseList.Insert(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.InsertItem(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationCaseList.Item(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.Link: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationCaseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  FhirRegulatedAuthorizationCases[index] := value;
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemN(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  ObjectByIndex[index] := value;
end;

{ TFhirRegulatedAuthorization }

constructor TFhirRegulatedAuthorization.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorization.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FType_.free;
  FDescription.free;
  FRegionList.Free;
  FStatus.free;
  FStatusDate.free;
  FValidityPeriod.free;
  FIndication.free;
  FIntendedUse.free;
  FBasisList.Free;
  FRelatedDateList.Free;
  FJurisdictionalAuthorizationList.Free;
  FHolder.free;
  FRegulator.free;
  FCase_.free;
  inherited;
end;

procedure TFhirRegulatedAuthorization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRegulatedAuthorization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRegulatedAuthorization(oSource).FIdentifierList);
  end;
  subject := TFhirRegulatedAuthorization(oSource).subject.Clone;
  type_ := TFhirRegulatedAuthorization(oSource).type_.Clone;
  descriptionElement := TFhirRegulatedAuthorization(oSource).descriptionElement.Clone;
  if (TFhirRegulatedAuthorization(oSource).FRegionList = nil) then
  begin
    FRegionList.free;
    FRegionList := nil;
  end
  else
  begin
    if FRegionList = nil then
      FRegionList := TFhirCodeableConceptList.Create;
    FRegionList.Assign(TFhirRegulatedAuthorization(oSource).FRegionList);
  end;
  status := TFhirRegulatedAuthorization(oSource).status.Clone;
  statusDateElement := TFhirRegulatedAuthorization(oSource).statusDateElement.Clone;
  validityPeriod := TFhirRegulatedAuthorization(oSource).validityPeriod.Clone;
  indication := TFhirRegulatedAuthorization(oSource).indication.Clone;
  intendedUse := TFhirRegulatedAuthorization(oSource).intendedUse.Clone;
  if (TFhirRegulatedAuthorization(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirCodeableConceptList.Create;
    FBasisList.Assign(TFhirRegulatedAuthorization(oSource).FBasisList);
  end;
  if (TFhirRegulatedAuthorization(oSource).FRelatedDateList = nil) then
  begin
    FRelatedDateList.free;
    FRelatedDateList := nil;
  end
  else
  begin
    if FRelatedDateList = nil then
      FRelatedDateList := TFhirRegulatedAuthorizationRelatedDateList.Create;
    FRelatedDateList.Assign(TFhirRegulatedAuthorization(oSource).FRelatedDateList);
  end;
  if (TFhirRegulatedAuthorization(oSource).FJurisdictionalAuthorizationList = nil) then
  begin
    FJurisdictionalAuthorizationList.free;
    FJurisdictionalAuthorizationList := nil;
  end
  else
  begin
    if FJurisdictionalAuthorizationList = nil then
      FJurisdictionalAuthorizationList := TFhirReferenceList.Create;
    FJurisdictionalAuthorizationList.Assign(TFhirRegulatedAuthorization(oSource).FJurisdictionalAuthorizationList);
  end;
  holder := TFhirRegulatedAuthorization(oSource).holder.Clone;
  regulator := TFhirRegulatedAuthorization(oSource).regulator.Clone;
  case_ := TFhirRegulatedAuthorization(oSource).case_.Clone;
end;

function TFhirRegulatedAuthorization.GetResourceType : TFhirResourceType;
begin
  result := frtRegulatedAuthorization;
end;

procedure TFhirRegulatedAuthorization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'region') Then
    list.addAll(self, 'region', FRegionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'indication[x]') or (child_name = 'indication') Then
     list.add(self.link, 'indication[x]', FIndication.Link);
  if (child_name = 'intendedUse') Then
     list.add(self.link, 'intendedUse', FIntendedUse.Link);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'relatedDate') Then
    list.addAll(self, 'relatedDate', FRelatedDateList);
  if (child_name = 'jurisdictionalAuthorization') Then
    list.addAll(self, 'jurisdictionalAuthorization', FJurisdictionalAuthorizationList);
  if (child_name = 'holder') Then
     list.add(self.link, 'holder', FHolder.Link);
  if (child_name = 'regulator') Then
     list.add(self.link, 'regulator', FRegulator.Link);
  if (child_name = 'case') Then
     list.add(self.link, 'case', FCase_.Link);
end;

procedure TFhirRegulatedAuthorization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'region', 'CodeableConcept', true, TFhirCodeableConcept, FRegionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'indication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FIndication.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'intendedUse', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedUse.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'basis', 'CodeableConcept', true, TFhirCodeableConcept, FBasisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'relatedDate', 'BackboneElement', true, TFhirRegulatedAuthorizationRelatedDate, FRelatedDateList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'jurisdictionalAuthorization', 'Reference', true, TFhirReference, FJurisdictionalAuthorizationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'holder', 'Reference', false, TFhirReference, FHolder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'regulator', 'Reference', false, TFhirReference, FRegulator.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'case', 'BackboneElement', false, TFhirRegulatedAuthorizationCase, FCase_.Link)); {L1172}
end;

function TFhirRegulatedAuthorization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'region') then
  begin
    RegionList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then
  begin
    Indication := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'intendedUse') then
  begin
    IntendedUse := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'relatedDate') then
  begin
    RelatedDateList.add(propValue as TFhirRegulatedAuthorizationRelatedDate) {L1048};
    result := propValue;
  end
  else if (propName = 'jurisdictionalAuthorization') then
  begin
    JurisdictionalAuthorizationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'holder') then
  begin
    Holder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'regulator') then
  begin
    Regulator := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'case') then
  begin
    Case_ := propValue as TFhirRegulatedAuthorizationCase {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'region') then RegionList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'relatedDate') then RelatedDateList.insertItem(index, propValue as TFhirRegulatedAuthorizationRelatedDate) {L1049}
  else if (propName = 'jurisdictionalAuthorization') then JurisdictionalAuthorizationList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirRegulatedAuthorization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'region') then result := RegionList.new() {L1053}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create() {L1203}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Indication') {L1191}
  else if (propName = 'intendedUse') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'basis') then result := BasisList.new() {L1053}
  else if (propName = 'relatedDate') then result := RelatedDateList.new() {L1053}
  else if (propName = 'jurisdictionalAuthorization') then result := JurisdictionalAuthorizationList.new() {L1053}
  else if (propName = 'holder') then result := TFhirReference.create() {L1203}
  else if (propName = 'regulator') then result := TFhirReference.create() {L1203}
  else if (propName = 'case') then result := TFhirRegulatedAuthorizationCase.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'region') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'indication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'intendedUse') then result := 'CodeableConcept'
  else if (propName = 'basis') then result := 'CodeableConcept'
  else if (propName = 'relatedDate') then result := 'BackboneElement'
  else if (propName = 'jurisdictionalAuthorization') then result := 'Reference'
  else if (propName = 'holder') then result := 'Reference'
  else if (propName = 'regulator') then result := 'Reference'
  else if (propName = 'case') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'region') then deletePropertyValue('region', RegionList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := nil {L1189}
  else if (propName = 'intendedUse') then IntendedUseElement := nil
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value) {L1054}
  else if (propName = 'relatedDate') then deletePropertyValue('relatedDate', RelatedDateList, value) {L1054}
  else if (propName = 'jurisdictionalAuthorization') then deletePropertyValue('jurisdictionalAuthorization', JurisdictionalAuthorizationList, value) {L1054}
  else if (propName = 'holder') then HolderElement := nil
  else if (propName = 'regulator') then RegulatorElement := nil
  else if (propName = 'case') then Case_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'region') then replacePropertyValue('region', RegionList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new) {L1222}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod {L1195}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := new as TFhirDataType {L1190}
  else if (propName = 'intendedUse') then IntendedUseElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new) {L1055}
  else if (propName = 'relatedDate') then replacePropertyValue('relatedDate', RelatedDateList, existing, new) {L1055}
  else if (propName = 'jurisdictionalAuthorization') then replacePropertyValue('jurisdictionalAuthorization', JurisdictionalAuthorizationList, existing, new) {L1055}
  else if (propName = 'holder') then HolderElement := new as TFhirReference {L1195}
  else if (propName = 'regulator') then RegulatorElement := new as TFhirReference {L1195}
  else if (propName = 'case') then Case_Element := new as TFhirRegulatedAuthorizationCase {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'region') then RegionList.move(source, destination) {L1050}
  else if (propName = 'basis') then BasisList.move(source, destination) {L1050}
  else if (propName = 'relatedDate') then RelatedDateList.move(source, destination) {L1050}
  else if (propName = 'jurisdictionalAuthorization') then JurisdictionalAuthorizationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorization.fhirType : string;
begin
  result := 'RegulatedAuthorization';
end;

function TFhirRegulatedAuthorization.Link : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Link);
end;

function TFhirRegulatedAuthorization.Clone : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Clone);
end;

function TFhirRegulatedAuthorization.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorization)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(regionList, o.regionList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(indicationElement, o.indicationElement, true) and compareDeep(intendedUseElement, o.intendedUseElement, true) and 
      compareDeep(basisList, o.basisList, true) and compareDeep(relatedDateList, o.relatedDateList, true) and 
      compareDeep(jurisdictionalAuthorizationList, o.jurisdictionalAuthorizationList, true) and 
      compareDeep(holderElement, o.holderElement, true) and compareDeep(regulatorElement, o.regulatorElement, true) and 
      compareDeep(case_Element, o.case_Element, true);
  end;
end;

function TFhirRegulatedAuthorization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FregionList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidityPeriod) and isEmptyProp(FIndication) and isEmptyProp(FIntendedUse) and isEmptyProp(FbasisList) and isEmptyProp(FrelatedDateList) and isEmptyProp(FjurisdictionalAuthorizationList) and isEmptyProp(FHolder) and isEmptyProp(FRegulator) and isEmptyProp(FCase_);
end;

function TFhirRegulatedAuthorization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRegulatedAuthorization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirRegulatedAuthorization.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRegulatedAuthorization.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirRegulatedAuthorization.GetRegionList : TFhirCodeableConceptList;
begin
  if FRegionList = nil then
    FRegionList := TFhirCodeableConceptList.Create;
  result := FRegionList;
end;

function TFhirRegulatedAuthorization.GetHasRegionList : boolean;
begin
  result := (FRegionList <> nil) and (FRegionList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value; {L1134}
end;

function TFhirRegulatedAuthorization.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirRegulatedAuthorization.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirRegulatedAuthorization.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetIndication(value : TFhirDataType);
begin
  FIndication.free;
  FIndication := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetIntendedUse(value : TFhirCodeableConcept);
begin
  FIntendedUse.free;
  FIntendedUse := value; {L1134}
end;

function TFhirRegulatedAuthorization.GetBasisList : TFhirCodeableConceptList;
begin
  if FBasisList = nil then
    FBasisList := TFhirCodeableConceptList.Create;
  result := FBasisList;
end;

function TFhirRegulatedAuthorization.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

function TFhirRegulatedAuthorization.GetRelatedDateList : TFhirRegulatedAuthorizationRelatedDateList;
begin
  if FRelatedDateList = nil then
    FRelatedDateList := TFhirRegulatedAuthorizationRelatedDateList.Create;
  result := FRelatedDateList;
end;

function TFhirRegulatedAuthorization.GetHasRelatedDateList : boolean;
begin
  result := (FRelatedDateList <> nil) and (FRelatedDateList.count > 0);
end;

function TFhirRegulatedAuthorization.GetJurisdictionalAuthorizationList : TFhirReferenceList;
begin
  if FJurisdictionalAuthorizationList = nil then
    FJurisdictionalAuthorizationList := TFhirReferenceList.Create;
  result := FJurisdictionalAuthorizationList;
end;

function TFhirRegulatedAuthorization.GetHasJurisdictionalAuthorizationList : boolean;
begin
  result := (FJurisdictionalAuthorizationList <> nil) and (FJurisdictionalAuthorizationList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetHolder(value : TFhirReference);
begin
  FHolder.free;
  FHolder := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetRegulator(value : TFhirReference);
begin
  FRegulator.free;
  FRegulator := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.SetCase_(value : TFhirRegulatedAuthorizationCase);
begin
  FCase_.free;
  FCase_ := value; {L1134}
end;

procedure TFhirRegulatedAuthorization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('type');
  fields.add('description');
  fields.add('region');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validityPeriod');
  fields.add('indication[x]');
  fields.add('intendedUse');
  fields.add('basis');
  fields.add('relatedDate');
  fields.add('jurisdictionalAuthorization');
  fields.add('holder');
  fields.add('regulator');
  fields.add('case');
end;

function TFhirRegulatedAuthorization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FregionList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FValidityPeriod.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FIntendedUse.sizeInBytes);
  inc(result, FbasisList.sizeInBytes);
  inc(result, FrelatedDateList.sizeInBytes);
  inc(result, FjurisdictionalAuthorizationList.sizeInBytes);
  inc(result, FHolder.sizeInBytes);
  inc(result, FRegulator.sizeInBytes);
  inc(result, FCase_.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationListEnumerator }

constructor TFhirRegulatedAuthorizationListEnumerator.Create(list : TFhirRegulatedAuthorizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationListEnumerator.GetCurrent : TFhirRegulatedAuthorization;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRegulatedAuthorizationList }

procedure TFhirRegulatedAuthorizationList.AddItem(value: TFhirRegulatedAuthorization);
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorization');
  add(value);
end;

function TFhirRegulatedAuthorizationList.Append: TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationList.GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
begin
  result := TFhirRegulatedAuthorizationListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationList.Clone: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Clone);
end;

function TFhirRegulatedAuthorizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationList.GetItemN(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorization;
end;
function TFhirRegulatedAuthorizationList.IndexOf(value: TFhirRegulatedAuthorization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationList.Insert(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.InsertItem(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationList.Item(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.Link: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  FhirRegulatedAuthorizations[index] := value;
end;

procedure TFhirRegulatedAuthorizationList.SetItemN(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
{ TFhirSubstanceInstance }

constructor TFhirSubstanceInstance.Create;
begin
  inherited;
end;

destructor TFhirSubstanceInstance.Destroy;
begin
  FIdentifier.free;
  FExpiry.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirSubstanceInstance.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceInstance(oSource).identifier.Clone;
  expiryElement := TFhirSubstanceInstance(oSource).expiryElement.Clone;
  quantity := TFhirSubstanceInstance(oSource).quantity.Clone;
end;

procedure TFhirSubstanceInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
end;

procedure TFhirSubstanceInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
end;

function TFhirSubstanceInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'expiry') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new) {L1222}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceInstance.fhirType : string;
begin
  result := 'Substance.instance';
end;

function TFhirSubstanceInstance.Link : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Link);
end;

function TFhirSubstanceInstance.Clone : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Clone);
end;

function TFhirSubstanceInstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceInstance)) then
    result := false
  else
  begin
    o := TFhirSubstanceInstance(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true);
  end;
end;

function TFhirSubstanceInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FExpiry) and isEmptyProp(FQuantity);
end;

procedure TFhirSubstanceInstance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value; {L1134}
end;

function TFhirSubstanceInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirSubstanceInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirSubstanceInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirSubstanceInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('expiry');
  fields.add('quantity');
end;

function TFhirSubstanceInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FExpiry.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
end;

{ TFhirSubstanceInstanceListEnumerator }

constructor TFhirSubstanceInstanceListEnumerator.Create(list : TFhirSubstanceInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceInstanceListEnumerator.GetCurrent : TFhirSubstanceInstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceInstanceList }

procedure TFhirSubstanceInstanceList.AddItem(value: TFhirSubstanceInstance);
begin
  assert(value.ClassName = 'TFhirSubstanceInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceInstance');
  add(value);
end;

function TFhirSubstanceInstanceList.Append: TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceInstanceList.GetEnumerator : TFhirSubstanceInstanceListEnumerator;
begin
  result := TFhirSubstanceInstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceInstanceList.Clone: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Clone);
end;

function TFhirSubstanceInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceInstanceList.GetItemN(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceInstance;
end;
function TFhirSubstanceInstanceList.IndexOf(value: TFhirSubstanceInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceInstanceList.Insert(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.InsertItem(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceInstanceList.Item(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.Link: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Link);
end;

procedure TFhirSubstanceInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceInstanceList.SetItemByIndex(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  FhirSubstanceInstances[index] := value;
end;

procedure TFhirSubstanceInstanceList.SetItemN(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', false, TFhirRatio, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubstance.Link)); {L1172}
end;

function TFhirSubstanceIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then
  begin
    Substance := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirRatio.create() {L1203}
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Substance') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Ratio'
  else if (propName = 'substance[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirRatio {L1195}
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceIngredient.fhirType : string;
begin
  result := 'Substance.ingredient';
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

function TFhirSubstanceIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceIngredient)) then
    result := false
  else
  begin
    o := TFhirSubstanceIngredient(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirSubstanceIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FSubstance);
end;

procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirDataType);
begin
  FSubstance.free;
  FSubstance := value; {L1134}
end;

procedure TFhirSubstanceIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('substance[x]');
end;

function TFhirSubstanceIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FSubstance.sizeInBytes);
end;

{ TFhirSubstanceIngredientListEnumerator }

constructor TFhirSubstanceIngredientListEnumerator.Create(list : TFhirSubstanceIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceIngredientListEnumerator.GetCurrent : TFhirSubstanceIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceIngredientList }

procedure TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient);
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
end;

function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.GetEnumerator : TFhirSubstanceIngredientListEnumerator;
begin
  result := TFhirSubstanceIngredientListEnumerator.Create(self.link);
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceIngredient;
end;
function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstance }

constructor TFhirSubstance.Create;
begin
  inherited;
end;

destructor TFhirSubstance.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FDescription.free;
  FInstanceList.Free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstance(oSource).FIdentifierList);
  end;
  statusElement := TFhirSubstance(oSource).statusElement.Clone;
  if (TFhirSubstance(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirSubstance(oSource).FCategoryList);
  end;
  code := TFhirSubstance(oSource).code.Clone;
  descriptionElement := TFhirSubstance(oSource).descriptionElement.Clone;
  if (TFhirSubstance(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirSubstanceInstanceList.Create;
    FInstanceList.Assign(TFhirSubstance(oSource).FInstanceList);
  end;
  if (TFhirSubstance(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirSubstanceIngredientList.Create;
    FIngredientList.Assign(TFhirSubstance(oSource).FIngredientList);
  end;
end;

function TFhirSubstance.GetResourceType : TFhirResourceType;
begin
  result := frtSubstance;
end;

procedure TFhirSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
end;

procedure TFhirSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirSubstanceInstance, FInstanceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirSubstanceIngredient, FIngredientList.Link)) {L1039};
end;

function TFhirSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirSubstanceInstance) {L1048};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirSubstanceIngredient) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirSubstanceInstance) {L1049}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirSubstanceIngredient) {L1049}
  else inherited;
end;

function TFhirSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull], CODES_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull])  {L1211}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'instance') then result := InstanceList.new() {L1053}
  else if (propName = 'ingredient') then result := IngredientList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {L1054}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, new) {L1210}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {L1055}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'instance') then InstanceList.move(source, destination) {L1050}
  else if (propName = 'ingredient') then IngredientList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstance.fhirType : string;
begin
  result := 'Substance';
end;

function TFhirSubstance.Link : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Link);
end;

function TFhirSubstance.Clone : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Clone);
end;

function TFhirSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstance)) then
    result := false
  else
  begin
    o := TFhirSubstance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(instanceList, o.instanceList, true) and 
      compareDeep(ingredientList, o.ingredientList, true);
  end;
end;

function TFhirSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FinstanceList) and isEmptyProp(FingredientList);
end;

function TFhirSubstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubstance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubstance.GetStatusST : TFhirFHIRSubstanceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRSubstanceStatusEnum(0)
  else
    result := TFhirFHIRSubstanceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRSubstanceStatusEnum, FStatus.value));
end;

procedure TFhirSubstance.SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[value], CODES_TFhirFHIRSubstanceStatusEnum[value]);
end;

function TFhirSubstance.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirSubstance.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirSubstance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirSubstance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirSubstance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubstance.GetInstanceList : TFhirSubstanceInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirSubstanceInstanceList.Create;
  result := FInstanceList;
end;

function TFhirSubstance.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirSubstance.GetIngredientList : TFhirSubstanceIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirSubstanceIngredientList.Create;
  result := FIngredientList;
end;

function TFhirSubstance.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirSubstance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('description');
  fields.add('instance');
  fields.add('ingredient');
end;

function TFhirSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
end;

{ TFhirSubstanceListEnumerator }

constructor TFhirSubstanceListEnumerator.Create(list : TFhirSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceListEnumerator.GetCurrent : TFhirSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceList }

procedure TFhirSubstanceList.AddItem(value: TFhirSubstance);
begin
  assert(value.ClassName = 'TFhirSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstance');
  add(value);
end;

function TFhirSubstanceList.Append: TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceList.GetEnumerator : TFhirSubstanceListEnumerator;
begin
  result := TFhirSubstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceList.Clone: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Clone);
end;

function TFhirSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceList.GetItemN(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstance;
end;
function TFhirSubstanceList.IndexOf(value: TFhirSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceList.Insert(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.InsertItem(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceList.Item(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.Link: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Link);
end;

procedure TFhirSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceList.SetItemByIndex(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  FhirSubstances[index] := value;
end;

procedure TFhirSubstanceList.SetItemN(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
{ TFhirSubstanceDefinitionMoiety }

constructor TFhirSubstanceDefinitionMoiety.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionMoiety.Destroy;
begin
  FRole.free;
  FIdentifier.free;
  FName.free;
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FAmount.free;
  FAmountType.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionMoiety.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirSubstanceDefinitionMoiety(oSource).role.Clone;
  identifier := TFhirSubstanceDefinitionMoiety(oSource).identifier.Clone;
  nameElement := TFhirSubstanceDefinitionMoiety(oSource).nameElement.Clone;
  stereochemistry := TFhirSubstanceDefinitionMoiety(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionMoiety(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionMoiety(oSource).molecularFormulaElement.Clone;
  amount := TFhirSubstanceDefinitionMoiety(oSource).amount.Clone;
  amountType := TFhirSubstanceDefinitionMoiety(oSource).amountType.Clone;
end;

procedure TFhirSubstanceDefinitionMoiety.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
end;

procedure TFhirSubstanceDefinitionMoiety.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirDataType, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link)); {L1172}
end;

function TFhirSubstanceDefinitionMoiety.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionMoiety.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionMoiety.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'molecularFormula') then result := TFhirString.create() {L1223}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount') {L1191}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionMoiety.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionMoiety.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil {L1189}
  else if (propName = 'amountType') then AmountTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionMoiety.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new) {L1222}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirDataType {L1190}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionMoiety.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionMoiety.fhirType : string;
begin
  result := 'SubstanceDefinition.moiety';
end;

function TFhirSubstanceDefinitionMoiety.Link : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Link);
end;

function TFhirSubstanceDefinitionMoiety.Clone : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Clone);
end;

function TFhirSubstanceDefinitionMoiety.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionMoiety;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionMoiety)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionMoiety(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(amountTypeElement, o.amountTypeElement, true);
  end;
end;

function TFhirSubstanceDefinitionMoiety.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FAmount) and isEmptyProp(FAmountType);
end;

procedure TFhirSubstanceDefinitionMoiety.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirSubstanceDefinitionMoiety.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value; {L1134}
end;

function TFhirSubstanceDefinitionMoiety.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value; {L1134}
end;

procedure TFhirSubstanceDefinitionMoiety.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('identifier');
  fields.add('name');
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('amount[x]');
  fields.add('amountType');
end;

function TFhirSubstanceDefinitionMoiety.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStereochemistry.sizeInBytes);
  inc(result, FOpticalActivity.sizeInBytes);
  inc(result, FMolecularFormula.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
end;

{ TFhirSubstanceDefinitionMoietyListEnumerator }

constructor TFhirSubstanceDefinitionMoietyListEnumerator.Create(list : TFhirSubstanceDefinitionMoietyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionMoietyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.GetCurrent : TFhirSubstanceDefinitionMoiety;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionMoietyList }

procedure TFhirSubstanceDefinitionMoietyList.AddItem(value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionMoiety', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionMoiety');
  add(value);
end;

function TFhirSubstanceDefinitionMoietyList.Append: TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionMoietyList.GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
begin
  result := TFhirSubstanceDefinitionMoietyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionMoietyList.Clone: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Clone);
end;

function TFhirSubstanceDefinitionMoietyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionMoietyList.GetItemN(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionMoiety;
end;
function TFhirSubstanceDefinitionMoietyList.IndexOf(value: TFhirSubstanceDefinitionMoiety): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionMoietyList.Insert(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionMoietyList.Item(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.Link: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionMoietyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  FhirSubstanceDefinitionMoieties[index] := value;
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionProperty }

constructor TFhirSubstanceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionProperty.Destroy;
begin
  FCategory.free;
  FCode.free;
  FParameters.free;
  FDefiningSubstance.free;
  FAmount.free;
  FReferenceRange.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirSubstanceDefinitionProperty(oSource).category.Clone;
  code := TFhirSubstanceDefinitionProperty(oSource).code.Clone;
  parametersElement := TFhirSubstanceDefinitionProperty(oSource).parametersElement.Clone;
  definingSubstance := TFhirSubstanceDefinitionProperty(oSource).definingSubstance.Clone;
  amount := TFhirSubstanceDefinitionProperty(oSource).amount.Clone;
  referenceRange := TFhirSubstanceDefinitionProperty(oSource).referenceRange.Clone;
  if (TFhirSubstanceDefinitionProperty(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionProperty(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'parameters') Then
     list.add(self.link, 'parameters', FParameters.Link);
  if (child_name = 'definingSubstance') Then
     list.add(self.link, 'definingSubstance', FDefiningSubstance.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'referenceRange') Then
     list.add(self.link, 'referenceRange', FReferenceRange.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parameters', 'string', false, TFhirString, FParameters.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'definingSubstance', 'CodeableReference', false, TFhirCodeableReference, FDefiningSubstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirDataType, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referenceRange', 'Range', false, TFhirRange, FReferenceRange.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'parameters') then
  begin
    ParametersElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'definingSubstance') then
  begin
    DefiningSubstance := propValue as TFhirCodeableReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRange := propValue as TFhirRange {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'parameters') then result := TFhirString.create() {L1223}
  else if (propName = 'definingSubstance') then result := TFhirCodeableReference.create() {L1203}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount') {L1191}
  else if (propName = 'referenceRange') then result := TFhirRange.create() {L1203}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'parameters') then result := 'string'
  else if (propName = 'definingSubstance') then result := 'CodeableReference'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else if (propName = 'referenceRange') then result := 'Range'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'parameters') then ParametersElement := nil
  else if (propName = 'definingSubstance') then DefiningSubstanceElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil {L1189}
  else if (propName = 'referenceRange') then ReferenceRangeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'parameters') then ParametersElement := asString(new) {L1222}
  else if (propName = 'definingSubstance') then DefiningSubstanceElement := new as TFhirCodeableReference {L1195}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirDataType {L1190}
  else if (propName = 'referenceRange') then ReferenceRangeElement := new as TFhirRange {L1195}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionProperty.fhirType : string;
begin
  result := 'SubstanceDefinition.property';
end;

function TFhirSubstanceDefinitionProperty.Link : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Link);
end;

function TFhirSubstanceDefinitionProperty.Clone : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Clone);
end;

function TFhirSubstanceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionProperty(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(parametersElement, o.parametersElement, true) and compareDeep(definingSubstanceElement, o.definingSubstanceElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(referenceRangeElement, o.referenceRangeElement, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FParameters) and isEmptyProp(FDefiningSubstance) and isEmptyProp(FAmount) and isEmptyProp(FReferenceRange) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionProperty.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirSubstanceDefinitionProperty.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirSubstanceDefinitionProperty.SetParameters(value : TFhirString);
begin
  FParameters.free;
  FParameters := value; {L1134}
end;

function TFhirSubstanceDefinitionProperty.GetParametersST : String;
begin
  if FParameters = nil then
    result := ''
  else
    result := FParameters.value;
end;

procedure TFhirSubstanceDefinitionProperty.SetParametersST(value : String);
begin
  if value <> '' then
  begin
    if FParameters = nil then
      FParameters := TFhirString.create;
    FParameters.value := value
  end
  else if FParameters <> nil then
    FParameters.value := '';
end;

procedure TFhirSubstanceDefinitionProperty.SetDefiningSubstance(value : TFhirCodeableReference);
begin
  FDefiningSubstance.free;
  FDefiningSubstance := value; {L1134}
end;

procedure TFhirSubstanceDefinitionProperty.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstanceDefinitionProperty.SetReferenceRange(value : TFhirRange);
begin
  FReferenceRange.free;
  FReferenceRange := value; {L1134}
end;

function TFhirSubstanceDefinitionProperty.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionProperty.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('code');
  fields.add('parameters');
  fields.add('definingSubstance');
  fields.add('amount[x]');
  fields.add('referenceRange');
  fields.add('source');
end;

function TFhirSubstanceDefinitionProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FParameters.sizeInBytes);
  inc(result, FDefiningSubstance.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FReferenceRange.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionPropertyListEnumerator }

constructor TFhirSubstanceDefinitionPropertyListEnumerator.Create(list : TFhirSubstanceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.GetCurrent : TFhirSubstanceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionPropertyList }

procedure TFhirSubstanceDefinitionPropertyList.AddItem(value: TFhirSubstanceDefinitionProperty);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionProperty');
  add(value);
end;

function TFhirSubstanceDefinitionPropertyList.Append: TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionPropertyList.GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
begin
  result := TFhirSubstanceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionPropertyList.Clone: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Clone);
end;

function TFhirSubstanceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionPropertyList.GetItemN(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionProperty;
end;
function TFhirSubstanceDefinitionPropertyList.IndexOf(value: TFhirSubstanceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionPropertyList.Insert(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionPropertyList.Item(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.Link: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  FhirSubstanceDefinitionProperties[index] := value;
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructure }

constructor TFhirSubstanceDefinitionStructure.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructure.Destroy;
begin
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FMolecularFormulaByMoiety.free;
  FIsotopeList.Free;
  FMolecularWeight.free;
  FTechniqueList.Free;
  FSourceDocumentList.Free;
  FRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructure.Assign(oSource : TFslObject);
begin
  inherited;
  stereochemistry := TFhirSubstanceDefinitionStructure(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionStructure(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaElement.Clone;
  molecularFormulaByMoietyElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaByMoietyElement.Clone;
  if (TFhirSubstanceDefinitionStructure(oSource).FIsotopeList = nil) then
  begin
    FIsotopeList.free;
    FIsotopeList := nil;
  end
  else
  begin
    if FIsotopeList = nil then
      FIsotopeList := TFhirSubstanceDefinitionStructureIsotopeList.Create;
    FIsotopeList.Assign(TFhirSubstanceDefinitionStructure(oSource).FIsotopeList);
  end;
  molecularWeight := TFhirSubstanceDefinitionStructure(oSource).molecularWeight.Clone;
  if (TFhirSubstanceDefinitionStructure(oSource).FTechniqueList = nil) then
  begin
    FTechniqueList.free;
    FTechniqueList := nil;
  end
  else
  begin
    if FTechniqueList = nil then
      FTechniqueList := TFhirCodeableConceptList.Create;
    FTechniqueList.Assign(TFhirSubstanceDefinitionStructure(oSource).FTechniqueList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList = nil) then
  begin
    FSourceDocumentList.free;
    FSourceDocumentList := nil;
  end
  else
  begin
    if FSourceDocumentList = nil then
      FSourceDocumentList := TFhirReferenceList.Create;
    FSourceDocumentList.Assign(TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FRepresentationList = nil) then
  begin
    FRepresentationList.free;
    FRepresentationList := nil;
  end
  else
  begin
    if FRepresentationList = nil then
      FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
    FRepresentationList.Assign(TFhirSubstanceDefinitionStructure(oSource).FRepresentationList);
  end;
end;

procedure TFhirSubstanceDefinitionStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'molecularFormulaByMoiety') Then
     list.add(self.link, 'molecularFormulaByMoiety', FMolecularFormulaByMoiety.Link);
  if (child_name = 'isotope') Then
    list.addAll(self, 'isotope', FIsotopeList);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
  if (child_name = 'technique') Then
    list.addAll(self, 'technique', FTechniqueList);
  if (child_name = 'sourceDocument') Then
    list.addAll(self, 'sourceDocument', FSourceDocumentList);
  if (child_name = 'representation') Then
    list.addAll(self, 'representation', FRepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'molecularFormulaByMoiety', 'string', false, TFhirString, FMolecularFormulaByMoiety.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'isotope', 'BackboneElement', true, TFhirSubstanceDefinitionStructureIsotope, FIsotopeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '', false, TFhirSubstanceDefinitionStructureIsotopeMolecularWeight, FMolecularWeight.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'technique', 'CodeableConcept', true, TFhirCodeableConcept, FTechniqueList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'sourceDocument', 'Reference', true, TFhirReference, FSourceDocumentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'representation', 'BackboneElement', true, TFhirSubstanceDefinitionStructureRepresentation, FRepresentationList.Link)) {L1039};
end;

function TFhirSubstanceDefinitionStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'molecularFormulaByMoiety') then
  begin
    MolecularFormulaByMoietyElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'isotope') then
  begin
    IsotopeList.add(propValue as TFhirSubstanceDefinitionStructureIsotope) {L1048};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight {L1199};
    result := propValue;
  end
  else if (propName = 'technique') then
  begin
    TechniqueList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'sourceDocument') then
  begin
    SourceDocumentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationList.add(propValue as TFhirSubstanceDefinitionStructureRepresentation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'isotope') then IsotopeList.insertItem(index, propValue as TFhirSubstanceDefinitionStructureIsotope) {L1049}
  else if (propName = 'technique') then TechniqueList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'sourceDocument') then SourceDocumentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'representation') then RepresentationList.insertItem(index, propValue as TFhirSubstanceDefinitionStructureRepresentation) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinitionStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'molecularFormula') then result := TFhirString.create() {L1223}
  else if (propName = 'molecularFormulaByMoiety') then result := TFhirString.create() {L1223}
  else if (propName = 'isotope') then result := IsotopeList.new() {L1053}
  else if (propName = 'molecularWeight') then result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.create() {L1203}
  else if (propName = 'technique') then result := TechniqueList.new() {L1053}
  else if (propName = 'sourceDocument') then result := SourceDocumentList.new() {L1053}
  else if (propName = 'representation') then result := RepresentationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'molecularFormulaByMoiety') then result := 'string'
  else if (propName = 'isotope') then result := 'BackboneElement'
  else if (propName = 'molecularWeight') then result := ''
  else if (propName = 'technique') then result := 'CodeableConcept'
  else if (propName = 'sourceDocument') then result := 'Reference'
  else if (propName = 'representation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := nil
  else if (propName = 'isotope') then deletePropertyValue('isotope', IsotopeList, value) {L1054}
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else if (propName = 'technique') then deletePropertyValue('technique', TechniqueList, value) {L1054}
  else if (propName = 'sourceDocument') then deletePropertyValue('sourceDocument', SourceDocumentList, value) {L1054}
  else if (propName = 'representation') then deletePropertyValue('representation', RepresentationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new) {L1222}
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := asString(new) {L1222}
  else if (propName = 'isotope') then replacePropertyValue('isotope', IsotopeList, existing, new) {L1055}
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight {L1195}
  else if (propName = 'technique') then replacePropertyValue('technique', TechniqueList, existing, new) {L1055}
  else if (propName = 'sourceDocument') then replacePropertyValue('sourceDocument', SourceDocumentList, existing, new) {L1055}
  else if (propName = 'representation') then replacePropertyValue('representation', RepresentationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'isotope') then IsotopeList.move(source, destination) {L1050}
  else if (propName = 'technique') then TechniqueList.move(source, destination) {L1050}
  else if (propName = 'sourceDocument') then SourceDocumentList.move(source, destination) {L1050}
  else if (propName = 'representation') then RepresentationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructure.fhirType : string;
begin
  result := 'SubstanceDefinition.structure';
end;

function TFhirSubstanceDefinitionStructure.Link : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Link);
end;

function TFhirSubstanceDefinitionStructure.Clone : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Clone);
end;

function TFhirSubstanceDefinitionStructure.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructure)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructure(other);
    result := compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(molecularFormulaByMoietyElement, o.molecularFormulaByMoietyElement, true) and 
      compareDeep(isotopeList, o.isotopeList, true) and compareDeep(molecularWeightElement, o.molecularWeightElement, true) and 
      compareDeep(techniqueList, o.techniqueList, true) and compareDeep(sourceDocumentList, o.sourceDocumentList, true) and 
      compareDeep(representationList, o.representationList, true);
  end;
end;

function TFhirSubstanceDefinitionStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FMolecularFormulaByMoiety) and isEmptyProp(FisotopeList) and isEmptyProp(FMolecularWeight) and isEmptyProp(FtechniqueList) and isEmptyProp(FsourceDocumentList) and isEmptyProp(FrepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructure.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value; {L1134}
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoiety(value : TFhirString);
begin
  FMolecularFormulaByMoiety.free;
  FMolecularFormulaByMoiety := value; {L1134}
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaByMoietyST : String;
begin
  if FMolecularFormulaByMoiety = nil then
    result := ''
  else
    result := FMolecularFormulaByMoiety.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoietyST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormulaByMoiety = nil then
      FMolecularFormulaByMoiety := TFhirString.create;
    FMolecularFormulaByMoiety.value := value
  end
  else if FMolecularFormulaByMoiety <> nil then
    FMolecularFormulaByMoiety.value := '';
end;

function TFhirSubstanceDefinitionStructure.GetIsotopeList : TFhirSubstanceDefinitionStructureIsotopeList;
begin
  if FIsotopeList = nil then
    FIsotopeList := TFhirSubstanceDefinitionStructureIsotopeList.Create;
  result := FIsotopeList;
end;

function TFhirSubstanceDefinitionStructure.GetHasIsotopeList : boolean;
begin
  result := (FIsotopeList <> nil) and (FIsotopeList.count > 0);
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularWeight(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value; {L1134}
end;

function TFhirSubstanceDefinitionStructure.GetTechniqueList : TFhirCodeableConceptList;
begin
  if FTechniqueList = nil then
    FTechniqueList := TFhirCodeableConceptList.Create;
  result := FTechniqueList;
end;

function TFhirSubstanceDefinitionStructure.GetHasTechniqueList : boolean;
begin
  result := (FTechniqueList <> nil) and (FTechniqueList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetSourceDocumentList : TFhirReferenceList;
begin
  if FSourceDocumentList = nil then
    FSourceDocumentList := TFhirReferenceList.Create;
  result := FSourceDocumentList;
end;

function TFhirSubstanceDefinitionStructure.GetHasSourceDocumentList : boolean;
begin
  result := (FSourceDocumentList <> nil) and (FSourceDocumentList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
begin
  if FRepresentationList = nil then
    FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
  result := FRepresentationList;
end;

function TFhirSubstanceDefinitionStructure.GetHasRepresentationList : boolean;
begin
  result := (FRepresentationList <> nil) and (FRepresentationList.count > 0);
end;

procedure TFhirSubstanceDefinitionStructure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('molecularFormulaByMoiety');
  fields.add('isotope');
  fields.add('molecularWeight');
  fields.add('technique');
  fields.add('sourceDocument');
  fields.add('representation');
end;

function TFhirSubstanceDefinitionStructure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStereochemistry.sizeInBytes);
  inc(result, FOpticalActivity.sizeInBytes);
  inc(result, FMolecularFormula.sizeInBytes);
  inc(result, FMolecularFormulaByMoiety.sizeInBytes);
  inc(result, FisotopeList.sizeInBytes);
  inc(result, FMolecularWeight.sizeInBytes);
  inc(result, FtechniqueList.sizeInBytes);
  inc(result, FsourceDocumentList.sizeInBytes);
  inc(result, FrepresentationList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureListEnumerator }

constructor TFhirSubstanceDefinitionStructureListEnumerator.Create(list : TFhirSubstanceDefinitionStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructure;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureList }

procedure TFhirSubstanceDefinitionStructureList.AddItem(value: TFhirSubstanceDefinitionStructure);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructure');
  add(value);
end;

function TFhirSubstanceDefinitionStructureList.Append: TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureList.GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureList.Clone: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructure;
end;
function TFhirSubstanceDefinitionStructureList.IndexOf(value: TFhirSubstanceDefinitionStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureList.Insert(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureList.Item(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.Link: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  FhirSubstanceDefinitionStructures[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructureIsotope }

constructor TFhirSubstanceDefinitionStructureIsotope.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructureIsotope.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FSubstitution.free;
  FHalfLife.free;
  FMolecularWeight.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructureIsotope.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceDefinitionStructureIsotope(oSource).identifier.Clone;
  name := TFhirSubstanceDefinitionStructureIsotope(oSource).name.Clone;
  substitution := TFhirSubstanceDefinitionStructureIsotope(oSource).substitution.Clone;
  halfLife := TFhirSubstanceDefinitionStructureIsotope(oSource).halfLife.Clone;
  molecularWeight := TFhirSubstanceDefinitionStructureIsotope(oSource).molecularWeight.Clone;
end;

procedure TFhirSubstanceDefinitionStructureIsotope.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'halfLife') Then
     list.add(self.link, 'halfLife', FHalfLife.Link);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', false, TFhirCodeableConcept, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'substitution', 'CodeableConcept', false, TFhirCodeableConcept, FSubstitution.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'halfLife', 'Quantity', false, TFhirQuantity, FHalfLife.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'molecularWeight', 'BackboneElement', false, TFhirSubstanceDefinitionStructureIsotopeMolecularWeight, FMolecularWeight.Link)); {L1172}
end;

function TFhirSubstanceDefinitionStructureIsotope.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'halfLife') then
  begin
    HalfLife := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionStructureIsotope.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'name') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'substitution') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'halfLife') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'molecularWeight') then result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructureIsotope.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'CodeableConcept'
  else if (propName = 'substitution') then result := 'CodeableConcept'
  else if (propName = 'halfLife') then result := 'Quantity'
  else if (propName = 'molecularWeight') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'halfLife') then HalfLifeElement := nil
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'name') then NameElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'halfLife') then HalfLifeElement := new as TFhirQuantity {L1195}
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructureIsotope.fhirType : string;
begin
  result := 'SubstanceDefinition.structure.isotope';
end;

function TFhirSubstanceDefinitionStructureIsotope.Link : TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope(inherited Link);
end;

function TFhirSubstanceDefinitionStructureIsotope.Clone : TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureIsotope.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructureIsotope;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructureIsotope)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructureIsotope(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(substitutionElement, o.substitutionElement, true) and compareDeep(halfLifeElement, o.halfLifeElement, true) and 
      compareDeep(molecularWeightElement, o.molecularWeightElement, true);
  end;
end;

function TFhirSubstanceDefinitionStructureIsotope.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FSubstitution) and isEmptyProp(FHalfLife) and isEmptyProp(FMolecularWeight);
end;

procedure TFhirSubstanceDefinitionStructureIsotope.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotope.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotope.SetSubstitution(value : TFhirCodeableConcept);
begin
  FSubstitution.free;
  FSubstitution := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotope.SetHalfLife(value : TFhirQuantity);
begin
  FHalfLife.free;
  FHalfLife := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotope.SetMolecularWeight(value : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotope.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('substitution');
  fields.add('halfLife');
  fields.add('molecularWeight');
end;

function TFhirSubstanceDefinitionStructureIsotope.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FHalfLife.sizeInBytes);
  inc(result, FMolecularWeight.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureIsotopeListEnumerator }

constructor TFhirSubstanceDefinitionStructureIsotopeListEnumerator.Create(list : TFhirSubstanceDefinitionStructureIsotopeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureIsotopeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureIsotopeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureIsotopeListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructureIsotope;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureIsotopeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureIsotopeList }

procedure TFhirSubstanceDefinitionStructureIsotopeList.AddItem(value: TFhirSubstanceDefinitionStructureIsotope);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructureIsotope', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructureIsotope');
  add(value);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Append: TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureIsotopeList.GetEnumerator : TFhirSubstanceDefinitionStructureIsotopeListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Clone: TFhirSubstanceDefinitionStructureIsotopeList;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureIsotopeList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructureIsotope;
end;
function TFhirSubstanceDefinitionStructureIsotopeList.IndexOf(value: TFhirSubstanceDefinitionStructureIsotope): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Insert(index: Integer): TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructureIsotope);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotope);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Item(index: Integer): TFhirSubstanceDefinitionStructureIsotope;
begin
  result := TFhirSubstanceDefinitionStructureIsotope(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureIsotopeList.Link: TFhirSubstanceDefinitionStructureIsotopeList;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructureIsotope);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotope);
  FhirSubstanceDefinitionStructureIsotopes[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructureIsotope);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotope);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructureIsotopeMolecularWeight }

constructor TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.Destroy;
begin
  FMethod.free;
  FType_.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.Assign(oSource : TFslObject);
begin
  inherited;
  method := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(oSource).method.Clone;
  type_ := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(oSource).type_.Clone;
  amount := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(oSource).amount.Clone;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.fhirType : string;
begin
  result := 'SubstanceDefinition.structure.isotope.molecularWeight';
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.Link : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(inherited Link);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.Clone : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructureIsotopeMolecularWeight)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FType_) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('method');
  fields.add('type');
  fields.add('amount');
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMethod.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator }

constructor TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.Create(list : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList }

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.AddItem(value: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructureIsotopeMolecularWeight', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructureIsotopeMolecularWeight');
  add(value);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Append: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.GetEnumerator : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeightListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Clone: TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
end;
function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.IndexOf(value: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Insert(index: Integer): TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Item(index: Integer): TFhirSubstanceDefinitionStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Link: TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
  FhirSubstanceDefinitionStructureIsotopeMolecularWeights[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionStructureIsotopeMolecularWeight);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructureRepresentation }

constructor TFhirSubstanceDefinitionStructureRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructureRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FFormat.free;
  FDocument.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionStructureRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstanceDefinitionStructureRepresentation(oSource).representationElement.Clone;
  format := TFhirSubstanceDefinitionStructureRepresentation(oSource).format.Clone;
  document := TFhirSubstanceDefinitionStructureRepresentation(oSource).document.Clone;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'document') Then
     list.add(self.link, 'document', FDocument.Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'format', 'CodeableConcept', false, TFhirCodeableConcept, FFormat.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'document', 'Reference', false, TFhirReference, FDocument.Link)); {L1172}
end;

function TFhirSubstanceDefinitionStructureRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    Document := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'representation') then result := TFhirString.create() {L1223}
  else if (propName = 'format') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'document') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructureRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'format') then result := 'CodeableConcept'
  else if (propName = 'document') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'document') then DocumentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'representation') then RepresentationElement := asString(new) {L1222}
  else if (propName = 'format') then FormatElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'document') then DocumentElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructureRepresentation.fhirType : string;
begin
  result := 'SubstanceDefinition.structure.representation';
end;

function TFhirSubstanceDefinitionStructureRepresentation.Link : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Link);
end;

function TFhirSubstanceDefinitionStructureRepresentation.Clone : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructureRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructureRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructureRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(formatElement, o.formatElement, true) and compareDeep(documentElement, o.documentElement, true);
  end;
end;

function TFhirSubstanceDefinitionStructureRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FFormat) and isEmptyProp(FDocument);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value; {L1134}
end;

function TFhirSubstanceDefinitionStructureRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetFormat(value : TFhirCodeableConcept);
begin
  FFormat.free;
  FFormat := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetDocument(value : TFhirReference);
begin
  FDocument.free;
  FDocument := value; {L1134}
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('format');
  fields.add('document');
end;

function TFhirSubstanceDefinitionStructureRepresentation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRepresentation.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
  inc(result, FDocument.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureRepresentationListEnumerator }

constructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionStructureRepresentationList }

procedure TFhirSubstanceDefinitionStructureRepresentationList.AddItem(value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructureRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructureRepresentation');
  add(value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Append: TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Clone: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation;
end;
function TFhirSubstanceDefinitionStructureRepresentationList.IndexOf(value: TFhirSubstanceDefinitionStructureRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Insert(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Item(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Link: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  FhirSubstanceDefinitionStructureRepresentations[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionCode }

constructor TFhirSubstanceDefinitionCode.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionCode.Destroy;
begin
  FCode.free;
  FStatus.free;
  FStatusDate.free;
  FNoteList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionCode.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstanceDefinitionCode(oSource).code.Clone;
  status := TFhirSubstanceDefinitionCode(oSource).status.Clone;
  statusDateElement := TFhirSubstanceDefinitionCode(oSource).statusDateElement.Clone;
  if (TFhirSubstanceDefinitionCode(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinitionCode(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinitionCode(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionCode(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionCode.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionCode.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceDefinitionCode.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionCode.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinitionCode.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionCode.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionCode.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionCode.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionCode.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionCode.fhirType : string;
begin
  result := 'SubstanceDefinition.code';
end;

function TFhirSubstanceDefinitionCode.Link : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Link);
end;

function TFhirSubstanceDefinitionCode.Clone : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Clone);
end;

function TFhirSubstanceDefinitionCode.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionCode;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionCode)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionCode(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionCode.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FnoteList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionCode.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirSubstanceDefinitionCode.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value; {L1134}
end;

function TFhirSubstanceDefinitionCode.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

function TFhirSubstanceDefinitionCode.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinitionCode.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinitionCode.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionCode.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceDefinitionCode.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('statusDate');
  fields.add('note');
  fields.add('source');
end;

function TFhirSubstanceDefinitionCode.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionCodeListEnumerator }

constructor TFhirSubstanceDefinitionCodeListEnumerator.Create(list : TFhirSubstanceDefinitionCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.GetCurrent : TFhirSubstanceDefinitionCode;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionCodeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionCodeList }

procedure TFhirSubstanceDefinitionCodeList.AddItem(value: TFhirSubstanceDefinitionCode);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionCode');
  add(value);
end;

function TFhirSubstanceDefinitionCodeList.Append: TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionCodeList.GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
begin
  result := TFhirSubstanceDefinitionCodeListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionCodeList.Clone: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Clone);
end;

function TFhirSubstanceDefinitionCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionCodeList.GetItemN(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionCode;
end;
function TFhirSubstanceDefinitionCodeList.IndexOf(value: TFhirSubstanceDefinitionCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionCodeList.Insert(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionCodeList.Item(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.Link: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Link);
end;

procedure TFhirSubstanceDefinitionCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  FhirSubstanceDefinitionCodes[index] := value;
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionName }

constructor TFhirSubstanceDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionName.Destroy;
begin
  FName.free;
  FType_.free;
  FStatus.free;
  FPreferred.free;
  FLanguageList.Free;
  FDomainList.Free;
  FJurisdictionList.Free;
  FSynonymList.Free;
  FTranslationList.Free;
  FOfficialList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirSubstanceDefinitionName(oSource).nameElement.Clone;
  type_ := TFhirSubstanceDefinitionName(oSource).type_.Clone;
  status := TFhirSubstanceDefinitionName(oSource).status.Clone;
  preferredElement := TFhirSubstanceDefinitionName(oSource).preferredElement.Clone;
  if (TFhirSubstanceDefinitionName(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeableConceptList.Create;
    FLanguageList.Assign(TFhirSubstanceDefinitionName(oSource).FLanguageList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirCodeableConceptList.Create;
    FDomainList.Assign(TFhirSubstanceDefinitionName(oSource).FDomainList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSubstanceDefinitionName(oSource).FJurisdictionList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirSubstanceDefinitionNameList.Create;
    FSynonymList.Assign(TFhirSubstanceDefinitionName(oSource).FSynonymList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FTranslationList = nil) then
  begin
    FTranslationList.free;
    FTranslationList := nil;
  end
  else
  begin
    if FTranslationList = nil then
      FTranslationList := TFhirSubstanceDefinitionNameList.Create;
    FTranslationList.Assign(TFhirSubstanceDefinitionName(oSource).FTranslationList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FOfficialList = nil) then
  begin
    FOfficialList.free;
    FOfficialList := nil;
  end
  else
  begin
    if FOfficialList = nil then
      FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
    FOfficialList.Assign(TFhirSubstanceDefinitionName(oSource).FOfficialList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionName(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'translation') Then
    list.addAll(self, 'translation', FTranslationList);
  if (child_name = 'official') Then
    list.addAll(self, 'official', FOfficialList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', true, TFhirCodeableConcept, FDomainList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'synonym', '', true, TFhirSubstanceDefinitionName, FSynonymList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'translation', '', true, TFhirSubstanceDefinitionName, FTranslationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'official', 'BackboneElement', true, TFhirSubstanceDefinitionNameOfficial, FOfficialList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(propValue as TFhirSubstanceDefinitionName) {L1048};
    result := propValue;
  end
  else if (propName = 'translation') then
  begin
    TranslationList.add(propValue as TFhirSubstanceDefinitionName) {L1048};
    result := propValue;
  end
  else if (propName = 'official') then
  begin
    OfficialList.add(propValue as TFhirSubstanceDefinitionNameOfficial) {L1048};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'synonym') then SynonymList.insertItem(index, propValue as TFhirSubstanceDefinitionName) {L1049}
  else if (propName = 'translation') then TranslationList.insertItem(index, propValue as TFhirSubstanceDefinitionName) {L1049}
  else if (propName = 'official') then OfficialList.insertItem(index, propValue as TFhirSubstanceDefinitionNameOfficial) {L1049}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'language') then result := LanguageList.new() {L1053}
  else if (propName = 'domain') then result := DomainList.new() {L1053}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new() {L1053}
  else if (propName = 'synonym') then result := SynonymList.new() {L1053}
  else if (propName = 'translation') then result := TranslationList.new() {L1053}
  else if (propName = 'official') then result := OfficialList.new() {L1053}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'synonym') then result := ''
  else if (propName = 'translation') then result := ''
  else if (propName = 'official') then result := 'BackboneElement'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value) {L1054}
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value) {L1054}
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {L1054}
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value) {L1054}
  else if (propName = 'translation') then deletePropertyValue('translation', TranslationList, value) {L1054}
  else if (propName = 'official') then deletePropertyValue('official', OfficialList, value) {L1054}
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new) {L1222}
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new) {L1055}
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new) {L1055}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {L1055}
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new) {L1055}
  else if (propName = 'translation') then replacePropertyValue('translation', TranslationList, existing, new) {L1055}
  else if (propName = 'official') then replacePropertyValue('official', OfficialList, existing, new) {L1055}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination) {L1050}
  else if (propName = 'domain') then DomainList.move(source, destination) {L1050}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination) {L1050}
  else if (propName = 'synonym') then SynonymList.move(source, destination) {L1050}
  else if (propName = 'translation') then TranslationList.move(source, destination) {L1050}
  else if (propName = 'official') then OfficialList.move(source, destination) {L1050}
  else if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionName.fhirType : string;
begin
  result := 'SubstanceDefinition.name';
end;

function TFhirSubstanceDefinitionName.Link : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Link);
end;

function TFhirSubstanceDefinitionName.Clone : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Clone);
end;

function TFhirSubstanceDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionName)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(preferredElement, o.preferredElement, true) and 
      compareDeep(languageList, o.languageList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(translationList, o.translationList, true) and compareDeep(officialList, o.officialList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FPreferred) and isEmptyProp(FlanguageList) and isEmptyProp(FdomainList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FsynonymList) and isEmptyProp(FtranslationList) and isEmptyProp(FofficialList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirSubstanceDefinitionName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceDefinitionName.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirSubstanceDefinitionName.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value; {L1134}
end;

function TFhirSubstanceDefinitionName.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirSubstanceDefinitionName.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

function TFhirSubstanceDefinitionName.GetLanguageList : TFhirCodeableConceptList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeableConceptList.Create;
  result := FLanguageList;
end;

function TFhirSubstanceDefinitionName.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetDomainList : TFhirCodeableConceptList;
begin
  if FDomainList = nil then
    FDomainList := TFhirCodeableConceptList.Create;
  result := FDomainList;
end;

function TFhirSubstanceDefinitionName.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSubstanceDefinitionName.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSynonymList : TFhirSubstanceDefinitionNameList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirSubstanceDefinitionNameList.Create;
  result := FSynonymList;
end;

function TFhirSubstanceDefinitionName.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetTranslationList : TFhirSubstanceDefinitionNameList;
begin
  if FTranslationList = nil then
    FTranslationList := TFhirSubstanceDefinitionNameList.Create;
  result := FTranslationList;
end;

function TFhirSubstanceDefinitionName.GetHasTranslationList : boolean;
begin
  result := (FTranslationList <> nil) and (FTranslationList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
begin
  if FOfficialList = nil then
    FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
  result := FOfficialList;
end;

function TFhirSubstanceDefinitionName.GetHasOfficialList : boolean;
begin
  result := (FOfficialList <> nil) and (FOfficialList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionName.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceDefinitionName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('preferred');
  fields.add('language');
  fields.add('domain');
  fields.add('jurisdiction');
  fields.add('synonym');
  fields.add('translation');
  fields.add('official');
  fields.add('source');
end;

function TFhirSubstanceDefinitionName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
  inc(result, FlanguageList.sizeInBytes);
  inc(result, FdomainList.sizeInBytes);
  inc(result, FjurisdictionList.sizeInBytes);
  inc(result, FsynonymList.sizeInBytes);
  inc(result, FtranslationList.sizeInBytes);
  inc(result, FofficialList.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionNameListEnumerator }

constructor TFhirSubstanceDefinitionNameListEnumerator.Create(list : TFhirSubstanceDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameListEnumerator.GetCurrent : TFhirSubstanceDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionNameList }

procedure TFhirSubstanceDefinitionNameList.AddItem(value: TFhirSubstanceDefinitionName);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionName');
  add(value);
end;

function TFhirSubstanceDefinitionNameList.Append: TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameList.GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameList.Clone: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameList.GetItemN(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionName;
end;
function TFhirSubstanceDefinitionNameList.IndexOf(value: TFhirSubstanceDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameList.Insert(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameList.Item(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.Link: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  FhirSubstanceDefinitionNames[index] := value;
end;

procedure TFhirSubstanceDefinitionNameList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionNameOfficial }

constructor TFhirSubstanceDefinitionNameOfficial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionNameOfficial.Destroy;
begin
  FAuthority.free;
  FStatus.free;
  FDate.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionNameOfficial.Assign(oSource : TFslObject);
begin
  inherited;
  authority := TFhirSubstanceDefinitionNameOfficial(oSource).authority.Clone;
  status := TFhirSubstanceDefinitionNameOfficial(oSource).status.Clone;
  dateElement := TFhirSubstanceDefinitionNameOfficial(oSource).dateElement.Clone;
end;

procedure TFhirSubstanceDefinitionNameOfficial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
end;

procedure TFhirSubstanceDefinitionNameOfficial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'CodeableConcept', false, TFhirCodeableConcept, FAuthority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
end;

function TFhirSubstanceDefinitionNameOfficial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    Authority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionNameOfficial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionNameOfficial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionNameOfficial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionNameOfficial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionNameOfficial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionNameOfficial.fhirType : string;
begin
  result := 'SubstanceDefinition.name.official';
end;

function TFhirSubstanceDefinitionNameOfficial.Link : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Link);
end;

function TFhirSubstanceDefinitionNameOfficial.Clone : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionNameOfficial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionNameOfficial)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionNameOfficial(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true);
  end;
end;

function TFhirSubstanceDefinitionNameOfficial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FStatus) and isEmptyProp(FDate);
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetAuthority(value : TFhirCodeableConcept);
begin
  FAuthority.free;
  FAuthority := value; {L1134}
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirSubstanceDefinitionNameOfficial.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirSubstanceDefinitionNameOfficial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authority');
  fields.add('status');
  fields.add('date');
end;

function TFhirSubstanceDefinitionNameOfficial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthority.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
end;

{ TFhirSubstanceDefinitionNameOfficialListEnumerator }

constructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(list : TFhirSubstanceDefinitionNameOfficialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.GetCurrent : TFhirSubstanceDefinitionNameOfficial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionNameOfficialList }

procedure TFhirSubstanceDefinitionNameOfficialList.AddItem(value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionNameOfficial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionNameOfficial');
  add(value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Append: TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameOfficialList.Clone: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetItemN(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionNameOfficial;
end;
function TFhirSubstanceDefinitionNameOfficialList.IndexOf(value: TFhirSubstanceDefinitionNameOfficial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Insert(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Item(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.Link: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  FhirSubstanceDefinitionNameOfficials[index] := value;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionRelationship }

constructor TFhirSubstanceDefinitionRelationship.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionRelationship.Destroy;
begin
  FSubstanceDefinition.free;
  FType_.free;
  FIsDefining.free;
  FAmount.free;
  FAmountRatioHighLimit.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionRelationship.Assign(oSource : TFslObject);
begin
  inherited;
  substanceDefinition := TFhirSubstanceDefinitionRelationship(oSource).substanceDefinition.Clone;
  type_ := TFhirSubstanceDefinitionRelationship(oSource).type_.Clone;
  isDefiningElement := TFhirSubstanceDefinitionRelationship(oSource).isDefiningElement.Clone;
  amount := TFhirSubstanceDefinitionRelationship(oSource).amount.Clone;
  amountRatioHighLimit := TFhirSubstanceDefinitionRelationship(oSource).amountRatioHighLimit.Clone;
  amountType := TFhirSubstanceDefinitionRelationship(oSource).amountType.Clone;
  if (TFhirSubstanceDefinitionRelationship(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionRelationship(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionRelationship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substanceDefinition[x]') or (child_name = 'substanceDefinition') Then
     list.add(self.link, 'substanceDefinition[x]', FSubstanceDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountRatioHighLimit') Then
     list.add(self.link, 'amountRatioHighLimit', FAmountRatioHighLimit.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substanceDefinition[x]', 'Reference|CodeableConcept', false, TFhirDataType, FSubstanceDefinition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|Ratio|string', false, TFhirDataType, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amountRatioHighLimit', 'Ratio', false, TFhirRatio, FAmountRatioHighLimit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceDefinitionRelationship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then
  begin
    SubstanceDefinition := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then
  begin
    Amount := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'amountRatioHighLimit') then
  begin
    AmountRatioHighLimit := propValue as TFhirRatio {L1199};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionRelationship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinitionRelationship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property SubstanceDefinition') {L1191}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'isDefining') then result := TFhirBoolean.create() {L1223}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then raise EFHIRException.create('Cannot make property Amount') {L1191}
  else if (propName = 'amountRatioHighLimit') then result := TFhirRatio.create() {L1203}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionRelationship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substanceDefinition[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount[x]') then result := 'Quantity|Range|Ratio|string'
  else if (propName = 'amountRatioHighLimit') then result := 'Ratio'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionRelationship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := nil {L1189}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then AmountElement := nil {L1189}
  else if (propName = 'amountRatioHighLimit') then AmountRatioHighLimitElement := nil
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionRelationship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := new as TFhirDataType {L1190}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new) {L1222}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then AmountElement := new as TFhirDataType {L1190}
  else if (propName = 'amountRatioHighLimit') then AmountRatioHighLimitElement := new as TFhirRatio {L1195}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionRelationship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionRelationship.fhirType : string;
begin
  result := 'SubstanceDefinition.relationship';
end;

function TFhirSubstanceDefinitionRelationship.Link : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Link);
end;

function TFhirSubstanceDefinitionRelationship.Clone : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationship.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionRelationship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionRelationship)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionRelationship(other);
    result := compareDeep(substanceDefinitionElement, o.substanceDefinitionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(isDefiningElement, o.isDefiningElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(amountRatioHighLimitElement, o.amountRatioHighLimitElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionRelationship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstanceDefinition) and isEmptyProp(FType_) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount) and isEmptyProp(FAmountRatioHighLimit) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.SetSubstanceDefinition(value : TFhirDataType);
begin
  FSubstanceDefinition.free;
  FSubstanceDefinition := value; {L1134}
end;

procedure TFhirSubstanceDefinitionRelationship.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value; {L1134}
end;

function TFhirSubstanceDefinitionRelationship.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmountRatioHighLimit(value : TFhirRatio);
begin
  FAmountRatioHighLimit.free;
  FAmountRatioHighLimit := value; {L1134}
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value; {L1134}
end;

function TFhirSubstanceDefinitionRelationship.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionRelationship.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceDefinitionRelationship.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substanceDefinition[x]');
  fields.add('type');
  fields.add('isDefining');
  fields.add('amount[x]');
  fields.add('amountRatioHighLimit');
  fields.add('amountType');
  fields.add('source');
end;

function TFhirSubstanceDefinitionRelationship.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstanceDefinition.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FIsDefining.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountRatioHighLimit.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionRelationshipListEnumerator }

constructor TFhirSubstanceDefinitionRelationshipListEnumerator.Create(list : TFhirSubstanceDefinitionRelationshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionRelationshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.GetCurrent : TFhirSubstanceDefinitionRelationship;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionRelationshipList }

procedure TFhirSubstanceDefinitionRelationshipList.AddItem(value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionRelationship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionRelationship');
  add(value);
end;

function TFhirSubstanceDefinitionRelationshipList.Append: TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionRelationshipList.GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
begin
  result := TFhirSubstanceDefinitionRelationshipListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionRelationshipList.Clone: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionRelationshipList.GetItemN(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionRelationship;
end;
function TFhirSubstanceDefinitionRelationshipList.IndexOf(value: TFhirSubstanceDefinitionRelationship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionRelationshipList.Insert(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionRelationshipList.Item(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.Link: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Link);
end;

procedure TFhirSubstanceDefinitionRelationshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  FhirSubstanceDefinitionRelationships[index] := value;
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinition }

constructor TFhirSubstanceDefinition.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinition.Destroy;
begin
  FIdentifier.free;
  FVersion.free;
  FStatus.free;
  FCategory.free;
  FClassificationList.Free;
  FDomain.free;
  FDescription.free;
  FSourceList.Free;
  FNoteList.Free;
  FManufacturerList.Free;
  FSupplierList.Free;
  FMoietyList.Free;
  FProperty_List.Free;
  FReferenceInformation.free;
  FStructure.free;
  FCodeList.Free;
  FNameList.Free;
  FMolecularWeightList.Free;
  FRelationshipList.Free;
  FNucleicAcid.free;
  FPolymer.free;
  FProtein.free;
  FSourceMaterial.free;
  inherited;
end;

procedure TFhirSubstanceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceDefinition(oSource).identifier.Clone;
  versionElement := TFhirSubstanceDefinition(oSource).versionElement.Clone;
  status := TFhirSubstanceDefinition(oSource).status.Clone;
  category := TFhirSubstanceDefinition(oSource).category.Clone;
  if (TFhirSubstanceDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirSubstanceDefinition(oSource).FClassificationList);
  end;
  domain := TFhirSubstanceDefinition(oSource).domain.Clone;
  descriptionElement := TFhirSubstanceDefinition(oSource).descriptionElement.Clone;
  if (TFhirSubstanceDefinition(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinition(oSource).FSourceList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinition(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirSubstanceDefinition(oSource).FManufacturerList);
  end;
  if (TFhirSubstanceDefinition(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList.Create;
    FSupplierList.Assign(TFhirSubstanceDefinition(oSource).FSupplierList);
  end;
  if (TFhirSubstanceDefinition(oSource).FMoietyList = nil) then
  begin
    FMoietyList.free;
    FMoietyList := nil;
  end
  else
  begin
    if FMoietyList = nil then
      FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
    FMoietyList.Assign(TFhirSubstanceDefinition(oSource).FMoietyList);
  end;
  if (TFhirSubstanceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirSubstanceDefinition(oSource).FProperty_List);
  end;
  referenceInformation := TFhirSubstanceDefinition(oSource).referenceInformation.Clone;
  structure := TFhirSubstanceDefinition(oSource).structure.Clone;
  if (TFhirSubstanceDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirSubstanceDefinitionCodeList.Create;
    FCodeList.Assign(TFhirSubstanceDefinition(oSource).FCodeList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirSubstanceDefinitionNameList.Create;
    FNameList.Assign(TFhirSubstanceDefinition(oSource).FNameList);
  end;
  if (TFhirSubstanceDefinition(oSource).FMolecularWeightList = nil) then
  begin
    FMolecularWeightList.free;
    FMolecularWeightList := nil;
  end
  else
  begin
    if FMolecularWeightList = nil then
      FMolecularWeightList := TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Create;
    FMolecularWeightList.Assign(TFhirSubstanceDefinition(oSource).FMolecularWeightList);
  end;
  if (TFhirSubstanceDefinition(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
    FRelationshipList.Assign(TFhirSubstanceDefinition(oSource).FRelationshipList);
  end;
  nucleicAcid := TFhirSubstanceDefinition(oSource).nucleicAcid.Clone;
  polymer := TFhirSubstanceDefinition(oSource).polymer.Clone;
  protein := TFhirSubstanceDefinition(oSource).protein.Clone;
  sourceMaterial := TFhirSubstanceDefinition(oSource).sourceMaterial.Clone;
end;

function TFhirSubstanceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceDefinition;
end;

procedure TFhirSubstanceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'moiety') Then
    list.addAll(self, 'moiety', FMoietyList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'referenceInformation') Then
     list.add(self.link, 'referenceInformation', FReferenceInformation.Link);
  if (child_name = 'structure') Then
     list.add(self.link, 'structure', FStructure.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'molecularWeight') Then
    list.addAll(self, 'molecularWeight', FMolecularWeightList);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'nucleicAcid') Then
     list.add(self.link, 'nucleicAcid', FNucleicAcid.Link);
  if (child_name = 'polymer') Then
     list.add(self.link, 'polymer', FPolymer.Link);
  if (child_name = 'protein') Then
     list.add(self.link, 'protein', FProtein.Link);
  if (child_name = 'sourceMaterial') Then
     list.add(self.link, 'sourceMaterial', FSourceMaterial.Link);
end;

procedure TFhirSubstanceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', true, TFhirReference, FSupplierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'moiety', 'BackboneElement', true, TFhirSubstanceDefinitionMoiety, FMoietyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirSubstanceDefinitionProperty, FProperty_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'referenceInformation', 'Reference', false, TFhirReference, FReferenceInformation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'structure', 'BackboneElement', false, TFhirSubstanceDefinitionStructure, FStructure.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'BackboneElement', true, TFhirSubstanceDefinitionCode, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirSubstanceDefinitionName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '', true, TFhirSubstanceDefinitionStructureIsotopeMolecularWeight, FMolecularWeightList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'relationship', 'BackboneElement', true, TFhirSubstanceDefinitionRelationship, FRelationshipList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'nucleicAcid', 'Reference', false, TFhirReference, FNucleicAcid.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'polymer', 'Reference', false, TFhirReference, FPolymer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'protein', 'Reference', false, TFhirReference, FProtein.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sourceMaterial', 'Reference', false, TFhirReference, FSourceMaterial.Link)); {L1172}
end;

function TFhirSubstanceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'moiety') then
  begin
    MoietyList.add(propValue as TFhirSubstanceDefinitionMoiety) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirSubstanceDefinitionProperty) {L1048};
    result := propValue;
  end
  else if (propName = 'referenceInformation') then
  begin
    ReferenceInformation := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    Structure := propValue as TFhirSubstanceDefinitionStructure {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirSubstanceDefinitionCode) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirSubstanceDefinitionName) {L1048};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeightList.add(propValue as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight) {L1048};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirSubstanceDefinitionRelationship) {L1048};
    result := propValue;
  end
  else if (propName = 'nucleicAcid') then
  begin
    NucleicAcid := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'polymer') then
  begin
    Polymer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'protein') then
  begin
    Protein := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'sourceMaterial') then
  begin
    SourceMaterial := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'moiety') then MoietyList.insertItem(index, propValue as TFhirSubstanceDefinitionMoiety) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirSubstanceDefinitionProperty) {L1049}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirSubstanceDefinitionCode) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirSubstanceDefinitionName) {L1049}
  else if (propName = 'molecularWeight') then MolecularWeightList.insertItem(index, propValue as TFhirSubstanceDefinitionStructureIsotopeMolecularWeight) {L1049}
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirSubstanceDefinitionRelationship) {L1049}
  else inherited;
end;

function TFhirSubstanceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'version') then result := TFhirString.create() {L1223}
  else if (propName = 'status') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'classification') then result := ClassificationList.new() {L1053}
  else if (propName = 'domain') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'manufacturer') then result := ManufacturerList.new() {L1053}
  else if (propName = 'supplier') then result := SupplierList.new() {L1053}
  else if (propName = 'moiety') then result := MoietyList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else if (propName = 'referenceInformation') then result := TFhirReference.create() {L1203}
  else if (propName = 'structure') then result := TFhirSubstanceDefinitionStructure.create() {L1203}
  else if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'molecularWeight') then result := MolecularWeightList.new() {L1053}
  else if (propName = 'relationship') then result := RelationshipList.new() {L1053}
  else if (propName = 'nucleicAcid') then result := TFhirReference.create() {L1203}
  else if (propName = 'polymer') then result := TFhirReference.create() {L1203}
  else if (propName = 'protein') then result := TFhirReference.create() {L1203}
  else if (propName = 'sourceMaterial') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'moiety') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'referenceInformation') then result := 'Reference'
  else if (propName = 'structure') then result := 'BackboneElement'
  else if (propName = 'code') then result := 'BackboneElement'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'molecularWeight') then result := ''
  else if (propName = 'relationship') then result := 'BackboneElement'
  else if (propName = 'nucleicAcid') then result := 'Reference'
  else if (propName = 'polymer') then result := 'Reference'
  else if (propName = 'protein') then result := 'Reference'
  else if (propName = 'sourceMaterial') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {L1054}
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {L1054}
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value) {L1054}
  else if (propName = 'moiety') then deletePropertyValue('moiety', MoietyList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else if (propName = 'referenceInformation') then ReferenceInformationElement := nil
  else if (propName = 'structure') then StructureElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'molecularWeight') then deletePropertyValue('molecularWeight', MolecularWeightList, value) {L1054}
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {L1054}
  else if (propName = 'nucleicAcid') then NucleicAcidElement := nil
  else if (propName = 'polymer') then PolymerElement := nil
  else if (propName = 'protein') then ProteinElement := nil
  else if (propName = 'sourceMaterial') then SourceMaterialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'version') then VersionElement := asString(new) {L1222}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {L1055}
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new) {L1222}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {L1055}
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new) {L1055}
  else if (propName = 'moiety') then replacePropertyValue('moiety', MoietyList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else if (propName = 'referenceInformation') then ReferenceInformationElement := new as TFhirReference {L1195}
  else if (propName = 'structure') then StructureElement := new as TFhirSubstanceDefinitionStructure {L1195}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'molecularWeight') then replacePropertyValue('molecularWeight', MolecularWeightList, existing, new) {L1055}
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {L1055}
  else if (propName = 'nucleicAcid') then NucleicAcidElement := new as TFhirReference {L1195}
  else if (propName = 'polymer') then PolymerElement := new as TFhirReference {L1195}
  else if (propName = 'protein') then ProteinElement := new as TFhirReference {L1195}
  else if (propName = 'sourceMaterial') then SourceMaterialElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classification') then ClassificationList.move(source, destination) {L1050}
  else if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination) {L1050}
  else if (propName = 'supplier') then SupplierList.move(source, destination) {L1050}
  else if (propName = 'moiety') then MoietyList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'molecularWeight') then MolecularWeightList.move(source, destination) {L1050}
  else if (propName = 'relationship') then RelationshipList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinition.fhirType : string;
begin
  result := 'SubstanceDefinition';
end;

function TFhirSubstanceDefinition.Link : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Link);
end;

function TFhirSubstanceDefinition.Clone : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Clone);
end;

function TFhirSubstanceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinition)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(domainElement, o.domainElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(sourceList, o.sourceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(supplierList, o.supplierList, true) and compareDeep(moietyList, o.moietyList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(referenceInformationElement, o.referenceInformationElement, true) and 
      compareDeep(structureElement, o.structureElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(molecularWeightList, o.molecularWeightList, true) and 
      compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nucleicAcidElement, o.nucleicAcidElement, true) and 
      compareDeep(polymerElement, o.polymerElement, true) and compareDeep(proteinElement, o.proteinElement, true) and 
      compareDeep(sourceMaterialElement, o.sourceMaterialElement, true);
  end;
end;

function TFhirSubstanceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FclassificationList) and isEmptyProp(FDomain) and isEmptyProp(FDescription) and isEmptyProp(FsourceList) and isEmptyProp(FnoteList) and isEmptyProp(FmanufacturerList) and isEmptyProp(FsupplierList) and isEmptyProp(FmoietyList) and isEmptyProp(Fproperty_List) and isEmptyProp(FReferenceInformation) and isEmptyProp(FStructure) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FmolecularWeightList) and isEmptyProp(FrelationshipList) and isEmptyProp(FNucleicAcid) and isEmptyProp(FPolymer) and isEmptyProp(FProtein) and isEmptyProp(FSourceMaterial);
end;

procedure TFhirSubstanceDefinition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value; {L1134}
end;

function TFhirSubstanceDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSubstanceDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSubstanceDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

function TFhirSubstanceDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirSubstanceDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirSubstanceDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstanceDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubstanceDefinition.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinition.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirSubstanceDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirSubstanceDefinition.GetSupplierList : TFhirReferenceList;
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList.Create;
  result := FSupplierList;
end;

function TFhirSubstanceDefinition.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

function TFhirSubstanceDefinition.GetMoietyList : TFhirSubstanceDefinitionMoietyList;
begin
  if FMoietyList = nil then
    FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
  result := FMoietyList;
end;

function TFhirSubstanceDefinition.GetHasMoietyList : boolean;
begin
  result := (FMoietyList <> nil) and (FMoietyList.count > 0);
end;

function TFhirSubstanceDefinition.GetProperty_List : TFhirSubstanceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirSubstanceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirSubstanceDefinition.SetReferenceInformation(value : TFhirReference);
begin
  FReferenceInformation.free;
  FReferenceInformation := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetStructure(value : TFhirSubstanceDefinitionStructure);
begin
  FStructure.free;
  FStructure := value; {L1134}
end;

function TFhirSubstanceDefinition.GetCodeList : TFhirSubstanceDefinitionCodeList;
begin
  if FCodeList = nil then
    FCodeList := TFhirSubstanceDefinitionCodeList.Create;
  result := FCodeList;
end;

function TFhirSubstanceDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirSubstanceDefinition.GetNameList : TFhirSubstanceDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirSubstanceDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirSubstanceDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirSubstanceDefinition.GetMolecularWeightList : TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList;
begin
  if FMolecularWeightList = nil then
    FMolecularWeightList := TFhirSubstanceDefinitionStructureIsotopeMolecularWeightList.Create;
  result := FMolecularWeightList;
end;

function TFhirSubstanceDefinition.GetHasMolecularWeightList : boolean;
begin
  result := (FMolecularWeightList <> nil) and (FMolecularWeightList.count > 0);
end;

function TFhirSubstanceDefinition.GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
  result := FRelationshipList;
end;

function TFhirSubstanceDefinition.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetNucleicAcid(value : TFhirReference);
begin
  FNucleicAcid.free;
  FNucleicAcid := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetPolymer(value : TFhirReference);
begin
  FPolymer.free;
  FPolymer := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetProtein(value : TFhirReference);
begin
  FProtein.free;
  FProtein := value; {L1134}
end;

procedure TFhirSubstanceDefinition.SetSourceMaterial(value : TFhirReference);
begin
  FSourceMaterial.free;
  FSourceMaterial := value; {L1134}
end;

procedure TFhirSubstanceDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('version');
  fields.add('status');
  fields.add('category');
  fields.add('classification');
  fields.add('domain');
  fields.add('description');
  fields.add('source');
  fields.add('note');
  fields.add('manufacturer');
  fields.add('supplier');
  fields.add('moiety');
  fields.add('property');
  fields.add('referenceInformation');
  fields.add('structure');
  fields.add('code');
  fields.add('name');
  fields.add('molecularWeight');
  fields.add('relationship');
  fields.add('nucleicAcid');
  fields.add('polymer');
  fields.add('protein');
  fields.add('sourceMaterial');
end;

function TFhirSubstanceDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FclassificationList.sizeInBytes);
  inc(result, FDomain.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FsupplierList.sizeInBytes);
  inc(result, FmoietyList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FReferenceInformation.sizeInBytes);
  inc(result, FStructure.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FmolecularWeightList.sizeInBytes);
  inc(result, FrelationshipList.sizeInBytes);
  inc(result, FNucleicAcid.sizeInBytes);
  inc(result, FPolymer.sizeInBytes);
  inc(result, FProtein.sizeInBytes);
  inc(result, FSourceMaterial.sizeInBytes);
end;

{ TFhirSubstanceDefinitionListEnumerator }

constructor TFhirSubstanceDefinitionListEnumerator.Create(list : TFhirSubstanceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionListEnumerator.GetCurrent : TFhirSubstanceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceDefinitionList }

procedure TFhirSubstanceDefinitionList.AddItem(value: TFhirSubstanceDefinition);
begin
  assert(value.ClassName = 'TFhirSubstanceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinition');
  add(value);
end;

function TFhirSubstanceDefinitionList.Append: TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionList.GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
begin
  result := TFhirSubstanceDefinitionListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionList.Clone: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Clone);
end;

function TFhirSubstanceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionList.GetItemN(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinition;
end;
function TFhirSubstanceDefinitionList.IndexOf(value: TFhirSubstanceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionList.Insert(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.InsertItem(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionList.Item(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.Link: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Link);
end;

procedure TFhirSubstanceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  FhirSubstanceDefinitions[index] := value;
end;

procedure TFhirSubstanceDefinitionList.SetItemN(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEDEFINITION}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
{ TFhirSubstanceNucleicAcidSubunit }

constructor TFhirSubstanceNucleicAcidSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FFivePrime.free;
  FThreePrime.free;
  FLinkageList.Free;
  FSugarList.Free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceNucleicAcidSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceNucleicAcidSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceAttachment.Clone;
  fivePrime := TFhirSubstanceNucleicAcidSubunit(oSource).fivePrime.Clone;
  threePrime := TFhirSubstanceNucleicAcidSubunit(oSource).threePrime.Clone;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList = nil) then
  begin
    FLinkageList.free;
    FLinkageList := nil;
  end
  else
  begin
    if FLinkageList = nil then
      FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
    FLinkageList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList);
  end;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList = nil) then
  begin
    FSugarList.free;
    FSugarList := nil;
  end
  else
  begin
    if FSugarList = nil then
      FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
    FSugarList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList);
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'fivePrime') Then
     list.add(self.link, 'fivePrime', FFivePrime.Link);
  if (child_name = 'threePrime') Then
     list.add(self.link, 'threePrime', FThreePrime.Link);
  if (child_name = 'linkage') Then
    list.addAll(self, 'linkage', FLinkageList);
  if (child_name = 'sugar') Then
    list.addAll(self, 'sugar', FSugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fivePrime', 'CodeableConcept', false, TFhirCodeableConcept, FFivePrime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'threePrime', 'CodeableConcept', false, TFhirCodeableConcept, FThreePrime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'linkage', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunitLinkage, FLinkageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'sugar', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunitSugar, FSugarList.Link)) {L1039};
end;

function TFhirSubstanceNucleicAcidSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'fivePrime') then
  begin
    FivePrime := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'threePrime') then
  begin
    ThreePrime := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'linkage') then
  begin
    LinkageList.add(propValue as TFhirSubstanceNucleicAcidSubunitLinkage) {L1048};
    result := propValue;
  end
  else if (propName = 'sugar') then
  begin
    SugarList.add(propValue as TFhirSubstanceNucleicAcidSubunitSugar) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkage') then LinkageList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitLinkage) {L1049}
  else if (propName = 'sugar') then SugarList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitSugar) {L1049}
  else inherited;
end;

function TFhirSubstanceNucleicAcidSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create() {L1223}
  else if (propName = 'sequence') then result := TFhirString.create() {L1223}
  else if (propName = 'length') then result := TFhirInteger.create() {L1223}
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'fivePrime') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'threePrime') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'linkage') then result := LinkageList.new() {L1053}
  else if (propName = 'sugar') then result := SugarList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'fivePrime') then result := 'CodeableConcept'
  else if (propName = 'threePrime') then result := 'CodeableConcept'
  else if (propName = 'linkage') then result := 'BackboneElement'
  else if (propName = 'sugar') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'fivePrime') then FivePrimeElement := nil
  else if (propName = 'threePrime') then ThreePrimeElement := nil
  else if (propName = 'linkage') then deletePropertyValue('linkage', LinkageList, value) {L1054}
  else if (propName = 'sugar') then deletePropertyValue('sugar', SugarList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new) {L1222}
  else if (propName = 'sequence') then SequenceElement := asString(new) {L1222}
  else if (propName = 'length') then LengthElement := asInteger(new) {L1222}
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment {L1195}
  else if (propName = 'fivePrime') then FivePrimeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'threePrime') then ThreePrimeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'linkage') then replacePropertyValue('linkage', LinkageList, existing, new) {L1055}
  else if (propName = 'sugar') then replacePropertyValue('sugar', SugarList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkage') then LinkageList.move(source, destination) {L1050}
  else if (propName = 'sugar') then SugarList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunit.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit';
end;

function TFhirSubstanceNucleicAcidSubunit.Link : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunit.Clone : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(fivePrimeElement, o.fivePrimeElement, true) and compareDeep(threePrimeElement, o.threePrimeElement, true) and 
      compareDeep(linkageList, o.linkageList, true) and compareDeep(sugarList, o.sugarList, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FFivePrime) and isEmptyProp(FThreePrime) and isEmptyProp(FlinkageList) and isEmptyProp(FsugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value; {L1134}
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetFivePrime(value : TFhirCodeableConcept);
begin
  FFivePrime.free;
  FFivePrime := value; {L1134}
end;

procedure TFhirSubstanceNucleicAcidSubunit.SetThreePrime(value : TFhirCodeableConcept);
begin
  FThreePrime.free;
  FThreePrime := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunit.GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  if FLinkageList = nil then
    FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
  result := FLinkageList;
end;

function TFhirSubstanceNucleicAcidSubunit.GetHasLinkageList : boolean;
begin
  result := (FLinkageList <> nil) and (FLinkageList.count > 0);
end;

function TFhirSubstanceNucleicAcidSubunit.GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  if FSugarList = nil then
    FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
  result := FSugarList;
end;

function TFhirSubstanceNucleicAcidSubunit.GetHasSugarList : boolean;
begin
  result := (FSugarList <> nil) and (FSugarList.count > 0);
end;

procedure TFhirSubstanceNucleicAcidSubunit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('fivePrime');
  fields.add('threePrime');
  fields.add('linkage');
  fields.add('sugar');
end;

function TFhirSubstanceNucleicAcidSubunit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubunit.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FSequenceAttachment.sizeInBytes);
  inc(result, FFivePrime.sizeInBytes);
  inc(result, FThreePrime.sizeInBytes);
  inc(result, FlinkageList.sizeInBytes);
  inc(result, FsugarList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitList }

procedure TFhirSubstanceNucleicAcidSubunitList.AddItem(value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunit');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Append: TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitList.Clone: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunit;
end;
function TFhirSubstanceNucleicAcidSubunitList.IndexOf(value: TFhirSubstanceNucleicAcidSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.Link: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  FhirSubstanceNucleicAcidSubunits[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitLinkage }

constructor TFhirSubstanceNucleicAcidSubunitLinkage.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkage.Destroy;
begin
  FConnectivity.free;
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  connectivityElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).connectivityElement.Clone;
  identifier := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'connectivity') Then
     list.add(self.link, 'connectivity', FConnectivity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'connectivity', 'string', false, TFhirString, FConnectivity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link)); {L1172}
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'connectivity') then
  begin
    ConnectivityElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'connectivity') then result := TFhirString.create() {L1223}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'residueSite') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'connectivity') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := asString(new) {L1222}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit.linkage';
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Link : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Clone : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitLinkage)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitLinkage(other);
    result := compareDeep(connectivityElement, o.connectivityElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FConnectivity) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivity(value : TFhirString);
begin
  FConnectivity.free;
  FConnectivity := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetConnectivityST : String;
begin
  if FConnectivity = nil then
    result := ''
  else
    result := FConnectivity.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivityST(value : String);
begin
  if value <> '' then
  begin
    if FConnectivity = nil then
      FConnectivity := TFhirString.create;
    FConnectivity.value := value
  end
  else if FConnectivity <> nil then
    FConnectivity.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('connectivity');
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FConnectivity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FResidueSite.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageList }

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.AddItem(value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitLinkage');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Append: TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Clone: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage;
end;
function TFhirSubstanceNucleicAcidSubunitLinkageList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Link: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  FhirSubstanceNucleicAcidSubunitLinkages[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitSugar }

constructor TFhirSubstanceNucleicAcidSubunitSugar.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugar.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceNucleicAcidSubunitSugar(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link)); {L1172}
end;

function TFhirSubstanceNucleicAcidSubunitSugar.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'residueSite') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.fhirType : string;
begin
  result := 'SubstanceNucleicAcid.subunit.sugar';
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Link : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Clone : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitSugar)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitSugar(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunitSugar.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value; {L1134}
end;

function TFhirSubstanceNucleicAcidSubunitSugar.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

function TFhirSubstanceNucleicAcidSubunitSugar.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FResidueSite.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitSugarListEnumerator }

constructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitSugarList }

procedure TFhirSubstanceNucleicAcidSubunitSugarList.AddItem(value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitSugar', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitSugar');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Append: TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Clone: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar;
end;
function TFhirSubstanceNucleicAcidSubunitSugarList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitSugar): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Link: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  FhirSubstanceNucleicAcidSubunitSugars[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcid }

constructor TFhirSubstanceNucleicAcid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcid.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FAreaOfHybridisation.free;
  FOligoNucleotideType.free;
  FSubunitList.Free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcid.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceNucleicAcid(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceNucleicAcid(oSource).numberOfSubunitsElement.Clone;
  areaOfHybridisationElement := TFhirSubstanceNucleicAcid(oSource).areaOfHybridisationElement.Clone;
  oligoNucleotideType := TFhirSubstanceNucleicAcid(oSource).oligoNucleotideType.Clone;
  if (TFhirSubstanceNucleicAcid(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceNucleicAcid(oSource).FSubunitList);
  end;
end;

function TFhirSubstanceNucleicAcid.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceNucleicAcid;
end;

procedure TFhirSubstanceNucleicAcid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'areaOfHybridisation') Then
     list.add(self.link, 'areaOfHybridisation', FAreaOfHybridisation.Link);
  if (child_name = 'oligoNucleotideType') Then
     list.add(self.link, 'oligoNucleotideType', FOligoNucleotideType.Link);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceNucleicAcid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'areaOfHybridisation', 'string', false, TFhirString, FAreaOfHybridisation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'oligoNucleotideType', 'CodeableConcept', false, TFhirCodeableConcept, FOligoNucleotideType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subunit', 'BackboneElement', true, TFhirSubstanceNucleicAcidSubunit, FSubunitList.Link)) {L1039};
end;

function TFhirSubstanceNucleicAcid.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'areaOfHybridisation') then
  begin
    AreaOfHybridisationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'oligoNucleotideType') then
  begin
    OligoNucleotideType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceNucleicAcidSubunit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunit) {L1049}
  else inherited;
end;

function TFhirSubstanceNucleicAcid.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create() {L1223}
  else if (propName = 'areaOfHybridisation') then result := TFhirString.create() {L1223}
  else if (propName = 'oligoNucleotideType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subunit') then result := SubunitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'areaOfHybridisation') then result := 'string'
  else if (propName = 'oligoNucleotideType') then result := 'CodeableConcept'
  else if (propName = 'subunit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcid.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := nil
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := nil
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new) {L1222}
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := asString(new) {L1222}
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcid.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subunit') then SubunitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcid.fhirType : string;
begin
  result := 'SubstanceNucleicAcid';
end;

function TFhirSubstanceNucleicAcid.Link : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Link);
end;

function TFhirSubstanceNucleicAcid.Clone : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Clone);
end;

function TFhirSubstanceNucleicAcid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcid)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcid(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(areaOfHybridisationElement, o.areaOfHybridisationElement, true) and 
      compareDeep(oligoNucleotideTypeElement, o.oligoNucleotideTypeElement, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceNucleicAcid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FAreaOfHybridisation) and isEmptyProp(FOligoNucleotideType) and isEmptyProp(FsubunitList);
end;

procedure TFhirSubstanceNucleicAcid.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value; {L1134}
end;

procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value; {L1134}
end;

function TFhirSubstanceNucleicAcid.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisation(value : TFhirString);
begin
  FAreaOfHybridisation.free;
  FAreaOfHybridisation := value; {L1134}
end;

function TFhirSubstanceNucleicAcid.GetAreaOfHybridisationST : String;
begin
  if FAreaOfHybridisation = nil then
    result := ''
  else
    result := FAreaOfHybridisation.value;
end;

procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisationST(value : String);
begin
  if value <> '' then
  begin
    if FAreaOfHybridisation = nil then
      FAreaOfHybridisation := TFhirString.create;
    FAreaOfHybridisation.value := value
  end
  else if FAreaOfHybridisation <> nil then
    FAreaOfHybridisation.value := '';
end;

procedure TFhirSubstanceNucleicAcid.SetOligoNucleotideType(value : TFhirCodeableConcept);
begin
  FOligoNucleotideType.free;
  FOligoNucleotideType := value; {L1134}
end;

function TFhirSubstanceNucleicAcid.GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
  result := FSubunitList;
end;

function TFhirSubstanceNucleicAcid.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

procedure TFhirSubstanceNucleicAcid.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('areaOfHybridisation');
  fields.add('oligoNucleotideType');
  fields.add('subunit');
end;

function TFhirSubstanceNucleicAcid.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceType.sizeInBytes);
  inc(result, FNumberOfSubunits.sizeInBytes);
  inc(result, FAreaOfHybridisation.sizeInBytes);
  inc(result, FOligoNucleotideType.sizeInBytes);
  inc(result, FsubunitList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidListEnumerator }

constructor TFhirSubstanceNucleicAcidListEnumerator.Create(list : TFhirSubstanceNucleicAcidList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidListEnumerator.GetCurrent : TFhirSubstanceNucleicAcid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidList }

procedure TFhirSubstanceNucleicAcidList.AddItem(value: TFhirSubstanceNucleicAcid);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcid');
  add(value);
end;

function TFhirSubstanceNucleicAcidList.Append: TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidList.GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidList.Clone: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidList.GetItemN(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcid;
end;
function TFhirSubstanceNucleicAcidList.IndexOf(value: TFhirSubstanceNucleicAcid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidList.Insert(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidList.Item(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.Link: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  FhirSubstanceNucleicAcids[index] := value;
end;

procedure TFhirSubstanceNucleicAcidList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
{ TFhirSubstancePolymerMonomerSet }

constructor TFhirSubstancePolymerMonomerSet.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSet.Destroy;
begin
  FRatioType.free;
  FStartingMaterialList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSet.Assign(oSource : TFslObject);
begin
  inherited;
  ratioType := TFhirSubstancePolymerMonomerSet(oSource).ratioType.Clone;
  if (TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList = nil) then
  begin
    FStartingMaterialList.free;
    FStartingMaterialList := nil;
  end
  else
  begin
    if FStartingMaterialList = nil then
      FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
    FStartingMaterialList.Assign(TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList);
  end;
end;

procedure TFhirSubstancePolymerMonomerSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ratioType') Then
     list.add(self.link, 'ratioType', FRatioType.Link);
  if (child_name = 'startingMaterial') Then
    list.addAll(self, 'startingMaterial', FStartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ratioType', 'CodeableConcept', false, TFhirCodeableConcept, FRatioType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'startingMaterial', 'BackboneElement', true, TFhirSubstancePolymerMonomerSetStartingMaterial, FStartingMaterialList.Link)) {L1039};
end;

function TFhirSubstancePolymerMonomerSet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ratioType') then
  begin
    RatioType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'startingMaterial') then
  begin
    StartingMaterialList.add(propValue as TFhirSubstancePolymerMonomerSetStartingMaterial) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSetStartingMaterial) {L1049}
  else inherited;
end;

function TFhirSubstancePolymerMonomerSet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ratioType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'startingMaterial') then result := StartingMaterialList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ratioType') then result := 'CodeableConcept'
  else if (propName = 'startingMaterial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := nil
  else if (propName = 'startingMaterial') then deletePropertyValue('startingMaterial', StartingMaterialList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'startingMaterial') then replacePropertyValue('startingMaterial', StartingMaterialList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSet.fhirType : string;
begin
  result := 'SubstancePolymer.monomerSet';
end;

function TFhirSubstancePolymerMonomerSet.Link : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Link);
end;

function TFhirSubstancePolymerMonomerSet.Clone : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSet.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSet)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSet(other);
    result := compareDeep(ratioTypeElement, o.ratioTypeElement, true) and compareDeep(startingMaterialList, o.startingMaterialList, true);
  end;
end;

function TFhirSubstancePolymerMonomerSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRatioType) and isEmptyProp(FstartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.SetRatioType(value : TFhirCodeableConcept);
begin
  FRatioType.free;
  FRatioType := value; {L1134}
end;

function TFhirSubstancePolymerMonomerSet.GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  if FStartingMaterialList = nil then
    FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
  result := FStartingMaterialList;
end;

function TFhirSubstancePolymerMonomerSet.GetHasStartingMaterialList : boolean;
begin
  result := (FStartingMaterialList <> nil) and (FStartingMaterialList.count > 0);
end;

procedure TFhirSubstancePolymerMonomerSet.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('ratioType');
  fields.add('startingMaterial');
end;

function TFhirSubstancePolymerMonomerSet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRatioType.sizeInBytes);
  inc(result, FstartingMaterialList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetListEnumerator }

constructor TFhirSubstancePolymerMonomerSetListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSet;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetList }

procedure TFhirSubstancePolymerMonomerSetList.AddItem(value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSet');
  add(value);
end;

function TFhirSubstancePolymerMonomerSetList.Append: TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetList.GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetList.Clone: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSet;
end;
function TFhirSubstancePolymerMonomerSetList.IndexOf(value: TFhirSubstancePolymerMonomerSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetList.Insert(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetList.Item(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.Link: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  FhirSubstancePolymerMonomerSets[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterial }

constructor TFhirSubstancePolymerMonomerSetStartingMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterial.Destroy;
begin
  FCode.free;
  FCategory.free;
  FIsDefining.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).code.Clone;
  category := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).category.Clone;
  isDefiningElement := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).isDefiningElement.Clone;
  amount := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).amount.Clone;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link)); {L1172}
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'isDefining') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'amount') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new) {L1222}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.fhirType : string;
begin
  result := 'SubstancePolymer.monomerSet.startingMaterial';
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Link : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Clone : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSetStartingMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSetStartingMaterial(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(isDefiningElement, o.isDefiningElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCategory) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value; {L1134}
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('category');
  fields.add('isDefining');
  fields.add('amount');
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FIsDefining.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator }

constructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialList }

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.AddItem(value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSetStartingMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSetStartingMaterial');
  add(value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Append: TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Clone: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial;
end;
function TFhirSubstancePolymerMonomerSetStartingMaterialList.IndexOf(value: TFhirSubstancePolymerMonomerSetStartingMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Insert(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Item(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Link: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  FhirSubstancePolymerMonomerSetStartingMaterials[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeat }

constructor TFhirSubstancePolymerRepeat.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeat.Destroy;
begin
  FAverageMolecularFormula.free;
  FRepeatUnitAmountType.free;
  FRepeatUnitList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeat.Assign(oSource : TFslObject);
begin
  inherited;
  averageMolecularFormulaElement := TFhirSubstancePolymerRepeat(oSource).averageMolecularFormulaElement.Clone;
  repeatUnitAmountType := TFhirSubstancePolymerRepeat(oSource).repeatUnitAmountType.Clone;
  if (TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList = nil) then
  begin
    FRepeatUnitList.free;
    FRepeatUnitList := nil;
  end
  else
  begin
    if FRepeatUnitList = nil then
      FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
    FRepeatUnitList.Assign(TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList);
  end;
end;

procedure TFhirSubstancePolymerRepeat.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'averageMolecularFormula') Then
     list.add(self.link, 'averageMolecularFormula', FAverageMolecularFormula.Link);
  if (child_name = 'repeatUnitAmountType') Then
     list.add(self.link, 'repeatUnitAmountType', FRepeatUnitAmountType.Link);
  if (child_name = 'repeatUnit') Then
    list.addAll(self, 'repeatUnit', FRepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'averageMolecularFormula', 'string', false, TFhirString, FAverageMolecularFormula.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'repeatUnitAmountType', 'CodeableConcept', false, TFhirCodeableConcept, FRepeatUnitAmountType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'repeatUnit', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnit, FRepeatUnitList.Link)) {L1039};
end;

function TFhirSubstancePolymerRepeat.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'averageMolecularFormula') then
  begin
    AverageMolecularFormulaElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'repeatUnitAmountType') then
  begin
    RepeatUnitAmountType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'repeatUnit') then
  begin
    RepeatUnitList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeat.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnit) {L1049}
  else inherited;
end;

function TFhirSubstancePolymerRepeat.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'averageMolecularFormula') then result := TFhirString.create() {L1223}
  else if (propName = 'repeatUnitAmountType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'repeatUnit') then result := RepeatUnitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeat.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'averageMolecularFormula') then result := 'string'
  else if (propName = 'repeatUnitAmountType') then result := 'CodeableConcept'
  else if (propName = 'repeatUnit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeat.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := nil
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := nil
  else if (propName = 'repeatUnit') then deletePropertyValue('repeatUnit', RepeatUnitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeat.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := asString(new) {L1222}
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'repeatUnit') then replacePropertyValue('repeatUnit', RepeatUnitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeat.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeat.fhirType : string;
begin
  result := 'SubstancePolymer.repeat';
end;

function TFhirSubstancePolymerRepeat.Link : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Link);
end;

function TFhirSubstancePolymerRepeat.Clone : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Clone);
end;

function TFhirSubstancePolymerRepeat.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeat;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeat)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeat(other);
    result := compareDeep(averageMolecularFormulaElement, o.averageMolecularFormulaElement, true) and 
      compareDeep(repeatUnitAmountTypeElement, o.repeatUnitAmountTypeElement, true) and 
      compareDeep(repeatUnitList, o.repeatUnitList, true);
  end;
end;

function TFhirSubstancePolymerRepeat.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAverageMolecularFormula) and isEmptyProp(FRepeatUnitAmountType) and isEmptyProp(FrepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormula(value : TFhirString);
begin
  FAverageMolecularFormula.free;
  FAverageMolecularFormula := value; {L1134}
end;

function TFhirSubstancePolymerRepeat.GetAverageMolecularFormulaST : String;
begin
  if FAverageMolecularFormula = nil then
    result := ''
  else
    result := FAverageMolecularFormula.value;
end;

procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FAverageMolecularFormula = nil then
      FAverageMolecularFormula := TFhirString.create;
    FAverageMolecularFormula.value := value
  end
  else if FAverageMolecularFormula <> nil then
    FAverageMolecularFormula.value := '';
end;

procedure TFhirSubstancePolymerRepeat.SetRepeatUnitAmountType(value : TFhirCodeableConcept);
begin
  FRepeatUnitAmountType.free;
  FRepeatUnitAmountType := value; {L1134}
end;

function TFhirSubstancePolymerRepeat.GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  if FRepeatUnitList = nil then
    FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
  result := FRepeatUnitList;
end;

function TFhirSubstancePolymerRepeat.GetHasRepeatUnitList : boolean;
begin
  result := (FRepeatUnitList <> nil) and (FRepeatUnitList.count > 0);
end;

procedure TFhirSubstancePolymerRepeat.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('averageMolecularFormula');
  fields.add('repeatUnitAmountType');
  fields.add('repeatUnit');
end;

function TFhirSubstancePolymerRepeat.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAverageMolecularFormula.sizeInBytes);
  inc(result, FRepeatUnitAmountType.sizeInBytes);
  inc(result, FrepeatUnitList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatListEnumerator }

constructor TFhirSubstancePolymerRepeatListEnumerator.Create(list : TFhirSubstancePolymerRepeatList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatListEnumerator.GetCurrent : TFhirSubstancePolymerRepeat;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatList }

procedure TFhirSubstancePolymerRepeatList.AddItem(value: TFhirSubstancePolymerRepeat);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeat', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeat');
  add(value);
end;

function TFhirSubstancePolymerRepeatList.Append: TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatList.GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatList.Clone: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatList.GetItemN(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeat;
end;
function TFhirSubstancePolymerRepeatList.IndexOf(value: TFhirSubstancePolymerRepeat): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatList.Insert(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatList.Item(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.Link: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  FhirSubstancePolymerRepeats[index] := value;
end;

procedure TFhirSubstancePolymerRepeatList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnit }

constructor TFhirSubstancePolymerRepeatRepeatUnit.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnit.Destroy;
begin
  FUnit_.free;
  FOrientation.free;
  FAmount.free;
  FDegreeOfPolymerisationList.Free;
  FStructuralRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.Assign(oSource : TFslObject);
begin
  inherited;
  unit_Element := TFhirSubstancePolymerRepeatRepeatUnit(oSource).unit_Element.Clone;
  orientation := TFhirSubstancePolymerRepeatRepeatUnit(oSource).orientation.Clone;
  amountElement := TFhirSubstancePolymerRepeatRepeatUnit(oSource).amountElement.Clone;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList = nil) then
  begin
    FDegreeOfPolymerisationList.free;
    FDegreeOfPolymerisationList := nil;
  end
  else
  begin
    if FDegreeOfPolymerisationList = nil then
      FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
    FDegreeOfPolymerisationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList);
  end;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList = nil) then
  begin
    FStructuralRepresentationList.free;
    FStructuralRepresentationList := nil;
  end
  else
  begin
    if FStructuralRepresentationList = nil then
      FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
    FStructuralRepresentationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList);
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'orientation') Then
     list.add(self.link, 'orientation', FOrientation.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'degreeOfPolymerisation') Then
    list.addAll(self, 'degreeOfPolymerisation', FDegreeOfPolymerisationList);
  if (child_name = 'structuralRepresentation') Then
    list.addAll(self, 'structuralRepresentation', FStructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'unit', 'string', false, TFhirString, FUnit_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'orientation', 'CodeableConcept', false, TFhirCodeableConcept, FOrientation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'integer', false, TFhirInteger, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'degreeOfPolymerisation', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation, FDegreeOfPolymerisationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'structuralRepresentation', 'BackboneElement', true, TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation, FStructuralRepresentationList.Link)) {L1039};
end;

function TFhirSubstancePolymerRepeatRepeatUnit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'unit') then
  begin
    Unit_Element := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'orientation') then
  begin
    Orientation := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'degreeOfPolymerisation') then
  begin
    DegreeOfPolymerisationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) {L1048};
    result := propValue;
  end
  else if (propName = 'structuralRepresentation') then
  begin
    StructuralRepresentationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) {L1049}
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) {L1049}
  else inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'unit') then result := TFhirString.create() {L1223}
  else if (propName = 'orientation') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirInteger.create() {L1223}
  else if (propName = 'degreeOfPolymerisation') then result := DegreeOfPolymerisationList.new() {L1053}
  else if (propName = 'structuralRepresentation') then result := StructuralRepresentationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'unit') then result := 'string'
  else if (propName = 'orientation') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'integer'
  else if (propName = 'degreeOfPolymerisation') then result := 'BackboneElement'
  else if (propName = 'structuralRepresentation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'orientation') then OrientationElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'degreeOfPolymerisation') then deletePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, value) {L1054}
  else if (propName = 'structuralRepresentation') then deletePropertyValue('structuralRepresentation', StructuralRepresentationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'unit') then Unit_Element := asString(new) {L1222}
  else if (propName = 'orientation') then OrientationElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := asInteger(new) {L1222}
  else if (propName = 'degreeOfPolymerisation') then replacePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, existing, new) {L1055}
  else if (propName = 'structuralRepresentation') then replacePropertyValue('structuralRepresentation', StructuralRepresentationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.move(source, destination) {L1050}
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit';
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Link : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Clone : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnit)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnit(other);
    result := compareDeep(unit_Element, o.unit_Element, true) and compareDeep(orientationElement, o.orientationElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(degreeOfPolymerisationList, o.degreeOfPolymerisationList, true) and 
      compareDeep(structuralRepresentationList, o.structuralRepresentationList, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUnit_) and isEmptyProp(FOrientation) and isEmptyProp(FAmount) and isEmptyProp(FdegreeOfPolymerisationList) and isEmptyProp(FstructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetUnit_(value : TFhirString);
begin
  FUnit_.free;
  FUnit_ := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetUnit_ST : String;
begin
  if FUnit_ = nil then
    result := ''
  else
    result := FUnit_.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetUnit_ST(value : String);
begin
  if value <> '' then
  begin
    if FUnit_ = nil then
      FUnit_ := TFhirString.create;
    FUnit_.value := value
  end
  else if FUnit_ <> nil then
    FUnit_.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetOrientation(value : TFhirCodeableConcept);
begin
  FOrientation.free;
  FOrientation := value; {L1134}
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetAmount(value : TFhirInteger);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetAmountST : String;
begin
  if FAmount = nil then
    result := ''
  else
    result := FAmount.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.SetAmountST(value : String);
begin
  if value <> '' then
  begin
    if FAmount = nil then
      FAmount := TFhirInteger.create;
    FAmount.value := value
  end
  else if FAmount <> nil then
    FAmount.value := '';
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  if FDegreeOfPolymerisationList = nil then
    FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
  result := FDegreeOfPolymerisationList;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetHasDegreeOfPolymerisationList : boolean;
begin
  result := (FDegreeOfPolymerisationList <> nil) and (FDegreeOfPolymerisationList.count > 0);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  if FStructuralRepresentationList = nil then
    FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
  result := FStructuralRepresentationList;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.GetHasStructuralRepresentationList : boolean;
begin
  result := (FStructuralRepresentationList <> nil) and (FStructuralRepresentationList.count > 0);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('unit');
  fields.add('orientation');
  fields.add('amount');
  fields.add('degreeOfPolymerisation');
  fields.add('structuralRepresentation');
end;

function TFhirSubstancePolymerRepeatRepeatUnit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUnit_.sizeInBytes);
  inc(result, FOrientation.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FdegreeOfPolymerisationList.sizeInBytes);
  inc(result, FstructuralRepresentationList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitList }

procedure TFhirSubstancePolymerRepeatRepeatUnitList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnit');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Append: TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Clone: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit;
end;
function TFhirSubstancePolymerRepeatRepeatUnitList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Link: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  FhirSubstancePolymerRepeatRepeatUnits[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation }

constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Destroy;
begin
  FType_.free;
  FAverage.free;
  FLow.free;
  FHigh.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).type_.Clone;
  averageElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).averageElement.Clone;
  lowElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).lowElement.Clone;
  highElement := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).highElement.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'average') Then
     list.add(self.link, 'average', FAverage.Link);
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'average', 'integer', false, TFhirInteger, FAverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'low', 'integer', false, TFhirInteger, FLow.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'high', 'integer', false, TFhirInteger, FHigh.Link)); {L1172}
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'average') then
  begin
    AverageElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'low') then
  begin
    LowElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    HighElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'average') then result := TFhirInteger.create() {L1223}
  else if (propName = 'low') then result := TFhirInteger.create() {L1223}
  else if (propName = 'high') then result := TFhirInteger.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'average') then result := 'integer'
  else if (propName = 'low') then result := 'integer'
  else if (propName = 'high') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'average') then AverageElement := nil
  else if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'average') then AverageElement := asInteger(new) {L1222}
  else if (propName = 'low') then LowElement := asInteger(new) {L1222}
  else if (propName = 'high') then HighElement := asInteger(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(averageElement, o.averageElement, true) and 
      compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAverage) and isEmptyProp(FLow) and isEmptyProp(FHigh);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetAverage(value : TFhirInteger);
begin
  FAverage.free;
  FAverage := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetAverageST : String;
begin
  if FAverage = nil then
    result := ''
  else
    result := FAverage.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetAverageST(value : String);
begin
  if value <> '' then
  begin
    if FAverage = nil then
      FAverage := TFhirInteger.create;
    FAverage.value := value
  end
  else if FAverage <> nil then
    FAverage.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetLow(value : TFhirInteger);
begin
  FLow.free;
  FLow := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetLowST : String;
begin
  if FLow = nil then
    result := ''
  else
    result := FLow.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetLowST(value : String);
begin
  if value <> '' then
  begin
    if FLow = nil then
      FLow := TFhirInteger.create;
    FLow.value := value
  end
  else if FLow <> nil then
    FLow.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetHigh(value : TFhirInteger);
begin
  FHigh.free;
  FHigh := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetHighST : String;
begin
  if FHigh = nil then
    result := ''
  else
    result := FHigh.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetHighST(value : String);
begin
  if value <> '' then
  begin
    if FHigh = nil then
      FHigh := TFhirInteger.create;
    FHigh.value := value
  end
  else if FHigh <> nil then
    FHigh.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('average');
  fields.add('low');
  fields.add('high');
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAverage.sizeInBytes);
  inc(result, FLow.sizeInBytes);
  inc(result, FHigh.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList }

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Append: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Link: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation }

constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FFormat.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).representationElement.Clone;
  format := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).format.Clone;
  attachment := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).attachment.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'format', 'CodeableConcept', false, TFhirCodeableConcept, FFormat.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link)); {L1172}
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'representation') then result := TFhirString.create() {L1223}
  else if (propName = 'format') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'attachment') then result := TFhirAttachment.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'format') then result := 'CodeableConcept'
  else if (propName = 'attachment') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'attachment') then AttachmentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'representation') then RepresentationElement := asString(new) {L1222}
  else if (propName = 'format') then FormatElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.fhirType : string;
begin
  result := 'SubstancePolymer.repeat.repeatUnit.structuralRepresentation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(formatElement, o.formatElement, true) and compareDeep(attachmentElement, o.attachmentElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FFormat) and isEmptyProp(FAttachment);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value; {L1134}
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetFormat(value : TFhirCodeableConcept);
begin
  FFormat.free;
  FFormat := value; {L1134}
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value; {L1134}
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('format');
  fields.add('attachment');
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRepresentation.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
  inc(result, FAttachment.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator }

constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList }

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Append: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Link: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymer }

constructor TFhirSubstancePolymer.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymer.Destroy;
begin
  FIdentifier.free;
  FClass_.free;
  FGeometry.free;
  FCopolymerConnectivityList.Free;
  FModification.free;
  FMonomerSetList.Free;
  FRepeat_List.Free;
  inherited;
end;

procedure TFhirSubstancePolymer.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstancePolymer(oSource).identifier.Clone;
  class_ := TFhirSubstancePolymer(oSource).class_.Clone;
  geometry := TFhirSubstancePolymer(oSource).geometry.Clone;
  if (TFhirSubstancePolymer(oSource).FCopolymerConnectivityList = nil) then
  begin
    FCopolymerConnectivityList.free;
    FCopolymerConnectivityList := nil;
  end
  else
  begin
    if FCopolymerConnectivityList = nil then
      FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
    FCopolymerConnectivityList.Assign(TFhirSubstancePolymer(oSource).FCopolymerConnectivityList);
  end;
  modificationElement := TFhirSubstancePolymer(oSource).modificationElement.Clone;
  if (TFhirSubstancePolymer(oSource).FMonomerSetList = nil) then
  begin
    FMonomerSetList.free;
    FMonomerSetList := nil;
  end
  else
  begin
    if FMonomerSetList = nil then
      FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
    FMonomerSetList.Assign(TFhirSubstancePolymer(oSource).FMonomerSetList);
  end;
  if (TFhirSubstancePolymer(oSource).FRepeat_List = nil) then
  begin
    FRepeat_List.free;
    FRepeat_List := nil;
  end
  else
  begin
    if FRepeat_List = nil then
      FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
    FRepeat_List.Assign(TFhirSubstancePolymer(oSource).FRepeat_List);
  end;
end;

function TFhirSubstancePolymer.GetResourceType : TFhirResourceType;
begin
  result := frtSubstancePolymer;
end;

procedure TFhirSubstancePolymer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'geometry') Then
     list.add(self.link, 'geometry', FGeometry.Link);
  if (child_name = 'copolymerConnectivity') Then
    list.addAll(self, 'copolymerConnectivity', FCopolymerConnectivityList);
  if (child_name = 'modification') Then
     list.add(self.link, 'modification', FModification.Link);
  if (child_name = 'monomerSet') Then
    list.addAll(self, 'monomerSet', FMonomerSetList);
  if (child_name = 'repeat') Then
    list.addAll(self, 'repeat', FRepeat_List);
end;

procedure TFhirSubstancePolymer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'geometry', 'CodeableConcept', false, TFhirCodeableConcept, FGeometry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'copolymerConnectivity', 'CodeableConcept', true, TFhirCodeableConcept, FCopolymerConnectivityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'modification', 'string', false, TFhirString, FModification.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'monomerSet', 'BackboneElement', true, TFhirSubstancePolymerMonomerSet, FMonomerSetList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'repeat', 'BackboneElement', true, TFhirSubstancePolymerRepeat, FRepeat_List.Link)) {L1039};
end;

function TFhirSubstancePolymer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'geometry') then
  begin
    Geometry := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'copolymerConnectivity') then
  begin
    CopolymerConnectivityList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'modification') then
  begin
    ModificationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'monomerSet') then
  begin
    MonomerSetList.add(propValue as TFhirSubstancePolymerMonomerSet) {L1048};
    result := propValue;
  end
  else if (propName = 'repeat') then
  begin
    Repeat_List.add(propValue as TFhirSubstancePolymerRepeat) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'monomerSet') then MonomerSetList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSet) {L1049}
  else if (propName = 'repeat') then Repeat_List.insertItem(index, propValue as TFhirSubstancePolymerRepeat) {L1049}
  else inherited;
end;

function TFhirSubstancePolymer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'class') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'geometry') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'copolymerConnectivity') then result := CopolymerConnectivityList.new() {L1053}
  else if (propName = 'modification') then result := TFhirString.create() {L1223}
  else if (propName = 'monomerSet') then result := MonomerSetList.new() {L1053}
  else if (propName = 'repeat') then result := Repeat_List.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'geometry') then result := 'CodeableConcept'
  else if (propName = 'copolymerConnectivity') then result := 'CodeableConcept'
  else if (propName = 'modification') then result := 'string'
  else if (propName = 'monomerSet') then result := 'BackboneElement'
  else if (propName = 'repeat') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'geometry') then GeometryElement := nil
  else if (propName = 'copolymerConnectivity') then deletePropertyValue('copolymerConnectivity', CopolymerConnectivityList, value) {L1054}
  else if (propName = 'modification') then ModificationElement := nil
  else if (propName = 'monomerSet') then deletePropertyValue('monomerSet', MonomerSetList, value) {L1054}
  else if (propName = 'repeat') then deletePropertyValue('repeat', Repeat_List, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'geometry') then GeometryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'copolymerConnectivity') then replacePropertyValue('copolymerConnectivity', CopolymerConnectivityList, existing, new) {L1055}
  else if (propName = 'modification') then ModificationElement := asString(new) {L1222}
  else if (propName = 'monomerSet') then replacePropertyValue('monomerSet', MonomerSetList, existing, new) {L1055}
  else if (propName = 'repeat') then replacePropertyValue('repeat', Repeat_List, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.move(source, destination) {L1050}
  else if (propName = 'monomerSet') then MonomerSetList.move(source, destination) {L1050}
  else if (propName = 'repeat') then Repeat_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymer.fhirType : string;
begin
  result := 'SubstancePolymer';
end;

function TFhirSubstancePolymer.Link : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Link);
end;

function TFhirSubstancePolymer.Clone : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Clone);
end;

function TFhirSubstancePolymer.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymer)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymer(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(class_Element, o.class_Element, true) and 
      compareDeep(geometryElement, o.geometryElement, true) and compareDeep(copolymerConnectivityList, o.copolymerConnectivityList, true) and 
      compareDeep(modificationElement, o.modificationElement, true) and compareDeep(monomerSetList, o.monomerSetList, true) and 
      compareDeep(repeat_List, o.repeat_List, true);
  end;
end;

function TFhirSubstancePolymer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FClass_) and isEmptyProp(FGeometry) and isEmptyProp(FcopolymerConnectivityList) and isEmptyProp(FModification) and isEmptyProp(FmonomerSetList) and isEmptyProp(Frepeat_List);
end;

procedure TFhirSubstancePolymer.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirSubstancePolymer.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value; {L1134}
end;

procedure TFhirSubstancePolymer.SetGeometry(value : TFhirCodeableConcept);
begin
  FGeometry.free;
  FGeometry := value; {L1134}
end;

function TFhirSubstancePolymer.GetCopolymerConnectivityList : TFhirCodeableConceptList;
begin
  if FCopolymerConnectivityList = nil then
    FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
  result := FCopolymerConnectivityList;
end;

function TFhirSubstancePolymer.GetHasCopolymerConnectivityList : boolean;
begin
  result := (FCopolymerConnectivityList <> nil) and (FCopolymerConnectivityList.count > 0);
end;

procedure TFhirSubstancePolymer.SetModification(value : TFhirString);
begin
  FModification.free;
  FModification := value; {L1134}
end;

function TFhirSubstancePolymer.GetModificationST : String;
begin
  if FModification = nil then
    result := ''
  else
    result := FModification.value;
end;

procedure TFhirSubstancePolymer.SetModificationST(value : String);
begin
  if value <> '' then
  begin
    if FModification = nil then
      FModification := TFhirString.create;
    FModification.value := value
  end
  else if FModification <> nil then
    FModification.value := '';
end;

function TFhirSubstancePolymer.GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
begin
  if FMonomerSetList = nil then
    FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
  result := FMonomerSetList;
end;

function TFhirSubstancePolymer.GetHasMonomerSetList : boolean;
begin
  result := (FMonomerSetList <> nil) and (FMonomerSetList.count > 0);
end;

function TFhirSubstancePolymer.GetRepeat_List : TFhirSubstancePolymerRepeatList;
begin
  if FRepeat_List = nil then
    FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
  result := FRepeat_List;
end;

function TFhirSubstancePolymer.GetHasRepeat_List : boolean;
begin
  result := (FRepeat_List <> nil) and (FRepeat_List.count > 0);
end;

procedure TFhirSubstancePolymer.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('class');
  fields.add('geometry');
  fields.add('copolymerConnectivity');
  fields.add('modification');
  fields.add('monomerSet');
  fields.add('repeat');
end;

function TFhirSubstancePolymer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FGeometry.sizeInBytes);
  inc(result, FcopolymerConnectivityList.sizeInBytes);
  inc(result, FModification.sizeInBytes);
  inc(result, FmonomerSetList.sizeInBytes);
  inc(result, Frepeat_List.sizeInBytes);
end;

{ TFhirSubstancePolymerListEnumerator }

constructor TFhirSubstancePolymerListEnumerator.Create(list : TFhirSubstancePolymerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerListEnumerator.GetCurrent : TFhirSubstancePolymer;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerList }

procedure TFhirSubstancePolymerList.AddItem(value: TFhirSubstancePolymer);
begin
  assert(value.ClassName = 'TFhirSubstancePolymer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymer');
  add(value);
end;

function TFhirSubstancePolymerList.Append: TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerList.GetEnumerator : TFhirSubstancePolymerListEnumerator;
begin
  result := TFhirSubstancePolymerListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerList.Clone: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Clone);
end;

function TFhirSubstancePolymerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerList.GetItemN(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymer;
end;
function TFhirSubstancePolymerList.IndexOf(value: TFhirSubstancePolymer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerList.Insert(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.InsertItem(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerList.Item(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.Link: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Link);
end;

procedure TFhirSubstancePolymerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  FhirSubstancePolymers[index] := value;
end;

procedure TFhirSubstancePolymerList.SetItemN(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
{ TFhirSubstanceProteinSubunit }

constructor TFhirSubstanceProteinSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProteinSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FNTerminalModificationId.free;
  FNTerminalModification.free;
  FCTerminalModificationId.free;
  FCTerminalModification.free;
  inherited;
end;

procedure TFhirSubstanceProteinSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceProteinSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceProteinSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceProteinSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceProteinSubunit(oSource).sequenceAttachment.Clone;
  nTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationId.Clone;
  nTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationElement.Clone;
  cTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationId.Clone;
  cTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationElement.Clone;
end;

procedure TFhirSubstanceProteinSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'nTerminalModificationId') Then
     list.add(self.link, 'nTerminalModificationId', FNTerminalModificationId.Link);
  if (child_name = 'nTerminalModification') Then
     list.add(self.link, 'nTerminalModification', FNTerminalModification.Link);
  if (child_name = 'cTerminalModificationId') Then
     list.add(self.link, 'cTerminalModificationId', FCTerminalModificationId.Link);
  if (child_name = 'cTerminalModification') Then
     list.add(self.link, 'cTerminalModification', FCTerminalModification.Link);
end;

procedure TFhirSubstanceProteinSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'nTerminalModificationId', 'Identifier', false, TFhirIdentifier, FNTerminalModificationId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'nTerminalModification', 'string', false, TFhirString, FNTerminalModification.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cTerminalModificationId', 'Identifier', false, TFhirIdentifier, FCTerminalModificationId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cTerminalModification', 'string', false, TFhirString, FCTerminalModification.Link)); {L1172}
end;

function TFhirSubstanceProteinSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'nTerminalModificationId') then
  begin
    NTerminalModificationId := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'nTerminalModification') then
  begin
    NTerminalModificationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'cTerminalModificationId') then
  begin
    CTerminalModificationId := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'cTerminalModification') then
  begin
    CTerminalModificationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceProteinSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceProteinSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create() {L1223}
  else if (propName = 'sequence') then result := TFhirString.create() {L1223}
  else if (propName = 'length') then result := TFhirInteger.create() {L1223}
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'nTerminalModificationId') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'nTerminalModification') then result := TFhirString.create() {L1223}
  else if (propName = 'cTerminalModificationId') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'cTerminalModification') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProteinSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'nTerminalModificationId') then result := 'Identifier'
  else if (propName = 'nTerminalModification') then result := 'string'
  else if (propName = 'cTerminalModificationId') then result := 'Identifier'
  else if (propName = 'cTerminalModification') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProteinSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := nil
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := nil
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := nil
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProteinSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new) {L1222}
  else if (propName = 'sequence') then SequenceElement := asString(new) {L1222}
  else if (propName = 'length') then LengthElement := asInteger(new) {L1222}
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment {L1195}
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := new as TFhirIdentifier {L1195}
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := asString(new) {L1222}
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := new as TFhirIdentifier {L1195}
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProteinSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProteinSubunit.fhirType : string;
begin
  result := 'SubstanceProtein.subunit';
end;

function TFhirSubstanceProteinSubunit.Link : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Link);
end;

function TFhirSubstanceProteinSubunit.Clone : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Clone);
end;

function TFhirSubstanceProteinSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProteinSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProteinSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceProteinSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(nTerminalModificationIdElement, o.nTerminalModificationIdElement, true) and 
      compareDeep(nTerminalModificationElement, o.nTerminalModificationElement, true) and 
      compareDeep(cTerminalModificationIdElement, o.cTerminalModificationIdElement, true) and 
      compareDeep(cTerminalModificationElement, o.cTerminalModificationElement, true);
  end;
end;

function TFhirSubstanceProteinSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FNTerminalModificationId) and isEmptyProp(FNTerminalModification) and isEmptyProp(FCTerminalModificationId) and isEmptyProp(FCTerminalModification);
end;

procedure TFhirSubstanceProteinSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value; {L1134}
end;

function TFhirSubstanceProteinSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

procedure TFhirSubstanceProteinSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirSubstanceProteinSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirSubstanceProteinSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value; {L1134}
end;

function TFhirSubstanceProteinSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirSubstanceProteinSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value; {L1134}
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationId(value : TFhirIdentifier);
begin
  FNTerminalModificationId.free;
  FNTerminalModificationId := value; {L1134}
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModification(value : TFhirString);
begin
  FNTerminalModification.free;
  FNTerminalModification := value; {L1134}
end;

function TFhirSubstanceProteinSubunit.GetNTerminalModificationST : String;
begin
  if FNTerminalModification = nil then
    result := ''
  else
    result := FNTerminalModification.value;
end;

procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FNTerminalModification = nil then
      FNTerminalModification := TFhirString.create;
    FNTerminalModification.value := value
  end
  else if FNTerminalModification <> nil then
    FNTerminalModification.value := '';
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationId(value : TFhirIdentifier);
begin
  FCTerminalModificationId.free;
  FCTerminalModificationId := value; {L1134}
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModification(value : TFhirString);
begin
  FCTerminalModification.free;
  FCTerminalModification := value; {L1134}
end;

function TFhirSubstanceProteinSubunit.GetCTerminalModificationST : String;
begin
  if FCTerminalModification = nil then
    result := ''
  else
    result := FCTerminalModification.value;
end;

procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FCTerminalModification = nil then
      FCTerminalModification := TFhirString.create;
    FCTerminalModification.value := value
  end
  else if FCTerminalModification <> nil then
    FCTerminalModification.value := '';
end;

procedure TFhirSubstanceProteinSubunit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('nTerminalModificationId');
  fields.add('nTerminalModification');
  fields.add('cTerminalModificationId');
  fields.add('cTerminalModification');
end;

function TFhirSubstanceProteinSubunit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubunit.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FSequenceAttachment.sizeInBytes);
  inc(result, FNTerminalModificationId.sizeInBytes);
  inc(result, FNTerminalModification.sizeInBytes);
  inc(result, FCTerminalModificationId.sizeInBytes);
  inc(result, FCTerminalModification.sizeInBytes);
end;

{ TFhirSubstanceProteinSubunitListEnumerator }

constructor TFhirSubstanceProteinSubunitListEnumerator.Create(list : TFhirSubstanceProteinSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinSubunitListEnumerator.GetCurrent : TFhirSubstanceProteinSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinSubunitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceProteinSubunitList }

procedure TFhirSubstanceProteinSubunitList.AddItem(value: TFhirSubstanceProteinSubunit);
begin
  assert(value.ClassName = 'TFhirSubstanceProteinSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProteinSubunit');
  add(value);
end;

function TFhirSubstanceProteinSubunitList.Append: TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinSubunitList.GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
begin
  result := TFhirSubstanceProteinSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinSubunitList.Clone: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Clone);
end;

function TFhirSubstanceProteinSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinSubunitList.GetItemN(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProteinSubunit;
end;
function TFhirSubstanceProteinSubunitList.IndexOf(value: TFhirSubstanceProteinSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinSubunitList.Insert(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.InsertItem(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinSubunitList.Item(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.Link: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Link);
end;

procedure TFhirSubstanceProteinSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  FhirSubstanceProteinSubunits[index] := value;
end;

procedure TFhirSubstanceProteinSubunitList.SetItemN(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceProtein }

constructor TFhirSubstanceProtein.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProtein.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FDisulfideLinkageList.Free;
  FSubunitList.Free;
  inherited;
end;

procedure TFhirSubstanceProtein.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceProtein(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceProtein(oSource).numberOfSubunitsElement.Clone;
  if (TFhirSubstanceProtein(oSource).FDisulfideLinkageList = nil) then
  begin
    FDisulfideLinkageList.free;
    FDisulfideLinkageList := nil;
  end
  else
  begin
    if FDisulfideLinkageList = nil then
      FDisulfideLinkageList := TFhirStringList.Create;
    FDisulfideLinkageList.Assign(TFhirSubstanceProtein(oSource).FDisulfideLinkageList);
  end;
  if (TFhirSubstanceProtein(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceProteinSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceProtein(oSource).FSubunitList);
  end;
end;

function TFhirSubstanceProtein.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceProtein;
end;

procedure TFhirSubstanceProtein.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'disulfideLinkage') Then
    list.addAll(self, 'disulfideLinkage', FDisulfideLinkageList);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceProtein.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'disulfideLinkage', 'string', true, TFhirString, FDisulfideLinkageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subunit', 'BackboneElement', true, TFhirSubstanceProteinSubunit, FSubunitList.Link)) {L1039};
end;

function TFhirSubstanceProtein.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'disulfideLinkage') then
  begin
    DisulfideLinkageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceProteinSubunit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceProtein.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceProteinSubunit) {L1049}
  else inherited;
end;

function TFhirSubstanceProtein.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create() {L1223}
  else if (propName = 'disulfideLinkage') then result := DisulfideLinkageList.new() {L1053}
  else if (propName = 'subunit') then result := SubunitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProtein.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'disulfideLinkage') then result := 'string'
  else if (propName = 'subunit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProtein.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'disulfideLinkage') then deletePropertyValue('disulfideLinkage', DisulfideLinkageList, value) {L1054}
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProtein.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new) {L1222}
  else if (propName = 'disulfideLinkage') then replacePropertyValue('disulfideLinkage', DisulfideLinkageList, existing, new) {L1055}
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProtein.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.move(source, destination) {L1046}
  else if (propName = 'subunit') then SubunitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProtein.fhirType : string;
begin
  result := 'SubstanceProtein';
end;

function TFhirSubstanceProtein.Link : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Link);
end;

function TFhirSubstanceProtein.Clone : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Clone);
end;

function TFhirSubstanceProtein.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProtein;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProtein)) then
    result := false
  else
  begin
    o := TFhirSubstanceProtein(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(disulfideLinkageList, o.disulfideLinkageList, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceProtein.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FdisulfideLinkageList) and isEmptyProp(FsubunitList);
end;

procedure TFhirSubstanceProtein.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value; {L1134}
end;

procedure TFhirSubstanceProtein.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value; {L1134}
end;

function TFhirSubstanceProtein.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

procedure TFhirSubstanceProtein.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

function TFhirSubstanceProtein.GetDisulfideLinkageList : TFhirStringList;
begin
  if FDisulfideLinkageList = nil then
    FDisulfideLinkageList := TFhirStringList.Create;
  result := FDisulfideLinkageList;
end;

function TFhirSubstanceProtein.GetHasDisulfideLinkageList : boolean;
begin
  result := (FDisulfideLinkageList <> nil) and (FDisulfideLinkageList.count > 0);
end;

function TFhirSubstanceProtein.GetSubunitList : TFhirSubstanceProteinSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceProteinSubunitList.Create;
  result := FSubunitList;
end;

function TFhirSubstanceProtein.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

procedure TFhirSubstanceProtein.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('disulfideLinkage');
  fields.add('subunit');
end;

function TFhirSubstanceProtein.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceType.sizeInBytes);
  inc(result, FNumberOfSubunits.sizeInBytes);
  inc(result, FdisulfideLinkageList.sizeInBytes);
  inc(result, FsubunitList.sizeInBytes);
end;

{ TFhirSubstanceProteinListEnumerator }

constructor TFhirSubstanceProteinListEnumerator.Create(list : TFhirSubstanceProteinList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinListEnumerator.GetCurrent : TFhirSubstanceProtein;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceProteinList }

procedure TFhirSubstanceProteinList.AddItem(value: TFhirSubstanceProtein);
begin
  assert(value.ClassName = 'TFhirSubstanceProtein', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProtein');
  add(value);
end;

function TFhirSubstanceProteinList.Append: TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinList.GetEnumerator : TFhirSubstanceProteinListEnumerator;
begin
  result := TFhirSubstanceProteinListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinList.Clone: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Clone);
end;

function TFhirSubstanceProteinList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinList.GetItemN(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProtein;
end;
function TFhirSubstanceProteinList.IndexOf(value: TFhirSubstanceProtein): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinList.Insert(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.InsertItem(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinList.Item(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.Link: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Link);
end;

procedure TFhirSubstanceProteinList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinList.SetItemByIndex(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  FhirSubstanceProteins[index] := value;
end;

procedure TFhirSubstanceProteinList.SetItemN(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
{ TFhirSubstanceReferenceInformationGene }

constructor TFhirSubstanceReferenceInformationGene.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGene.Destroy;
begin
  FGeneSequenceOrigin.free;
  FGene.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGene.Assign(oSource : TFslObject);
begin
  inherited;
  geneSequenceOrigin := TFhirSubstanceReferenceInformationGene(oSource).geneSequenceOrigin.Clone;
  gene := TFhirSubstanceReferenceInformationGene(oSource).gene.Clone;
  if (TFhirSubstanceReferenceInformationGene(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGene(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGene.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'geneSequenceOrigin') Then
     list.add(self.link, 'geneSequenceOrigin', FGeneSequenceOrigin.Link);
  if (child_name = 'gene') Then
     list.add(self.link, 'gene', FGene.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'geneSequenceOrigin', 'CodeableConcept', false, TFhirCodeableConcept, FGeneSequenceOrigin.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'gene', 'CodeableConcept', false, TFhirCodeableConcept, FGene.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceReferenceInformationGene.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then
  begin
    GeneSequenceOrigin := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    Gene := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGene.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceReferenceInformationGene.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'gene') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGene.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'geneSequenceOrigin') then result := 'CodeableConcept'
  else if (propName = 'gene') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGene.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := nil
  else if (propName = 'gene') then GeneElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGene.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'gene') then GeneElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGene.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGene.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.gene';
end;

function TFhirSubstanceReferenceInformationGene.Link : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Link);
end;

function TFhirSubstanceReferenceInformationGene.Clone : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGene.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGene;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGene)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGene(other);
    result := compareDeep(geneSequenceOriginElement, o.geneSequenceOriginElement, true) and 
      compareDeep(geneElement, o.geneElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGene.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FGeneSequenceOrigin) and isEmptyProp(FGene) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.SetGeneSequenceOrigin(value : TFhirCodeableConcept);
begin
  FGeneSequenceOrigin.free;
  FGeneSequenceOrigin := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationGene.SetGene(value : TFhirCodeableConcept);
begin
  FGene.free;
  FGene := value; {L1134}
end;

function TFhirSubstanceReferenceInformationGene.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationGene.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceReferenceInformationGene.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('geneSequenceOrigin');
  fields.add('gene');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationGene.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FGeneSequenceOrigin.sizeInBytes);
  inc(result, FGene.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneListEnumerator }

constructor TFhirSubstanceReferenceInformationGeneListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGene;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneList }

procedure TFhirSubstanceReferenceInformationGeneList.AddItem(value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGene', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGene');
  add(value);
end;

function TFhirSubstanceReferenceInformationGeneList.Append: TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneList.GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneList.Clone: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGene;
end;
function TFhirSubstanceReferenceInformationGeneList.IndexOf(value: TFhirSubstanceReferenceInformationGene): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneList.Insert(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneList.Item(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.Link: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  FhirSubstanceReferenceInformationGenes[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationGeneElement }

constructor TFhirSubstanceReferenceInformationGeneElement.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGeneElement.Destroy;
begin
  FType_.free;
  FElement.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceReferenceInformationGeneElement(oSource).type_.Clone;
  element := TFhirSubstanceReferenceInformationGeneElement(oSource).element.Clone;
  if (TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'element', 'Identifier', false, TFhirIdentifier, FElement.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceReferenceInformationGeneElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    Element := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceReferenceInformationGeneElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'element') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGeneElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'element') then result := 'Identifier'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'element') then ElementElement := new as TFhirIdentifier {L1195}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGeneElement.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.geneElement';
end;

function TFhirSubstanceReferenceInformationGeneElement.Link : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Link);
end;

function TFhirSubstanceReferenceInformationGeneElement.Clone : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElement.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGeneElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGeneElement)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGeneElement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(elementElement, o.elementElement, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGeneElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FElement) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationGeneElement.SetElement(value : TFhirIdentifier);
begin
  FElement.free;
  FElement := value; {L1134}
end;

function TFhirSubstanceReferenceInformationGeneElement.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationGeneElement.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('element');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationGeneElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FElement.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneElementListEnumerator }

constructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneElementList }

procedure TFhirSubstanceReferenceInformationGeneElementList.AddItem(value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGeneElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGeneElement');
  add(value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Append: TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Clone: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGeneElement;
end;
function TFhirSubstanceReferenceInformationGeneElementList.IndexOf(value: TFhirSubstanceReferenceInformationGeneElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Insert(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Item(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Link: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  FhirSubstanceReferenceInformationGeneElements[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationTarget }

constructor TFhirSubstanceReferenceInformationTarget.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationTarget.Destroy;
begin
  FTarget.free;
  FType_.free;
  FInteraction.free;
  FOrganism.free;
  FOrganismType.free;
  FAmount.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationTarget.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirSubstanceReferenceInformationTarget(oSource).target.Clone;
  type_ := TFhirSubstanceReferenceInformationTarget(oSource).type_.Clone;
  interaction := TFhirSubstanceReferenceInformationTarget(oSource).interaction.Clone;
  organism := TFhirSubstanceReferenceInformationTarget(oSource).organism.Clone;
  organismType := TFhirSubstanceReferenceInformationTarget(oSource).organismType.Clone;
  amount := TFhirSubstanceReferenceInformationTarget(oSource).amount.Clone;
  amountType := TFhirSubstanceReferenceInformationTarget(oSource).amountType.Clone;
  if (TFhirSubstanceReferenceInformationTarget(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationTarget(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'interaction') Then
     list.add(self.link, 'interaction', FInteraction.Link);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'organismType') Then
     list.add(self.link, 'organismType', FOrganismType.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Identifier', false, TFhirIdentifier, FTarget.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'interaction', 'CodeableConcept', false, TFhirCodeableConcept, FInteraction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organism', 'CodeableConcept', false, TFhirCodeableConcept, FOrganism.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organismType', 'CodeableConcept', false, TFhirCodeableConcept, FOrganismType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|string', false, TFhirDataType, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link)) {L1039};
end;

function TFhirSubstanceReferenceInformationTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    Interaction := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'organismType') then
  begin
    OrganismType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then
  begin
    Amount := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSubstanceReferenceInformationTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'interaction') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'organism') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'organismType') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Amount') {L1191}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := SourceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'interaction') then result := 'CodeableConcept'
  else if (propName = 'organism') then result := 'CodeableConcept'
  else if (propName = 'organismType') then result := 'CodeableConcept'
  else if (propName = 'amount[x]') then result := 'Quantity|Range|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'interaction') then InteractionElement := nil
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'organismType') then OrganismTypeElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := nil {L1189}
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirIdentifier {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'interaction') then InteractionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'organism') then OrganismElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'organismType') then OrganismTypeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := new as TFhirDataType {L1190}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationTarget.fhirType : string;
begin
  result := 'SubstanceReferenceInformation.target';
end;

function TFhirSubstanceReferenceInformationTarget.Link : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Link);
end;

function TFhirSubstanceReferenceInformationTarget.Clone : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTarget.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationTarget)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationTarget(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(interactionElement, o.interactionElement, true) and compareDeep(organismElement, o.organismElement, true) and 
      compareDeep(organismTypeElement, o.organismTypeElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FType_) and isEmptyProp(FInteraction) and isEmptyProp(FOrganism) and isEmptyProp(FOrganismType) and isEmptyProp(FAmount) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.SetTarget(value : TFhirIdentifier);
begin
  FTarget.free;
  FTarget := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetInteraction(value : TFhirCodeableConcept);
begin
  FInteraction.free;
  FInteraction := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetOrganism(value : TFhirCodeableConcept);
begin
  FOrganism.free;
  FOrganism := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetOrganismType(value : TFhirCodeableConcept);
begin
  FOrganismType.free;
  FOrganismType := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirSubstanceReferenceInformationTarget.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value; {L1134}
end;

function TFhirSubstanceReferenceInformationTarget.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceReferenceInformationTarget.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

procedure TFhirSubstanceReferenceInformationTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('target');
  fields.add('type');
  fields.add('interaction');
  fields.add('organism');
  fields.add('organismType');
  fields.add('amount[x]');
  fields.add('amountType');
  fields.add('source');
end;

function TFhirSubstanceReferenceInformationTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTarget.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FInteraction.sizeInBytes);
  inc(result, FOrganism.sizeInBytes);
  inc(result, FOrganismType.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationTargetListEnumerator }

constructor TFhirSubstanceReferenceInformationTargetListEnumerator.Create(list : TFhirSubstanceReferenceInformationTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationTarget;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationTargetList }

procedure TFhirSubstanceReferenceInformationTargetList.AddItem(value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationTarget');
  add(value);
end;

function TFhirSubstanceReferenceInformationTargetList.Append: TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationTargetList.GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationTargetListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationTargetList.Clone: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationTargetList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationTarget;
end;
function TFhirSubstanceReferenceInformationTargetList.IndexOf(value: TFhirSubstanceReferenceInformationTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationTargetList.Insert(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationTargetList.Item(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.Link: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  FhirSubstanceReferenceInformationTargets[index] := value;
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformation }

constructor TFhirSubstanceReferenceInformation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformation.Destroy;
begin
  FComment.free;
  FGeneList.Free;
  FGeneElementList.Free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformation.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirSubstanceReferenceInformation(oSource).commentElement.Clone;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneList = nil) then
  begin
    FGeneList.free;
    FGeneList := nil;
  end
  else
  begin
    if FGeneList = nil then
      FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
    FGeneList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneElementList = nil) then
  begin
    FGeneElementList.free;
    FGeneElementList := nil;
  end
  else
  begin
    if FGeneElementList = nil then
      FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
    FGeneElementList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneElementList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
    FTargetList.Assign(TFhirSubstanceReferenceInformation(oSource).FTargetList);
  end;
end;

function TFhirSubstanceReferenceInformation.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceReferenceInformation;
end;

procedure TFhirSubstanceReferenceInformation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'gene') Then
    list.addAll(self, 'gene', FGeneList);
  if (child_name = 'geneElement') Then
    list.addAll(self, 'geneElement', FGeneElementList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirSubstanceReferenceInformation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'gene', 'BackboneElement', true, TFhirSubstanceReferenceInformationGene, FGeneList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'geneElement', 'BackboneElement', true, TFhirSubstanceReferenceInformationGeneElement, FGeneElementList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirSubstanceReferenceInformationTarget, FTargetList.Link)) {L1039};
end;

function TFhirSubstanceReferenceInformation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    GeneList.add(propValue as TFhirSubstanceReferenceInformationGene) {L1048};
    result := propValue;
  end
  else if (propName = 'geneElement') then
  begin
    GeneElementList.add(propValue as TFhirSubstanceReferenceInformationGeneElement) {L1048};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirSubstanceReferenceInformationTarget) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'gene') then GeneList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGene) {L1049}
  else if (propName = 'geneElement') then GeneElementList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGeneElement) {L1049}
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirSubstanceReferenceInformationTarget) {L1049}
  else inherited;
end;

function TFhirSubstanceReferenceInformation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create() {L1223}
  else if (propName = 'gene') then result := GeneList.new() {L1053}
  else if (propName = 'geneElement') then result := GeneElementList.new() {L1053}
  else if (propName = 'target') then result := TargetList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'gene') then result := 'BackboneElement'
  else if (propName = 'geneElement') then result := 'BackboneElement'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'gene') then deletePropertyValue('gene', GeneList, value) {L1054}
  else if (propName = 'geneElement') then deletePropertyValue('geneElement', GeneElementList, value) {L1054}
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else if (propName = 'gene') then replacePropertyValue('gene', GeneList, existing, new) {L1055}
  else if (propName = 'geneElement') then replacePropertyValue('geneElement', GeneElementList, existing, new) {L1055}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'gene') then GeneList.move(source, destination) {L1050}
  else if (propName = 'geneElement') then GeneElementList.move(source, destination) {L1050}
  else if (propName = 'target') then TargetList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformation.fhirType : string;
begin
  result := 'SubstanceReferenceInformation';
end;

function TFhirSubstanceReferenceInformation.Link : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Link);
end;

function TFhirSubstanceReferenceInformation.Clone : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Clone);
end;

function TFhirSubstanceReferenceInformation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformation)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformation(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(geneList, o.geneList, true) and 
      compareDeep(geneElementList, o.geneElementList, true) and compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirSubstanceReferenceInformation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FgeneList) and isEmptyProp(FgeneElementList) and isEmptyProp(FtargetList);
end;

procedure TFhirSubstanceReferenceInformation.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirSubstanceReferenceInformation.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSubstanceReferenceInformation.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirSubstanceReferenceInformation.GetGeneList : TFhirSubstanceReferenceInformationGeneList;
begin
  if FGeneList = nil then
    FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
  result := FGeneList;
end;

function TFhirSubstanceReferenceInformation.GetHasGeneList : boolean;
begin
  result := (FGeneList <> nil) and (FGeneList.count > 0);
end;

function TFhirSubstanceReferenceInformation.GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
begin
  if FGeneElementList = nil then
    FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
  result := FGeneElementList;
end;

function TFhirSubstanceReferenceInformation.GetHasGeneElementList : boolean;
begin
  result := (FGeneElementList <> nil) and (FGeneElementList.count > 0);
end;

function TFhirSubstanceReferenceInformation.GetTargetList : TFhirSubstanceReferenceInformationTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
  result := FTargetList;
end;

function TFhirSubstanceReferenceInformation.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

procedure TFhirSubstanceReferenceInformation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('comment');
  fields.add('gene');
  fields.add('geneElement');
  fields.add('target');
end;

function TFhirSubstanceReferenceInformation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComment.sizeInBytes);
  inc(result, FgeneList.sizeInBytes);
  inc(result, FgeneElementList.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationListEnumerator }

constructor TFhirSubstanceReferenceInformationListEnumerator.Create(list : TFhirSubstanceReferenceInformationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationListEnumerator.GetCurrent : TFhirSubstanceReferenceInformation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationList }

procedure TFhirSubstanceReferenceInformationList.AddItem(value: TFhirSubstanceReferenceInformation);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformation');
  add(value);
end;

function TFhirSubstanceReferenceInformationList.Append: TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationList.GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationList.Clone: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationList.GetItemN(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformation;
end;
function TFhirSubstanceReferenceInformationList.IndexOf(value: TFhirSubstanceReferenceInformation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationList.Insert(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationList.Item(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.Link: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  FhirSubstanceReferenceInformations[index] := value;
end;

procedure TFhirSubstanceReferenceInformationList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
{ TFhirSubstanceSourceMaterialFractionDescription }

constructor TFhirSubstanceSourceMaterialFractionDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialFractionDescription.Destroy;
begin
  FFraction.free;
  FMaterialType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.Assign(oSource : TFslObject);
begin
  inherited;
  fractionElement := TFhirSubstanceSourceMaterialFractionDescription(oSource).fractionElement.Clone;
  materialType := TFhirSubstanceSourceMaterialFractionDescription(oSource).materialType.Clone;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'fraction') Then
     list.add(self.link, 'fraction', FFraction.Link);
  if (child_name = 'materialType') Then
     list.add(self.link, 'materialType', FMaterialType.Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'fraction', 'string', false, TFhirString, FFraction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'materialType', 'CodeableConcept', false, TFhirCodeableConcept, FMaterialType.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialFractionDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'fraction') then
  begin
    FractionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'materialType') then
  begin
    MaterialType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'fraction') then result := TFhirString.create() {L1223}
  else if (propName = 'materialType') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialFractionDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'fraction') then result := 'string'
  else if (propName = 'materialType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := nil
  else if (propName = 'materialType') then MaterialTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := asString(new) {L1222}
  else if (propName = 'materialType') then MaterialTypeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialFractionDescription.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.fractionDescription';
end;

function TFhirSubstanceSourceMaterialFractionDescription.Link : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialFractionDescription.Clone : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialFractionDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialFractionDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialFractionDescription(other);
    result := compareDeep(fractionElement, o.fractionElement, true) and compareDeep(materialTypeElement, o.materialTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialFractionDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFraction) and isEmptyProp(FMaterialType);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetFraction(value : TFhirString);
begin
  FFraction.free;
  FFraction := value; {L1134}
end;

function TFhirSubstanceSourceMaterialFractionDescription.GetFractionST : String;
begin
  if FFraction = nil then
    result := ''
  else
    result := FFraction.value;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetFractionST(value : String);
begin
  if value <> '' then
  begin
    if FFraction = nil then
      FFraction := TFhirString.create;
    FFraction.value := value
  end
  else if FFraction <> nil then
    FFraction.value := '';
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.SetMaterialType(value : TFhirCodeableConcept);
begin
  FMaterialType.free;
  FMaterialType := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('fraction');
  fields.add('materialType');
end;

function TFhirSubstanceSourceMaterialFractionDescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFraction.sizeInBytes);
  inc(result, FMaterialType.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator }

constructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionList }

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialFractionDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialFractionDescription');
  add(value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Append: TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Clone: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription;
end;
function TFhirSubstanceSourceMaterialFractionDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialFractionDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Link: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  FhirSubstanceSourceMaterialFractionDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganism }

constructor TFhirSubstanceSourceMaterialOrganism.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganism.Destroy;
begin
  FFamily.free;
  FGenus.free;
  FSpecies.free;
  FIntraspecificType.free;
  FIntraspecificDescription.free;
  FAuthorList.Free;
  FHybrid.free;
  FOrganismGeneral.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganism.Assign(oSource : TFslObject);
begin
  inherited;
  family := TFhirSubstanceSourceMaterialOrganism(oSource).family.Clone;
  genus := TFhirSubstanceSourceMaterialOrganism(oSource).genus.Clone;
  species := TFhirSubstanceSourceMaterialOrganism(oSource).species.Clone;
  intraspecificType := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificType.Clone;
  intraspecificDescriptionElement := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificDescriptionElement.Clone;
  if (TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
    FAuthorList.Assign(TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList);
  end;
  hybrid := TFhirSubstanceSourceMaterialOrganism(oSource).hybrid.Clone;
  organismGeneral := TFhirSubstanceSourceMaterialOrganism(oSource).organismGeneral.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganism.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'family') Then
     list.add(self.link, 'family', FFamily.Link);
  if (child_name = 'genus') Then
     list.add(self.link, 'genus', FGenus.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
  if (child_name = 'intraspecificType') Then
     list.add(self.link, 'intraspecificType', FIntraspecificType.Link);
  if (child_name = 'intraspecificDescription') Then
     list.add(self.link, 'intraspecificDescription', FIntraspecificDescription.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'hybrid') Then
     list.add(self.link, 'hybrid', FHybrid.Link);
  if (child_name = 'organismGeneral') Then
     list.add(self.link, 'organismGeneral', FOrganismGeneral.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganism.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'family', 'CodeableConcept', false, TFhirCodeableConcept, FFamily.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'genus', 'CodeableConcept', false, TFhirCodeableConcept, FGenus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'intraspecificType', 'CodeableConcept', false, TFhirCodeableConcept, FIntraspecificType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'intraspecificDescription', 'string', false, TFhirString, FIntraspecificDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'author', 'BackboneElement', true, TFhirSubstanceSourceMaterialOrganismAuthor, FAuthorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'hybrid', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganismHybrid, FHybrid.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organismGeneral', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganismOrganismGeneral, FOrganismGeneral.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialOrganism.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'family') then
  begin
    Family := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'genus') then
  begin
    Genus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'intraspecificType') then
  begin
    IntraspecificType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'intraspecificDescription') then
  begin
    IntraspecificDescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirSubstanceSourceMaterialOrganismAuthor) {L1048};
    result := propValue;
  end
  else if (propName = 'hybrid') then
  begin
    Hybrid := propValue as TFhirSubstanceSourceMaterialOrganismHybrid {L1199};
    result := propValue;
  end
  else if (propName = 'organismGeneral') then
  begin
    OrganismGeneral := propValue as TFhirSubstanceSourceMaterialOrganismOrganismGeneral {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganism.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirSubstanceSourceMaterialOrganismAuthor) {L1049}
  else inherited;
end;

function TFhirSubstanceSourceMaterialOrganism.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'family') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'genus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'species') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'intraspecificType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'intraspecificDescription') then result := TFhirString.create() {L1223}
  else if (propName = 'author') then result := AuthorList.new() {L1053}
  else if (propName = 'hybrid') then result := TFhirSubstanceSourceMaterialOrganismHybrid.create() {L1203}
  else if (propName = 'organismGeneral') then result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganism.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'family') then result := 'CodeableConcept'
  else if (propName = 'genus') then result := 'CodeableConcept'
  else if (propName = 'species') then result := 'CodeableConcept'
  else if (propName = 'intraspecificType') then result := 'CodeableConcept'
  else if (propName = 'intraspecificDescription') then result := 'string'
  else if (propName = 'author') then result := 'BackboneElement'
  else if (propName = 'hybrid') then result := 'BackboneElement'
  else if (propName = 'organismGeneral') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganism.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := nil
  else if (propName = 'genus') then GenusElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := nil
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {L1054}
  else if (propName = 'hybrid') then HybridElement := nil
  else if (propName = 'organismGeneral') then OrganismGeneralElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganism.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'genus') then GenusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := asString(new) {L1222}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {L1055}
  else if (propName = 'hybrid') then HybridElement := new as TFhirSubstanceSourceMaterialOrganismHybrid {L1195}
  else if (propName = 'organismGeneral') then OrganismGeneralElement := new as TFhirSubstanceSourceMaterialOrganismOrganismGeneral {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganism.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganism.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism';
end;

function TFhirSubstanceSourceMaterialOrganism.Link : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganism.Clone : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganism.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganism;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganism)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganism(other);
    result := compareDeep(familyElement, o.familyElement, true) and compareDeep(genusElement, o.genusElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true) and compareDeep(intraspecificTypeElement, o.intraspecificTypeElement, true) and 
      compareDeep(intraspecificDescriptionElement, o.intraspecificDescriptionElement, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(hybridElement, o.hybridElement, true) and 
      compareDeep(organismGeneralElement, o.organismGeneralElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganism.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFamily) and isEmptyProp(FGenus) and isEmptyProp(FSpecies) and isEmptyProp(FIntraspecificType) and isEmptyProp(FIntraspecificDescription) and isEmptyProp(FauthorList) and isEmptyProp(FHybrid) and isEmptyProp(FOrganismGeneral);
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetFamily(value : TFhirCodeableConcept);
begin
  FFamily.free;
  FFamily := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetGenus(value : TFhirCodeableConcept);
begin
  FGenus.free;
  FGenus := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificType(value : TFhirCodeableConcept);
begin
  FIntraspecificType.free;
  FIntraspecificType := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescription(value : TFhirString);
begin
  FIntraspecificDescription.free;
  FIntraspecificDescription := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganism.GetIntraspecificDescriptionST : String;
begin
  if FIntraspecificDescription = nil then
    result := ''
  else
    result := FIntraspecificDescription.value;
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FIntraspecificDescription = nil then
      FIntraspecificDescription := TFhirString.create;
    FIntraspecificDescription.value := value
  end
  else if FIntraspecificDescription <> nil then
    FIntraspecificDescription.value := '';
end;

function TFhirSubstanceSourceMaterialOrganism.GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
  result := FAuthorList;
end;

function TFhirSubstanceSourceMaterialOrganism.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  FHybrid.free;
  FHybrid := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  FOrganismGeneral.free;
  FOrganismGeneral := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganism.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('family');
  fields.add('genus');
  fields.add('species');
  fields.add('intraspecificType');
  fields.add('intraspecificDescription');
  fields.add('author');
  fields.add('hybrid');
  fields.add('organismGeneral');
end;

function TFhirSubstanceSourceMaterialOrganism.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFamily.sizeInBytes);
  inc(result, FGenus.sizeInBytes);
  inc(result, FSpecies.sizeInBytes);
  inc(result, FIntraspecificType.sizeInBytes);
  inc(result, FIntraspecificDescription.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FHybrid.sizeInBytes);
  inc(result, FOrganismGeneral.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganism;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismList }

procedure TFhirSubstanceSourceMaterialOrganismList.AddItem(value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganism', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganism');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Append: TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismList.Clone: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganism;
end;
function TFhirSubstanceSourceMaterialOrganismList.IndexOf(value: TFhirSubstanceSourceMaterialOrganism): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.Link: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  FhirSubstanceSourceMaterialOrganisms[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismAuthor }

constructor TFhirSubstanceSourceMaterialOrganismAuthor.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthor.Destroy;
begin
  FAuthorType.free;
  FAuthorDescription.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.Assign(oSource : TFslObject);
begin
  inherited;
  authorType := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorType.Clone;
  authorDescriptionElement := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorDescriptionElement.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authorType') Then
     list.add(self.link, 'authorType', FAuthorType.Link);
  if (child_name = 'authorDescription') Then
     list.add(self.link, 'authorDescription', FAuthorDescription.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authorType', 'CodeableConcept', false, TFhirCodeableConcept, FAuthorType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authorDescription', 'string', false, TFhirString, FAuthorDescription.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authorType') then
  begin
    AuthorType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'authorDescription') then
  begin
    AuthorDescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authorType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'authorDescription') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authorType') then result := 'CodeableConcept'
  else if (propName = 'authorDescription') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := nil
  else if (propName = 'authorDescription') then AuthorDescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'authorDescription') then AuthorDescriptionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.author';
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Link : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Clone : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismAuthor)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismAuthor(other);
    result := compareDeep(authorTypeElement, o.authorTypeElement, true) and compareDeep(authorDescriptionElement, o.authorDescriptionElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthorType) and isEmptyProp(FAuthorDescription);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorType(value : TFhirCodeableConcept);
begin
  FAuthorType.free;
  FAuthorType := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescription(value : TFhirString);
begin
  FAuthorDescription.free;
  FAuthorDescription := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.GetAuthorDescriptionST : String;
begin
  if FAuthorDescription = nil then
    result := ''
  else
    result := FAuthorDescription.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorDescription = nil then
      FAuthorDescription := TFhirString.create;
    FAuthorDescription.value := value
  end
  else if FAuthorDescription <> nil then
    FAuthorDescription.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authorType');
  fields.add('authorDescription');
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthorType.sizeInBytes);
  inc(result, FAuthorDescription.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorList }

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.AddItem(value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismAuthor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismAuthor');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Append: TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Clone: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor;
end;
function TFhirSubstanceSourceMaterialOrganismAuthorList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismAuthor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Link: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  FhirSubstanceSourceMaterialOrganismAuthors[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismHybrid }

constructor TFhirSubstanceSourceMaterialOrganismHybrid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybrid.Destroy;
begin
  FMaternalOrganismId.free;
  FMaternalOrganismName.free;
  FPaternalOrganismId.free;
  FPaternalOrganismName.free;
  FHybridType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.Assign(oSource : TFslObject);
begin
  inherited;
  maternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismIdElement.Clone;
  maternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismNameElement.Clone;
  paternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismIdElement.Clone;
  paternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismNameElement.Clone;
  hybridType := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).hybridType.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'maternalOrganismId') Then
     list.add(self.link, 'maternalOrganismId', FMaternalOrganismId.Link);
  if (child_name = 'maternalOrganismName') Then
     list.add(self.link, 'maternalOrganismName', FMaternalOrganismName.Link);
  if (child_name = 'paternalOrganismId') Then
     list.add(self.link, 'paternalOrganismId', FPaternalOrganismId.Link);
  if (child_name = 'paternalOrganismName') Then
     list.add(self.link, 'paternalOrganismName', FPaternalOrganismName.Link);
  if (child_name = 'hybridType') Then
     list.add(self.link, 'hybridType', FHybridType.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'maternalOrganismId', 'string', false, TFhirString, FMaternalOrganismId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'maternalOrganismName', 'string', false, TFhirString, FMaternalOrganismName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paternalOrganismId', 'string', false, TFhirString, FPaternalOrganismId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paternalOrganismName', 'string', false, TFhirString, FPaternalOrganismName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'hybridType', 'CodeableConcept', false, TFhirCodeableConcept, FHybridType.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then
  begin
    MaternalOrganismIdElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'maternalOrganismName') then
  begin
    MaternalOrganismNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'paternalOrganismId') then
  begin
    PaternalOrganismIdElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'paternalOrganismName') then
  begin
    PaternalOrganismNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'hybridType') then
  begin
    HybridType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then result := TFhirString.create() {L1223}
  else if (propName = 'maternalOrganismName') then result := TFhirString.create() {L1223}
  else if (propName = 'paternalOrganismId') then result := TFhirString.create() {L1223}
  else if (propName = 'paternalOrganismName') then result := TFhirString.create() {L1223}
  else if (propName = 'hybridType') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'maternalOrganismId') then result := 'string'
  else if (propName = 'maternalOrganismName') then result := 'string'
  else if (propName = 'paternalOrganismId') then result := 'string'
  else if (propName = 'paternalOrganismName') then result := 'string'
  else if (propName = 'hybridType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := nil
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := nil
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := nil
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := nil
  else if (propName = 'hybridType') then HybridTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := asString(new) {L1222}
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := asString(new) {L1222}
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := asString(new) {L1222}
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := asString(new) {L1222}
  else if (propName = 'hybridType') then HybridTypeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.hybrid';
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Link : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Clone : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismHybrid)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismHybrid(other);
    result := compareDeep(maternalOrganismIdElement, o.maternalOrganismIdElement, true) and 
      compareDeep(maternalOrganismNameElement, o.maternalOrganismNameElement, true) and 
      compareDeep(paternalOrganismIdElement, o.paternalOrganismIdElement, true) and 
      compareDeep(paternalOrganismNameElement, o.paternalOrganismNameElement, true) and 
      compareDeep(hybridTypeElement, o.hybridTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMaternalOrganismId) and isEmptyProp(FMaternalOrganismName) and isEmptyProp(FPaternalOrganismId) and isEmptyProp(FPaternalOrganismName) and isEmptyProp(FHybridType);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismId(value : TFhirString);
begin
  FMaternalOrganismId.free;
  FMaternalOrganismId := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismIdST : String;
begin
  if FMaternalOrganismId = nil then
    result := ''
  else
    result := FMaternalOrganismId.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismId = nil then
      FMaternalOrganismId := TFhirString.create;
    FMaternalOrganismId.value := value
  end
  else if FMaternalOrganismId <> nil then
    FMaternalOrganismId.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismName(value : TFhirString);
begin
  FMaternalOrganismName.free;
  FMaternalOrganismName := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismNameST : String;
begin
  if FMaternalOrganismName = nil then
    result := ''
  else
    result := FMaternalOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismName = nil then
      FMaternalOrganismName := TFhirString.create;
    FMaternalOrganismName.value := value
  end
  else if FMaternalOrganismName <> nil then
    FMaternalOrganismName.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismId(value : TFhirString);
begin
  FPaternalOrganismId.free;
  FPaternalOrganismId := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismIdST : String;
begin
  if FPaternalOrganismId = nil then
    result := ''
  else
    result := FPaternalOrganismId.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismId = nil then
      FPaternalOrganismId := TFhirString.create;
    FPaternalOrganismId.value := value
  end
  else if FPaternalOrganismId <> nil then
    FPaternalOrganismId.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismName(value : TFhirString);
begin
  FPaternalOrganismName.free;
  FPaternalOrganismName := value; {L1134}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismNameST : String;
begin
  if FPaternalOrganismName = nil then
    result := ''
  else
    result := FPaternalOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismName = nil then
      FPaternalOrganismName := TFhirString.create;
    FPaternalOrganismName.value := value
  end
  else if FPaternalOrganismName <> nil then
    FPaternalOrganismName.value := '';
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetHybridType(value : TFhirCodeableConcept);
begin
  FHybridType.free;
  FHybridType := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('maternalOrganismId');
  fields.add('maternalOrganismName');
  fields.add('paternalOrganismId');
  fields.add('paternalOrganismName');
  fields.add('hybridType');
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMaternalOrganismId.sizeInBytes);
  inc(result, FMaternalOrganismName.sizeInBytes);
  inc(result, FPaternalOrganismId.sizeInBytes);
  inc(result, FPaternalOrganismName.sizeInBytes);
  inc(result, FHybridType.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismHybridListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismHybridList }

procedure TFhirSubstanceSourceMaterialOrganismHybridList.AddItem(value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismHybrid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismHybrid');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Append: TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Clone: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid;
end;
function TFhirSubstanceSourceMaterialOrganismHybridList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismHybrid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Link: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  FhirSubstanceSourceMaterialOrganismHybrids[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneral }

constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Destroy;
begin
  FKingdom.free;
  FPhylum.free;
  FClass_.free;
  FOrder.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Assign(oSource : TFslObject);
begin
  inherited;
  kingdom := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).kingdom.Clone;
  phylum := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).phylum.Clone;
  class_ := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).class_.Clone;
  order := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).order.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kingdom') Then
     list.add(self.link, 'kingdom', FKingdom.Link);
  if (child_name = 'phylum') Then
     list.add(self.link, 'phylum', FPhylum.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kingdom', 'CodeableConcept', false, TFhirCodeableConcept, FKingdom.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'phylum', 'CodeableConcept', false, TFhirCodeableConcept, FPhylum.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'order', 'CodeableConcept', false, TFhirCodeableConcept, FOrder.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kingdom') then
  begin
    Kingdom := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'phylum') then
  begin
    Phylum := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    Order := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kingdom') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'phylum') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'class') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'order') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kingdom') then result := 'CodeableConcept'
  else if (propName = 'phylum') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'order') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := nil
  else if (propName = 'phylum') then PhylumElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'order') then OrderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'phylum') then PhylumElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'order') then OrderElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.organism.organismGeneral';
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismOrganismGeneral)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(other);
    result := compareDeep(kingdomElement, o.kingdomElement, true) and compareDeep(phylumElement, o.phylumElement, true) and 
      compareDeep(class_Element, o.class_Element, true) and compareDeep(orderElement, o.orderElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKingdom) and isEmptyProp(FPhylum) and isEmptyProp(FClass_) and isEmptyProp(FOrder);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetKingdom(value : TFhirCodeableConcept);
begin
  FKingdom.free;
  FKingdom := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetPhylum(value : TFhirCodeableConcept);
begin
  FPhylum.free;
  FPhylum := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetOrder(value : TFhirCodeableConcept);
begin
  FOrder.free;
  FOrder := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kingdom');
  fields.add('phylum');
  fields.add('class');
  fields.add('order');
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKingdom.sizeInBytes);
  inc(result, FPhylum.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FOrder.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator }

constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralList }

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.AddItem(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismOrganismGeneral', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismOrganismGeneral');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Append: TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Clone: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
end;
function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Link: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  FhirSubstanceSourceMaterialOrganismOrganismGenerals[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialPartDescription }

constructor TFhirSubstanceSourceMaterialPartDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialPartDescription.Destroy;
begin
  FPart.free;
  FPartLocation.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.Assign(oSource : TFslObject);
begin
  inherited;
  part := TFhirSubstanceSourceMaterialPartDescription(oSource).part.Clone;
  partLocation := TFhirSubstanceSourceMaterialPartDescription(oSource).partLocation.Clone;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'partLocation') Then
     list.add(self.link, 'partLocation', FPartLocation.Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'CodeableConcept', false, TFhirCodeableConcept, FPart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'partLocation', 'CodeableConcept', false, TFhirCodeableConcept, FPartLocation.Link)); {L1172}
end;

function TFhirSubstanceSourceMaterialPartDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    Part := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'partLocation') then
  begin
    PartLocation := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'partLocation') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialPartDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'CodeableConcept'
  else if (propName = 'partLocation') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'partLocation') then PartLocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'partLocation') then PartLocationElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialPartDescription.fhirType : string;
begin
  result := 'SubstanceSourceMaterial.partDescription';
end;

function TFhirSubstanceSourceMaterialPartDescription.Link : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialPartDescription.Clone : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialPartDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialPartDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialPartDescription(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(partLocationElement, o.partLocationElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialPartDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FPartLocation);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.SetPart(value : TFhirCodeableConcept);
begin
  FPart.free;
  FPart := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialPartDescription.SetPartLocation(value : TFhirCodeableConcept);
begin
  FPartLocation.free;
  FPartLocation := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterialPartDescription.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('part');
  fields.add('partLocation');
end;

function TFhirSubstanceSourceMaterialPartDescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPart.sizeInBytes);
  inc(result, FPartLocation.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialPartDescriptionListEnumerator }

constructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialPartDescriptionList }

procedure TFhirSubstanceSourceMaterialPartDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialPartDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialPartDescription');
  add(value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Append: TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Clone: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialPartDescription;
end;
function TFhirSubstanceSourceMaterialPartDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialPartDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Link: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  FhirSubstanceSourceMaterialPartDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterial }

constructor TFhirSubstanceSourceMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterial.Destroy;
begin
  FSourceMaterialClass.free;
  FSourceMaterialType.free;
  FSourceMaterialState.free;
  FOrganismId.free;
  FOrganismName.free;
  FParentSubstanceIdList.Free;
  FParentSubstanceNameList.Free;
  FCountryOfOriginList.Free;
  FGeographicalLocationList.Free;
  FDevelopmentStage.free;
  FFractionDescriptionList.Free;
  FOrganism.free;
  FPartDescriptionList.Free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  sourceMaterialClass := TFhirSubstanceSourceMaterial(oSource).sourceMaterialClass.Clone;
  sourceMaterialType := TFhirSubstanceSourceMaterial(oSource).sourceMaterialType.Clone;
  sourceMaterialState := TFhirSubstanceSourceMaterial(oSource).sourceMaterialState.Clone;
  organismId := TFhirSubstanceSourceMaterial(oSource).organismId.Clone;
  organismNameElement := TFhirSubstanceSourceMaterial(oSource).organismNameElement.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList = nil) then
  begin
    FParentSubstanceIdList.free;
    FParentSubstanceIdList := nil;
  end
  else
  begin
    if FParentSubstanceIdList = nil then
      FParentSubstanceIdList := TFhirIdentifierList.Create;
    FParentSubstanceIdList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList = nil) then
  begin
    FParentSubstanceNameList.free;
    FParentSubstanceNameList := nil;
  end
  else
  begin
    if FParentSubstanceNameList = nil then
      FParentSubstanceNameList := TFhirStringList.Create;
    FParentSubstanceNameList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList = nil) then
  begin
    FCountryOfOriginList.free;
    FCountryOfOriginList := nil;
  end
  else
  begin
    if FCountryOfOriginList = nil then
      FCountryOfOriginList := TFhirCodeableConceptList.Create;
    FCountryOfOriginList.Assign(TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList = nil) then
  begin
    FGeographicalLocationList.free;
    FGeographicalLocationList := nil;
  end
  else
  begin
    if FGeographicalLocationList = nil then
      FGeographicalLocationList := TFhirStringList.Create;
    FGeographicalLocationList.Assign(TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList);
  end;
  developmentStage := TFhirSubstanceSourceMaterial(oSource).developmentStage.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList = nil) then
  begin
    FFractionDescriptionList.free;
    FFractionDescriptionList := nil;
  end
  else
  begin
    if FFractionDescriptionList = nil then
      FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
    FFractionDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList);
  end;
  organism := TFhirSubstanceSourceMaterial(oSource).organism.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList = nil) then
  begin
    FPartDescriptionList.free;
    FPartDescriptionList := nil;
  end
  else
  begin
    if FPartDescriptionList = nil then
      FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
    FPartDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList);
  end;
end;

function TFhirSubstanceSourceMaterial.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceSourceMaterial;
end;

procedure TFhirSubstanceSourceMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sourceMaterialClass') Then
     list.add(self.link, 'sourceMaterialClass', FSourceMaterialClass.Link);
  if (child_name = 'sourceMaterialType') Then
     list.add(self.link, 'sourceMaterialType', FSourceMaterialType.Link);
  if (child_name = 'sourceMaterialState') Then
     list.add(self.link, 'sourceMaterialState', FSourceMaterialState.Link);
  if (child_name = 'organismId') Then
     list.add(self.link, 'organismId', FOrganismId.Link);
  if (child_name = 'organismName') Then
     list.add(self.link, 'organismName', FOrganismName.Link);
  if (child_name = 'parentSubstanceId') Then
    list.addAll(self, 'parentSubstanceId', FParentSubstanceIdList);
  if (child_name = 'parentSubstanceName') Then
    list.addAll(self, 'parentSubstanceName', FParentSubstanceNameList);
  if (child_name = 'countryOfOrigin') Then
    list.addAll(self, 'countryOfOrigin', FCountryOfOriginList);
  if (child_name = 'geographicalLocation') Then
    list.addAll(self, 'geographicalLocation', FGeographicalLocationList);
  if (child_name = 'developmentStage') Then
     list.add(self.link, 'developmentStage', FDevelopmentStage.Link);
  if (child_name = 'fractionDescription') Then
    list.addAll(self, 'fractionDescription', FFractionDescriptionList);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'partDescription') Then
    list.addAll(self, 'partDescription', FPartDescriptionList);
end;

procedure TFhirSubstanceSourceMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sourceMaterialClass', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialClass.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sourceMaterialType', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'sourceMaterialState', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialState.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organismId', 'Identifier', false, TFhirIdentifier, FOrganismId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organismName', 'string', false, TFhirString, FOrganismName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parentSubstanceId', 'Identifier', true, TFhirIdentifier, FParentSubstanceIdList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'parentSubstanceName', 'string', true, TFhirString, FParentSubstanceNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'countryOfOrigin', 'CodeableConcept', true, TFhirCodeableConcept, FCountryOfOriginList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'geographicalLocation', 'string', true, TFhirString, FGeographicalLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'developmentStage', 'CodeableConcept', false, TFhirCodeableConcept, FDevelopmentStage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fractionDescription', 'BackboneElement', true, TFhirSubstanceSourceMaterialFractionDescription, FFractionDescriptionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'organism', 'BackboneElement', false, TFhirSubstanceSourceMaterialOrganism, FOrganism.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'partDescription', 'BackboneElement', true, TFhirSubstanceSourceMaterialPartDescription, FPartDescriptionList.Link)) {L1039};
end;

function TFhirSubstanceSourceMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then
  begin
    SourceMaterialClass := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'sourceMaterialType') then
  begin
    SourceMaterialType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'sourceMaterialState') then
  begin
    SourceMaterialState := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'organismId') then
  begin
    OrganismId := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'organismName') then
  begin
    OrganismNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'parentSubstanceId') then
  begin
    ParentSubstanceIdList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'parentSubstanceName') then
  begin
    ParentSubstanceNameList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'countryOfOrigin') then
  begin
    CountryOfOriginList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'geographicalLocation') then
  begin
    GeographicalLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'developmentStage') then
  begin
    DevelopmentStage := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'fractionDescription') then
  begin
    FractionDescriptionList.add(propValue as TFhirSubstanceSourceMaterialFractionDescription) {L1048};
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirSubstanceSourceMaterialOrganism {L1199};
    result := propValue;
  end
  else if (propName = 'partDescription') then
  begin
    PartDescriptionList.add(propValue as TFhirSubstanceSourceMaterialPartDescription) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'geographicalLocation') then GeographicalLocationList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'fractionDescription') then FractionDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialFractionDescription) {L1049}
  else if (propName = 'partDescription') then PartDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialPartDescription) {L1049}
  else inherited;
end;

function TFhirSubstanceSourceMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'sourceMaterialType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'sourceMaterialState') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'organismId') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'organismName') then result := TFhirString.create() {L1223}
  else if (propName = 'parentSubstanceId') then result := ParentSubstanceIdList.new() {L1053}
  else if (propName = 'parentSubstanceName') then result := ParentSubstanceNameList.new() {L1053}
  else if (propName = 'countryOfOrigin') then result := CountryOfOriginList.new() {L1053}
  else if (propName = 'geographicalLocation') then result := GeographicalLocationList.new() {L1053}
  else if (propName = 'developmentStage') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'fractionDescription') then result := FractionDescriptionList.new() {L1053}
  else if (propName = 'organism') then result := TFhirSubstanceSourceMaterialOrganism.create() {L1203}
  else if (propName = 'partDescription') then result := PartDescriptionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sourceMaterialClass') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialType') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialState') then result := 'CodeableConcept'
  else if (propName = 'organismId') then result := 'Identifier'
  else if (propName = 'organismName') then result := 'string'
  else if (propName = 'parentSubstanceId') then result := 'Identifier'
  else if (propName = 'parentSubstanceName') then result := 'string'
  else if (propName = 'countryOfOrigin') then result := 'CodeableConcept'
  else if (propName = 'geographicalLocation') then result := 'string'
  else if (propName = 'developmentStage') then result := 'CodeableConcept'
  else if (propName = 'fractionDescription') then result := 'BackboneElement'
  else if (propName = 'organism') then result := 'BackboneElement'
  else if (propName = 'partDescription') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := nil
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := nil
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := nil
  else if (propName = 'organismId') then OrganismIdElement := nil
  else if (propName = 'organismName') then OrganismNameElement := nil
  else if (propName = 'parentSubstanceId') then deletePropertyValue('parentSubstanceId', ParentSubstanceIdList, value) {L1054}
  else if (propName = 'parentSubstanceName') then deletePropertyValue('parentSubstanceName', ParentSubstanceNameList, value) {L1054}
  else if (propName = 'countryOfOrigin') then deletePropertyValue('countryOfOrigin', CountryOfOriginList, value) {L1054}
  else if (propName = 'geographicalLocation') then deletePropertyValue('geographicalLocation', GeographicalLocationList, value) {L1054}
  else if (propName = 'developmentStage') then DevelopmentStageElement := nil
  else if (propName = 'fractionDescription') then deletePropertyValue('fractionDescription', FractionDescriptionList, value) {L1054}
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'partDescription') then deletePropertyValue('partDescription', PartDescriptionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'organismId') then OrganismIdElement := new as TFhirIdentifier {L1195}
  else if (propName = 'organismName') then OrganismNameElement := asString(new) {L1222}
  else if (propName = 'parentSubstanceId') then replacePropertyValue('parentSubstanceId', ParentSubstanceIdList, existing, new) {L1055}
  else if (propName = 'parentSubstanceName') then replacePropertyValue('parentSubstanceName', ParentSubstanceNameList, existing, new) {L1055}
  else if (propName = 'countryOfOrigin') then replacePropertyValue('countryOfOrigin', CountryOfOriginList, existing, new) {L1055}
  else if (propName = 'geographicalLocation') then replacePropertyValue('geographicalLocation', GeographicalLocationList, existing, new) {L1055}
  else if (propName = 'developmentStage') then DevelopmentStageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'fractionDescription') then replacePropertyValue('fractionDescription', FractionDescriptionList, existing, new) {L1055}
  else if (propName = 'organism') then OrganismElement := new as TFhirSubstanceSourceMaterialOrganism {L1195}
  else if (propName = 'partDescription') then replacePropertyValue('partDescription', PartDescriptionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.move(source, destination) {L1050}
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.move(source, destination) {L1046}
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.move(source, destination) {L1050}
  else if (propName = 'geographicalLocation') then GeographicalLocationList.move(source, destination) {L1046}
  else if (propName = 'fractionDescription') then FractionDescriptionList.move(source, destination) {L1050}
  else if (propName = 'partDescription') then PartDescriptionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterial.fhirType : string;
begin
  result := 'SubstanceSourceMaterial';
end;

function TFhirSubstanceSourceMaterial.Link : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Link);
end;

function TFhirSubstanceSourceMaterial.Clone : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Clone);
end;

function TFhirSubstanceSourceMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterial(other);
    result := compareDeep(sourceMaterialClassElement, o.sourceMaterialClassElement, true) and 
      compareDeep(sourceMaterialTypeElement, o.sourceMaterialTypeElement, true) and 
      compareDeep(sourceMaterialStateElement, o.sourceMaterialStateElement, true) and 
      compareDeep(organismIdElement, o.organismIdElement, true) and compareDeep(organismNameElement, o.organismNameElement, true) and 
      compareDeep(parentSubstanceIdList, o.parentSubstanceIdList, true) and compareDeep(parentSubstanceNameList, o.parentSubstanceNameList, true) and 
      compareDeep(countryOfOriginList, o.countryOfOriginList, true) and compareDeep(geographicalLocationList, o.geographicalLocationList, true) and 
      compareDeep(developmentStageElement, o.developmentStageElement, true) and compareDeep(fractionDescriptionList, o.fractionDescriptionList, true) and 
      compareDeep(organismElement, o.organismElement, true) and compareDeep(partDescriptionList, o.partDescriptionList, true);
  end;
end;

function TFhirSubstanceSourceMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSourceMaterialClass) and isEmptyProp(FSourceMaterialType) and isEmptyProp(FSourceMaterialState) and isEmptyProp(FOrganismId) and isEmptyProp(FOrganismName) and isEmptyProp(FparentSubstanceIdList) and isEmptyProp(FparentSubstanceNameList) and isEmptyProp(FcountryOfOriginList) and isEmptyProp(FgeographicalLocationList) and isEmptyProp(FDevelopmentStage) and isEmptyProp(FfractionDescriptionList) and isEmptyProp(FOrganism) and isEmptyProp(FpartDescriptionList);
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialClass(value : TFhirCodeableConcept);
begin
  FSourceMaterialClass.free;
  FSourceMaterialClass := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialType(value : TFhirCodeableConcept);
begin
  FSourceMaterialType.free;
  FSourceMaterialType := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterial.SetSourceMaterialState(value : TFhirCodeableConcept);
begin
  FSourceMaterialState.free;
  FSourceMaterialState := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismId(value : TFhirIdentifier);
begin
  FOrganismId.free;
  FOrganismId := value; {L1134}
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismName(value : TFhirString);
begin
  FOrganismName.free;
  FOrganismName := value; {L1134}
end;

function TFhirSubstanceSourceMaterial.GetOrganismNameST : String;
begin
  if FOrganismName = nil then
    result := ''
  else
    result := FOrganismName.value;
end;

procedure TFhirSubstanceSourceMaterial.SetOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FOrganismName = nil then
      FOrganismName := TFhirString.create;
    FOrganismName.value := value
  end
  else if FOrganismName <> nil then
    FOrganismName.value := '';
end;

function TFhirSubstanceSourceMaterial.GetParentSubstanceIdList : TFhirIdentifierList;
begin
  if FParentSubstanceIdList = nil then
    FParentSubstanceIdList := TFhirIdentifierList.Create;
  result := FParentSubstanceIdList;
end;

function TFhirSubstanceSourceMaterial.GetHasParentSubstanceIdList : boolean;
begin
  result := (FParentSubstanceIdList <> nil) and (FParentSubstanceIdList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetParentSubstanceNameList : TFhirStringList;
begin
  if FParentSubstanceNameList = nil then
    FParentSubstanceNameList := TFhirStringList.Create;
  result := FParentSubstanceNameList;
end;

function TFhirSubstanceSourceMaterial.GetHasParentSubstanceNameList : boolean;
begin
  result := (FParentSubstanceNameList <> nil) and (FParentSubstanceNameList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetCountryOfOriginList : TFhirCodeableConceptList;
begin
  if FCountryOfOriginList = nil then
    FCountryOfOriginList := TFhirCodeableConceptList.Create;
  result := FCountryOfOriginList;
end;

function TFhirSubstanceSourceMaterial.GetHasCountryOfOriginList : boolean;
begin
  result := (FCountryOfOriginList <> nil) and (FCountryOfOriginList.count > 0);
end;

function TFhirSubstanceSourceMaterial.GetGeographicalLocationList : TFhirStringList;
begin
  if FGeographicalLocationList = nil then
    FGeographicalLocationList := TFhirStringList.Create;
  result := FGeographicalLocationList;
end;

function TFhirSubstanceSourceMaterial.GetHasGeographicalLocationList : boolean;
begin
  result := (FGeographicalLocationList <> nil) and (FGeographicalLocationList.count > 0);
end;

procedure TFhirSubstanceSourceMaterial.SetDevelopmentStage(value : TFhirCodeableConcept);
begin
  FDevelopmentStage.free;
  FDevelopmentStage := value; {L1134}
end;

function TFhirSubstanceSourceMaterial.GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  if FFractionDescriptionList = nil then
    FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
  result := FFractionDescriptionList;
end;

function TFhirSubstanceSourceMaterial.GetHasFractionDescriptionList : boolean;
begin
  result := (FFractionDescriptionList <> nil) and (FFractionDescriptionList.count > 0);
end;

procedure TFhirSubstanceSourceMaterial.SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
begin
  FOrganism.free;
  FOrganism := value; {L1134}
end;

function TFhirSubstanceSourceMaterial.GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  if FPartDescriptionList = nil then
    FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
  result := FPartDescriptionList;
end;

function TFhirSubstanceSourceMaterial.GetHasPartDescriptionList : boolean;
begin
  result := (FPartDescriptionList <> nil) and (FPartDescriptionList.count > 0);
end;

procedure TFhirSubstanceSourceMaterial.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sourceMaterialClass');
  fields.add('sourceMaterialType');
  fields.add('sourceMaterialState');
  fields.add('organismId');
  fields.add('organismName');
  fields.add('parentSubstanceId');
  fields.add('parentSubstanceName');
  fields.add('countryOfOrigin');
  fields.add('geographicalLocation');
  fields.add('developmentStage');
  fields.add('fractionDescription');
  fields.add('organism');
  fields.add('partDescription');
end;

function TFhirSubstanceSourceMaterial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSourceMaterialClass.sizeInBytes);
  inc(result, FSourceMaterialType.sizeInBytes);
  inc(result, FSourceMaterialState.sizeInBytes);
  inc(result, FOrganismId.sizeInBytes);
  inc(result, FOrganismName.sizeInBytes);
  inc(result, FparentSubstanceIdList.sizeInBytes);
  inc(result, FparentSubstanceNameList.sizeInBytes);
  inc(result, FcountryOfOriginList.sizeInBytes);
  inc(result, FgeographicalLocationList.sizeInBytes);
  inc(result, FDevelopmentStage.sizeInBytes);
  inc(result, FfractionDescriptionList.sizeInBytes);
  inc(result, FOrganism.sizeInBytes);
  inc(result, FpartDescriptionList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialListEnumerator }

constructor TFhirSubstanceSourceMaterialListEnumerator.Create(list : TFhirSubstanceSourceMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialListEnumerator.GetCurrent : TFhirSubstanceSourceMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialList }

procedure TFhirSubstanceSourceMaterialList.AddItem(value: TFhirSubstanceSourceMaterial);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterial');
  add(value);
end;

function TFhirSubstanceSourceMaterialList.Append: TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialList.GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialList.Clone: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialList.GetItemN(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterial;
end;
function TFhirSubstanceSourceMaterialList.IndexOf(value: TFhirSubstanceSourceMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialList.Insert(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialList.Item(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.Link: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  FhirSubstanceSourceMaterials[index] := value;
end;

procedure TFhirSubstanceSourceMaterialList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}

end.

