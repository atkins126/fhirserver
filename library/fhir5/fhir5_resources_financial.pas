unit fhir5_resources_financial;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Fri, Aug 21, 2020 11:27+1000 for FHIR v4.5.0

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base,
  fhir5_resources_canonical;

type
{$IFDEF FHIR_ACCOUNT}
  TFhirAccountCoverage = class;
  TFhirAccountCoverageList = class;
  TFhirAccountGuarantor = class;
  TFhirAccountGuarantorList = class;
  TFhirAccount = class;
  TFhirAccountList = class;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
  TFhirChargeItemPerformer = class;
  TFhirChargeItemPerformerList = class;
  TFhirChargeItem = class;
  TFhirChargeItemList = class;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  TFhirChargeItemDefinitionApplicability = class;
  TFhirChargeItemDefinitionApplicabilityList = class;
  TFhirChargeItemDefinitionPropertyGroup = class;
  TFhirChargeItemDefinitionPropertyGroupList = class;
  TFhirChargeItemDefinitionPropertyGroupPriceComponent = class;
  TFhirChargeItemDefinitionPropertyGroupPriceComponentList = class;
  TFhirChargeItemDefinition = class;
  TFhirChargeItemDefinitionList = class;
{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  TFhirCitationSummary = class;
  TFhirCitationSummaryList = class;
  TFhirCitationVariantCitation = class;
  TFhirCitationVariantCitationList = class;
  TFhirCitationJournal = class;
  TFhirCitationJournalList = class;
  TFhirCitationJournalJournalIssue = class;
  TFhirCitationJournalJournalIssueList = class;
  TFhirCitationJournalJournalIssuePublicationDate = class;
  TFhirCitationJournalJournalIssuePublicationDateList = class;
  TFhirCitationPublicationInfo = class;
  TFhirCitationPublicationInfoList = class;
  TFhirCitationPublicationInfoPublishedIn = class;
  TFhirCitationPublicationInfoPublishedInList = class;
  TFhirCitationAlternativeTitle = class;
  TFhirCitationAlternativeTitleList = class;
  TFhirCitationPagination = class;
  TFhirCitationPaginationList = class;
  TFhirCitationArticleUrl = class;
  TFhirCitationArticleUrlList = class;
  TFhirCitationAlternativeAbstract = class;
  TFhirCitationAlternativeAbstractList = class;
  TFhirCitationContributorship = class;
  TFhirCitationContributorshipList = class;
  TFhirCitationContributorshipEntry = class;
  TFhirCitationContributorshipEntryList = class;
  TFhirCitationContributorshipEntryAffiliationInfo = class;
  TFhirCitationContributorshipEntryAffiliationInfoList = class;
  TFhirCitationContributorshipSummary = class;
  TFhirCitationContributorshipSummaryList = class;
  TFhirCitationAlternativeForm = class;
  TFhirCitationAlternativeFormList = class;
  TFhirCitationAlternativeFormJournalIssue = class;
  TFhirCitationAlternativeFormJournalIssueList = class;
  TFhirCitationAlternativeFormJournalIssuePublicationDate = class;
  TFhirCitationAlternativeFormJournalIssuePublicationDateList = class;
  TFhirCitationAlternativeFormPagination = class;
  TFhirCitationAlternativeFormPaginationList = class;
  TFhirCitationAlternativeFormPublicationInfo = class;
  TFhirCitationAlternativeFormPublicationInfoList = class;
  TFhirCitationAlternativeFormPublicationInfoPublishedIn = class;
  TFhirCitationAlternativeFormPublicationInfoPublishedInList = class;
  TFhirCitationKeywordList = class;
  TFhirCitationKeywordListList = class;
  TFhirCitationKeywordListKeyword = class;
  TFhirCitationKeywordListKeywordList = class;
  TFhirCitationMedlinePubMed = class;
  TFhirCitationMedlinePubMedList = class;
  TFhirCitationMedlinePubMedPubMedPubDate = class;
  TFhirCitationMedlinePubMedPubMedPubDateList = class;
  TFhirCitationMedlinePubMedRelatedArticle = class;
  TFhirCitationMedlinePubMedRelatedArticleList = class;
  TFhirCitation = class;
  TFhirCitationList = class;
{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  TFhirClaimRelated = class;
  TFhirClaimRelatedList = class;
  TFhirClaimPayee = class;
  TFhirClaimPayeeList = class;
  TFhirClaimCareTeam = class;
  TFhirClaimCareTeamList = class;
  TFhirClaimSupportingInfo = class;
  TFhirClaimSupportingInfoList = class;
  TFhirClaimDiagnosis = class;
  TFhirClaimDiagnosisList = class;
  TFhirClaimProcedure = class;
  TFhirClaimProcedureList = class;
  TFhirClaimInsurance = class;
  TFhirClaimInsuranceList = class;
  TFhirClaimAccident = class;
  TFhirClaimAccidentList = class;
  TFhirClaimItem = class;
  TFhirClaimItemList = class;
  TFhirClaimItemDetail = class;
  TFhirClaimItemDetailList = class;
  TFhirClaimItemDetailSubDetail = class;
  TFhirClaimItemDetailSubDetailList = class;
  TFhirClaim = class;
  TFhirClaimList = class;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  TFhirClaimResponseItem = class;
  TFhirClaimResponseItemList = class;
  TFhirClaimResponseItemAdjudication = class;
  TFhirClaimResponseItemAdjudicationList = class;
  TFhirClaimResponseItemDetail = class;
  TFhirClaimResponseItemDetailList = class;
  TFhirClaimResponseItemDetailSubDetail = class;
  TFhirClaimResponseItemDetailSubDetailList = class;
  TFhirClaimResponseAddItem = class;
  TFhirClaimResponseAddItemList = class;
  TFhirClaimResponseAddItemDetail = class;
  TFhirClaimResponseAddItemDetailList = class;
  TFhirClaimResponseAddItemDetailSubDetail = class;
  TFhirClaimResponseAddItemDetailSubDetailList = class;
  TFhirClaimResponseTotal = class;
  TFhirClaimResponseTotalList = class;
  TFhirClaimResponsePayment = class;
  TFhirClaimResponsePaymentList = class;
  TFhirClaimResponseProcessNote = class;
  TFhirClaimResponseProcessNoteList = class;
  TFhirClaimResponseInsurance = class;
  TFhirClaimResponseInsuranceList = class;
  TFhirClaimResponseError = class;
  TFhirClaimResponseErrorList = class;
  TFhirClaimResponse = class;
  TFhirClaimResponseList = class;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
  TFhirCoverageClass = class;
  TFhirCoverageClassList = class;
  TFhirCoverageCostToBeneficiary = class;
  TFhirCoverageCostToBeneficiaryList = class;
  TFhirCoverageCostToBeneficiaryException = class;
  TFhirCoverageCostToBeneficiaryExceptionList = class;
  TFhirCoverage = class;
  TFhirCoverageList = class;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  TFhirCoverageEligibilityRequestSupportingInfo = class;
  TFhirCoverageEligibilityRequestSupportingInfoList = class;
  TFhirCoverageEligibilityRequestInsurance = class;
  TFhirCoverageEligibilityRequestInsuranceList = class;
  TFhirCoverageEligibilityRequestItem = class;
  TFhirCoverageEligibilityRequestItemList = class;
  TFhirCoverageEligibilityRequestItemDiagnosis = class;
  TFhirCoverageEligibilityRequestItemDiagnosisList = class;
  TFhirCoverageEligibilityRequest = class;
  TFhirCoverageEligibilityRequestList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  TFhirCoverageEligibilityResponseInsurance = class;
  TFhirCoverageEligibilityResponseInsuranceList = class;
  TFhirCoverageEligibilityResponseInsuranceItem = class;
  TFhirCoverageEligibilityResponseInsuranceItemList = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class;
  TFhirCoverageEligibilityResponseError = class;
  TFhirCoverageEligibilityResponseErrorList = class;
  TFhirCoverageEligibilityResponse = class;
  TFhirCoverageEligibilityResponseList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  TFhirEnrollmentRequest = class;
  TFhirEnrollmentRequestList = class;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  TFhirEnrollmentResponse = class;
  TFhirEnrollmentResponseList = class;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  TFhirExplanationOfBenefitRelated = class;
  TFhirExplanationOfBenefitRelatedList = class;
  TFhirExplanationOfBenefitPayee = class;
  TFhirExplanationOfBenefitPayeeList = class;
  TFhirExplanationOfBenefitCareTeam = class;
  TFhirExplanationOfBenefitCareTeamList = class;
  TFhirExplanationOfBenefitSupportingInfo = class;
  TFhirExplanationOfBenefitSupportingInfoList = class;
  TFhirExplanationOfBenefitDiagnosis = class;
  TFhirExplanationOfBenefitDiagnosisList = class;
  TFhirExplanationOfBenefitProcedure = class;
  TFhirExplanationOfBenefitProcedureList = class;
  TFhirExplanationOfBenefitInsurance = class;
  TFhirExplanationOfBenefitInsuranceList = class;
  TFhirExplanationOfBenefitAccident = class;
  TFhirExplanationOfBenefitAccidentList = class;
  TFhirExplanationOfBenefitItem = class;
  TFhirExplanationOfBenefitItemList = class;
  TFhirExplanationOfBenefitItemAdjudication = class;
  TFhirExplanationOfBenefitItemAdjudicationList = class;
  TFhirExplanationOfBenefitItemDetail = class;
  TFhirExplanationOfBenefitItemDetailList = class;
  TFhirExplanationOfBenefitItemDetailSubDetail = class;
  TFhirExplanationOfBenefitItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitAddItem = class;
  TFhirExplanationOfBenefitAddItemList = class;
  TFhirExplanationOfBenefitAddItemDetail = class;
  TFhirExplanationOfBenefitAddItemDetailList = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitTotal = class;
  TFhirExplanationOfBenefitTotalList = class;
  TFhirExplanationOfBenefitPayment = class;
  TFhirExplanationOfBenefitPaymentList = class;
  TFhirExplanationOfBenefitProcessNote = class;
  TFhirExplanationOfBenefitProcessNoteList = class;
  TFhirExplanationOfBenefitBenefitBalance = class;
  TFhirExplanationOfBenefitBenefitBalanceList = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class;
  TFhirExplanationOfBenefit = class;
  TFhirExplanationOfBenefitList = class;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
  TFhirInsurancePlanContact = class;
  TFhirInsurancePlanContactList = class;
  TFhirInsurancePlanCoverage = class;
  TFhirInsurancePlanCoverageList = class;
  TFhirInsurancePlanCoverageBenefit = class;
  TFhirInsurancePlanCoverageBenefitList = class;
  TFhirInsurancePlanCoverageBenefitLimit = class;
  TFhirInsurancePlanCoverageBenefitLimitList = class;
  TFhirInsurancePlanPlan = class;
  TFhirInsurancePlanPlanList = class;
  TFhirInsurancePlanPlanGeneralCost = class;
  TFhirInsurancePlanPlanGeneralCostList = class;
  TFhirInsurancePlanPlanSpecificCost = class;
  TFhirInsurancePlanPlanSpecificCostList = class;
  TFhirInsurancePlanPlanSpecificCostBenefit = class;
  TFhirInsurancePlanPlanSpecificCostBenefitList = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class;
  TFhirInsurancePlan = class;
  TFhirInsurancePlanList = class;
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  TFhirInvoiceParticipant = class;
  TFhirInvoiceParticipantList = class;
  TFhirInvoiceLineItem = class;
  TFhirInvoiceLineItemList = class;
  TFhirInvoiceLineItemPriceComponent = class;
  TFhirInvoiceLineItemPriceComponentList = class;
  TFhirInvoice = class;
  TFhirInvoiceList = class;
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
  TFhirPaymentNotice = class;
  TFhirPaymentNoticeList = class;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  TFhirPaymentReconciliationDetail = class;
  TFhirPaymentReconciliationDetailList = class;
  TFhirPaymentReconciliationProcessNote = class;
  TFhirPaymentReconciliationProcessNoteList = class;
  TFhirPaymentReconciliation = class;
  TFhirPaymentReconciliationList = class;
{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_ACCOUNT}
  // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
  TFhirAccountCoverage = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference;
    FPriority : TFhirPositiveInt;
    procedure SetCoverage(value : TFhirReference);
    procedure SetPriority(value : TFhirPositiveInt);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);

    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountCoverage; overload;
    function Clone : TFhirAccountCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).  A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // The party(s) that contribute to payment (or part of) of the charges applied to this account (including self-pay).  A coverage may only be responsible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to The priority of the coverage in the context of this account.
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the coverage in the context of this account.
    property priorityElement : TFhirPositiveInt read FPriority write SetPriority;

  end;

  TFhirAccountCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountCoverageList;
    function GetCurrent : TFhirAccountCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountCoverage read GetCurrent;
  end;

  TFhirAccountCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccountCoverage;
    procedure SetItemN(index : Integer; value : TFhirAccountCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountCoverageList; overload;
    function Clone : TFhirAccountCoverageList; overload;
    function GetEnumerator : TFhirAccountCoverageListEnumerator;
    
    //  Add a FhirAccountCoverage to the end of the list.
    function Append : TFhirAccountCoverage;
    
    // Add an already existing FhirAccountCoverage to the end of the list.
    procedure AddItem(value : TFhirAccountCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountCoverage) : Integer;
    
    // Insert FhirAccountCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountCoverage;
    
    // Insert an existing FhirAccountCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountCoverage);
    
    // Get the iIndexth FhirAccountCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccountCoverages[index : Integer] : TFhirAccountCoverage read GetItemN write SetItemN; default;
  End;

  // The parties responsible for balancing the account if other payment options fall short.
  TFhirAccountGuarantor = class (TFhirBackboneElement)
  protected
    FParty : TFhirReference;
    FOnHold : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetParty(value : TFhirReference);
    procedure SetOnHold(value : TFhirBoolean);
    function GetOnHoldST : Boolean;
    procedure SetOnHoldST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountGuarantor; overload;
    function Clone : TFhirAccountGuarantor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The entity who is responsible. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // The entity who is responsible.
    property partyElement : TFhirReference read FParty write SetParty;

    // Typed access to A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHold : Boolean read GetOnHoldST write SetOnHoldST;
    // A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHoldElement : TFhirBoolean read FOnHold write SetOnHold;

    // Typed access to The timeframe during which the guarantor accepts responsibility for the account. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe during which the guarantor accepts responsibility for the account.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAccountGuarantorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountGuarantorList;
    function GetCurrent : TFhirAccountGuarantor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountGuarantorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountGuarantor read GetCurrent;
  end;

  TFhirAccountGuarantorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccountGuarantor;
    procedure SetItemN(index : Integer; value : TFhirAccountGuarantor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountGuarantorList; overload;
    function Clone : TFhirAccountGuarantorList; overload;
    function GetEnumerator : TFhirAccountGuarantorListEnumerator;
    
    //  Add a FhirAccountGuarantor to the end of the list.
    function Append : TFhirAccountGuarantor;
    
    // Add an already existing FhirAccountGuarantor to the end of the list.
    procedure AddItem(value : TFhirAccountGuarantor); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountGuarantor) : Integer;
    
    // Insert FhirAccountGuarantor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountGuarantor;
    
    // Insert an existing FhirAccountGuarantor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountGuarantor);
    
    // Get the iIndexth FhirAccountGuarantor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountGuarantor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountGuarantor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccountGuarantors[index : Integer] : TFhirAccountGuarantor read GetItemN write SetItemN; default;
  End;

  // A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
  TFhirAccount = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    FsubjectList : TFhirReferenceList;
    FServicePeriod : TFhirPeriod;
    FcoverageList : TFhirAccountCoverageList;
    FOwner : TFhirReference;
    FDescription : TFhirString;
    FguarantorList : TFhirAccountGuarantorList;
    FPartOf : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirAccountStatusEnum;
    procedure SetStatusST(value : TFhirAccountStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetServicePeriod(value : TFhirPeriod);
    function GetCoverageList : TFhirAccountCoverageList;
    function GetHasCoverageList : Boolean;
    procedure SetOwner(value : TFhirReference);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetGuarantorList : TFhirAccountGuarantorList;
    function GetHasGuarantorList : Boolean;
    procedure SetPartOf(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccount; overload;
    function Clone : TFhirAccount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier used to reference the account.  Might or might not be intended for human use (e.g. credit card number).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates whether the account is presently used/usable or not.
    property status : TFhirAccountStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Categorizes the account for reporting and searching purposes. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes the account for reporting and searching purposes.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name used for the account when displaying it to humans in reports, etc.
    property name : String read GetNameST write SetNameST;
    // Name used for the account when displaying it to humans in reports, etc.
    property nameElement : TFhirString read FName write SetName;

    // Identifies the entity which incurs the expenses. While the immediate recipients of services or goods might be entities related to the subject, the expenses were ultimately incurred by the subject of the Account.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The date range of services associated with this account. (defined for API consistency)
    property servicePeriod : TFhirPeriod read FServicePeriod write SetServicePeriod;
    // The date range of services associated with this account.
    property servicePeriodElement : TFhirPeriod read FServicePeriod write SetServicePeriod;

    // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
    property coverageList : TFhirAccountCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Typed access to Indicates the service area, hospital, department, etc. with responsibility for managing the Account. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // Indicates the service area, hospital, department, etc. with responsibility for managing the Account.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Typed access to Provides additional information about what the account tracks and how it is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Provides additional information about what the account tracks and how it is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The parties responsible for balancing the account if other payment options fall short.
    property guarantorList : TFhirAccountGuarantorList read GetGuarantorList;
    property hasGuarantorList : boolean read GetHasGuarantorList;

    // Typed access to Reference to a parent Account. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Reference to a parent Account.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

  end;

  TFhirAccountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountList;
    function GetCurrent : TFhirAccount;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccount read GetCurrent;
  end;

  TFhirAccountList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAccount;
    procedure SetItemN(index : Integer; value : TFhirAccount);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAccountList; overload;
    function Clone : TFhirAccountList; overload;
    function GetEnumerator : TFhirAccountListEnumerator;
    
    //  Add a FhirAccount to the end of the list.
    function Append : TFhirAccount;
    
    // Add an already existing FhirAccount to the end of the list.
    procedure AddItem(value : TFhirAccount); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccount) : Integer;
    
    // Insert FhirAccount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccount;
    
    // Insert an existing FhirAccount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccount);
    
    // Get the iIndexth FhirAccount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccount);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAccount;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAccounts[index : Integer] : TFhirAccount read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
  // Indicates who or what performed or participated in the charged service.
  TFhirChargeItemPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemPerformer; overload;
    function Clone : TFhirChargeItemPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.). (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.).
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirChargeItemPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemPerformerList;
    function GetCurrent : TFhirChargeItemPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemPerformer read GetCurrent;
  end;

  TFhirChargeItemPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemPerformer;
    procedure SetItemN(index : Integer; value : TFhirChargeItemPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemPerformerList; overload;
    function Clone : TFhirChargeItemPerformerList; overload;
    function GetEnumerator : TFhirChargeItemPerformerListEnumerator;
    
    //  Add a FhirChargeItemPerformer to the end of the list.
    function Append : TFhirChargeItemPerformer;
    
    // Add an already existing FhirChargeItemPerformer to the end of the list.
    procedure AddItem(value : TFhirChargeItemPerformer); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemPerformer) : Integer;
    
    // Insert FhirChargeItemPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemPerformer;
    
    // Insert an existing FhirChargeItemPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemPerformer);
    
    // Get the iIndexth FhirChargeItemPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemPerformers[index : Integer] : TFhirChargeItemPerformer read GetItemN write SetItemN; default;
  End;

  // The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
  TFhirChargeItem = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionUriList : TFhirUriList;
    FdefinitionCanonicalList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FpartOfList : TFhirReferenceList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FContext : TFhirReference;
    FOccurrence : TFhirDataType;
    FperformerList : TFhirChargeItemPerformerList;
    FPerformingOrganization : TFhirReference;
    FRequestingOrganization : TFhirReference;
    FCostCenter : TFhirReference;
    FQuantity : TFhirQuantity;
    FbodysiteList : TFhirCodeableConceptList;
    FFactorOverride : TFhirDecimal;
    FPriceOverride : TFhirMoney;
    FOverrideReason : TFhirString;
    FEnterer : TFhirReference;
    FEnteredDate : TFhirDateTime;
    FreasonList : TFhirCodeableConceptList;
    FserviceList : TFhirReferenceList;
    FProduct : TFhirDataType;
    FaccountList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FsupportingInformationList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionUriList : TFhirUriList;
    function GetHasDefinitionUriList : Boolean;
    function GetDefinitionCanonicalList : TFhirCanonicalList;
    function GetHasDefinitionCanonicalList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirChargeItemStatusEnum;
    procedure SetStatusST(value : TFhirChargeItemStatusEnum);
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetContext(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    function GetPerformerList : TFhirChargeItemPerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetPerformingOrganization(value : TFhirReference);
    procedure SetRequestingOrganization(value : TFhirReference);
    procedure SetCostCenter(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    function GetBodysiteList : TFhirCodeableConceptList;
    function GetHasBodysiteList : Boolean;
    procedure SetFactorOverride(value : TFhirDecimal);
    function GetFactorOverrideST : String;
    procedure SetFactorOverrideST(value : String);
    procedure SetPriceOverride(value : TFhirMoney);
    procedure SetOverrideReason(value : TFhirString);
    function GetOverrideReasonST : String;
    procedure SetOverrideReasonST(value : String);
    procedure SetEnterer(value : TFhirReference);
    procedure SetEnteredDate(value : TFhirDateTime);
    function GetEnteredDateST : TFslDateTime;
    procedure SetEnteredDateST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetServiceList : TFhirReferenceList;
    function GetHasServiceList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItem; overload;
    function Clone : TFhirChargeItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this event performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // References the (external) source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionUriList : TFhirUriList read GetDefinitionUriList;
    property hasDefinitionUriList : boolean read GetHasDefinitionUriList;

    // References the source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionCanonicalList : TFhirCanonicalList read GetDefinitionCanonicalList;
    property hasDefinitionCanonicalList : boolean read GetHasDefinitionCanonicalList;

    // The current state of the ChargeItem.
    property status : TFhirChargeItemStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // ChargeItems can be grouped to larger ChargeItems covering the whole set.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to A code that identifies the charge, like a billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the charge, like a billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The individual or set of individuals the action is being or was performed on. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The individual or set of individuals the action is being or was performed on.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference read FContext write SetContext;

    // Typed access to Date/time(s) or duration when the charged service was applied. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // Date/time(s) or duration when the charged service was applied.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Indicates who or what performed or participated in the charged service.
    property performerList : TFhirChargeItemPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The organization requesting the service. (defined for API consistency)
    property performingOrganization : TFhirReference read FPerformingOrganization write SetPerformingOrganization;
    // The organization requesting the service.
    property performingOrganizationElement : TFhirReference read FPerformingOrganization write SetPerformingOrganization;

    // Typed access to The organization performing the service. (defined for API consistency)
    property requestingOrganization : TFhirReference read FRequestingOrganization write SetRequestingOrganization;
    // The organization performing the service.
    property requestingOrganizationElement : TFhirReference read FRequestingOrganization write SetRequestingOrganization;

    // Typed access to The financial cost center permits the tracking of charge attribution. (defined for API consistency)
    property costCenter : TFhirReference read FCostCenter write SetCostCenter;
    // The financial cost center permits the tracking of charge attribution.
    property costCenterElement : TFhirReference read FCostCenter write SetCostCenter;

    // Typed access to Quantity of which the charge item has been serviced. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Quantity of which the charge item has been serviced.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The anatomical location where the related service has been applied.
    property bodysiteList : TFhirCodeableConceptList read GetBodysiteList;
    property hasBodysiteList : boolean read GetHasBodysiteList;

    // Typed access to Factor overriding the factor determined by the rules associated with the code.
    property factorOverride : String read GetFactorOverrideST write SetFactorOverrideST;
    // Factor overriding the factor determined by the rules associated with the code.
    property factorOverrideElement : TFhirDecimal read FFactorOverride write SetFactorOverride;

    // Typed access to Total price of the charge overriding the list price associated with the code. (defined for API consistency)
    property priceOverride : TFhirMoney read FPriceOverride write SetPriceOverride;
    // Total price of the charge overriding the list price associated with the code.
    property priceOverrideElement : TFhirMoney read FPriceOverride write SetPriceOverride;

    // Typed access to If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReason : String read GetOverrideReasonST write SetOverrideReasonST;
    // If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReasonElement : TFhirString read FOverrideReason write SetOverrideReason;

    // Typed access to The device, practitioner, etc. who entered the charge item. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // The device, practitioner, etc. who entered the charge item.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to Date the charge item was entered.
    property enteredDate : TFslDateTime read GetEnteredDateST write SetEnteredDateST;
    // Date the charge item was entered.
    property enteredDateElement : TFhirDateTime read FEnteredDate write SetEnteredDate;

    // Describes why the event occurred in coded or textual form.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Indicated the rendered service that caused this charge.
    property serviceList : TFhirReferenceList read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to Identifies the device, food, drug or other product being charged either by type code or reference to an instance. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the device, food, drug or other product being charged either by type code or reference to an instance.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Account into which this ChargeItems belongs.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Comments made about the event by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Further information supporting this charge.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

  end;

  TFhirChargeItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemList;
    function GetCurrent : TFhirChargeItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItem read GetCurrent;
  end;

  TFhirChargeItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItem;
    procedure SetItemN(index : Integer; value : TFhirChargeItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemList; overload;
    function Clone : TFhirChargeItemList; overload;
    function GetEnumerator : TFhirChargeItemListEnumerator;
    
    //  Add a FhirChargeItem to the end of the list.
    function Append : TFhirChargeItem;
    
    // Add an already existing FhirChargeItem to the end of the list.
    procedure AddItem(value : TFhirChargeItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItem) : Integer;
    
    // Insert FhirChargeItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItem;
    
    // Insert an existing FhirChargeItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItem);
    
    // Get the iIndexth FhirChargeItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItems[index : Integer] : TFhirChargeItem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
  // Expressions that describe applicability criteria for the billing code.
  TFhirChargeItemDefinitionApplicability = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetLanguage(value : TFhirString);
    function GetLanguageST : String;
    procedure SetLanguageST(value : String);
    procedure SetExpression(value : TFhirString);
    function GetExpressionST : String;
    procedure SetExpressionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionApplicability; overload;
    function Clone : TFhirChargeItemDefinitionApplicability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A brief, natural language description of the condition that effectively communicates the intended semantics.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the condition that effectively communicates the intended semantics.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The media type of the language for the expression, e.g. "text/cql" for Clinical Query Language expressions or "text/fhirpath" for FHIRPath expressions.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression, e.g. "text/cql" for Clinical Query Language expressions or "text/fhirpath" for FHIRPath expressions.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression that returns true or false, indicating whether the condition is satisfied. When using FHIRPath expressions, the %context environment variable must be replaced at runtime with the ChargeItem resource to which this definition is applied.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression that returns true or false, indicating whether the condition is satisfied. When using FHIRPath expressions, the %context environment variable must be replaced at runtime with the ChargeItem resource to which this definition is applied.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirChargeItemDefinitionApplicabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionApplicabilityList;
    function GetCurrent : TFhirChargeItemDefinitionApplicability;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionApplicabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionApplicability read GetCurrent;
  end;

  TFhirChargeItemDefinitionApplicabilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionApplicability;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionApplicability);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionApplicabilityList; overload;
    function Clone : TFhirChargeItemDefinitionApplicabilityList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionApplicabilityListEnumerator;
    
    //  Add a FhirChargeItemDefinitionApplicability to the end of the list.
    function Append : TFhirChargeItemDefinitionApplicability;
    
    // Add an already existing FhirChargeItemDefinitionApplicability to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionApplicability); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionApplicability) : Integer;
    
    // Insert FhirChargeItemDefinitionApplicability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionApplicability;
    
    // Insert an existing FhirChargeItemDefinitionApplicability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionApplicability);
    
    // Get the iIndexth FhirChargeItemDefinitionApplicability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionApplicability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionApplicability;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionApplicabilities[index : Integer] : TFhirChargeItemDefinitionApplicability read GetItemN write SetItemN; default;
  End;

  // Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
  TFhirChargeItemDefinitionPropertyGroup = class (TFhirBackboneElement)
  protected
    FapplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    FpriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    function GetHasApplicabilityList : Boolean;
    function GetPriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetHasPriceComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionPropertyGroup; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Expressions that describe applicability criteria for the priceComponent.
    property applicabilityList : TFhirChargeItemDefinitionApplicabilityList read GetApplicabilityList;
    property hasApplicabilityList : boolean read GetHasApplicabilityList;

    // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
    property priceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList read GetPriceComponentList;
    property hasPriceComponentList : boolean read GetHasPriceComponentList;

  end;

  TFhirChargeItemDefinitionPropertyGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionPropertyGroupList;
    function GetCurrent : TFhirChargeItemDefinitionPropertyGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionPropertyGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionPropertyGroup read GetCurrent;
  end;

  TFhirChargeItemDefinitionPropertyGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionPropertyGroupList; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionPropertyGroupListEnumerator;
    
    //  Add a FhirChargeItemDefinitionPropertyGroup to the end of the list.
    function Append : TFhirChargeItemDefinitionPropertyGroup;
    
    // Add an already existing FhirChargeItemDefinitionPropertyGroup to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionPropertyGroup); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionPropertyGroup) : Integer;
    
    // Insert FhirChargeItemDefinitionPropertyGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    
    // Insert an existing FhirChargeItemDefinitionPropertyGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
    
    // Get the iIndexth FhirChargeItemDefinitionPropertyGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionPropertyGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionPropertyGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionPropertyGroups[index : Integer] : TFhirChargeItemDefinitionPropertyGroup read GetItemN write SetItemN; default;
  End;

  // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the prices have been calculated.
  TFhirChargeItemDefinitionPropertyGroupPriceComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FFactor : TFhirDecimal;
    FAmount : TFhirMoney;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirInvoicePriceComponentTypeEnum;
    procedure SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This code identifies the type of the component.
    property type_ : TFhirInvoicePriceComponentTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The factor that has been applied on the base price for calculating this component.
    property factor : String read GetFactorST write SetFactorST;
    // The factor that has been applied on the base price for calculating this component.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The amount calculated for this component. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount calculated for this component.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
    function GetCurrent : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionPropertyGroupPriceComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinitionPropertyGroupPriceComponent read GetCurrent;
  end;

  TFhirChargeItemDefinitionPropertyGroupPriceComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionPropertyGroupPriceComponentList; overload;
    function Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponentList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator;
    
    //  Add a FhirChargeItemDefinitionPropertyGroupPriceComponent to the end of the list.
    function Append : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // Add an already existing FhirChargeItemDefinitionPropertyGroupPriceComponent to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinitionPropertyGroupPriceComponent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinitionPropertyGroupPriceComponent) : Integer;
    
    // Insert FhirChargeItemDefinitionPropertyGroupPriceComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // Insert an existing FhirChargeItemDefinitionPropertyGroupPriceComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
    
    // Get the iIndexth FhirChargeItemDefinitionPropertyGroupPriceComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinitionPropertyGroupPriceComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitionPropertyGroupPriceComponents[index : Integer] : TFhirChargeItemDefinitionPropertyGroupPriceComponent read GetItemN write SetItemN; default;
  End;

  // The ChargeItemDefinition resource provides the properties that apply to the (billing) codes necessary to calculate costs and prices. The properties may differ largely depending on type and realm, therefore this resource gives only a rough structure and requires profiling for each type of billing code system.
  TFhirChargeItemDefinition = class (TFhirMetadataResource)
  protected
    FderivedFromUriList : TFhirUriList;
    FpartOfList : TFhirCanonicalList;
    FreplacesList : TFhirCanonicalList;
    FCode : TFhirCodeableConcept;
    FinstanceList : TFhirReferenceList;
    FapplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    FpropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetDerivedFromUriList : TFhirUriList;
    function GetHasDerivedFromUriList : Boolean;
    function GetPartOfList : TFhirCanonicalList;
    function GetHasPartOfList : Boolean;
    function GetReplacesList : TFhirCanonicalList;
    function GetHasReplacesList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetInstanceList : TFhirReferenceList;
    function GetHasInstanceList : Boolean;
    function GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
    function GetHasApplicabilityList : Boolean;
    function GetPropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
    function GetHasPropertyGroupList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemDefinition; overload;
    function Clone : TFhirChargeItemDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this charge item definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this charge item definition is (or will be) {$IFNDEF FPC}published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the charge item definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this charge item definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this charge item definition is (or will be) {$IFNDEF FPC}published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the charge item definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this charge item definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the charge item definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the charge item definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the charge item definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the charge item definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A short, descriptive, user-friendly title for the charge item definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the charge item definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The URL pointing to an externally-defined charge item definition that is adhered to in whole or in part by this definition.
    property derivedFromUriList : TFhirUriList read GetDerivedFromUriList;
    property hasDerivedFromUriList : boolean read GetHasDerivedFromUriList;

    // A larger definition of which this particular definition is a component or step.
    property partOfList : TFhirCanonicalList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // As new versions of a protocol or guideline are defined, allows identification of what versions are replaced by a new instance.
    property replacesList : TFhirCanonicalList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // The current state of the ChargeItemDefinition.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this charge item definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this charge item definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the charge item definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the charge item definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the charge item definition was {$IFNDEF FPC}published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the charge item definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}published{$ENDIF} the charge item definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}published{$ENDIF} the charge item definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the charge item definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the charge item definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate charge item definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the charge item definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the charge item definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the charge item definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the charge item definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the charge item definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the charge item definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the charge item definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Typed access to The defined billing details in this resource pertain to the given billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The defined billing details in this resource pertain to the given billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The defined billing details in this resource pertain to the given product instance(s).
    property instanceList : TFhirReferenceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // Expressions that describe applicability criteria for the billing code.
    property applicabilityList : TFhirChargeItemDefinitionApplicabilityList read GetApplicabilityList;
    property hasApplicabilityList : boolean read GetHasApplicabilityList;

    // Group of properties which are applicable under the same conditions. If no applicability rules are established for the group, then all properties always apply.
    property propertyGroupList : TFhirChargeItemDefinitionPropertyGroupList read GetPropertyGroupList;
    property hasPropertyGroupList : boolean read GetHasPropertyGroupList;

  end;

  TFhirChargeItemDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemDefinitionList;
    function GetCurrent : TFhirChargeItemDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemDefinition read GetCurrent;
  end;

  TFhirChargeItemDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirChargeItemDefinition;
    procedure SetItemN(index : Integer; value : TFhirChargeItemDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirChargeItemDefinitionList; overload;
    function Clone : TFhirChargeItemDefinitionList; overload;
    function GetEnumerator : TFhirChargeItemDefinitionListEnumerator;
    
    //  Add a FhirChargeItemDefinition to the end of the list.
    function Append : TFhirChargeItemDefinition;
    
    // Add an already existing FhirChargeItemDefinition to the end of the list.
    procedure AddItem(value : TFhirChargeItemDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemDefinition) : Integer;
    
    // Insert FhirChargeItemDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemDefinition;
    
    // Insert an existing FhirChargeItemDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemDefinition);
    
    // Get the iIndexth FhirChargeItemDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirChargeItemDefinitions[index : Integer] : TFhirChargeItemDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
  // A human-readable display of the citation.
  TFhirCitationSummary = class (TFhirBackboneElement)
  protected
    FStyle : TFhirCodeableConcept;
    FText : TFhirMarkdown;
    procedure SetStyle(value : TFhirCodeableConcept);
    procedure SetText(value : TFhirMarkdown);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationSummary; overload;
    function Clone : TFhirCitationSummary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Format for display of the citation. (defined for API consistency)
    property style : TFhirCodeableConcept read FStyle write SetStyle;
    // Format for display of the citation.
    property styleElement : TFhirCodeableConcept read FStyle write SetStyle;

    // Typed access to The human-readable display of the citation.
    property text : String read GetTextST write SetTextST;
    // The human-readable display of the citation.
    property textElement : TFhirMarkdown read FText write SetText;

  end;

  TFhirCitationSummaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationSummaryList;
    function GetCurrent : TFhirCitationSummary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationSummaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationSummary read GetCurrent;
  end;

  TFhirCitationSummaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationSummary;
    procedure SetItemN(index : Integer; value : TFhirCitationSummary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationSummaryList; overload;
    function Clone : TFhirCitationSummaryList; overload;
    function GetEnumerator : TFhirCitationSummaryListEnumerator;
    
    //  Add a FhirCitationSummary to the end of the list.
    function Append : TFhirCitationSummary;
    
    // Add an already existing FhirCitationSummary to the end of the list.
    procedure AddItem(value : TFhirCitationSummary); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationSummary) : Integer;
    
    // Insert FhirCitationSummary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationSummary;
    
    // Insert an existing FhirCitationSummary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationSummary);
    
    // Get the iIndexth FhirCitationSummary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationSummary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationSummary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationSummaries[index : Integer] : TFhirCitationSummary read GetItemN write SetItemN; default;
  End;

  // Variant citation.
  TFhirCitationVariantCitation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    FBaseCitation : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetBaseCitation(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationVariantCitation; overload;
    function Clone : TFhirCitationVariantCitation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to describe the reason for the variant citation, such as version or subpart specification. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to describe the reason for the variant citation, such as version or subpart specification.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to describe the specific variation, such as version number or subpart specification.
    property value : String read GetValueST write SetValueST;
    // Used to describe the specific variation, such as version number or subpart specification.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Base citation. (defined for API consistency)
    property baseCitation : TFhirReference read FBaseCitation write SetBaseCitation;
    // Base citation.
    property baseCitationElement : TFhirReference read FBaseCitation write SetBaseCitation;

  end;

  TFhirCitationVariantCitationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationVariantCitationList;
    function GetCurrent : TFhirCitationVariantCitation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationVariantCitationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationVariantCitation read GetCurrent;
  end;

  TFhirCitationVariantCitationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationVariantCitation;
    procedure SetItemN(index : Integer; value : TFhirCitationVariantCitation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationVariantCitationList; overload;
    function Clone : TFhirCitationVariantCitationList; overload;
    function GetEnumerator : TFhirCitationVariantCitationListEnumerator;
    
    //  Add a FhirCitationVariantCitation to the end of the list.
    function Append : TFhirCitationVariantCitation;
    
    // Add an already existing FhirCitationVariantCitation to the end of the list.
    procedure AddItem(value : TFhirCitationVariantCitation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationVariantCitation) : Integer;
    
    // Insert FhirCitationVariantCitation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationVariantCitation;
    
    // Insert an existing FhirCitationVariantCitation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationVariantCitation);
    
    // Get the iIndexth FhirCitationVariantCitation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationVariantCitation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationVariantCitation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationVariantCitations[index : Integer] : TFhirCitationVariantCitation read GetItemN write SetItemN; default;
  End;

  // Contains identifiers and classifiers for the journal cited.
  TFhirCitationJournal = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCountry : TFhirString;
    FJournalIssue : TFhirCitationJournalJournalIssue;
    FTitle : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCountry(value : TFhirString);
    function GetCountryST : String;
    procedure SetCountryST(value : String);
    procedure SetJournalIssue(value : TFhirCitationJournalJournalIssue);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationJournal; overload;
    function Clone : TFhirCitationJournal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Journal identifiers include ISSN, ISO Abbreviation and NLMuniqueID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Place of publication of the journal.
    property country : String read GetCountryST write SetCountryST;
    // Place of publication of the journal.
    property countryElement : TFhirString read FCountry write SetCountry;

    // Typed access to The specific issue in which the cited article resides. (defined for API consistency)
    property journalIssue : TFhirCitationJournalJournalIssue read FJournalIssue write SetJournalIssue;
    // The specific issue in which the cited article resides.
    property journalIssueElement : TFhirCitationJournalJournalIssue read FJournalIssue write SetJournalIssue;

    // Typed access to Journal title.
    property title : String read GetTitleST write SetTitleST;
    // Journal title.
    property titleElement : TFhirString read FTitle write SetTitle;

  end;

  TFhirCitationJournalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationJournalList;
    function GetCurrent : TFhirCitationJournal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationJournalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationJournal read GetCurrent;
  end;

  TFhirCitationJournalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationJournal;
    procedure SetItemN(index : Integer; value : TFhirCitationJournal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationJournalList; overload;
    function Clone : TFhirCitationJournalList; overload;
    function GetEnumerator : TFhirCitationJournalListEnumerator;
    
    //  Add a FhirCitationJournal to the end of the list.
    function Append : TFhirCitationJournal;
    
    // Add an already existing FhirCitationJournal to the end of the list.
    procedure AddItem(value : TFhirCitationJournal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationJournal) : Integer;
    
    // Insert FhirCitationJournal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationJournal;
    
    // Insert an existing FhirCitationJournal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationJournal);
    
    // Get the iIndexth FhirCitationJournal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationJournal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationJournal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationJournals[index : Integer] : TFhirCitationJournal read GetItemN write SetItemN; default;
  End;

  // The specific issue in which the cited article resides.
  TFhirCitationJournalJournalIssue = class (TFhirBackboneElement)
  protected
    FCitedMedium : TFhirCodeableConcept;
    FVolume : TFhirString;
    FIssue : TFhirString;
    FPublicationDate : TFhirCitationJournalJournalIssuePublicationDate;
    procedure SetCitedMedium(value : TFhirCodeableConcept);
    procedure SetVolume(value : TFhirString);
    function GetVolumeST : String;
    procedure SetVolumeST(value : String);
    procedure SetIssue(value : TFhirString);
    function GetIssueST : String;
    procedure SetIssueST(value : String);
    procedure SetPublicationDate(value : TFhirCitationJournalJournalIssuePublicationDate);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationJournalJournalIssue; overload;
    function Clone : TFhirCitationJournalJournalIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to NLM codes Internet or Print. (defined for API consistency)
    property citedMedium : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;
    // NLM codes Internet or Print.
    property citedMediumElement : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;

    // Typed access to Volume number of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property volume : String read GetVolumeST write SetVolumeST;
    // Volume number of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property volumeElement : TFhirString read FVolume write SetVolume;

    // Typed access to Issue, part or supplement of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property issue : String read GetIssueST write SetIssueST;
    // Issue, part or supplement of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property issueElement : TFhirString read FIssue write SetIssue;

    // Typed access to Date on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}. (defined for API consistency)
    property publicationDate : TFhirCitationJournalJournalIssuePublicationDate read FPublicationDate write SetPublicationDate;
    // Date on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property publicationDateElement : TFhirCitationJournalJournalIssuePublicationDate read FPublicationDate write SetPublicationDate;

  end;

  TFhirCitationJournalJournalIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationJournalJournalIssueList;
    function GetCurrent : TFhirCitationJournalJournalIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationJournalJournalIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationJournalJournalIssue read GetCurrent;
  end;

  TFhirCitationJournalJournalIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationJournalJournalIssue;
    procedure SetItemN(index : Integer; value : TFhirCitationJournalJournalIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationJournalJournalIssueList; overload;
    function Clone : TFhirCitationJournalJournalIssueList; overload;
    function GetEnumerator : TFhirCitationJournalJournalIssueListEnumerator;
    
    //  Add a FhirCitationJournalJournalIssue to the end of the list.
    function Append : TFhirCitationJournalJournalIssue;
    
    // Add an already existing FhirCitationJournalJournalIssue to the end of the list.
    procedure AddItem(value : TFhirCitationJournalJournalIssue); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationJournalJournalIssue) : Integer;
    
    // Insert FhirCitationJournalJournalIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationJournalJournalIssue;
    
    // Insert an existing FhirCitationJournalJournalIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationJournalJournalIssue);
    
    // Get the iIndexth FhirCitationJournalJournalIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationJournalJournalIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationJournalJournalIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationJournalJournalIssues[index : Integer] : TFhirCitationJournalJournalIssue read GetItemN write SetItemN; default;
  End;

  // Date on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
  TFhirCitationJournalJournalIssuePublicationDate = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FYear : TFhirString;
    FMonth : TFhirString;
    FDay : TFhirString;
    FSeason : TFhirString;
    FText : TFhirString;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetYear(value : TFhirString);
    function GetYearST : String;
    procedure SetYearST(value : String);
    procedure SetMonth(value : TFhirString);
    function GetMonthST : String;
    procedure SetMonthST(value : String);
    procedure SetDay(value : TFhirString);
    function GetDayST : String;
    procedure SetDayST(value : String);
    procedure SetSeason(value : TFhirString);
    function GetSeasonST : String;
    procedure SetSeasonST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationJournalJournalIssuePublicationDate; overload;
    function Clone : TFhirCitationJournalJournalIssuePublicationDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Defining the date on which the issue of the joutnal was {$IFNDEF FPC}published{$ENDIF}.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Defining the date on which the issue of the joutnal was {$IFNDEF FPC}published{$ENDIF}.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Year on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property year : String read GetYearST write SetYearST;
    // Year on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property yearElement : TFhirString read FYear write SetYear;

    // Typed access to Month on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property month : String read GetMonthST write SetMonthST;
    // Month on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property monthElement : TFhirString read FMonth write SetMonth;

    // Typed access to Day on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property day : String read GetDayST write SetDayST;
    // Day on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property dayElement : TFhirString read FDay write SetDay;

    // Typed access to Spring, Summer, Fall/Autumn, Winter.
    property season : String read GetSeasonST write SetSeasonST;
    // Spring, Summer, Fall/Autumn, Winter.
    property seasonElement : TFhirString read FSeason write SetSeason;

    // Typed access to Text representation of the date of which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property text : String read GetTextST write SetTextST;
    // Text representation of the date of which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirCitationJournalJournalIssuePublicationDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationJournalJournalIssuePublicationDateList;
    function GetCurrent : TFhirCitationJournalJournalIssuePublicationDate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationJournalJournalIssuePublicationDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationJournalJournalIssuePublicationDate read GetCurrent;
  end;

  TFhirCitationJournalJournalIssuePublicationDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationJournalJournalIssuePublicationDate;
    procedure SetItemN(index : Integer; value : TFhirCitationJournalJournalIssuePublicationDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationJournalJournalIssuePublicationDateList; overload;
    function Clone : TFhirCitationJournalJournalIssuePublicationDateList; overload;
    function GetEnumerator : TFhirCitationJournalJournalIssuePublicationDateListEnumerator;
    
    //  Add a FhirCitationJournalJournalIssuePublicationDate to the end of the list.
    function Append : TFhirCitationJournalJournalIssuePublicationDate;
    
    // Add an already existing FhirCitationJournalJournalIssuePublicationDate to the end of the list.
    procedure AddItem(value : TFhirCitationJournalJournalIssuePublicationDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationJournalJournalIssuePublicationDate) : Integer;
    
    // Insert FhirCitationJournalJournalIssuePublicationDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationJournalJournalIssuePublicationDate;
    
    // Insert an existing FhirCitationJournalJournalIssuePublicationDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationJournalJournalIssuePublicationDate);
    
    // Get the iIndexth FhirCitationJournalJournalIssuePublicationDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationJournalJournalIssuePublicationDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationJournalJournalIssuePublicationDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationJournalJournalIssuePublicationDates[index : Integer] : TFhirCitationJournalJournalIssuePublicationDate read GetItemN write SetItemN; default;
  End;

  // Citation detail for sources other than journals such as books and databases.
  TFhirCitationPublicationInfo = class (TFhirBackboneElement)
  protected
    FPublishedIn : TFhirCitationPublicationInfoPublishedIn;
    FEntryDate : TFhirDateTime;
    FRevisionDate : TFhirDateTime;
    FPageCount : TFhirString;
    procedure SetPublishedIn(value : TFhirCitationPublicationInfoPublishedIn);
    procedure SetEntryDate(value : TFhirDateTime);
    function GetEntryDateST : TFslDateTime;
    procedure SetEntryDateST(value : TFslDateTime);
    procedure SetRevisionDate(value : TFhirDateTime);
    function GetRevisionDateST : TFslDateTime;
    procedure SetRevisionDateST(value : TFslDateTime);
    procedure SetPageCount(value : TFhirString);
    function GetPageCountST : String;
    procedure SetPageCountST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationPublicationInfo; overload;
    function Clone : TFhirCitationPublicationInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in. (defined for API consistency)
    property publishedIn : TFhirCitationPublicationInfoPublishedIn read FPublishedIn write SetPublishedIn;
    // The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in.
    property publishedInElement : TFhirCitationPublicationInfoPublishedIn read FPublishedIn write SetPublishedIn;

    // Typed access to The date the article was added to the database.
    property entryDate : TFslDateTime read GetEntryDateST write SetEntryDateST;
    // The date the article was added to the database.
    property entryDateElement : TFhirDateTime read FEntryDate write SetEntryDate;

    // Typed access to The date the article was last revised or updated in the database.
    property revisionDate : TFslDateTime read GetRevisionDateST write SetRevisionDateST;
    // The date the article was last revised or updated in the database.
    property revisionDateElement : TFhirDateTime read FRevisionDate write SetRevisionDate;

    // Typed access to Actual or Approximate number of pages or screens.
    property pageCount : String read GetPageCountST write SetPageCountST;
    // Actual or Approximate number of pages or screens.
    property pageCountElement : TFhirString read FPageCount write SetPageCount;

  end;

  TFhirCitationPublicationInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationPublicationInfoList;
    function GetCurrent : TFhirCitationPublicationInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationPublicationInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationPublicationInfo read GetCurrent;
  end;

  TFhirCitationPublicationInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationPublicationInfo;
    procedure SetItemN(index : Integer; value : TFhirCitationPublicationInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationPublicationInfoList; overload;
    function Clone : TFhirCitationPublicationInfoList; overload;
    function GetEnumerator : TFhirCitationPublicationInfoListEnumerator;
    
    //  Add a FhirCitationPublicationInfo to the end of the list.
    function Append : TFhirCitationPublicationInfo;
    
    // Add an already existing FhirCitationPublicationInfo to the end of the list.
    procedure AddItem(value : TFhirCitationPublicationInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationPublicationInfo) : Integer;
    
    // Insert FhirCitationPublicationInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationPublicationInfo;
    
    // Insert an existing FhirCitationPublicationInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationPublicationInfo);
    
    // Get the iIndexth FhirCitationPublicationInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationPublicationInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationPublicationInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationPublicationInfos[index : Integer] : TFhirCitationPublicationInfo read GetItemN write SetItemN; default;
  End;

  // The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in.
  TFhirCitationPublicationInfoPublishedIn = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FPublisher : TFhirReference;
    FPublisherLocation : TFhirString;
    FStartDate : TFhirDate;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetPublisher(value : TFhirReference);
    procedure SetPublisherLocation(value : TFhirString);
    function GetPublisherLocationST : String;
    procedure SetPublisherLocationST(value : String);
    procedure SetStartDate(value : TFhirDate);
    function GetStartDateST : TFslDateTime;
    procedure SetStartDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationPublicationInfoPublishedIn; overload;
    function Clone : TFhirCitationPublicationInfoPublishedIn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Database or book. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Database or book.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Identifiers may include ISBN (International Standard Book Number) for books.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Name of the database or title of the book.
    property name : String read GetNameST write SetNameST;
    // Name of the database or title of the book.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name of the publisher. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // Name of the publisher.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to Geographic location of the publisher.
    property publisherLocation : String read GetPublisherLocationST write SetPublisherLocationST;
    // Geographic location of the publisher.
    property publisherLocationElement : TFhirString read FPublisherLocation write SetPublisherLocation;

    // Typed access to When the database was first available or when the book was {$IFNDEF FPC}published{$ENDIF}.
    property startDate : TFslDateTime read GetStartDateST write SetStartDateST;
    // When the database was first available or when the book was {$IFNDEF FPC}published{$ENDIF}.
    property startDateElement : TFhirDate read FStartDate write SetStartDate;

  end;

  TFhirCitationPublicationInfoPublishedInListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationPublicationInfoPublishedInList;
    function GetCurrent : TFhirCitationPublicationInfoPublishedIn;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationPublicationInfoPublishedInList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationPublicationInfoPublishedIn read GetCurrent;
  end;

  TFhirCitationPublicationInfoPublishedInList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationPublicationInfoPublishedIn;
    procedure SetItemN(index : Integer; value : TFhirCitationPublicationInfoPublishedIn);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationPublicationInfoPublishedInList; overload;
    function Clone : TFhirCitationPublicationInfoPublishedInList; overload;
    function GetEnumerator : TFhirCitationPublicationInfoPublishedInListEnumerator;
    
    //  Add a FhirCitationPublicationInfoPublishedIn to the end of the list.
    function Append : TFhirCitationPublicationInfoPublishedIn;
    
    // Add an already existing FhirCitationPublicationInfoPublishedIn to the end of the list.
    procedure AddItem(value : TFhirCitationPublicationInfoPublishedIn); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationPublicationInfoPublishedIn) : Integer;
    
    // Insert FhirCitationPublicationInfoPublishedIn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationPublicationInfoPublishedIn;
    
    // Insert an existing FhirCitationPublicationInfoPublishedIn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationPublicationInfoPublishedIn);
    
    // Get the iIndexth FhirCitationPublicationInfoPublishedIn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationPublicationInfoPublishedIn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationPublicationInfoPublishedIn;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationPublicationInfoPublishedIns[index : Integer] : TFhirCitationPublicationInfoPublishedIn read GetItemN write SetItemN; default;
  End;

  // Used for variant titles, such as translations.
  TFhirCitationAlternativeTitle = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    FTitle : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetTitle(value : TFhirMarkdown);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeTitle; overload;
    function Clone : TFhirCitationAlternativeTitle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to express the reason and specific aspect for the variant title, such as language and specific language. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to express the reason and specific aspect for the variant title, such as language and specific language.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to express the specific language. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Used to express the specific language.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Full variant title of the article.
    property title : String read GetTitleST write SetTitleST;
    // Full variant title of the article.
    property titleElement : TFhirMarkdown read FTitle write SetTitle;

  end;

  TFhirCitationAlternativeTitleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeTitleList;
    function GetCurrent : TFhirCitationAlternativeTitle;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeTitleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeTitle read GetCurrent;
  end;

  TFhirCitationAlternativeTitleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeTitle;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeTitle);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeTitleList; overload;
    function Clone : TFhirCitationAlternativeTitleList; overload;
    function GetEnumerator : TFhirCitationAlternativeTitleListEnumerator;
    
    //  Add a FhirCitationAlternativeTitle to the end of the list.
    function Append : TFhirCitationAlternativeTitle;
    
    // Add an already existing FhirCitationAlternativeTitle to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeTitle); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeTitle) : Integer;
    
    // Insert FhirCitationAlternativeTitle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeTitle;
    
    // Insert an existing FhirCitationAlternativeTitle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeTitle);
    
    // Get the iIndexth FhirCitationAlternativeTitle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeTitle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeTitle;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeTitles[index : Integer] : TFhirCitationAlternativeTitle read GetItemN write SetItemN; default;
  End;

  // Indicates the inclusive pages for the article cited.
  TFhirCitationPagination = class (TFhirBackboneElement)
  protected
    FPageString : TFhirString;
    FFirstPage : TFhirString;
    FLastPage : TFhirString;
    procedure SetPageString(value : TFhirString);
    function GetPageStringST : String;
    procedure SetPageStringST(value : String);
    procedure SetFirstPage(value : TFhirString);
    function GetFirstPageST : String;
    procedure SetFirstPageST(value : String);
    procedure SetLastPage(value : TFhirString);
    function GetLastPageST : String;
    procedure SetLastPageST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationPagination; overload;
    function Clone : TFhirCitationPagination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used for full display of pagination.
    property pageString : String read GetPageStringST write SetPageStringST;
    // Used for full display of pagination.
    property pageStringElement : TFhirString read FPageString write SetPageString;

    // Typed access to Used for isolated representation of first page.
    property firstPage : String read GetFirstPageST write SetFirstPageST;
    // Used for isolated representation of first page.
    property firstPageElement : TFhirString read FFirstPage write SetFirstPage;

    // Typed access to Used for isolated representation of last page.
    property lastPage : String read GetLastPageST write SetLastPageST;
    // Used for isolated representation of last page.
    property lastPageElement : TFhirString read FLastPage write SetLastPage;

  end;

  TFhirCitationPaginationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationPaginationList;
    function GetCurrent : TFhirCitationPagination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationPaginationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationPagination read GetCurrent;
  end;

  TFhirCitationPaginationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationPagination;
    procedure SetItemN(index : Integer; value : TFhirCitationPagination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationPaginationList; overload;
    function Clone : TFhirCitationPaginationList; overload;
    function GetEnumerator : TFhirCitationPaginationListEnumerator;
    
    //  Add a FhirCitationPagination to the end of the list.
    function Append : TFhirCitationPagination;
    
    // Add an already existing FhirCitationPagination to the end of the list.
    procedure AddItem(value : TFhirCitationPagination); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationPagination) : Integer;
    
    // Insert FhirCitationPagination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationPagination;
    
    // Insert an existing FhirCitationPagination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationPagination);
    
    // Get the iIndexth FhirCitationPagination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationPagination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationPagination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationPaginations[index : Integer] : TFhirCitationPagination read GetItemN write SetItemN; default;
  End;

  // Used for any URL for the article cited.
  TFhirCitationArticleUrl = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FUrl : TFhirUri;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationArticleUrl; overload;
    function Clone : TFhirCitationArticleUrl; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code the reason for different URLs, eg abstract and full-text. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code the reason for different URLs, eg abstract and full-text.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The specific URL.
    property url : String read GetUrlST write SetUrlST;
    // The specific URL.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirCitationArticleUrlListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationArticleUrlList;
    function GetCurrent : TFhirCitationArticleUrl;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationArticleUrlList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationArticleUrl read GetCurrent;
  end;

  TFhirCitationArticleUrlList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationArticleUrl;
    procedure SetItemN(index : Integer; value : TFhirCitationArticleUrl);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationArticleUrlList; overload;
    function Clone : TFhirCitationArticleUrlList; overload;
    function GetEnumerator : TFhirCitationArticleUrlListEnumerator;
    
    //  Add a FhirCitationArticleUrl to the end of the list.
    function Append : TFhirCitationArticleUrl;
    
    // Add an already existing FhirCitationArticleUrl to the end of the list.
    procedure AddItem(value : TFhirCitationArticleUrl); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationArticleUrl) : Integer;
    
    // Insert FhirCitationArticleUrl before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationArticleUrl;
    
    // Insert an existing FhirCitationArticleUrl before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationArticleUrl);
    
    // Get the iIndexth FhirCitationArticleUrl. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationArticleUrl);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationArticleUrl;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationArticleUrls[index : Integer] : TFhirCitationArticleUrl read GetItemN write SetItemN; default;
  End;

  // Used for variant abstracts, such as translations.
  TFhirCitationAlternativeAbstract = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    FAbstract : TFhirMarkdown;
    FAbstractCopyright : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetAbstract(value : TFhirMarkdown);
    function GetAbstractST : String;
    procedure SetAbstractST(value : String);
    procedure SetAbstractCopyright(value : TFhirMarkdown);
    function GetAbstractCopyrightST : String;
    procedure SetAbstractCopyrightST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeAbstract; overload;
    function Clone : TFhirCitationAlternativeAbstract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used to express the reason for the variant abstract, such as language. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used to express the reason for the variant abstract, such as language.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to express the specific language. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Used to express the specific language.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Full variant abstract of the article.
    property abstract : String read GetAbstractST write SetAbstractST;
    // Full variant abstract of the article.
    property abstractElement : TFhirMarkdown read FAbstract write SetAbstract;

    // Typed access to Copyright information for the abstract text.
    property abstractCopyright : String read GetAbstractCopyrightST write SetAbstractCopyrightST;
    // Copyright information for the abstract text.
    property abstractCopyrightElement : TFhirMarkdown read FAbstractCopyright write SetAbstractCopyright;

  end;

  TFhirCitationAlternativeAbstractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeAbstractList;
    function GetCurrent : TFhirCitationAlternativeAbstract;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeAbstractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeAbstract read GetCurrent;
  end;

  TFhirCitationAlternativeAbstractList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeAbstract;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeAbstract);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeAbstractList; overload;
    function Clone : TFhirCitationAlternativeAbstractList; overload;
    function GetEnumerator : TFhirCitationAlternativeAbstractListEnumerator;
    
    //  Add a FhirCitationAlternativeAbstract to the end of the list.
    function Append : TFhirCitationAlternativeAbstract;
    
    // Add an already existing FhirCitationAlternativeAbstract to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeAbstract); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeAbstract) : Integer;
    
    // Insert FhirCitationAlternativeAbstract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeAbstract;
    
    // Insert an existing FhirCitationAlternativeAbstract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeAbstract);
    
    // Get the iIndexth FhirCitationAlternativeAbstract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeAbstract);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeAbstract;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeAbstracts[index : Integer] : TFhirCitationAlternativeAbstract read GetItemN write SetItemN; default;
  End;

  // This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements.
  TFhirCitationContributorship = class (TFhirBackboneElement)
  protected
    FComplete : TFhirBoolean;
    FentryList : TFhirCitationContributorshipEntryList;
    FsummaryList : TFhirCitationContributorshipSummaryList;
    procedure SetComplete(value : TFhirBoolean);
    function GetCompleteST : Boolean;
    procedure SetCompleteST(value : Boolean);
    function GetEntryList : TFhirCitationContributorshipEntryList;
    function GetHasEntryList : Boolean;
    function GetSummaryList : TFhirCitationContributorshipSummaryList;
    function GetHasSummaryList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationContributorship; overload;
    function Clone : TFhirCitationContributorship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates if the list includes all authors and/or contributors.
    property complete : Boolean read GetCompleteST write SetCompleteST;
    // Indicates if the list includes all authors and/or contributors.
    property completeElement : TFhirBoolean read FComplete write SetComplete;

    // An individual entity named in the author list or contributor list.
    property entryList : TFhirCitationContributorshipEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Used to record a display of the author/contributor list without separate coding for each list member.
    property summaryList : TFhirCitationContributorshipSummaryList read GetSummaryList;
    property hasSummaryList : boolean read GetHasSummaryList;

  end;

  TFhirCitationContributorshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationContributorshipList;
    function GetCurrent : TFhirCitationContributorship;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationContributorshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationContributorship read GetCurrent;
  end;

  TFhirCitationContributorshipList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationContributorship;
    procedure SetItemN(index : Integer; value : TFhirCitationContributorship);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationContributorshipList; overload;
    function Clone : TFhirCitationContributorshipList; overload;
    function GetEnumerator : TFhirCitationContributorshipListEnumerator;
    
    //  Add a FhirCitationContributorship to the end of the list.
    function Append : TFhirCitationContributorship;
    
    // Add an already existing FhirCitationContributorship to the end of the list.
    procedure AddItem(value : TFhirCitationContributorship); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationContributorship) : Integer;
    
    // Insert FhirCitationContributorship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationContributorship;
    
    // Insert an existing FhirCitationContributorship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationContributorship);
    
    // Get the iIndexth FhirCitationContributorship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationContributorship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationContributorship;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationContributorships[index : Integer] : TFhirCitationContributorship read GetItemN write SetItemN; default;
  End;

  // An individual entity named in the author list or contributor list.
  TFhirCitationContributorshipEntry = class (TFhirBackboneElement)
  protected
    FName : TFhirHumanName;
    FInitials : TFhirString;
    FCollectiveName : TFhirString;
    FidentifierList : TFhirIdentifierList;
    FaffiliationInfoList : TFhirCitationContributorshipEntryAffiliationInfoList;
    FaddressList : TFhirAddressList;
    FtelecomList : TFhirContactPointList;
    FcontributionList : TFhirCodeableConceptList;
    FNotAnAuthor : TFhirBoolean;
    FCorrespondingAuthor : TFhirBoolean;
    FListOrder : TFhirPositiveInt;
    procedure SetName(value : TFhirHumanName);
    procedure SetInitials(value : TFhirString);
    function GetInitialsST : String;
    procedure SetInitialsST(value : String);
    procedure SetCollectiveName(value : TFhirString);
    function GetCollectiveNameST : String;
    procedure SetCollectiveNameST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetAffiliationInfoList : TFhirCitationContributorshipEntryAffiliationInfoList;
    function GetHasAffiliationInfoList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetContributionList : TFhirCodeableConceptList;
    function GetHasContributionList : Boolean;
    procedure SetNotAnAuthor(value : TFhirBoolean);
    function GetNotAnAuthorST : Boolean;
    procedure SetNotAnAuthorST(value : Boolean);
    procedure SetCorrespondingAuthor(value : TFhirBoolean);
    function GetCorrespondingAuthorST : Boolean;
    procedure SetCorrespondingAuthorST(value : Boolean);
    procedure SetListOrder(value : TFhirPositiveInt);
    function GetListOrderST : String;
    procedure SetListOrderST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationContributorshipEntry; overload;
    function Clone : TFhirCitationContributorshipEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name associated with the individual. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the individual.
    property nameElement : TFhirHumanName read FName write SetName;

    // Typed access to Initials for forename.
    property initials : String read GetInitialsST write SetInitialsST;
    // Initials for forename.
    property initialsElement : TFhirString read FInitials write SetInitials;

    // Typed access to Used for collective or corporate name as an author.
    property collectiveName : String read GetCollectiveNameST write SetCollectiveNameST;
    // Used for collective or corporate name as an author.
    property collectiveNameElement : TFhirString read FCollectiveName write SetCollectiveName;

    // Unique person identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Organization affiliated with the entity.
    property affiliationInfoList : TFhirCitationContributorshipEntryAffiliationInfoList read GetAffiliationInfoList;
    property hasAffiliationInfoList : boolean read GetHasAffiliationInfoList;

    // Physical mailing address for the author or contributor.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Email or telephone contact methods for the author or contributor.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // This element identifies the specific nature of an individual’s contribution with respect to the cited work.
    property contributionList : TFhirCodeableConceptList read GetContributionList;
    property hasContributionList : boolean read GetHasContributionList;

    // Typed access to False, missing, or empty elements implies authorship.
    property notAnAuthor : Boolean read GetNotAnAuthorST write SetNotAnAuthorST;
    // False, missing, or empty elements implies authorship.
    property notAnAuthorElement : TFhirBoolean read FNotAnAuthor write SetNotAnAuthor;

    // Typed access to Indication of which author is the corresponding author for the article cited.
    property correspondingAuthor : Boolean read GetCorrespondingAuthorST write SetCorrespondingAuthorST;
    // Indication of which author is the corresponding author for the article cited.
    property correspondingAuthorElement : TFhirBoolean read FCorrespondingAuthor write SetCorrespondingAuthor;

    // Typed access to Used to code order of authors.
    property listOrder : String read GetListOrderST write SetListOrderST;
    // Used to code order of authors.
    property listOrderElement : TFhirPositiveInt read FListOrder write SetListOrder;

  end;

  TFhirCitationContributorshipEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationContributorshipEntryList;
    function GetCurrent : TFhirCitationContributorshipEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationContributorshipEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationContributorshipEntry read GetCurrent;
  end;

  TFhirCitationContributorshipEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationContributorshipEntry;
    procedure SetItemN(index : Integer; value : TFhirCitationContributorshipEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationContributorshipEntryList; overload;
    function Clone : TFhirCitationContributorshipEntryList; overload;
    function GetEnumerator : TFhirCitationContributorshipEntryListEnumerator;
    
    //  Add a FhirCitationContributorshipEntry to the end of the list.
    function Append : TFhirCitationContributorshipEntry;
    
    // Add an already existing FhirCitationContributorshipEntry to the end of the list.
    procedure AddItem(value : TFhirCitationContributorshipEntry); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationContributorshipEntry) : Integer;
    
    // Insert FhirCitationContributorshipEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationContributorshipEntry;
    
    // Insert an existing FhirCitationContributorshipEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationContributorshipEntry);
    
    // Get the iIndexth FhirCitationContributorshipEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationContributorshipEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationContributorshipEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationContributorshipEntries[index : Integer] : TFhirCitationContributorshipEntry read GetItemN write SetItemN; default;
  End;

  // Organization affiliated with the entity.
  TFhirCitationContributorshipEntryAffiliationInfo = class (TFhirBackboneElement)
  protected
    FAffiliation : TFhirString;
    FRole : TFhirString;
    FidentifierList : TFhirIdentifierList;
    procedure SetAffiliation(value : TFhirString);
    function GetAffiliationST : String;
    procedure SetAffiliationST(value : String);
    procedure SetRole(value : TFhirString);
    function GetRoleST : String;
    procedure SetRoleST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationContributorshipEntryAffiliationInfo; overload;
    function Clone : TFhirCitationContributorshipEntryAffiliationInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Display for the organization.
    property affiliation : String read GetAffiliationST write SetAffiliationST;
    // Display for the organization.
    property affiliationElement : TFhirString read FAffiliation write SetAffiliation;

    // Typed access to Role within the organization, such as professional title.
    property role : String read GetRoleST write SetRoleST;
    // Role within the organization, such as professional title.
    property roleElement : TFhirString read FRole write SetRole;

    // Identifier for the organization.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

  end;

  TFhirCitationContributorshipEntryAffiliationInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationContributorshipEntryAffiliationInfoList;
    function GetCurrent : TFhirCitationContributorshipEntryAffiliationInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationContributorshipEntryAffiliationInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationContributorshipEntryAffiliationInfo read GetCurrent;
  end;

  TFhirCitationContributorshipEntryAffiliationInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationContributorshipEntryAffiliationInfo;
    procedure SetItemN(index : Integer; value : TFhirCitationContributorshipEntryAffiliationInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationContributorshipEntryAffiliationInfoList; overload;
    function Clone : TFhirCitationContributorshipEntryAffiliationInfoList; overload;
    function GetEnumerator : TFhirCitationContributorshipEntryAffiliationInfoListEnumerator;
    
    //  Add a FhirCitationContributorshipEntryAffiliationInfo to the end of the list.
    function Append : TFhirCitationContributorshipEntryAffiliationInfo;
    
    // Add an already existing FhirCitationContributorshipEntryAffiliationInfo to the end of the list.
    procedure AddItem(value : TFhirCitationContributorshipEntryAffiliationInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationContributorshipEntryAffiliationInfo) : Integer;
    
    // Insert FhirCitationContributorshipEntryAffiliationInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationContributorshipEntryAffiliationInfo;
    
    // Insert an existing FhirCitationContributorshipEntryAffiliationInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationContributorshipEntryAffiliationInfo);
    
    // Get the iIndexth FhirCitationContributorshipEntryAffiliationInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationContributorshipEntryAffiliationInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationContributorshipEntryAffiliationInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationContributorshipEntryAffiliationInfos[index : Integer] : TFhirCitationContributorshipEntryAffiliationInfo read GetItemN write SetItemN; default;
  End;

  // Used to record a display of the author/contributor list without separate coding for each list member.
  TFhirCitationContributorshipSummary = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FStyle : TFhirCodeableConcept;
    FSource : TFhirCodeableConcept;
    FValue : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStyle(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirMarkdown);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationContributorshipSummary; overload;
    function Clone : TFhirCitationContributorshipSummary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used most commonly to express an author list or a contributorship statement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Used most commonly to express an author list or a contributorship statement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The format for the display string. (defined for API consistency)
    property style : TFhirCodeableConcept read FStyle write SetStyle;
    // The format for the display string.
    property styleElement : TFhirCodeableConcept read FStyle write SetStyle;

    // Typed access to Used to code the producer or rule for creating the display string. (defined for API consistency)
    property source : TFhirCodeableConcept read FSource write SetSource;
    // Used to code the producer or rule for creating the display string.
    property sourceElement : TFhirCodeableConcept read FSource write SetSource;

    // Typed access to The display string for the author list, contributor list, or contributorship statement.
    property value : String read GetValueST write SetValueST;
    // The display string for the author list, contributor list, or contributorship statement.
    property valueElement : TFhirMarkdown read FValue write SetValue;

  end;

  TFhirCitationContributorshipSummaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationContributorshipSummaryList;
    function GetCurrent : TFhirCitationContributorshipSummary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationContributorshipSummaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationContributorshipSummary read GetCurrent;
  end;

  TFhirCitationContributorshipSummaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationContributorshipSummary;
    procedure SetItemN(index : Integer; value : TFhirCitationContributorshipSummary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationContributorshipSummaryList; overload;
    function Clone : TFhirCitationContributorshipSummaryList; overload;
    function GetEnumerator : TFhirCitationContributorshipSummaryListEnumerator;
    
    //  Add a FhirCitationContributorshipSummary to the end of the list.
    function Append : TFhirCitationContributorshipSummary;
    
    // Add an already existing FhirCitationContributorshipSummary to the end of the list.
    procedure AddItem(value : TFhirCitationContributorshipSummary); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationContributorshipSummary) : Integer;
    
    // Insert FhirCitationContributorshipSummary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationContributorshipSummary;
    
    // Insert an existing FhirCitationContributorshipSummary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationContributorshipSummary);
    
    // Get the iIndexth FhirCitationContributorshipSummary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationContributorshipSummary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationContributorshipSummary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationContributorshipSummaries[index : Integer] : TFhirCitationContributorshipSummary read GetItemN write SetItemN; default;
  End;

  // Used to represent alternative forms of the article that are not separate citations.
  TFhirCitationAlternativeForm = class (TFhirBackboneElement)
  protected
    FPublishingModel : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    FJournalIssue : TFhirCitationAlternativeFormJournalIssue;
    FPagination : TFhirCitationAlternativeFormPagination;
    FPublicationInfo : TFhirCitationAlternativeFormPublicationInfo;
    procedure SetPublishingModel(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetJournalIssue(value : TFhirCitationAlternativeFormJournalIssue);
    procedure SetPagination(value : TFhirCitationAlternativeFormPagination);
    procedure SetPublicationInfo(value : TFhirCitationAlternativeFormPublicationInfo);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeForm; overload;
    function Clone : TFhirCitationAlternativeForm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identify the medium/media in which the cited article is {$IFNDEF FPC}published{$ENDIF}, eg print, electronic or print-electronic. (defined for API consistency)
    property publishingModel : TFhirCodeableConcept read FPublishingModel write SetPublishingModel;
    // Identify the medium/media in which the cited article is {$IFNDEF FPC}published{$ENDIF}, eg print, electronic or print-electronic.
    property publishingModelElement : TFhirCodeableConcept read FPublishingModel write SetPublishingModel;

    // Typed access to Language in which this form of the article is {$IFNDEF FPC}published{$ENDIF}. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Language in which this form of the article is {$IFNDEF FPC}published{$ENDIF}.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to The specific issue in which the cited article resides. (defined for API consistency)
    property journalIssue : TFhirCitationAlternativeFormJournalIssue read FJournalIssue write SetJournalIssue;
    // The specific issue in which the cited article resides.
    property journalIssueElement : TFhirCitationAlternativeFormJournalIssue read FJournalIssue write SetJournalIssue;

    // Typed access to Indicates the inclusive pages for the article cited. (defined for API consistency)
    property pagination : TFhirCitationAlternativeFormPagination read FPagination write SetPagination;
    // Indicates the inclusive pages for the article cited.
    property paginationElement : TFhirCitationAlternativeFormPagination read FPagination write SetPagination;

    // Typed access to Citation detail for sources other than journals such as books and databases. (defined for API consistency)
    property publicationInfo : TFhirCitationAlternativeFormPublicationInfo read FPublicationInfo write SetPublicationInfo;
    // Citation detail for sources other than journals such as books and databases.
    property publicationInfoElement : TFhirCitationAlternativeFormPublicationInfo read FPublicationInfo write SetPublicationInfo;

  end;

  TFhirCitationAlternativeFormListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormList;
    function GetCurrent : TFhirCitationAlternativeForm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeForm read GetCurrent;
  end;

  TFhirCitationAlternativeFormList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeForm;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeForm);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormList; overload;
    function Clone : TFhirCitationAlternativeFormList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormListEnumerator;
    
    //  Add a FhirCitationAlternativeForm to the end of the list.
    function Append : TFhirCitationAlternativeForm;
    
    // Add an already existing FhirCitationAlternativeForm to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeForm); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeForm) : Integer;
    
    // Insert FhirCitationAlternativeForm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeForm;
    
    // Insert an existing FhirCitationAlternativeForm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeForm);
    
    // Get the iIndexth FhirCitationAlternativeForm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeForm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeForm;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeForms[index : Integer] : TFhirCitationAlternativeForm read GetItemN write SetItemN; default;
  End;

  // The specific issue in which the cited article resides.
  TFhirCitationAlternativeFormJournalIssue = class (TFhirBackboneElement)
  protected
    FCitedMedium : TFhirCodeableConcept;
    FVolume : TFhirString;
    FIssue : TFhirString;
    FPublicationDate : TFhirCitationAlternativeFormJournalIssuePublicationDate;
    procedure SetCitedMedium(value : TFhirCodeableConcept);
    procedure SetVolume(value : TFhirString);
    function GetVolumeST : String;
    procedure SetVolumeST(value : String);
    procedure SetIssue(value : TFhirString);
    function GetIssueST : String;
    procedure SetIssueST(value : String);
    procedure SetPublicationDate(value : TFhirCitationAlternativeFormJournalIssuePublicationDate);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeFormJournalIssue; overload;
    function Clone : TFhirCitationAlternativeFormJournalIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the form of the medium cited. Common codes are "Internet" or "Print.". (defined for API consistency)
    property citedMedium : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;
    // Describes the form of the medium cited. Common codes are "Internet" or "Print.".
    property citedMediumElement : TFhirCodeableConcept read FCitedMedium write SetCitedMedium;

    // Typed access to Volume number of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property volume : String read GetVolumeST write SetVolumeST;
    // Volume number of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property volumeElement : TFhirString read FVolume write SetVolume;

    // Typed access to Issue, part or supplement of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property issue : String read GetIssueST write SetIssueST;
    // Issue, part or supplement of journal in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property issueElement : TFhirString read FIssue write SetIssue;

    // Typed access to Defining the date on which the issue of the joutnal was {$IFNDEF FPC}published{$ENDIF}. (defined for API consistency)
    property publicationDate : TFhirCitationAlternativeFormJournalIssuePublicationDate read FPublicationDate write SetPublicationDate;
    // Defining the date on which the issue of the joutnal was {$IFNDEF FPC}published{$ENDIF}.
    property publicationDateElement : TFhirCitationAlternativeFormJournalIssuePublicationDate read FPublicationDate write SetPublicationDate;

  end;

  TFhirCitationAlternativeFormJournalIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormJournalIssueList;
    function GetCurrent : TFhirCitationAlternativeFormJournalIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormJournalIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeFormJournalIssue read GetCurrent;
  end;

  TFhirCitationAlternativeFormJournalIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeFormJournalIssue;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeFormJournalIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormJournalIssueList; overload;
    function Clone : TFhirCitationAlternativeFormJournalIssueList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormJournalIssueListEnumerator;
    
    //  Add a FhirCitationAlternativeFormJournalIssue to the end of the list.
    function Append : TFhirCitationAlternativeFormJournalIssue;
    
    // Add an already existing FhirCitationAlternativeFormJournalIssue to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeFormJournalIssue); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeFormJournalIssue) : Integer;
    
    // Insert FhirCitationAlternativeFormJournalIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeFormJournalIssue;
    
    // Insert an existing FhirCitationAlternativeFormJournalIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeFormJournalIssue);
    
    // Get the iIndexth FhirCitationAlternativeFormJournalIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeFormJournalIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeFormJournalIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeFormJournalIssues[index : Integer] : TFhirCitationAlternativeFormJournalIssue read GetItemN write SetItemN; default;
  End;

  // Defining the date on which the issue of the joutnal was {$IFNDEF FPC}published{$ENDIF}.
  TFhirCitationAlternativeFormJournalIssuePublicationDate = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FYear : TFhirString;
    FMonth : TFhirString;
    FDay : TFhirString;
    FSeason : TFhirString;
    FText : TFhirString;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetYear(value : TFhirString);
    function GetYearST : String;
    procedure SetYearST(value : String);
    procedure SetMonth(value : TFhirString);
    function GetMonthST : String;
    procedure SetMonthST(value : String);
    procedure SetDay(value : TFhirString);
    function GetDayST : String;
    procedure SetDayST(value : String);
    procedure SetSeason(value : TFhirString);
    function GetSeasonST : String;
    procedure SetSeasonST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeFormJournalIssuePublicationDate; overload;
    function Clone : TFhirCitationAlternativeFormJournalIssuePublicationDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Year on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property year : String read GetYearST write SetYearST;
    // Year on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property yearElement : TFhirString read FYear write SetYear;

    // Typed access to Month on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property month : String read GetMonthST write SetMonthST;
    // Month on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property monthElement : TFhirString read FMonth write SetMonth;

    // Typed access to Day on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property day : String read GetDayST write SetDayST;
    // Day on which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property dayElement : TFhirString read FDay write SetDay;

    // Typed access to Spring, Summer, Fall/Autumn, Winter.
    property season : String read GetSeasonST write SetSeasonST;
    // Spring, Summer, Fall/Autumn, Winter.
    property seasonElement : TFhirString read FSeason write SetSeason;

    // Typed access to Text representation of the date of which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property text : String read GetTextST write SetTextST;
    // Text representation of the date of which the issue of the journal was {$IFNDEF FPC}published{$ENDIF}.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormJournalIssuePublicationDateList;
    function GetCurrent : TFhirCitationAlternativeFormJournalIssuePublicationDate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormJournalIssuePublicationDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeFormJournalIssuePublicationDate read GetCurrent;
  end;

  TFhirCitationAlternativeFormJournalIssuePublicationDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeFormJournalIssuePublicationDate;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeFormJournalIssuePublicationDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormJournalIssuePublicationDateList; overload;
    function Clone : TFhirCitationAlternativeFormJournalIssuePublicationDateList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator;
    
    //  Add a FhirCitationAlternativeFormJournalIssuePublicationDate to the end of the list.
    function Append : TFhirCitationAlternativeFormJournalIssuePublicationDate;
    
    // Add an already existing FhirCitationAlternativeFormJournalIssuePublicationDate to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeFormJournalIssuePublicationDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeFormJournalIssuePublicationDate) : Integer;
    
    // Insert FhirCitationAlternativeFormJournalIssuePublicationDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeFormJournalIssuePublicationDate;
    
    // Insert an existing FhirCitationAlternativeFormJournalIssuePublicationDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeFormJournalIssuePublicationDate);
    
    // Get the iIndexth FhirCitationAlternativeFormJournalIssuePublicationDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeFormJournalIssuePublicationDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeFormJournalIssuePublicationDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeFormJournalIssuePublicationDates[index : Integer] : TFhirCitationAlternativeFormJournalIssuePublicationDate read GetItemN write SetItemN; default;
  End;

  // Indicates the inclusive pages for the article cited.
  TFhirCitationAlternativeFormPagination = class (TFhirBackboneElement)
  protected
    FPageString : TFhirString;
    FFirstPage : TFhirString;
    FLastPage : TFhirString;
    procedure SetPageString(value : TFhirString);
    function GetPageStringST : String;
    procedure SetPageStringST(value : String);
    procedure SetFirstPage(value : TFhirString);
    function GetFirstPageST : String;
    procedure SetFirstPageST(value : String);
    procedure SetLastPage(value : TFhirString);
    function GetLastPageST : String;
    procedure SetLastPageST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeFormPagination; overload;
    function Clone : TFhirCitationAlternativeFormPagination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used for full display of pagination.
    property pageString : String read GetPageStringST write SetPageStringST;
    // Used for full display of pagination.
    property pageStringElement : TFhirString read FPageString write SetPageString;

    // Typed access to Used for isolated representation of first page.
    property firstPage : String read GetFirstPageST write SetFirstPageST;
    // Used for isolated representation of first page.
    property firstPageElement : TFhirString read FFirstPage write SetFirstPage;

    // Typed access to Used for isolated representation of last page.
    property lastPage : String read GetLastPageST write SetLastPageST;
    // Used for isolated representation of last page.
    property lastPageElement : TFhirString read FLastPage write SetLastPage;

  end;

  TFhirCitationAlternativeFormPaginationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormPaginationList;
    function GetCurrent : TFhirCitationAlternativeFormPagination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormPaginationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeFormPagination read GetCurrent;
  end;

  TFhirCitationAlternativeFormPaginationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeFormPagination;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeFormPagination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormPaginationList; overload;
    function Clone : TFhirCitationAlternativeFormPaginationList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormPaginationListEnumerator;
    
    //  Add a FhirCitationAlternativeFormPagination to the end of the list.
    function Append : TFhirCitationAlternativeFormPagination;
    
    // Add an already existing FhirCitationAlternativeFormPagination to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeFormPagination); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeFormPagination) : Integer;
    
    // Insert FhirCitationAlternativeFormPagination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeFormPagination;
    
    // Insert an existing FhirCitationAlternativeFormPagination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeFormPagination);
    
    // Get the iIndexth FhirCitationAlternativeFormPagination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeFormPagination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeFormPagination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeFormPaginations[index : Integer] : TFhirCitationAlternativeFormPagination read GetItemN write SetItemN; default;
  End;

  // Citation detail for sources other than journals such as books and databases.
  TFhirCitationAlternativeFormPublicationInfo = class (TFhirBackboneElement)
  protected
    FPublishedIn : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
    FEntryDate : TFhirDateTime;
    FRevisionDate : TFhirDateTime;
    FPageCount : TFhirString;
    procedure SetPublishedIn(value : TFhirCitationAlternativeFormPublicationInfoPublishedIn);
    procedure SetEntryDate(value : TFhirDateTime);
    function GetEntryDateST : TFslDateTime;
    procedure SetEntryDateST(value : TFslDateTime);
    procedure SetRevisionDate(value : TFhirDateTime);
    function GetRevisionDateST : TFslDateTime;
    procedure SetRevisionDateST(value : TFslDateTime);
    procedure SetPageCount(value : TFhirString);
    function GetPageCountST : String;
    procedure SetPageCountST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeFormPublicationInfo; overload;
    function Clone : TFhirCitationAlternativeFormPublicationInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in. (defined for API consistency)
    property publishedIn : TFhirCitationAlternativeFormPublicationInfoPublishedIn read FPublishedIn write SetPublishedIn;
    // The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in.
    property publishedInElement : TFhirCitationAlternativeFormPublicationInfoPublishedIn read FPublishedIn write SetPublishedIn;

    // Typed access to The date the article was added to the database.
    property entryDate : TFslDateTime read GetEntryDateST write SetEntryDateST;
    // The date the article was added to the database.
    property entryDateElement : TFhirDateTime read FEntryDate write SetEntryDate;

    // Typed access to The date the article was last revised or updated in the database.
    property revisionDate : TFslDateTime read GetRevisionDateST write SetRevisionDateST;
    // The date the article was last revised or updated in the database.
    property revisionDateElement : TFhirDateTime read FRevisionDate write SetRevisionDate;

    // Typed access to Actual or Approximate number of pages or screens.
    property pageCount : String read GetPageCountST write SetPageCountST;
    // Actual or Approximate number of pages or screens.
    property pageCountElement : TFhirString read FPageCount write SetPageCount;

  end;

  TFhirCitationAlternativeFormPublicationInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormPublicationInfoList;
    function GetCurrent : TFhirCitationAlternativeFormPublicationInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormPublicationInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeFormPublicationInfo read GetCurrent;
  end;

  TFhirCitationAlternativeFormPublicationInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeFormPublicationInfo;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeFormPublicationInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormPublicationInfoList; overload;
    function Clone : TFhirCitationAlternativeFormPublicationInfoList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormPublicationInfoListEnumerator;
    
    //  Add a FhirCitationAlternativeFormPublicationInfo to the end of the list.
    function Append : TFhirCitationAlternativeFormPublicationInfo;
    
    // Add an already existing FhirCitationAlternativeFormPublicationInfo to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeFormPublicationInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeFormPublicationInfo) : Integer;
    
    // Insert FhirCitationAlternativeFormPublicationInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeFormPublicationInfo;
    
    // Insert an existing FhirCitationAlternativeFormPublicationInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeFormPublicationInfo);
    
    // Get the iIndexth FhirCitationAlternativeFormPublicationInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeFormPublicationInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeFormPublicationInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeFormPublicationInfos[index : Integer] : TFhirCitationAlternativeFormPublicationInfo read GetItemN write SetItemN; default;
  End;

  // The collection the cited article is {$IFNDEF FPC}published{$ENDIF} in.
  TFhirCitationAlternativeFormPublicationInfoPublishedIn = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    FPublisher : TFhirReference;
    FPublisherLocation : TFhirString;
    FStartDate : TFhirDate;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetPublisher(value : TFhirReference);
    procedure SetPublisherLocation(value : TFhirString);
    function GetPublisherLocationST : String;
    procedure SetPublisherLocationST(value : String);
    procedure SetStartDate(value : TFhirDate);
    function GetStartDateST : TFslDateTime;
    procedure SetStartDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationAlternativeFormPublicationInfoPublishedIn; overload;
    function Clone : TFhirCitationAlternativeFormPublicationInfoPublishedIn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Database or book. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Database or book.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name of the database or title of the book.
    property name : String read GetNameST write SetNameST;
    // Name of the database or title of the book.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name of the publisher. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // Name of the publisher.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to Geographic location of the publisher.
    property publisherLocation : String read GetPublisherLocationST write SetPublisherLocationST;
    // Geographic location of the publisher.
    property publisherLocationElement : TFhirString read FPublisherLocation write SetPublisherLocation;

    // Typed access to When the database was first available or when the book was {$IFNDEF FPC}published{$ENDIF}.
    property startDate : TFslDateTime read GetStartDateST write SetStartDateST;
    // When the database was first available or when the book was {$IFNDEF FPC}published{$ENDIF}.
    property startDateElement : TFhirDate read FStartDate write SetStartDate;

  end;

  TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationAlternativeFormPublicationInfoPublishedInList;
    function GetCurrent : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationAlternativeFormPublicationInfoPublishedInList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationAlternativeFormPublicationInfoPublishedIn read GetCurrent;
  end;

  TFhirCitationAlternativeFormPublicationInfoPublishedInList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
    procedure SetItemN(index : Integer; value : TFhirCitationAlternativeFormPublicationInfoPublishedIn);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationAlternativeFormPublicationInfoPublishedInList; overload;
    function Clone : TFhirCitationAlternativeFormPublicationInfoPublishedInList; overload;
    function GetEnumerator : TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator;
    
    //  Add a FhirCitationAlternativeFormPublicationInfoPublishedIn to the end of the list.
    function Append : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
    
    // Add an already existing FhirCitationAlternativeFormPublicationInfoPublishedIn to the end of the list.
    procedure AddItem(value : TFhirCitationAlternativeFormPublicationInfoPublishedIn); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationAlternativeFormPublicationInfoPublishedIn) : Integer;
    
    // Insert FhirCitationAlternativeFormPublicationInfoPublishedIn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
    
    // Insert an existing FhirCitationAlternativeFormPublicationInfoPublishedIn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationAlternativeFormPublicationInfoPublishedIn);
    
    // Get the iIndexth FhirCitationAlternativeFormPublicationInfoPublishedIn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationAlternativeFormPublicationInfoPublishedIn);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationAlternativeFormPublicationInfoPublishedIns[index : Integer] : TFhirCitationAlternativeFormPublicationInfoPublishedIn read GetItemN write SetItemN; default;
  End;

  // A list of words classified as keywords for specific use in search functions.
  TFhirCitationKeywordList = class (TFhirBackboneElement)
  protected
    FOwner : TFhirString;
    FkeywordList : TFhirCitationKeywordListKeywordList;
    procedure SetOwner(value : TFhirString);
    function GetOwnerST : String;
    procedure SetOwnerST(value : String);
    function GetKeywordList : TFhirCitationKeywordListKeywordList;
    function GetHasKeywordList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationKeywordList; overload;
    function Clone : TFhirCitationKeywordList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The entity responsible for the creation or maintenance of this keyword list.
    property owner : String read GetOwnerST write SetOwnerST;
    // The entity responsible for the creation or maintenance of this keyword list.
    property ownerElement : TFhirString read FOwner write SetOwner;

    // For each keyword in the keyword list.
    property keywordList : TFhirCitationKeywordListKeywordList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

  end;

  TFhirCitationKeywordListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationKeywordListList;
    function GetCurrent : TFhirCitationKeywordList;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationKeywordListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationKeywordList read GetCurrent;
  end;

  TFhirCitationKeywordListList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationKeywordList;
    procedure SetItemN(index : Integer; value : TFhirCitationKeywordList);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationKeywordListList; overload;
    function Clone : TFhirCitationKeywordListList; overload;
    function GetEnumerator : TFhirCitationKeywordListListEnumerator;
    
    //  Add a FhirCitationKeywordList to the end of the list.
    function Append : TFhirCitationKeywordList;
    
    // Add an already existing FhirCitationKeywordList to the end of the list.
    procedure AddItem(value : TFhirCitationKeywordList); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationKeywordList) : Integer;
    
    // Insert FhirCitationKeywordList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationKeywordList;
    
    // Insert an existing FhirCitationKeywordList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationKeywordList);
    
    // Get the iIndexth FhirCitationKeywordList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationKeywordList);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationKeywordList;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationKeywordLists[index : Integer] : TFhirCitationKeywordList read GetItemN write SetItemN; default;
  End;

  // For each keyword in the keyword list.
  TFhirCitationKeywordListKeyword = class (TFhirBackboneElement)
  protected
    FMajorTopic : TFhirBoolean;
    FValue : TFhirString;
    procedure SetMajorTopic(value : TFhirBoolean);
    function GetMajorTopicST : Boolean;
    procedure SetMajorTopicST(value : Boolean);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationKeywordListKeyword; overload;
    function Clone : TFhirCitationKeywordListKeyword; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether or not it is a major topic.
    property majorTopic : Boolean read GetMajorTopicST write SetMajorTopicST;
    // Whether or not it is a major topic.
    property majorTopicElement : TFhirBoolean read FMajorTopic write SetMajorTopic;

    // Typed access to The actual keyword.
    property value : String read GetValueST write SetValueST;
    // The actual keyword.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirCitationKeywordListKeywordListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationKeywordListKeywordList;
    function GetCurrent : TFhirCitationKeywordListKeyword;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationKeywordListKeywordList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationKeywordListKeyword read GetCurrent;
  end;

  TFhirCitationKeywordListKeywordList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationKeywordListKeyword;
    procedure SetItemN(index : Integer; value : TFhirCitationKeywordListKeyword);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationKeywordListKeywordList; overload;
    function Clone : TFhirCitationKeywordListKeywordList; overload;
    function GetEnumerator : TFhirCitationKeywordListKeywordListEnumerator;
    
    //  Add a FhirCitationKeywordListKeyword to the end of the list.
    function Append : TFhirCitationKeywordListKeyword;
    
    // Add an already existing FhirCitationKeywordListKeyword to the end of the list.
    procedure AddItem(value : TFhirCitationKeywordListKeyword); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationKeywordListKeyword) : Integer;
    
    // Insert FhirCitationKeywordListKeyword before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationKeywordListKeyword;
    
    // Insert an existing FhirCitationKeywordListKeyword before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationKeywordListKeyword);
    
    // Get the iIndexth FhirCitationKeywordListKeyword. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationKeywordListKeyword);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationKeywordListKeyword;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationKeywordListKeywords[index : Integer] : TFhirCitationKeywordListKeyword read GetItemN write SetItemN; default;
  End;

  // These elements are items with values assigned by MEDLINE or PubMed management.
  TFhirCitationMedlinePubMed = class (TFhirBackboneElement)
  protected
    FMedlineState : TFhirCodeableConcept;
    FOwner : TFhirCodeableConcept;
    FPmid : TFhirPositiveInt;
    FPmidVersion : TFhirPositiveInt;
    FDateCreated : TFhirDate;
    FDateCompleted : TFhirDate;
    FDateRevised : TFhirDate;
    FpubMedPubDateList : TFhirCitationMedlinePubMedPubMedPubDateList;
    FPublicationState : TFhirCodeableConcept;
    FrelatedArticleList : TFhirCitationMedlinePubMedRelatedArticleList;
    procedure SetMedlineState(value : TFhirCodeableConcept);
    procedure SetOwner(value : TFhirCodeableConcept);
    procedure SetPmid(value : TFhirPositiveInt);
    function GetPmidST : String;
    procedure SetPmidST(value : String);
    procedure SetPmidVersion(value : TFhirPositiveInt);
    function GetPmidVersionST : String;
    procedure SetPmidVersionST(value : String);
    procedure SetDateCreated(value : TFhirDate);
    function GetDateCreatedST : TFslDateTime;
    procedure SetDateCreatedST(value : TFslDateTime);
    procedure SetDateCompleted(value : TFhirDate);
    function GetDateCompletedST : TFslDateTime;
    procedure SetDateCompletedST(value : TFslDateTime);
    procedure SetDateRevised(value : TFhirDate);
    function GetDateRevisedST : TFslDateTime;
    procedure SetDateRevisedST(value : TFslDateTime);
    function GetPubMedPubDateList : TFhirCitationMedlinePubMedPubMedPubDateList;
    function GetHasPubMedPubDateList : Boolean;
    procedure SetPublicationState(value : TFhirCodeableConcept);
    function GetRelatedArticleList : TFhirCitationMedlinePubMedRelatedArticleList;
    function GetHasRelatedArticleList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationMedlinePubMed; overload;
    function Clone : TFhirCitationMedlinePubMed; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Used for status. (defined for API consistency)
    property medlineState : TFhirCodeableConcept read FMedlineState write SetMedlineState;
    // Used for status.
    property medlineStateElement : TFhirCodeableConcept read FMedlineState write SetMedlineState;

    // Typed access to Used for owner. (defined for API consistency)
    property owner : TFhirCodeableConcept read FOwner write SetOwner;
    // Used for owner.
    property ownerElement : TFhirCodeableConcept read FOwner write SetOwner;

    // Typed access to PubMed ID.
    property pmid : String read GetPmidST write SetPmidST;
    // PubMed ID.
    property pmidElement : TFhirPositiveInt read FPmid write SetPmid;

    // Typed access to PubMed ID Version.
    property pmidVersion : String read GetPmidVersionST write SetPmidVersionST;
    // PubMed ID Version.
    property pmidVersionElement : TFhirPositiveInt read FPmidVersion write SetPmidVersion;

    // Typed access to Creation date.
    property dateCreated : TFslDateTime read GetDateCreatedST write SetDateCreatedST;
    // Creation date.
    property dateCreatedElement : TFhirDate read FDateCreated write SetDateCreated;

    // Typed access to Completion date.
    property dateCompleted : TFslDateTime read GetDateCompletedST write SetDateCompletedST;
    // Completion date.
    property dateCompletedElement : TFhirDate read FDateCompleted write SetDateCompleted;

    // Typed access to Revision date.
    property dateRevised : TFslDateTime read GetDateRevisedST write SetDateRevisedST;
    // Revision date.
    property dateRevisedElement : TFhirDate read FDateRevised write SetDateRevised;

    // Subcomponent of certainty.
    property pubMedPubDateList : TFhirCitationMedlinePubMedPubMedPubDateList read GetPubMedPubDateList;
    property hasPubMedPubDateList : boolean read GetHasPubMedPubDateList;

    // Typed access to Publication Status. (defined for API consistency)
    property publicationState : TFhirCodeableConcept read FPublicationState write SetPublicationState;
    // Publication Status.
    property publicationStateElement : TFhirCodeableConcept read FPublicationState write SetPublicationState;

    // Related article.
    property relatedArticleList : TFhirCitationMedlinePubMedRelatedArticleList read GetRelatedArticleList;
    property hasRelatedArticleList : boolean read GetHasRelatedArticleList;

  end;

  TFhirCitationMedlinePubMedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationMedlinePubMedList;
    function GetCurrent : TFhirCitationMedlinePubMed;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationMedlinePubMedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationMedlinePubMed read GetCurrent;
  end;

  TFhirCitationMedlinePubMedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationMedlinePubMed;
    procedure SetItemN(index : Integer; value : TFhirCitationMedlinePubMed);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationMedlinePubMedList; overload;
    function Clone : TFhirCitationMedlinePubMedList; overload;
    function GetEnumerator : TFhirCitationMedlinePubMedListEnumerator;
    
    //  Add a FhirCitationMedlinePubMed to the end of the list.
    function Append : TFhirCitationMedlinePubMed;
    
    // Add an already existing FhirCitationMedlinePubMed to the end of the list.
    procedure AddItem(value : TFhirCitationMedlinePubMed); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationMedlinePubMed) : Integer;
    
    // Insert FhirCitationMedlinePubMed before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationMedlinePubMed;
    
    // Insert an existing FhirCitationMedlinePubMed before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationMedlinePubMed);
    
    // Get the iIndexth FhirCitationMedlinePubMed. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationMedlinePubMed);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationMedlinePubMed;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationMedlinePubMeds[index : Integer] : TFhirCitationMedlinePubMed read GetItemN write SetItemN; default;
  End;

  // Subcomponent of certainty.
  TFhirCitationMedlinePubMedPubMedPubDate = class (TFhirBackboneElement)
  protected
    FPublicationState : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    procedure SetPublicationState(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationMedlinePubMedPubMedPubDate; overload;
    function Clone : TFhirCitationMedlinePubMedPubMedPubDate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to PubMed Publication Status. (defined for API consistency)
    property publicationState : TFhirCodeableConcept read FPublicationState write SetPublicationState;
    // PubMed Publication Status.
    property publicationStateElement : TFhirCodeableConcept read FPublicationState write SetPublicationState;

    // Typed access to PubMed Publication Date.
    property date : TFslDateTime read GetDateST write SetDateST;
    // PubMed Publication Date.
    property dateElement : TFhirDateTime read FDate write SetDate;

  end;

  TFhirCitationMedlinePubMedPubMedPubDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationMedlinePubMedPubMedPubDateList;
    function GetCurrent : TFhirCitationMedlinePubMedPubMedPubDate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationMedlinePubMedPubMedPubDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationMedlinePubMedPubMedPubDate read GetCurrent;
  end;

  TFhirCitationMedlinePubMedPubMedPubDateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationMedlinePubMedPubMedPubDate;
    procedure SetItemN(index : Integer; value : TFhirCitationMedlinePubMedPubMedPubDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationMedlinePubMedPubMedPubDateList; overload;
    function Clone : TFhirCitationMedlinePubMedPubMedPubDateList; overload;
    function GetEnumerator : TFhirCitationMedlinePubMedPubMedPubDateListEnumerator;
    
    //  Add a FhirCitationMedlinePubMedPubMedPubDate to the end of the list.
    function Append : TFhirCitationMedlinePubMedPubMedPubDate;
    
    // Add an already existing FhirCitationMedlinePubMedPubMedPubDate to the end of the list.
    procedure AddItem(value : TFhirCitationMedlinePubMedPubMedPubDate); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationMedlinePubMedPubMedPubDate) : Integer;
    
    // Insert FhirCitationMedlinePubMedPubMedPubDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationMedlinePubMedPubMedPubDate;
    
    // Insert an existing FhirCitationMedlinePubMedPubMedPubDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationMedlinePubMedPubMedPubDate);
    
    // Get the iIndexth FhirCitationMedlinePubMedPubMedPubDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationMedlinePubMedPubMedPubDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationMedlinePubMedPubMedPubDate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationMedlinePubMedPubMedPubDates[index : Integer] : TFhirCitationMedlinePubMedPubMedPubDate read GetItemN write SetItemN; default;
  End;

  // Related article.
  TFhirCitationMedlinePubMedRelatedArticle = class (TFhirBackboneElement)
  protected
    FCitationReference : TFhirReference;
    FCitationMarkdown : TFhirMarkdown;
    FidentifierList : TFhirIdentifierList;
    procedure SetCitationReference(value : TFhirReference);
    procedure SetCitationMarkdown(value : TFhirMarkdown);
    function GetCitationMarkdownST : String;
    procedure SetCitationMarkdownST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitationMedlinePubMedRelatedArticle; overload;
    function Clone : TFhirCitationMedlinePubMedRelatedArticle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Citation Resource for related article. (defined for API consistency)
    property citationReference : TFhirReference read FCitationReference write SetCitationReference;
    // Citation Resource for related article.
    property citationReferenceElement : TFhirReference read FCitationReference write SetCitationReference;

    // Typed access to Citation string for related article.
    property citationMarkdown : String read GetCitationMarkdownST write SetCitationMarkdownST;
    // Citation string for related article.
    property citationMarkdownElement : TFhirMarkdown read FCitationMarkdown write SetCitationMarkdown;

    // Identifier for related article.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

  end;

  TFhirCitationMedlinePubMedRelatedArticleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationMedlinePubMedRelatedArticleList;
    function GetCurrent : TFhirCitationMedlinePubMedRelatedArticle;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationMedlinePubMedRelatedArticleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitationMedlinePubMedRelatedArticle read GetCurrent;
  end;

  TFhirCitationMedlinePubMedRelatedArticleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitationMedlinePubMedRelatedArticle;
    procedure SetItemN(index : Integer; value : TFhirCitationMedlinePubMedRelatedArticle);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationMedlinePubMedRelatedArticleList; overload;
    function Clone : TFhirCitationMedlinePubMedRelatedArticleList; overload;
    function GetEnumerator : TFhirCitationMedlinePubMedRelatedArticleListEnumerator;
    
    //  Add a FhirCitationMedlinePubMedRelatedArticle to the end of the list.
    function Append : TFhirCitationMedlinePubMedRelatedArticle;
    
    // Add an already existing FhirCitationMedlinePubMedRelatedArticle to the end of the list.
    procedure AddItem(value : TFhirCitationMedlinePubMedRelatedArticle); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitationMedlinePubMedRelatedArticle) : Integer;
    
    // Insert FhirCitationMedlinePubMedRelatedArticle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitationMedlinePubMedRelatedArticle;
    
    // Insert an existing FhirCitationMedlinePubMedRelatedArticle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitationMedlinePubMedRelatedArticle);
    
    // Get the iIndexth FhirCitationMedlinePubMedRelatedArticle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitationMedlinePubMedRelatedArticle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitationMedlinePubMedRelatedArticle;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitationMedlinePubMedRelatedArticles[index : Integer] : TFhirCitationMedlinePubMedRelatedArticle read GetItemN write SetItemN; default;
  End;

  // The Citation.
  TFhirCitation = class (TFhirMetadataResource)
  protected
    FrelatedIdentifierList : TFhirIdentifierList;
    FsummaryList : TFhirCitationSummaryList;
    FDateCited : TFhirDateTime;
    FVariantCitation : TFhirCitationVariantCitation;
    FPublishingModel : TFhirCodeableConcept;
    FJournal : TFhirCitationJournal;
    FPublicationInfo : TFhirCitationPublicationInfo;
    FArticleTitle : TFhirMarkdown;
    FalternativeTitleList : TFhirCitationAlternativeTitleList;
    FPagination : TFhirCitationPagination;
    FarticleUrlList : TFhirCitationArticleUrlList;
    FAbstract : TFhirMarkdown;
    FAbstractCopyright : TFhirMarkdown;
    FalternativeAbstractList : TFhirCitationAlternativeAbstractList;
    FContributorship : TFhirCitationContributorship;
    FArticleLanguage : TFhirCodeableConcept;
    FalternativeFormList : TFhirCitationAlternativeFormList;
    FclassifierList : TFhirCodeableConceptList;
    FkeywordListList : TFhirCitationKeywordListList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FnoteList : TFhirAnnotationList;
    FMedlinePubMed : TFhirCitationMedlinePubMed;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetRelatedIdentifierList : TFhirIdentifierList;
    function GetHasRelatedIdentifierList : Boolean;
    function GetSummaryList : TFhirCitationSummaryList;
    function GetHasSummaryList : Boolean;
    procedure SetDateCited(value : TFhirDateTime);
    function GetDateCitedST : TFslDateTime;
    procedure SetDateCitedST(value : TFslDateTime);
    procedure SetVariantCitation(value : TFhirCitationVariantCitation);
    procedure SetPublishingModel(value : TFhirCodeableConcept);
    procedure SetJournal(value : TFhirCitationJournal);
    procedure SetPublicationInfo(value : TFhirCitationPublicationInfo);
    procedure SetArticleTitle(value : TFhirMarkdown);
    function GetArticleTitleST : String;
    procedure SetArticleTitleST(value : String);
    function GetAlternativeTitleList : TFhirCitationAlternativeTitleList;
    function GetHasAlternativeTitleList : Boolean;
    procedure SetPagination(value : TFhirCitationPagination);
    function GetArticleUrlList : TFhirCitationArticleUrlList;
    function GetHasArticleUrlList : Boolean;
    procedure SetAbstract(value : TFhirMarkdown);
    function GetAbstractST : String;
    procedure SetAbstractST(value : String);
    procedure SetAbstractCopyright(value : TFhirMarkdown);
    function GetAbstractCopyrightST : String;
    procedure SetAbstractCopyrightST(value : String);
    function GetAlternativeAbstractList : TFhirCitationAlternativeAbstractList;
    function GetHasAlternativeAbstractList : Boolean;
    procedure SetContributorship(value : TFhirCitationContributorship);
    procedure SetArticleLanguage(value : TFhirCodeableConcept);
    function GetAlternativeFormList : TFhirCitationAlternativeFormList;
    function GetHasAlternativeFormList : Boolean;
    function GetClassifierList : TFhirCodeableConceptList;
    function GetHasClassifierList : Boolean;
    function GetKeywordListList : TFhirCitationKeywordListList;
    function GetHasKeywordListList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetMedlinePubMed(value : TFhirCitationMedlinePubMed);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCitation; overload;
    function Clone : TFhirCitation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this citation when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) {$IFNDEF FPC}published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this citation when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) {$IFNDEF FPC}published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate citation instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A formal identifier that is used to identify this citation when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A formal identifier that is used to identify things closely related to this citation.
    property relatedIdentifierList : TFhirIdentifierList read GetRelatedIdentifierList;
    property hasRelatedIdentifierList : boolean read GetHasRelatedIdentifierList;

    // A human-readable display of the citation.
    property summaryList : TFhirCitationSummaryList read GetSummaryList;
    property hasSummaryList : boolean read GetHasSummaryList;

    // Typed access to Date Cited.
    property dateCited : TFslDateTime read GetDateCitedST write SetDateCitedST;
    // Date Cited.
    property dateCitedElement : TFhirDateTime read FDateCited write SetDateCited;

    // Typed access to Variant citation. (defined for API consistency)
    property variantCitation : TFhirCitationVariantCitation read FVariantCitation write SetVariantCitation;
    // Variant citation.
    property variantCitationElement : TFhirCitationVariantCitation read FVariantCitation write SetVariantCitation;

    // Typed access to Identify the medium/media in which the cited article is {$IFNDEF FPC}published{$ENDIF}, eg print, electronic or print-electronic. (defined for API consistency)
    property publishingModel : TFhirCodeableConcept read FPublishingModel write SetPublishingModel;
    // Identify the medium/media in which the cited article is {$IFNDEF FPC}published{$ENDIF}, eg print, electronic or print-electronic.
    property publishingModelElement : TFhirCodeableConcept read FPublishingModel write SetPublishingModel;

    // Typed access to Contains identifiers and classifiers for the journal cited. (defined for API consistency)
    property journal : TFhirCitationJournal read FJournal write SetJournal;
    // Contains identifiers and classifiers for the journal cited.
    property journalElement : TFhirCitationJournal read FJournal write SetJournal;

    // Typed access to Citation detail for sources other than journals such as books and databases. (defined for API consistency)
    property publicationInfo : TFhirCitationPublicationInfo read FPublicationInfo write SetPublicationInfo;
    // Citation detail for sources other than journals such as books and databases.
    property publicationInfoElement : TFhirCitationPublicationInfo read FPublicationInfo write SetPublicationInfo;

    // Typed access to Full title of the article.
    property articleTitle : String read GetArticleTitleST write SetArticleTitleST;
    // Full title of the article.
    property articleTitleElement : TFhirMarkdown read FArticleTitle write SetArticleTitle;

    // Used for variant titles, such as translations.
    property alternativeTitleList : TFhirCitationAlternativeTitleList read GetAlternativeTitleList;
    property hasAlternativeTitleList : boolean read GetHasAlternativeTitleList;

    // Typed access to Indicates the inclusive pages for the article cited. (defined for API consistency)
    property pagination : TFhirCitationPagination read FPagination write SetPagination;
    // Indicates the inclusive pages for the article cited.
    property paginationElement : TFhirCitationPagination read FPagination write SetPagination;

    // Used for any URL for the article cited.
    property articleUrlList : TFhirCitationArticleUrlList read GetArticleUrlList;
    property hasArticleUrlList : boolean read GetHasArticleUrlList;

    // Typed access to Abstract text, as {$IFNDEF FPC}published{$ENDIF}; may include structured labels.
    property abstract : String read GetAbstractST write SetAbstractST;
    // Abstract text, as {$IFNDEF FPC}published{$ENDIF}; may include structured labels.
    property abstractElement : TFhirMarkdown read FAbstract write SetAbstract;

    // Typed access to Copyright information for the abstract text.
    property abstractCopyright : String read GetAbstractCopyrightST write SetAbstractCopyrightST;
    // Copyright information for the abstract text.
    property abstractCopyrightElement : TFhirMarkdown read FAbstractCopyright write SetAbstractCopyright;

    // Used for variant abstracts, such as translations.
    property alternativeAbstractList : TFhirCitationAlternativeAbstractList read GetAlternativeAbstractList;
    property hasAlternativeAbstractList : boolean read GetHasAlternativeAbstractList;

    // Typed access to This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements. (defined for API consistency)
    property contributorship : TFhirCitationContributorship read FContributorship write SetContributorship;
    // This element is used to list authors and other contributors, their contact information, specific contributions, and summary statements.
    property contributorshipElement : TFhirCitationContributorship read FContributorship write SetContributorship;

    // Typed access to The language in which the article is {$IFNDEF FPC}published{$ENDIF}. (defined for API consistency)
    property articleLanguage : TFhirCodeableConcept read FArticleLanguage write SetArticleLanguage;
    // The language in which the article is {$IFNDEF FPC}published{$ENDIF}.
    property articleLanguageElement : TFhirCodeableConcept read FArticleLanguage write SetArticleLanguage;

    // Used to represent alternative forms of the article that are not separate citations.
    property alternativeFormList : TFhirCitationAlternativeFormList read GetAlternativeFormList;
    property hasAlternativeFormList : boolean read GetHasAlternativeFormList;

    // Used for many classifiers including PublicationType, CitationSubset, MeshHeading, Chemical.
    property classifierList : TFhirCodeableConceptList read GetClassifierList;
    property hasClassifierList : boolean read GetHasClassifierList;

    // A list of words classified as keywords for specific use in search functions.
    property keywordListList : TFhirCitationKeywordListList read GetKeywordListList;
    property hasKeywordListList : boolean read GetHasKeywordListList;

    // Link or citation to artifact associated with the referenced material.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Used for general notes and annotations not coded elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to These elements are items with values assigned by MEDLINE or PubMed management. (defined for API consistency)
    property medlinePubMed : TFhirCitationMedlinePubMed read FMedlinePubMed write SetMedlinePubMed;
    // These elements are items with values assigned by MEDLINE or PubMed management.
    property medlinePubMedElement : TFhirCitationMedlinePubMed read FMedlinePubMed write SetMedlinePubMed;

  end;

  TFhirCitationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCitationList;
    function GetCurrent : TFhirCitation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCitationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCitation read GetCurrent;
  end;

  TFhirCitationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCitation;
    procedure SetItemN(index : Integer; value : TFhirCitation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCitationList; overload;
    function Clone : TFhirCitationList; overload;
    function GetEnumerator : TFhirCitationListEnumerator;
    
    //  Add a FhirCitation to the end of the list.
    function Append : TFhirCitation;
    
    // Add an already existing FhirCitation to the end of the list.
    procedure AddItem(value : TFhirCitation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCitation) : Integer;
    
    // Insert FhirCitation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCitation;
    
    // Insert an existing FhirCitation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCitation);
    
    // Get the iIndexth FhirCitation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCitation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCitation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCitations[index : Integer] : TFhirCitation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirClaimRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference;
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    procedure SetClaim(value : TFhirReference);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimRelated; overload;
    function Clone : TFhirClaimRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirClaimRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimRelatedList;
    function GetCurrent : TFhirClaimRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimRelated read GetCurrent;
  end;

  TFhirClaimRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimRelated;
    procedure SetItemN(index : Integer; value : TFhirClaimRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimRelatedList; overload;
    function Clone : TFhirClaimRelatedList; overload;
    function GetEnumerator : TFhirClaimRelatedListEnumerator;
    
    //  Add a FhirClaimRelated to the end of the list.
    function Append : TFhirClaimRelated;
    
    // Add an already existing FhirClaimRelated to the end of the list.
    procedure AddItem(value : TFhirClaimRelated); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimRelated) : Integer;
    
    // Insert FhirClaimRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimRelated;
    
    // Insert an existing FhirClaimRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimRelated);
    
    // Get the iIndexth FhirClaimRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimRelateds[index : Integer] : TFhirClaimRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirClaimPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimPayee; overload;
    function Clone : TFhirClaimPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirClaimPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimPayeeList;
    function GetCurrent : TFhirClaimPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimPayee read GetCurrent;
  end;

  TFhirClaimPayeeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimPayee;
    procedure SetItemN(index : Integer; value : TFhirClaimPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimPayeeList; overload;
    function Clone : TFhirClaimPayeeList; overload;
    function GetEnumerator : TFhirClaimPayeeListEnumerator;
    
    //  Add a FhirClaimPayee to the end of the list.
    function Append : TFhirClaimPayee;
    
    // Add an already existing FhirClaimPayee to the end of the list.
    procedure AddItem(value : TFhirClaimPayee); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimPayee) : Integer;
    
    // Insert FhirClaimPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimPayee;
    
    // Insert an existing FhirClaimPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimPayee);
    
    // Get the iIndexth FhirClaimPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimPayee;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimPayees[index : Integer] : TFhirClaimPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirClaimCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference;
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetProvider(value : TFhirReference);
    procedure SetResponsible(value : TFhirBoolean);
    function GetResponsibleST : Boolean;
    procedure SetResponsibleST(value : Boolean);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetQualification(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimCareTeam; overload;
    function Clone : TFhirClaimCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirClaimCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimCareTeamList;
    function GetCurrent : TFhirClaimCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimCareTeam read GetCurrent;
  end;

  TFhirClaimCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimCareTeam;
    procedure SetItemN(index : Integer; value : TFhirClaimCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimCareTeamList; overload;
    function Clone : TFhirClaimCareTeamList; overload;
    function GetEnumerator : TFhirClaimCareTeamListEnumerator;
    
    //  Add a FhirClaimCareTeam to the end of the list.
    function Append : TFhirClaimCareTeam;
    
    // Add an already existing FhirClaimCareTeam to the end of the list.
    procedure AddItem(value : TFhirClaimCareTeam); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimCareTeam) : Integer;
    
    // Insert FhirClaimCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimCareTeam;
    
    // Insert an existing FhirClaimCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimCareTeam);
    
    // Get the iIndexth FhirClaimCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimCareTeams[index : Integer] : TFhirClaimCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirClaimSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirDataType;
    FValue : TFhirDataType;
    FReason : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetTiming(value : TFhirDataType);
    procedure SetValue(value : TFhirDataType);
    procedure SetReason(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimSupportingInfo; overload;
    function Clone : TFhirClaimSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirClaimSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimSupportingInfoList;
    function GetCurrent : TFhirClaimSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimSupportingInfo read GetCurrent;
  end;

  TFhirClaimSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirClaimSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimSupportingInfoList; overload;
    function Clone : TFhirClaimSupportingInfoList; overload;
    function GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
    
    //  Add a FhirClaimSupportingInfo to the end of the list.
    function Append : TFhirClaimSupportingInfo;
    
    // Add an already existing FhirClaimSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirClaimSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimSupportingInfo) : Integer;
    
    // Insert FhirClaimSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimSupportingInfo;
    
    // Insert an existing FhirClaimSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimSupportingInfo);
    
    // Get the iIndexth FhirClaimSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimSupportingInfos[index : Integer] : TFhirClaimSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirClaimDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirDataType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetDiagnosis(value : TFhirDataType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetOnAdmission(value : TFhirCodeableConcept);
    procedure SetPackageCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimDiagnosis; overload;
    function Clone : TFhirClaimDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirClaimDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimDiagnosisList;
    function GetCurrent : TFhirClaimDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimDiagnosis read GetCurrent;
  end;

  TFhirClaimDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirClaimDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimDiagnosisList; overload;
    function Clone : TFhirClaimDiagnosisList; overload;
    function GetEnumerator : TFhirClaimDiagnosisListEnumerator;
    
    //  Add a FhirClaimDiagnosis to the end of the list.
    function Append : TFhirClaimDiagnosis;
    
    // Add an already existing FhirClaimDiagnosis to the end of the list.
    procedure AddItem(value : TFhirClaimDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimDiagnosis) : Integer;
    
    // Insert FhirClaimDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimDiagnosis;
    
    // Insert an existing FhirClaimDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimDiagnosis);
    
    // Get the iIndexth FhirClaimDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimDiagnoses[index : Integer] : TFhirClaimDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirClaimProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirDataType;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetProcedure_(value : TFhirDataType);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimProcedure; overload;
    function Clone : TFhirClaimProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirDataType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirDataType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimProcedureList;
    function GetCurrent : TFhirClaimProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimProcedure read GetCurrent;
  end;

  TFhirClaimProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimProcedure;
    procedure SetItemN(index : Integer; value : TFhirClaimProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimProcedureList; overload;
    function Clone : TFhirClaimProcedureList; overload;
    function GetEnumerator : TFhirClaimProcedureListEnumerator;
    
    //  Add a FhirClaimProcedure to the end of the list.
    function Append : TFhirClaimProcedure;
    
    // Add an already existing FhirClaimProcedure to the end of the list.
    procedure AddItem(value : TFhirClaimProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimProcedure) : Integer;
    
    // Insert FhirClaimProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimProcedure;
    
    // Insert an existing FhirClaimProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimProcedure);
    
    // Get the iIndexth FhirClaimProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimProcedures[index : Integer] : TFhirClaimProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FIdentifier : TFhirIdentifier;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    procedure SetClaimResponse(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimInsurance; overload;
    function Clone : TFhirClaimInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to The business identifier to be used when the claim is sent for adjudication against this insurance policy. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The business identifier to be used when the claim is sent for adjudication against this insurance policy.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimInsuranceList;
    function GetCurrent : TFhirClaimInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimInsurance read GetCurrent;
  end;

  TFhirClaimInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimInsuranceList; overload;
    function Clone : TFhirClaimInsuranceList; overload;
    function GetEnumerator : TFhirClaimInsuranceListEnumerator;
    
    //  Add a FhirClaimInsurance to the end of the list.
    function Append : TFhirClaimInsurance;
    
    // Add an already existing FhirClaimInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimInsurance) : Integer;
    
    // Insert FhirClaimInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimInsurance;
    
    // Insert an existing FhirClaimInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimInsurance);
    
    // Get the iIndexth FhirClaimInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimInsurances[index : Integer] : TFhirClaimInsurance read GetItemN write SetItemN; default;
  End;

  // Details of an accident which resulted in injuries which required the products and services listed in the claim.
  TFhirClaimAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirDataType;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimAccident; overload;
    function Clone : TFhirClaimAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirDataType read FLocation write SetLocation;

  end;

  TFhirClaimAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimAccidentList;
    function GetCurrent : TFhirClaimAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimAccident read GetCurrent;
  end;

  TFhirClaimAccidentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimAccident;
    procedure SetItemN(index : Integer; value : TFhirClaimAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimAccidentList; overload;
    function Clone : TFhirClaimAccidentList; overload;
    function GetEnumerator : TFhirClaimAccidentListEnumerator;
    
    //  Add a FhirClaimAccident to the end of the list.
    function Append : TFhirClaimAccident;
    
    // Add an already existing FhirClaimAccident to the end of the list.
    procedure AddItem(value : TFhirClaimAccident); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimAccident) : Integer;
    
    // Insert FhirClaimAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimAccident;
    
    // Insert an existing FhirClaimAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimAccident);
    
    // Get the iIndexth FhirClaimAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimAccident;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimAccidents[index : Integer] : TFhirClaimAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
  TFhirClaimItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList;
    FdetailList : TFhirClaimItemDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetDetailList : TFhirClaimItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItem; overload;
    function Clone : TFhirClaimItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // CareTeam members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnosis applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The Encounters during which this Claim was created or to which the creation of this record is tightly associated.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemList;
    function GetCurrent : TFhirClaimItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItem read GetCurrent;
  end;

  TFhirClaimItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItem;
    procedure SetItemN(index : Integer; value : TFhirClaimItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemList; overload;
    function Clone : TFhirClaimItemList; overload;
    function GetEnumerator : TFhirClaimItemListEnumerator;
    
    //  Add a FhirClaimItem to the end of the list.
    function Append : TFhirClaimItem;
    
    // Add an already existing FhirClaimItem to the end of the list.
    procedure AddItem(value : TFhirClaimItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItem) : Integer;
    
    // Insert FhirClaimItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItem;
    
    // Insert an existing FhirClaimItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItem);
    
    // Get the iIndexth FhirClaimItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItems[index : Integer] : TFhirClaimItem read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FsubDetailList : TFhirClaimItemDetailSubDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetSubDetailList : TFhirClaimItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetail; overload;
    function Clone : TFhirClaimItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property subDetailList : TFhirClaimItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailList;
    function GetCurrent : TFhirClaimItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetail read GetCurrent;
  end;

  TFhirClaimItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemDetailList; overload;
    function Clone : TFhirClaimItemDetailList; overload;
    function GetEnumerator : TFhirClaimItemDetailListEnumerator;
    
    //  Add a FhirClaimItemDetail to the end of the list.
    function Append : TFhirClaimItemDetail;
    
    // Add an already existing FhirClaimItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetail) : Integer;
    
    // Insert FhirClaimItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetail;
    
    // Insert an existing FhirClaimItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetail);
    
    // Get the iIndexth FhirClaimItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItemDetails[index : Integer] : TFhirClaimItemDetail read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetailSubDetail; overload;
    function Clone : TFhirClaimItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailSubDetailList;
    function GetCurrent : TFhirClaimItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimItemDetailSubDetailList; overload;
    function Clone : TFhirClaimItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimItemDetailSubDetail;
    
    // Add an already existing FhirClaimItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetailSubDetail;
    
    // Insert an existing FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimItemDetailSubDetails[index : Integer] : TFhirClaimItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.
  TFhirClaim = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FPriority : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirClaimRelatedList;
    FPrescription : TFhirReference;
    FOriginalPrescription : TFhirReference;
    FPayee : TFhirClaimPayee;
    FReferral : TFhirReference;
    FFacility : TFhirReference;
    FcareTeamList : TFhirClaimCareTeamList;
    FsupportingInfoList : TFhirClaimSupportingInfoList;
    FdiagnosisList : TFhirClaimDiagnosisList;
    Fprocedure_List : TFhirClaimProcedureList;
    FinsuranceList : TFhirClaimInsuranceList;
    FAccident : TFhirClaimAccident;
    FitemList : TFhirClaimItemList;
    FTotal : TFhirMoney;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetBillablePeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirClaimRelatedList;
    function GetHasRelatedList : Boolean;
    procedure SetPrescription(value : TFhirReference);
    procedure SetOriginalPrescription(value : TFhirReference);
    procedure SetPayee(value : TFhirClaimPayee);
    procedure SetReferral(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    function GetCareTeamList : TFhirClaimCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirClaimSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirClaimDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirClaimProcedureList;
    function GetHasProcedure_List : Boolean;
    function GetInsuranceList : TFhirClaimInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetAccident(value : TFhirClaimAccident);
    function GetItemList : TFhirClaimItemList;
    function GetHasItemList : Boolean;
    procedure SetTotal(value : TFhirMoney);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaim; overload;
    function Clone : TFhirClaim; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this claim.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The Insurer who is target of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who is target of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirClaimRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirClaimPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirClaimPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirClaimCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirClaimSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirClaimDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirClaimProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of an accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirClaimAccident read FAccident write SetAccident;
    // Details of an accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirClaimAccident read FAccident write SetAccident;

    // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
    property itemList : TFhirClaimItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Typed access to The total value of the all the items in the claim. (defined for API consistency)
    property total : TFhirMoney read FTotal write SetTotal;
    // The total value of the all the items in the claim.
    property totalElement : TFhirMoney read FTotal write SetTotal;

  end;

  TFhirClaimListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimList;
    function GetCurrent : TFhirClaim;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaim read GetCurrent;
  end;

  TFhirClaimList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaim;
    procedure SetItemN(index : Integer; value : TFhirClaim);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimList; overload;
    function Clone : TFhirClaimList; overload;
    function GetEnumerator : TFhirClaimListEnumerator;
    
    //  Add a FhirClaim to the end of the list.
    function Append : TFhirClaim;
    
    // Add an already existing FhirClaim to the end of the list.
    procedure AddItem(value : TFhirClaim); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaim) : Integer;
    
    // Insert FhirClaim before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaim;
    
    // Insert an existing FhirClaim before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaim);
    
    // Get the iIndexth FhirClaim. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaim);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaim;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaims[index : Integer] : TFhirClaim read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirClaimResponseItem = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseItemDetailList;
    procedure SetItemSequence(value : TFhirPositiveInt);
    function GetItemSequenceST : String;
    procedure SetItemSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItem; overload;
    function Clone : TFhirClaimResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim item entries.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // A number to uniquely reference the claim item entries.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimResponseItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemList;
    function GetCurrent : TFhirClaimResponseItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItem read GetCurrent;
  end;

  TFhirClaimResponseItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemList; overload;
    function Clone : TFhirClaimResponseItemList; overload;
    function GetEnumerator : TFhirClaimResponseItemListEnumerator;
    
    //  Add a FhirClaimResponseItem to the end of the list.
    function Append : TFhirClaimResponseItem;
    
    // Add an already existing FhirClaimResponseItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItem) : Integer;
    
    // Insert FhirClaimResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItem;
    
    // Insert an existing FhirClaimResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItem);
    
    // Get the iIndexth FhirClaimResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItems[index : Integer] : TFhirClaimResponseItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirClaimResponseItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
    procedure SetValue(value : TFhirDecimal);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemAdjudication; overload;
    function Clone : TFhirClaimResponseItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemAdjudicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemAdjudicationList; overload;
    function Clone : TFhirClaimResponseItemAdjudicationList; overload;
    function GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
    
    //  Add a FhirClaimResponseItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemAdjudication;
    
    // Add an already existing FhirClaimResponseItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemAdjudication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemAdjudication) : Integer;
    
    // Insert FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemAdjudication;
    
    // Insert an existing FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // Get the iIndexth FhirClaimResponseItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemAdjudications[index : Integer] : TFhirClaimResponseItemAdjudication read GetItemN write SetItemN; default;
  End;

  // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimResponseItemDetail = class (TFhirBackboneElement)
  protected
    FDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    procedure SetDetailSequence(value : TFhirPositiveInt);
    function GetDetailSequenceST : String;
    procedure SetDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetail; overload;
    function Clone : TFhirClaimResponseItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim detail entry.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // A number to uniquely reference the claim detail entry.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A sub-detail adjudication of a simple product or service.
    property subDetailList : TFhirClaimResponseItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailList;
    function GetCurrent : TFhirClaimResponseItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemDetailList; overload;
    function Clone : TFhirClaimResponseItemDetailList; overload;
    function GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
    
    //  Add a FhirClaimResponseItemDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetail;
    
    // Add an already existing FhirClaimResponseItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetail) : Integer;
    
    // Insert FhirClaimResponseItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetail;
    
    // Insert an existing FhirClaimResponseItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemDetails[index : Integer] : TFhirClaimResponseItemDetail read GetItemN write SetItemN; default;
  End;

  // A sub-detail adjudication of a simple product or service.
  TFhirClaimResponseItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSubDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    procedure SetSubDetailSequence(value : TFhirPositiveInt);
    function GetSubDetailSequenceST : String;
    procedure SetSubDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely reference the claim sub-detail entry.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // A number to uniquely reference the claim sub-detail entry.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseItemDetailSubDetailList; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimResponseItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetail;
    
    // Add an already existing FhirClaimResponseItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    
    // Insert an existing FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseItemDetailSubDetails[index : Integer] : TFhirClaimResponseItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirClaimResponseAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubdetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubdetailSequenceList : TFhirPositiveIntList;
    function GetHasSubdetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList;
    function GetHasProviderList : Boolean;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItem; overload;
    function Clone : TFhirClaimResponseAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details within the details within the claim item which this line is intended to replace.
    property subdetailSequenceList : TFhirPositiveIntList read GetSubdetailSequenceList;
    property hasSubdetailSequenceList : boolean read GetHasSubdetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirClaimResponseAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemList;
    function GetCurrent : TFhirClaimResponseAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItem read GetCurrent;
  end;

  TFhirClaimResponseAddItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemList; overload;
    function Clone : TFhirClaimResponseAddItemList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
    
    //  Add a FhirClaimResponseAddItem to the end of the list.
    function Append : TFhirClaimResponseAddItem;
    
    // Add an already existing FhirClaimResponseAddItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItem) : Integer;
    
    // Insert FhirClaimResponseAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItem;
    
    // Insert an existing FhirClaimResponseAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItem);
    
    // Get the iIndexth FhirClaimResponseAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItems[index : Integer] : TFhirClaimResponseAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirClaimResponseAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemDetailList; overload;
    function Clone : TFhirClaimResponseAddItemDetailList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
    
    //  Add a FhirClaimResponseAddItemDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetail;
    
    // Add an already existing FhirClaimResponseAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetail) : Integer;
    
    // Insert FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetail;
    
    // Insert an existing FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItemDetails[index : Integer] : TFhirClaimResponseAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseAddItemDetailSubDetailList; overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
    
    //  Add a FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetailSubDetail;
    
    // Add an already existing FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetailSubDetail) : Integer;
    
    // Insert FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    
    // Insert an existing FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseAddItemDetailSubDetails[index : Integer] : TFhirClaimResponseAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirClaimResponseTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseTotal; overload;
    function Clone : TFhirClaimResponseTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirClaimResponseTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseTotalList;
    function GetCurrent : TFhirClaimResponseTotal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseTotal read GetCurrent;
  end;

  TFhirClaimResponseTotalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseTotal;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseTotalList; overload;
    function Clone : TFhirClaimResponseTotalList; overload;
    function GetEnumerator : TFhirClaimResponseTotalListEnumerator;
    
    //  Add a FhirClaimResponseTotal to the end of the list.
    function Append : TFhirClaimResponseTotal;
    
    // Add an already existing FhirClaimResponseTotal to the end of the list.
    procedure AddItem(value : TFhirClaimResponseTotal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseTotal) : Integer;
    
    // Insert FhirClaimResponseTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseTotal;
    
    // Insert an existing FhirClaimResponseTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseTotal);
    
    // Get the iIndexth FhirClaimResponseTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseTotal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseTotals[index : Integer] : TFhirClaimResponseTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirClaimResponsePayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAdjustment(value : TFhirMoney);
    procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAmount(value : TFhirMoney);
    procedure SetIdentifier(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponsePayment; overload;
    function Clone : TFhirClaimResponsePayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirClaimResponsePaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponsePaymentList;
    function GetCurrent : TFhirClaimResponsePayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponsePaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponsePayment read GetCurrent;
  end;

  TFhirClaimResponsePaymentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponsePayment;
    procedure SetItemN(index : Integer; value : TFhirClaimResponsePayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponsePaymentList; overload;
    function Clone : TFhirClaimResponsePaymentList; overload;
    function GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
    
    //  Add a FhirClaimResponsePayment to the end of the list.
    function Append : TFhirClaimResponsePayment;
    
    // Add an already existing FhirClaimResponsePayment to the end of the list.
    procedure AddItem(value : TFhirClaimResponsePayment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponsePayment) : Integer;
    
    // Insert FhirClaimResponsePayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponsePayment;
    
    // Insert an existing FhirClaimResponsePayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponsePayment);
    
    // Get the iIndexth FhirClaimResponsePayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponsePayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponsePayment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponsePayments[index : Integer] : TFhirClaimResponsePayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirClaimResponseProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    procedure SetNumber(value : TFhirPositiveInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseProcessNote; overload;
    function Clone : TFhirClaimResponseProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirClaimResponseProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseProcessNoteList;
    function GetCurrent : TFhirClaimResponseProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseProcessNote read GetCurrent;
  end;

  TFhirClaimResponseProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseProcessNote;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseProcessNoteList; overload;
    function Clone : TFhirClaimResponseProcessNoteList; overload;
    function GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
    
    //  Add a FhirClaimResponseProcessNote to the end of the list.
    function Append : TFhirClaimResponseProcessNote;
    
    // Add an already existing FhirClaimResponseProcessNote to the end of the list.
    procedure AddItem(value : TFhirClaimResponseProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseProcessNote) : Integer;
    
    // Insert FhirClaimResponseProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseProcessNote;
    
    // Insert an existing FhirClaimResponseProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // Get the iIndexth FhirClaimResponseProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseProcessNotes[index : Integer] : TFhirClaimResponseProcessNote read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimResponseInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    FClaimResponse : TFhirReference;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
    procedure SetClaimResponse(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseInsurance; overload;
    function Clone : TFhirClaimResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseInsuranceList;
    function GetCurrent : TFhirClaimResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseInsurance read GetCurrent;
  end;

  TFhirClaimResponseInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseInsuranceList; overload;
    function Clone : TFhirClaimResponseInsuranceList; overload;
    function GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
    
    //  Add a FhirClaimResponseInsurance to the end of the list.
    function Append : TFhirClaimResponseInsurance;
    
    // Add an already existing FhirClaimResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimResponseInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseInsurance) : Integer;
    
    // Insert FhirClaimResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseInsurance;
    
    // Insert an existing FhirClaimResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseInsurance);
    
    // Get the iIndexth FhirClaimResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseInsurances[index : Integer] : TFhirClaimResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the adjudication.
  TFhirClaimResponseError = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FDetailSequence : TFhirPositiveInt;
    FSubDetailSequence : TFhirPositiveInt;
    FCode : TFhirCodeableConcept;
    procedure SetItemSequence(value : TFhirPositiveInt);
    function GetItemSequenceST : String;
    procedure SetItemSequenceST(value : String);
    procedure SetDetailSequence(value : TFhirPositiveInt);
    function GetDetailSequenceST : String;
    procedure SetDetailSequenceST(value : String);
    procedure SetSubDetailSequence(value : TFhirPositiveInt);
    function GetSubDetailSequenceST : String;
    procedure SetSubDetailSequenceST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseError; overload;
    function Clone : TFhirClaimResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // Typed access to The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // Typed access to The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // Typed access to An error code, from a specified code system, which details why the claim could not be adjudicated. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code, from a specified code system, which details why the claim could not be adjudicated.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirClaimResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseErrorList;
    function GetCurrent : TFhirClaimResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseError read GetCurrent;
  end;

  TFhirClaimResponseErrorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponseError;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseErrorList; overload;
    function Clone : TFhirClaimResponseErrorList; overload;
    function GetEnumerator : TFhirClaimResponseErrorListEnumerator;
    
    //  Add a FhirClaimResponseError to the end of the list.
    function Append : TFhirClaimResponseError;
    
    // Add an already existing FhirClaimResponseError to the end of the list.
    procedure AddItem(value : TFhirClaimResponseError); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseError) : Integer;
    
    // Insert FhirClaimResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseError;
    
    // Insert an existing FhirClaimResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseError);
    
    // Get the iIndexth FhirClaimResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseError;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponseErrors[index : Integer] : TFhirClaimResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides the adjudication details from the processing of a Claim resource.
  TFhirClaimResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference;
    FRequestor : TFhirReference;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPreAuthRef : TFhirString;
    FPreAuthPeriod : TFhirPeriod;
    FPayeeType : TFhirCodeableConcept;
    FitemList : TFhirClaimResponseItemList;
    FaddItemList : TFhirClaimResponseAddItemList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FtotalList : TFhirClaimResponseTotalList;
    FPayment : TFhirClaimResponsePayment;
    FFundsReserve : TFhirCodeableConcept;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirClaimResponseProcessNoteList;
    FcommunicationRequestList : TFhirReferenceList;
    FinsuranceList : TFhirClaimResponseInsuranceList;
    FerrorList : TFhirClaimResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetInsurer(value : TFhirReference);
    procedure SetRequestor(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetPreAuthRef(value : TFhirString);
    function GetPreAuthRefST : String;
    procedure SetPreAuthRefST(value : String);
    procedure SetPreAuthPeriod(value : TFhirPeriod);
    procedure SetPayeeType(value : TFhirCodeableConcept);
    function GetItemList : TFhirClaimResponseItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirClaimResponseAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirClaimResponseTotalList;
    function GetHasTotalList : Boolean;
    procedure SetPayment(value : TFhirClaimResponsePayment);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    procedure SetFormCode(value : TFhirCodeableConcept);
    procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirClaimResponseProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetCommunicationRequestList : TFhirReferenceList;
    function GetHasCommunicationRequestList : Boolean;
    function GetInsuranceList : TFhirClaimResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetErrorList : TFhirClaimResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponse; overload;
    function Clone : TFhirClaimResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this claim response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to The time frame during which this authorization is effective. (defined for API consistency)
    property preAuthPeriod : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;
    // The time frame during which this authorization is effective.
    property preAuthPeriodElement : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;

    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property payeeType : TFhirCodeableConcept read FPayeeType write SetPayeeType;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property payeeTypeElement : TFhirCodeableConcept read FPayeeType write SetPayeeType;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirClaimResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirClaimResponseAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirClaimResponseTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirClaimResponsePayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirClaimResponsePayment read FPayment write SetPayment;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirClaimResponseProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Request for additional supporting or authorizing information.
    property communicationRequestList : TFhirReferenceList read GetCommunicationRequestList;
    property hasCommunicationRequestList : boolean read GetHasCommunicationRequestList;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Errors encountered during the processing of the adjudication.
    property errorList : TFhirClaimResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirClaimResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseList;
    function GetCurrent : TFhirClaimResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponse read GetCurrent;
  end;

  TFhirClaimResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClaimResponse;
    procedure SetItemN(index : Integer; value : TFhirClaimResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClaimResponseList; overload;
    function Clone : TFhirClaimResponseList; overload;
    function GetEnumerator : TFhirClaimResponseListEnumerator;
    
    //  Add a FhirClaimResponse to the end of the list.
    function Append : TFhirClaimResponse;
    
    // Add an already existing FhirClaimResponse to the end of the list.
    procedure AddItem(value : TFhirClaimResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponse) : Integer;
    
    // Insert FhirClaimResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponse;
    
    // Insert an existing FhirClaimResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponse);
    
    // Get the iIndexth FhirClaimResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClaimResponses[index : Integer] : TFhirClaimResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
  // A suite of underwriter specific classifiers.
  TFhirCoverageClass = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    FName : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageClass; overload;
    function Clone : TFhirCoverageClass; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of classification for which an insurer-specific class label or number and optional name is provided.  For example, type may be used to identify a class of coverage or employer group, policy, or plan. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of classification for which an insurer-specific class label or number and optional name is provided.  For example, type may be used to identify a class of coverage or employer group, policy, or plan.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The alphanumeric string value associated with the insurer issued label.
    property value : String read GetValueST write SetValueST;
    // The alphanumeric string value associated with the insurer issued label.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to A short description for the class.
    property name : String read GetNameST write SetNameST;
    // A short description for the class.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirCoverageClassListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageClassList;
    function GetCurrent : TFhirCoverageClass;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageClassList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageClass read GetCurrent;
  end;

  TFhirCoverageClassList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageClass;
    procedure SetItemN(index : Integer; value : TFhirCoverageClass);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageClassList; overload;
    function Clone : TFhirCoverageClassList; overload;
    function GetEnumerator : TFhirCoverageClassListEnumerator;
    
    //  Add a FhirCoverageClass to the end of the list.
    function Append : TFhirCoverageClass;
    
    // Add an already existing FhirCoverageClass to the end of the list.
    procedure AddItem(value : TFhirCoverageClass); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageClass) : Integer;
    
    // Insert FhirCoverageClass before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageClass;
    
    // Insert an existing FhirCoverageClass before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageClass);
    
    // Get the iIndexth FhirCoverageClass. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageClass);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageClass;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageClasses[index : Integer] : TFhirCoverageClass read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
  TFhirCoverageCostToBeneficiary = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FexceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    function GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetHasExceptionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiary; overload;
    function Clone : TFhirCoverageCostToBeneficiary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of patient centric costs associated with treatment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of patient centric costs associated with treatment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount due from the patient for the cost category. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The amount due from the patient for the cost category.
    property valueElement : TFhirDataType read FValue write SetValue;

    // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
    property exceptionList : TFhirCoverageCostToBeneficiaryExceptionList read GetExceptionList;
    property hasExceptionList : boolean read GetHasExceptionList;

  end;

  TFhirCoverageCostToBeneficiaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryList;
    function GetCurrent : TFhirCoverageCostToBeneficiary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiary read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiary;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageCostToBeneficiaryList; overload;
    function Clone : TFhirCoverageCostToBeneficiaryList; overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
    
    //  Add a FhirCoverageCostToBeneficiary to the end of the list.
    function Append : TFhirCoverageCostToBeneficiary;
    
    // Add an already existing FhirCoverageCostToBeneficiary to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiary); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiary) : Integer;
    
    // Insert FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiary;
    
    // Insert an existing FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // Get the iIndexth FhirCoverageCostToBeneficiary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageCostToBeneficiaries[index : Integer] : TFhirCoverageCostToBeneficiary read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
  TFhirCoverageCostToBeneficiaryException = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiaryException; overload;
    function Clone : TFhirCoverageCostToBeneficiaryException; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code for the specific exception. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The code for the specific exception.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The timeframe the exception is in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe the exception is in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCoverageCostToBeneficiaryExceptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetCurrent : TFhirCoverageCostToBeneficiaryException;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiaryException read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryExceptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageCostToBeneficiaryExceptionList; overload;
    function Clone : TFhirCoverageCostToBeneficiaryExceptionList; overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
    
    //  Add a FhirCoverageCostToBeneficiaryException to the end of the list.
    function Append : TFhirCoverageCostToBeneficiaryException;
    
    // Add an already existing FhirCoverageCostToBeneficiaryException to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiaryException); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiaryException) : Integer;
    
    // Insert FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    
    // Insert an existing FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // Get the iIndexth FhirCoverageCostToBeneficiaryException. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageCostToBeneficiaryExceptions[index : Integer] : TFhirCoverageCostToBeneficiaryException read GetItemN write SetItemN; default;
  End;

  // Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.
  TFhirCoverage = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FPolicyHolder : TFhirReference;
    FSubscriber : TFhirReference;
    FSubscriberId : TFhirIdentifier;
    FBeneficiary : TFhirReference;
    FDependent : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FpayorList : TFhirReferenceList;
    Fclass_List : TFhirCoverageClassList;
    FOrder : TFhirPositiveInt;
    FNetwork : TFhirString;
    FcostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    FSubrogation : TFhirBoolean;
    FcontractList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetPolicyHolder(value : TFhirReference);
    procedure SetSubscriber(value : TFhirReference);
    procedure SetSubscriberId(value : TFhirIdentifier);
    procedure SetBeneficiary(value : TFhirReference);
    procedure SetDependent(value : TFhirString);
    function GetDependentST : String;
    procedure SetDependentST(value : String);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    function GetPayorList : TFhirReferenceList;
    function GetHasPayorList : Boolean;
    function GetClass_List : TFhirCoverageClassList;
    function GetHasClass_List : Boolean;
    procedure SetOrder(value : TFhirPositiveInt);
    function GetOrderST : String;
    procedure SetOrderST(value : String);
    procedure SetNetwork(value : TFhirString);
    function GetNetworkST : String;
    procedure SetNetworkST(value : String);
    function GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    function GetHasCostToBeneficiaryList : Boolean;
    procedure SetSubrogation(value : TFhirBoolean);
    function GetSubrogationST : Boolean;
    procedure SetSubrogationST(value : Boolean);
    function GetContractList : TFhirReferenceList;
    function GetHasContractList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverage; overload;
    function Clone : TFhirCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The party who 'owns' the insurance policy. (defined for API consistency)
    property policyHolder : TFhirReference read FPolicyHolder write SetPolicyHolder;
    // The party who 'owns' the insurance policy.
    property policyHolderElement : TFhirReference read FPolicyHolder write SetPolicyHolder;

    // Typed access to The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due. (defined for API consistency)
    property subscriber : TFhirReference read FSubscriber write SetSubscriber;
    // The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due.
    property subscriberElement : TFhirReference read FSubscriber write SetSubscriber;

    // Typed access to The insurer assigned ID for the Subscriber. (defined for API consistency)
    property subscriberId : TFhirIdentifier read FSubscriberId write SetSubscriberId;
    // The insurer assigned ID for the Subscriber.
    property subscriberIdElement : TFhirIdentifier read FSubscriberId write SetSubscriberId;

    // Typed access to The party who benefits from the insurance coverage; the patient when products and/or services are provided. (defined for API consistency)
    property beneficiary : TFhirReference read FBeneficiary write SetBeneficiary;
    // The party who benefits from the insurance coverage; the patient when products and/or services are provided.
    property beneficiaryElement : TFhirReference read FBeneficiary write SetBeneficiary;

    // Typed access to A designator for a dependent under the coverage.
    property dependent : String read GetDependentST write SetDependentST;
    // A designator for a dependent under the coverage.
    property dependentElement : TFhirString read FDependent write SetDependent;

    // Typed access to The relationship of beneficiary (patient) to the subscriber. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The relationship of beneficiary (patient) to the subscriber.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The program or plan underwriter or payor including both insurance and non-insurance agreements, such as patient-pay agreements.
    property payorList : TFhirReferenceList read GetPayorList;
    property hasPayorList : boolean read GetHasPayorList;

    // A suite of underwriter specific classifiers.
    property class_List : TFhirCoverageClassList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // Typed access to The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property order : String read GetOrderST write SetOrderST;
    // The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property orderElement : TFhirPositiveInt read FOrder write SetOrder;

    // Typed access to The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property network : String read GetNetworkST write SetNetworkST;
    // The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property networkElement : TFhirString read FNetwork write SetNetwork;

    // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
    property costToBeneficiaryList : TFhirCoverageCostToBeneficiaryList read GetCostToBeneficiaryList;
    property hasCostToBeneficiaryList : boolean read GetHasCostToBeneficiaryList;

    // Typed access to When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogation : Boolean read GetSubrogationST write SetSubrogationST;
    // When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogationElement : TFhirBoolean read FSubrogation write SetSubrogation;

    // The policy(s) which constitute this insurance coverage.
    property contractList : TFhirReferenceList read GetContractList;
    property hasContractList : boolean read GetHasContractList;

  end;

  TFhirCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageList;
    function GetCurrent : TFhirCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverage read GetCurrent;
  end;

  TFhirCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverage;
    procedure SetItemN(index : Integer; value : TFhirCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageList; overload;
    function Clone : TFhirCoverageList; overload;
    function GetEnumerator : TFhirCoverageListEnumerator;
    
    //  Add a FhirCoverage to the end of the list.
    function Append : TFhirCoverage;
    
    // Add an already existing FhirCoverage to the end of the list.
    procedure AddItem(value : TFhirCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverage) : Integer;
    
    // Insert FhirCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverage;
    
    // Insert an existing FhirCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverage);
    
    // Get the iIndexth FhirCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverages[index : Integer] : TFhirCoverage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirCoverageEligibilityRequestSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FInformation : TFhirReference;
    FAppliesToAll : TFhirBoolean;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetInformation(value : TFhirReference);
    procedure SetAppliesToAll(value : TFhirBoolean);
    function GetAppliesToAllST : Boolean;
    procedure SetAppliesToAllST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property information : TFhirReference read FInformation write SetInformation;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property informationElement : TFhirReference read FInformation write SetInformation;

    // Typed access to The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAll : Boolean read GetAppliesToAllST write SetAppliesToAllST;
    // The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAllElement : TFhirBoolean read FAppliesToAll write SetAppliesToAll;

  end;

  TFhirCoverageEligibilityRequestSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestSupportingInfo read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestSupportingInfoList; overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfoList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    function Append : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // Add an already existing FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestSupportingInfo) : Integer;
    
    // Insert FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // Insert an existing FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // Get the iIndexth FhirCoverageEligibilityRequestSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestSupportingInfos[index : Integer] : TFhirCoverageEligibilityRequestSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityRequestInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FBusinessArrangement : TFhirString;
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    procedure SetBusinessArrangement(value : TFhirString);
    function GetBusinessArrangementST : String;
    procedure SetBusinessArrangementST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestInsurance; overload;
    function Clone : TFhirCoverageEligibilityRequestInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

  end;

  TFhirCoverageEligibilityRequestInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityRequestInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestInsuranceList; overload;
    function Clone : TFhirCoverageEligibilityRequestInsuranceList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityRequestInsurance;
    
    // Add an already existing FhirCoverageEligibilityRequestInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestInsurance) : Integer;
    
    // Insert FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    
    // Insert an existing FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityRequestInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestInsurances[index : Integer] : TFhirCoverageEligibilityRequestInsurance read GetItemN write SetItemN; default;
  End;

  // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
  TFhirCoverageEligibilityRequestItem = class (TFhirBackboneElement)
  protected
    FsupportingInfoSequenceList : TFhirPositiveIntList;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFacility : TFhirReference;
    FdiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    FdetailList : TFhirReferenceList;
    function GetSupportingInfoSequenceList : TFhirPositiveIntList;
    function GetHasSupportingInfoSequenceList : Boolean;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetProvider(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFacility(value : TFhirReference);
    function GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItem; overload;
    function Clone : TFhirCoverageEligibilityRequestItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Exceptions, special conditions and supporting information applicable for this service or product line.
    property supportingInfoSequenceList : TFhirPositiveIntList read GetSupportingInfoSequenceList;
    property hasSupportingInfoSequenceList : boolean read GetHasSupportingInfoSequenceList;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is responsible for the product or service to be rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the product or service to be rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount charged to the patient by the provider for a single unit. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // The amount charged to the patient by the provider for a single unit.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to Facility where the services will be provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services will be provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Patient diagnosis for which care is sought.
    property diagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The plan/proposal/order describing the proposed service in detail.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCoverageEligibilityRequestItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemList;
    function GetCurrent : TFhirCoverageEligibilityRequestItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItem read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestItemList; overload;
    function Clone : TFhirCoverageEligibilityRequestItemList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestItem to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItem;
    
    // Add an already existing FhirCoverageEligibilityRequestItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItem) : Integer;
    
    // Insert FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItem;
    
    // Insert an existing FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestItems[index : Integer] : TFhirCoverageEligibilityRequestItem read GetItemN write SetItemN; default;
  End;

  // Patient diagnosis for which care is sought.
  TFhirCoverageEligibilityRequestItemDiagnosis = class (TFhirBackboneElement)
  protected
    FDiagnosis : TFhirDataType;
    procedure SetDiagnosis(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

  end;

  TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItemDiagnosis read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestItemDiagnosisList; overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosisList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // Add an already existing FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItemDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItemDiagnosis) : Integer;
    
    // Insert FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // Insert an existing FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItemDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequestItemDiagnoses[index : Integer] : TFhirCoverageEligibilityRequestItemDiagnosis read GetItemN write SetItemN; default;
  End;

  // The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.
  TFhirCoverageEligibilityRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPriority : TFhirCodeableConcept;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference;
    FServiced : TFhirDataType;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FProvider : TFhirReference;
    FInsurer : TFhirReference;
    FFacility : TFhirReference;
    FsupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    FinsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    FitemList : TFhirCoverageEligibilityRequestItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetPriority(value : TFhirCodeableConcept);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    function GetPurposeST : TFhirEligibilityRequestPurposeEnumList;
    procedure SetPurposeST(value : TFhirEligibilityRequestPurposeEnumList);
    procedure SetPatient(value : TFhirReference);
    procedure SetServiced(value : TFhirDataType);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    function GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetItemList : TFhirCoverageEligibilityRequestItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequest; overload;
    function Clone : TFhirCoverageEligibilityRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the requestor expects the processor to complete processing. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // When the requestor expects the processor to complete processing.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityRequestPurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Person who created the request. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Person who created the request.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the request.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The Insurer who issued the coverage in question and is the recipient of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the recipient of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to Facility where the services are intended to be provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services are intended to be provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityRequestInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
    property itemList : TFhirCoverageEligibilityRequestItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestList;
    function GetCurrent : TFhirCoverageEligibilityRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequest read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequest;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityRequestList; overload;
    function Clone : TFhirCoverageEligibilityRequestList; overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
    
    //  Add a FhirCoverageEligibilityRequest to the end of the list.
    function Append : TFhirCoverageEligibilityRequest;
    
    // Add an already existing FhirCoverageEligibilityRequest to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequest) : Integer;
    
    // Insert FhirCoverageEligibilityRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequest;
    
    // Insert an existing FhirCoverageEligibilityRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // Get the iIndexth FhirCoverageEligibilityRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityRequests[index : Integer] : TFhirCoverageEligibilityRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityResponseInsurance = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference;
    FInforce : TFhirBoolean;
    FBenefitPeriod : TFhirPeriod;
    FitemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    procedure SetCoverage(value : TFhirReference);
    procedure SetInforce(value : TFhirBoolean);
    function GetInforceST : Boolean;
    procedure SetInforceST(value : Boolean);
    procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsurance; overload;
    function Clone : TFhirCoverageEligibilityResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Typed access to Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforce : Boolean read GetInforceST write SetInforceST;
    // Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforceElement : TFhirBoolean read FInforce write SetInforce;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Benefits and optionally current balances, and authorization details by category or service.
    property itemList : TFhirCoverageEligibilityResponseInsuranceItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsurance;
    
    // Add an already existing FhirCoverageEligibilityResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsurance) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    
    // Insert an existing FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsurances[index : Integer] : TFhirCoverageEligibilityResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Benefits and optionally current balances, and authorization details by category or service.
  TFhirCoverageEligibilityResponseInsuranceItem = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FbenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    FAuthorizationRequired : TFhirBoolean;
    FauthorizationSupportingList : TFhirCodeableConceptList;
    FAuthorizationUrl : TFhirUri;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetProvider(value : TFhirReference);
    procedure SetExcluded(value : TFhirBoolean);
    function GetExcludedST : Boolean;
    procedure SetExcludedST(value : Boolean);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNetwork(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetTerm(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetHasBenefitList : Boolean;
    procedure SetAuthorizationRequired(value : TFhirBoolean);
    function GetAuthorizationRequiredST : Boolean;
    procedure SetAuthorizationRequiredST(value : Boolean);
    function GetAuthorizationSupportingList : TFhirCodeableConceptList;
    function GetHasAuthorizationSupportingList : Boolean;
    procedure SetAuthorizationUrl(value : TFhirUri);
    function GetAuthorizationUrlST : String;
    procedure SetAuthorizationUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is eligible for the provision of the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is eligible for the provision of the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits used to date.
    property benefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

    // Typed access to A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequired : Boolean read GetAuthorizationRequiredST write SetAuthorizationRequiredST;
    // A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequiredElement : TFhirBoolean read FAuthorizationRequired write SetAuthorizationRequired;

    // Codes or comments regarding information or actions associated with the preauthorization.
    property authorizationSupportingList : TFhirCodeableConceptList read GetAuthorizationSupportingList;
    property hasAuthorizationSupportingList : boolean read GetHasAuthorizationSupportingList;

    // Typed access to A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrl : String read GetAuthorizationUrlST write SetAuthorizationUrlST;
    // A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrlElement : TFhirUri read FAuthorizationUrl write SetAuthorizationUrl;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItem read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceItemList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItem) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // Insert an existing FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsuranceItems[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItem read GetItemN write SetItemN; default;
  End;

  // Benefits used to date.
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirDataType;
    FUsed : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirDataType);
    procedure SetUsed(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirDataType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirDataType read FUsed write SetUsed;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit) : Integer;
    
    // Insert FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // Insert an existing FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItemBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseInsuranceItemBenefits[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the request.
  TFhirCoverageEligibilityResponseError = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseError; overload;
    function Clone : TFhirCoverageEligibilityResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An error code,from a specified code system, which details why the eligibility check could not be performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code,from a specified code system, which details why the eligibility check could not be performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirCoverageEligibilityResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseErrorList;
    function GetCurrent : TFhirCoverageEligibilityResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseError read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseErrorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseError;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseErrorList; overload;
    function Clone : TFhirCoverageEligibilityResponseErrorList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponseError to the end of the list.
    function Append : TFhirCoverageEligibilityResponseError;
    
    // Add an already existing FhirCoverageEligibilityResponseError to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseError); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseError) : Integer;
    
    // Insert FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseError;
    
    // Insert an existing FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // Get the iIndexth FhirCoverageEligibilityResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseError;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponseErrors[index : Integer] : TFhirCoverageEligibilityResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource.
  TFhirCoverageEligibilityResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference;
    FServiced : TFhirDataType;
    FCreated : TFhirDateTime;
    FRequestor : TFhirReference;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FInsurer : TFhirReference;
    FinsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    FPreAuthRef : TFhirString;
    FForm : TFhirCodeableConcept;
    FerrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    function GetPurposeST : TFhirEligibilityResponsePurposeEnumList;
    procedure SetPurposeST(value : TFhirEligibilityResponsePurposeEnumList);
    procedure SetPatient(value : TFhirReference);
    procedure SetServiced(value : TFhirDataType);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetRequestor(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetInsurer(value : TFhirReference);
    function GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetPreAuthRef(value : TFhirString);
    function GetPreAuthRefST : String;
    procedure SetPreAuthRefST(value : String);
    procedure SetForm(value : TFhirCodeableConcept);
    function GetErrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponse; overload;
    function Clone : TFhirCoverageEligibilityResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityResponsePurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The provider which is responsible for the request.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // Typed access to Reference to the original request resource. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Reference to the original request resource.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The outcome of the request processing.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The Insurer who issued the coverage in question and is the author of the response. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the author of the response.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // A code for the form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Errors encountered during the processing of the request.
    property errorList : TFhirCoverageEligibilityResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirCoverageEligibilityResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseList;
    function GetCurrent : TFhirCoverageEligibilityResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponse read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponse;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCoverageEligibilityResponseList; overload;
    function Clone : TFhirCoverageEligibilityResponseList; overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
    
    //  Add a FhirCoverageEligibilityResponse to the end of the list.
    function Append : TFhirCoverageEligibilityResponse;
    
    // Add an already existing FhirCoverageEligibilityResponse to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponse) : Integer;
    
    // Insert FhirCoverageEligibilityResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponse;
    
    // Insert an existing FhirCoverageEligibilityResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // Get the iIndexth FhirCoverageEligibilityResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCoverageEligibilityResponses[index : Integer] : TFhirCoverageEligibilityResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  // This resource provides the insurance enrollment details to the insurer regarding a specified coverage.
  TFhirEnrollmentRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FCandidate : TFhirReference;
    FCoverage : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetCandidate(value : TFhirReference);
    procedure SetCoverage(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentRequest; overload;
    function Clone : TFhirEnrollmentRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The Insurer who is target  of the request.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to Patient Resource. (defined for API consistency)
    property candidate : TFhirReference read FCandidate write SetCandidate;
    // Patient Resource.
    property candidateElement : TFhirReference read FCandidate write SetCandidate;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

  end;

  TFhirEnrollmentRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentRequestList;
    function GetCurrent : TFhirEnrollmentRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentRequest read GetCurrent;
  end;

  TFhirEnrollmentRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEnrollmentRequest;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEnrollmentRequestList; overload;
    function Clone : TFhirEnrollmentRequestList; overload;
    function GetEnumerator : TFhirEnrollmentRequestListEnumerator;
    
    //  Add a FhirEnrollmentRequest to the end of the list.
    function Append : TFhirEnrollmentRequest;
    
    // Add an already existing FhirEnrollmentRequest to the end of the list.
    procedure AddItem(value : TFhirEnrollmentRequest); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentRequest) : Integer;
    
    // Insert FhirEnrollmentRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentRequest;
    
    // Insert an existing FhirEnrollmentRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentRequest);
    
    // Get the iIndexth FhirEnrollmentRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEnrollmentRequests[index : Integer] : TFhirEnrollmentRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  // This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource.
  TFhirEnrollmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference;
    FRequestProvider : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetRequest(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetOrganization(value : TFhirReference);
    procedure SetRequestProvider(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentResponse; overload;
    function Clone : TFhirEnrollmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Processing status: error, complete.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference read FRequestProvider write SetRequestProvider;

  end;

  TFhirEnrollmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentResponseList;
    function GetCurrent : TFhirEnrollmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentResponse read GetCurrent;
  end;

  TFhirEnrollmentResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEnrollmentResponse;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEnrollmentResponseList; overload;
    function Clone : TFhirEnrollmentResponseList; overload;
    function GetEnumerator : TFhirEnrollmentResponseListEnumerator;
    
    //  Add a FhirEnrollmentResponse to the end of the list.
    function Append : TFhirEnrollmentResponse;
    
    // Add an already existing FhirEnrollmentResponse to the end of the list.
    procedure AddItem(value : TFhirEnrollmentResponse); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentResponse) : Integer;
    
    // Insert FhirEnrollmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentResponse;
    
    // Insert an existing FhirEnrollmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentResponse);
    
    // Get the iIndexth FhirEnrollmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEnrollmentResponses[index : Integer] : TFhirEnrollmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirExplanationOfBenefitRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference;
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    procedure SetClaim(value : TFhirReference);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitRelated; overload;
    function Clone : TFhirExplanationOfBenefitRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirExplanationOfBenefitRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitRelatedList;
    function GetCurrent : TFhirExplanationOfBenefitRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitRelated read GetCurrent;
  end;

  TFhirExplanationOfBenefitRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitRelated;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitRelatedList; overload;
    function Clone : TFhirExplanationOfBenefitRelatedList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
    
    //  Add a FhirExplanationOfBenefitRelated to the end of the list.
    function Append : TFhirExplanationOfBenefitRelated;
    
    // Add an already existing FhirExplanationOfBenefitRelated to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitRelated); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitRelated) : Integer;
    
    // Insert FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitRelated;
    
    // Insert an existing FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // Get the iIndexth FhirExplanationOfBenefitRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitRelateds[index : Integer] : TFhirExplanationOfBenefitRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirExplanationOfBenefitPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayee; overload;
    function Clone : TFhirExplanationOfBenefitPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirExplanationOfBenefitPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPayeeList;
    function GetCurrent : TFhirExplanationOfBenefitPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayee read GetCurrent;
  end;

  TFhirExplanationOfBenefitPayeeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayee;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitPayeeList; overload;
    function Clone : TFhirExplanationOfBenefitPayeeList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
    
    //  Add a FhirExplanationOfBenefitPayee to the end of the list.
    function Append : TFhirExplanationOfBenefitPayee;
    
    // Add an already existing FhirExplanationOfBenefitPayee to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayee); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayee) : Integer;
    
    // Insert FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayee;
    
    // Insert an existing FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // Get the iIndexth FhirExplanationOfBenefitPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayee;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitPayees[index : Integer] : TFhirExplanationOfBenefitPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirExplanationOfBenefitCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference;
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetProvider(value : TFhirReference);
    procedure SetResponsible(value : TFhirBoolean);
    function GetResponsibleST : Boolean;
    procedure SetResponsibleST(value : Boolean);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetQualification(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitCareTeam; overload;
    function Clone : TFhirExplanationOfBenefitCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirExplanationOfBenefitCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitCareTeamList;
    function GetCurrent : TFhirExplanationOfBenefitCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitCareTeam read GetCurrent;
  end;

  TFhirExplanationOfBenefitCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitCareTeamList; overload;
    function Clone : TFhirExplanationOfBenefitCareTeamList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
    
    //  Add a FhirExplanationOfBenefitCareTeam to the end of the list.
    function Append : TFhirExplanationOfBenefitCareTeam;
    
    // Add an already existing FhirExplanationOfBenefitCareTeam to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitCareTeam); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitCareTeam) : Integer;
    
    // Insert FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    
    // Insert an existing FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // Get the iIndexth FhirExplanationOfBenefitCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitCareTeams[index : Integer] : TFhirExplanationOfBenefitCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirExplanationOfBenefitSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirDataType;
    FValue : TFhirDataType;
    FReason : TFhirCoding;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetTiming(value : TFhirDataType);
    procedure SetValue(value : TFhirDataType);
    procedure SetReason(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitSupportingInfo; overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCoding read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCoding read FReason write SetReason;

  end;

  TFhirExplanationOfBenefitSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitSupportingInfo read GetCurrent;
  end;

  TFhirExplanationOfBenefitSupportingInfoList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitSupportingInfoList; overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfoList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
    
    //  Add a FhirExplanationOfBenefitSupportingInfo to the end of the list.
    function Append : TFhirExplanationOfBenefitSupportingInfo;
    
    // Add an already existing FhirExplanationOfBenefitSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitSupportingInfo); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitSupportingInfo) : Integer;
    
    // Insert FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    
    // Insert an existing FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // Get the iIndexth FhirExplanationOfBenefitSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitSupportingInfos[index : Integer] : TFhirExplanationOfBenefitSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirExplanationOfBenefitDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirDataType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetDiagnosis(value : TFhirDataType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetOnAdmission(value : TFhirCodeableConcept);
    procedure SetPackageCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitDiagnosis; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirDataType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirDataType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirExplanationOfBenefitDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitDiagnosisList;
    function GetCurrent : TFhirExplanationOfBenefitDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitDiagnosis read GetCurrent;
  end;

  TFhirExplanationOfBenefitDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitDiagnosisList; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosisList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
    
    //  Add a FhirExplanationOfBenefitDiagnosis to the end of the list.
    function Append : TFhirExplanationOfBenefitDiagnosis;
    
    // Add an already existing FhirExplanationOfBenefitDiagnosis to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitDiagnosis) : Integer;
    
    // Insert FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    
    // Insert an existing FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // Get the iIndexth FhirExplanationOfBenefitDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitDiagnoses[index : Integer] : TFhirExplanationOfBenefitDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirExplanationOfBenefitProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirDataType;
    FudiList : TFhirReferenceList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetProcedure_(value : TFhirDataType);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcedure; overload;
    function Clone : TFhirExplanationOfBenefitProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirDataType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirDataType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirExplanationOfBenefitProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcedureList;
    function GetCurrent : TFhirExplanationOfBenefitProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcedure read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcedure;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitProcedureList; overload;
    function Clone : TFhirExplanationOfBenefitProcedureList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
    
    //  Add a FhirExplanationOfBenefitProcedure to the end of the list.
    function Append : TFhirExplanationOfBenefitProcedure;
    
    // Add an already existing FhirExplanationOfBenefitProcedure to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcedure); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcedure) : Integer;
    
    // Insert FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcedure;
    
    // Insert an existing FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // Get the iIndexth FhirExplanationOfBenefitProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitProcedures[index : Integer] : TFhirExplanationOfBenefitProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirExplanationOfBenefitInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference;
    FpreAuthRefList : TFhirStringList;
    procedure SetFocal(value : TFhirBoolean);
    function GetFocalST : Boolean;
    procedure SetFocalST(value : Boolean);
    procedure SetCoverage(value : TFhirReference);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitInsurance; overload;
    function Clone : TFhirExplanationOfBenefitInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference read FCoverage write SetCoverage;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

  end;

  TFhirExplanationOfBenefitInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitInsuranceList;
    function GetCurrent : TFhirExplanationOfBenefitInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitInsurance read GetCurrent;
  end;

  TFhirExplanationOfBenefitInsuranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitInsurance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitInsuranceList; overload;
    function Clone : TFhirExplanationOfBenefitInsuranceList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
    
    //  Add a FhirExplanationOfBenefitInsurance to the end of the list.
    function Append : TFhirExplanationOfBenefitInsurance;
    
    // Add an already existing FhirExplanationOfBenefitInsurance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitInsurance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitInsurance) : Integer;
    
    // Insert FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitInsurance;
    
    // Insert an existing FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // Get the iIndexth FhirExplanationOfBenefitInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitInsurance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitInsurances[index : Integer] : TFhirExplanationOfBenefitInsurance read GetItemN write SetItemN; default;
  End;

  // Details of a accident which resulted in injuries which required the products and services listed in the claim.
  TFhirExplanationOfBenefitAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirDataType;
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAccident; overload;
    function Clone : TFhirExplanationOfBenefitAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirDataType read FLocation write SetLocation;

  end;

  TFhirExplanationOfBenefitAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAccidentList;
    function GetCurrent : TFhirExplanationOfBenefitAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAccident read GetCurrent;
  end;

  TFhirExplanationOfBenefitAccidentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAccident;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAccidentList; overload;
    function Clone : TFhirExplanationOfBenefitAccidentList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAccident to the end of the list.
    function Append : TFhirExplanationOfBenefitAccident;
    
    // Add an already existing FhirExplanationOfBenefitAccident to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAccident); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAccident) : Integer;
    
    // Insert FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAccident;
    
    // Insert an existing FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // Get the iIndexth FhirExplanationOfBenefitAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAccident;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAccidents[index : Integer] : TFhirExplanationOfBenefitAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirExplanationOfBenefitItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitItemDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItem; overload;
    function Clone : TFhirExplanationOfBenefitItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Care team members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnoses applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // A billed item may include goods or services provided in multiple encounters.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Second-tier of goods and services.
    property detailList : TFhirExplanationOfBenefitItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemList;
    function GetCurrent : TFhirExplanationOfBenefitItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemList; overload;
    function Clone : TFhirExplanationOfBenefitItemList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItem to the end of the list.
    function Append : TFhirExplanationOfBenefitItem;
    
    // Add an already existing FhirExplanationOfBenefitItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItem) : Integer;
    
    // Insert FhirExplanationOfBenefitItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItem;
    
    // Insert an existing FhirExplanationOfBenefitItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // Get the iIndexth FhirExplanationOfBenefitItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItems[index : Integer] : TFhirExplanationOfBenefitItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirExplanationOfBenefitItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
    procedure SetValue(value : TFhirDecimal);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemAdjudication; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirExplanationOfBenefitItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemAdjudication read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemAdjudicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemAdjudicationList; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudicationList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemAdjudication to the end of the list.
    function Append : TFhirExplanationOfBenefitItemAdjudication;
    
    // Add an already existing FhirExplanationOfBenefitItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemAdjudication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemAdjudication) : Integer;
    
    // Insert FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    
    // Insert an existing FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // Get the iIndexth FhirExplanationOfBenefitItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemAdjudications[index : Integer] : TFhirExplanationOfBenefitItemAdjudication read GetItemN write SetItemN; default;
  End;

  // Second-tier of goods and services.
  TFhirExplanationOfBenefitItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Third-tier of goods and services.
    property subDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemDetailList; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetail;
    
    // Add an already existing FhirExplanationOfBenefitItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    
    // Insert an existing FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemDetails[index : Integer] : TFhirExplanationOfBenefitItemDetail read GetItemN write SetItemN; default;
  End;

  // Third-tier of goods and services.
  TFhirExplanationOfBenefitItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetRevenue(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList;
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitItemDetailSubDetailList; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // Add an already existing FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetailSubDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // Insert an existing FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirExplanationOfBenefitAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubDetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirDataType;
    FLocation : TFhirDataType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubDetailSequenceList : TFhirPositiveIntList;
    function GetHasSubDetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList;
    function GetHasProviderList : Boolean;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    procedure SetServiced(value : TFhirDataType);
    procedure SetLocation(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItem; overload;
    function Clone : TFhirExplanationOfBenefitAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace.
    property subDetailSequenceList : TFhirPositiveIntList read GetSubDetailSequenceList;
    property hasSubDetailSequenceList : boolean read GetHasSubDetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirDataType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirDataType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirDataType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirDataType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirExplanationOfBenefitAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemList;
    function GetCurrent : TFhirExplanationOfBenefitAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItem to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItem;
    
    // Add an already existing FhirExplanationOfBenefitAddItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItem) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItem;
    
    // Insert an existing FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItems[index : Integer] : TFhirExplanationOfBenefitAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemDetailList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetail;
    
    // Add an already existing FhirExplanationOfBenefitAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    
    // Insert an existing FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItemDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetailList; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetailList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
    
    //  Add a FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // Add an already existing FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetailSubDetail) : Integer;
    
    // Insert FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // Insert an existing FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitAddItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirExplanationOfBenefitTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitTotal; overload;
    function Clone : TFhirExplanationOfBenefitTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirExplanationOfBenefitTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitTotalList;
    function GetCurrent : TFhirExplanationOfBenefitTotal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitTotal read GetCurrent;
  end;

  TFhirExplanationOfBenefitTotalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitTotal;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitTotalList; overload;
    function Clone : TFhirExplanationOfBenefitTotalList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
    
    //  Add a FhirExplanationOfBenefitTotal to the end of the list.
    function Append : TFhirExplanationOfBenefitTotal;
    
    // Add an already existing FhirExplanationOfBenefitTotal to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitTotal); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitTotal) : Integer;
    
    // Insert FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitTotal;
    
    // Insert an existing FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // Get the iIndexth FhirExplanationOfBenefitTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitTotal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitTotals[index : Integer] : TFhirExplanationOfBenefitTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirExplanationOfBenefitPayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAdjustment(value : TFhirMoney);
    procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAmount(value : TFhirMoney);
    procedure SetIdentifier(value : TFhirIdentifier);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayment; overload;
    function Clone : TFhirExplanationOfBenefitPayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirExplanationOfBenefitPaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPaymentList;
    function GetCurrent : TFhirExplanationOfBenefitPayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayment read GetCurrent;
  end;

  TFhirExplanationOfBenefitPaymentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayment;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitPaymentList; overload;
    function Clone : TFhirExplanationOfBenefitPaymentList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
    
    //  Add a FhirExplanationOfBenefitPayment to the end of the list.
    function Append : TFhirExplanationOfBenefitPayment;
    
    // Add an already existing FhirExplanationOfBenefitPayment to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayment); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayment) : Integer;
    
    // Insert FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayment;
    
    // Insert an existing FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // Get the iIndexth FhirExplanationOfBenefitPayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitPayments[index : Integer] : TFhirExplanationOfBenefitPayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirExplanationOfBenefitProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    procedure SetNumber(value : TFhirPositiveInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcessNote; overload;
    function Clone : TFhirExplanationOfBenefitProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirExplanationOfBenefitProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcessNoteList;
    function GetCurrent : TFhirExplanationOfBenefitProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcessNote read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitProcessNoteList; overload;
    function Clone : TFhirExplanationOfBenefitProcessNoteList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
    
    //  Add a FhirExplanationOfBenefitProcessNote to the end of the list.
    function Append : TFhirExplanationOfBenefitProcessNote;
    
    // Add an already existing FhirExplanationOfBenefitProcessNote to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcessNote) : Integer;
    
    // Insert FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    
    // Insert an existing FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // Get the iIndexth FhirExplanationOfBenefitProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitProcessNotes[index : Integer] : TFhirExplanationOfBenefitProcessNote read GetItemN write SetItemN; default;
  End;

  // Balance by Benefit Category.
  TFhirExplanationOfBenefitBenefitBalance = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FfinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetExcluded(value : TFhirBoolean);
    function GetExcludedST : Boolean;
    procedure SetExcludedST(value : Boolean);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNetwork(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetTerm(value : TFhirCodeableConcept);
    function GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetHasFinancialList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalance; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits Used to date.
    property financialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList read GetFinancialList;
    property hasFinancialList : boolean read GetHasFinancialList;

  end;

  TFhirExplanationOfBenefitBenefitBalanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalance read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitBenefitBalanceList; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
    
    //  Add a FhirExplanationOfBenefitBenefitBalance to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalance;
    
    // Add an already existing FhirExplanationOfBenefitBenefitBalance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalance); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalance) : Integer;
    
    // Insert FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    
    // Insert an existing FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitBenefitBalances[index : Integer] : TFhirExplanationOfBenefitBenefitBalance read GetItemN write SetItemN; default;
  End;

  // Benefits Used to date.
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirDataType;
    FUsed : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirDataType);
    procedure SetUsed(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirDataType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirDataType read FUsed write SetUsed;

  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancialList; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancialList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
    
    //  Add a FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // Add an already existing FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalanceFinancial) : Integer;
    
    // Insert FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // Insert an existing FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalanceFinancial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefitBenefitBalanceFinancials[index : Integer] : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetItemN write SetItemN; default;
  End;

  // This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
  TFhirExplanationOfBenefit = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference;
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference;
    FInsurer : TFhirReference;
    FProvider : TFhirReference;
    FPriority : TFhirCodeableConcept;
    FFundsReserveRequested : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirExplanationOfBenefitRelatedList;
    FPrescription : TFhirReference;
    FOriginalPrescription : TFhirReference;
    FPayee : TFhirExplanationOfBenefitPayee;
    FReferral : TFhirReference;
    FFacility : TFhirReference;
    FClaim : TFhirReference;
    FClaimResponse : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FpreAuthRefPeriodList : TFhirPeriodList;
    FcareTeamList : TFhirExplanationOfBenefitCareTeamList;
    FsupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    FdiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    Fprocedure_List : TFhirExplanationOfBenefitProcedureList;
    FPrecedence : TFhirPositiveInt;
    FinsuranceList : TFhirExplanationOfBenefitInsuranceList;
    FAccident : TFhirExplanationOfBenefitAccident;
    FitemList : TFhirExplanationOfBenefitItemList;
    FaddItemList : TFhirExplanationOfBenefitAddItemList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FtotalList : TFhirExplanationOfBenefitTotalList;
    FPayment : TFhirExplanationOfBenefitPayment;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    FBenefitPeriod : TFhirPeriod;
    FbenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirExplanationOfBenefitStatusEnum;
    procedure SetStatusST(value : TFhirExplanationOfBenefitStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetUse(value : TFhirEnum);
    function GetUseST : TFhirUseEnum;
    procedure SetUseST(value : TFhirUseEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetBillablePeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetEnterer(value : TFhirReference);
    procedure SetInsurer(value : TFhirReference);
    procedure SetProvider(value : TFhirReference);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetFundsReserveRequested(value : TFhirCodeableConcept);
    procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirExplanationOfBenefitRelatedList;
    function GetHasRelatedList : Boolean;
    procedure SetPrescription(value : TFhirReference);
    procedure SetOriginalPrescription(value : TFhirReference);
    procedure SetPayee(value : TFhirExplanationOfBenefitPayee);
    procedure SetReferral(value : TFhirReference);
    procedure SetFacility(value : TFhirReference);
    procedure SetClaim(value : TFhirReference);
    procedure SetClaimResponse(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    function GetPreAuthRefPeriodList : TFhirPeriodList;
    function GetHasPreAuthRefPeriodList : Boolean;
    function GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
    function GetHasProcedure_List : Boolean;
    procedure SetPrecedence(value : TFhirPositiveInt);
    function GetPrecedenceST : String;
    procedure SetPrecedenceST(value : String);
    function GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
    function GetHasInsuranceList : Boolean;
    procedure SetAccident(value : TFhirExplanationOfBenefitAccident);
    function GetItemList : TFhirExplanationOfBenefitItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirExplanationOfBenefitAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirExplanationOfBenefitTotalList;
    function GetHasTotalList : Boolean;
    procedure SetPayment(value : TFhirExplanationOfBenefitPayment);
    procedure SetFormCode(value : TFhirCodeableConcept);
    procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetHasBenefitBalanceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefit; overload;
    function Clone : TFhirExplanationOfBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this explanation of benefit.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirExplanationOfBenefitStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserveRequested : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveRequestedElement : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirExplanationOfBenefitRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference read FFacility write SetFacility;

    // Typed access to The business identifier for the instance of the adjudication request: claim predetermination or preauthorization. (defined for API consistency)
    property claim : TFhirReference read FClaim write SetClaim;
    // The business identifier for the instance of the adjudication request: claim predetermination or preauthorization.
    property claimElement : TFhirReference read FClaim write SetClaim;

    // Typed access to The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response. (defined for API consistency)
    property claimResponse : TFhirReference read FClaimResponse write SetClaimResponse;
    // The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response.
    property claimResponseElement : TFhirReference read FClaimResponse write SetClaimResponse;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // The timeframe during which the supplied preauthorization reference may be quoted on claims to obtain the adjudication as provided.
    property preAuthRefPeriodList : TFhirPeriodList read GetPreAuthRefPeriodList;
    property hasPreAuthRefPeriodList : boolean read GetHasPreAuthRefPeriodList;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirExplanationOfBenefitCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirExplanationOfBenefitSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirExplanationOfBenefitDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirExplanationOfBenefitProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedence : String read GetPrecedenceST write SetPrecedenceST;
    // This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedenceElement : TFhirPositiveInt read FPrecedence write SetPrecedence;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirExplanationOfBenefitInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of a accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;
    // Details of a accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirExplanationOfBenefitItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirExplanationOfBenefitAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirExplanationOfBenefitTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirExplanationOfBenefitProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Balance by Benefit Category.
    property benefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList read GetBenefitBalanceList;
    property hasBenefitBalanceList : boolean read GetHasBenefitBalanceList;

  end;

  TFhirExplanationOfBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitList;
    function GetCurrent : TFhirExplanationOfBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefit read GetCurrent;
  end;

  TFhirExplanationOfBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirExplanationOfBenefit;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirExplanationOfBenefitList; overload;
    function Clone : TFhirExplanationOfBenefitList; overload;
    function GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
    
    //  Add a FhirExplanationOfBenefit to the end of the list.
    function Append : TFhirExplanationOfBenefit;
    
    // Add an already existing FhirExplanationOfBenefit to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefit) : Integer;
    
    // Insert FhirExplanationOfBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefit;
    
    // Insert an existing FhirExplanationOfBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefit);
    
    // Get the iIndexth FhirExplanationOfBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirExplanationOfBenefits[index : Integer] : TFhirExplanationOfBenefit read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
  // The contact for the health insurance product for a certain purpose.
  TFhirInsurancePlanContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    procedure SetPurpose(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanContact; overload;
    function Clone : TFhirInsurancePlanContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirInsurancePlanContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanContactList;
    function GetCurrent : TFhirInsurancePlanContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanContact read GetCurrent;
  end;

  TFhirInsurancePlanContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanContact;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanContactList; overload;
    function Clone : TFhirInsurancePlanContactList; overload;
    function GetEnumerator : TFhirInsurancePlanContactListEnumerator;
    
    //  Add a FhirInsurancePlanContact to the end of the list.
    function Append : TFhirInsurancePlanContact;
    
    // Add an already existing FhirInsurancePlanContact to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanContact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanContact) : Integer;
    
    // Insert FhirInsurancePlanContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanContact;
    
    // Insert an existing FhirInsurancePlanContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanContact);
    
    // Get the iIndexth FhirInsurancePlanContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanContacts[index : Integer] : TFhirInsurancePlanContact read GetItemN write SetItemN; default;
  End;

  // Details about the coverage offered by the insurance product.
  TFhirInsurancePlanCoverage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FnetworkList : TFhirReferenceList;
    FbenefitList : TFhirInsurancePlanCoverageBenefitList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
    function GetHasBenefitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverage; overload;
    function Clone : TFhirInsurancePlanCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Specific benefits under this type of coverage.
    property benefitList : TFhirInsurancePlanCoverageBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageList;
    function GetCurrent : TFhirInsurancePlanCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverage read GetCurrent;
  end;

  TFhirInsurancePlanCoverageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverage;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageList; overload;
    function Clone : TFhirInsurancePlanCoverageList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
    
    //  Add a FhirInsurancePlanCoverage to the end of the list.
    function Append : TFhirInsurancePlanCoverage;
    
    // Add an already existing FhirInsurancePlanCoverage to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverage); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverage) : Integer;
    
    // Insert FhirInsurancePlanCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverage;
    
    // Insert an existing FhirInsurancePlanCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // Get the iIndexth FhirInsurancePlanCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverages[index : Integer] : TFhirInsurancePlanCoverage read GetItemN write SetItemN; default;
  End;

  // Specific benefits under this type of coverage.
  TFhirInsurancePlanCoverageBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRequirement : TFhirString;
    FlimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRequirement(value : TFhirString);
    function GetRequirementST : String;
    procedure SetRequirementST(value : String);
    function GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetHasLimitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of benefit (primary care; speciality care; inpatient; outpatient). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of benefit (primary care; speciality care; inpatient; outpatient).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The referral requirements to have access/coverage for this benefit.
    property requirement : String read GetRequirementST write SetRequirementST;
    // The referral requirements to have access/coverage for this benefit.
    property requirementElement : TFhirString read FRequirement write SetRequirement;

    // The specific limits on the benefit.
    property limitList : TFhirInsurancePlanCoverageBenefitLimitList read GetLimitList;
    property hasLimitList : boolean read GetHasLimitList;

  end;

  TFhirInsurancePlanCoverageBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageBenefitList; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
    
    //  Add a FhirInsurancePlanCoverageBenefit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefit;
    
    // Add an already existing FhirInsurancePlanCoverageBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefit) : Integer;
    
    // Insert FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    
    // Insert an existing FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverageBenefits[index : Integer] : TFhirInsurancePlanCoverageBenefit read GetItemN write SetItemN; default;
  End;

  // The specific limits on the benefit.
  TFhirInsurancePlanCoverageBenefitLimit = class (TFhirBackboneElement)
  protected
    FValue : TFhirQuantity;
    FCode : TFhirCodeableConcept;
    procedure SetValue(value : TFhirQuantity);
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to The specific limit on the benefit. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific limit on the benefit.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirInsurancePlanCoverageBenefitLimitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefitLimit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitLimitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanCoverageBenefitLimitList; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimitList; overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
    
    //  Add a FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefitLimit;
    
    // Add an already existing FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefitLimit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefitLimit) : Integer;
    
    // Insert FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    
    // Insert an existing FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefitLimit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanCoverageBenefitLimits[index : Integer] : TFhirInsurancePlanCoverageBenefitLimit read GetItemN write SetItemN; default;
  End;

  // Details about an insurance plan.
  TFhirInsurancePlanPlan = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FcoverageAreaList : TFhirReferenceList;
    FnetworkList : TFhirReferenceList;
    FgeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    FspecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    function GetHasGeneralCostList : Boolean;
    function GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetHasSpecificCostList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlan; overload;
    function Clone : TFhirInsurancePlanPlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this health insurance plan which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Type of plan. For example, "Platinum" or "High Deductable". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of plan. For example, "Platinum" or "High Deductable".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The geographic region in which a health insurance plan's benefits apply.
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Overall costs associated with the plan.
    property generalCostList : TFhirInsurancePlanPlanGeneralCostList read GetGeneralCostList;
    property hasGeneralCostList : boolean read GetHasGeneralCostList;

    // Costs associated with the coverage provided by the product.
    property specificCostList : TFhirInsurancePlanPlanSpecificCostList read GetSpecificCostList;
    property hasSpecificCostList : boolean read GetHasSpecificCostList;

  end;

  TFhirInsurancePlanPlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanList;
    function GetCurrent : TFhirInsurancePlanPlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlan read GetCurrent;
  end;

  TFhirInsurancePlanPlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanList; overload;
    function Clone : TFhirInsurancePlanPlanList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
    
    //  Add a FhirInsurancePlanPlan to the end of the list.
    function Append : TFhirInsurancePlanPlan;
    
    // Add an already existing FhirInsurancePlanPlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlan); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlan) : Integer;
    
    // Insert FhirInsurancePlanPlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlan;
    
    // Insert an existing FhirInsurancePlanPlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlan);
    
    // Get the iIndexth FhirInsurancePlanPlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlans[index : Integer] : TFhirInsurancePlanPlan read GetItemN write SetItemN; default;
  End;

  // Overall costs associated with the plan.
  TFhirInsurancePlanPlanGeneralCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FGroupSize : TFhirPositiveInt;
    FCost : TFhirMoney;
    FComment : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupSize(value : TFhirPositiveInt);
    function GetGroupSizeST : String;
    procedure SetGroupSizeST(value : String);
    procedure SetCost(value : TFhirMoney);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanGeneralCost; overload;
    function Clone : TFhirInsurancePlanPlanGeneralCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Number of participants enrolled in the plan.
    property groupSize : String read GetGroupSizeST write SetGroupSizeST;
    // Number of participants enrolled in the plan.
    property groupSizeElement : TFhirPositiveInt read FGroupSize write SetGroupSize;

    // Typed access to Value of the cost. (defined for API consistency)
    property cost : TFhirMoney read FCost write SetCost;
    // Value of the cost.
    property costElement : TFhirMoney read FCost write SetCost;

    // Typed access to Additional information about the general costs associated with this plan.
    property comment : String read GetCommentST write SetCommentST;
    // Additional information about the general costs associated with this plan.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirInsurancePlanPlanGeneralCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanGeneralCostList;
    function GetCurrent : TFhirInsurancePlanPlanGeneralCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanGeneralCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanGeneralCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanGeneralCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanGeneralCostList; overload;
    function Clone : TFhirInsurancePlanPlanGeneralCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanGeneralCost to the end of the list.
    function Append : TFhirInsurancePlanPlanGeneralCost;
    
    // Add an already existing FhirInsurancePlanPlanGeneralCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanGeneralCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanGeneralCost) : Integer;
    
    // Insert FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    
    // Insert an existing FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // Get the iIndexth FhirInsurancePlanPlanGeneralCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanGeneralCosts[index : Integer] : TFhirInsurancePlanPlanGeneralCost read GetItemN write SetItemN; default;
  End;

  // Costs associated with the coverage provided by the product.
  TFhirInsurancePlanPlanSpecificCost = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FbenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    procedure SetCategory(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetHasBenefitList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health).
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // List of the specific benefits under this category of benefit.
    property benefitList : TFhirInsurancePlanPlanSpecificCostBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanPlanSpecificCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCost;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCost) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCost read GetItemN write SetItemN; default;
  End;

  // List of the specific benefits under this category of benefit.
  TFhirInsurancePlanPlanSpecificCostBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FcostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetHasCostList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // List of the costs associated with a specific benefit.
    property costList : TFhirInsurancePlanPlanSpecificCostBenefitCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefit read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefit); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefit) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCostBenefits[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefit read GetItemN write SetItemN; default;
  End;

  // List of the costs associated with a specific benefit.
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FApplicability : TFhirCodeableConcept;
    FqualifiersList : TFhirCodeableConceptList;
    FValue : TFhirQuantity;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetApplicability(value : TFhirCodeableConcept);
    function GetQualifiersList : TFhirCodeableConceptList;
    function GetHasQualifiersList : Boolean;
    procedure SetValue(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of cost (copay; individual cap; family cap; coinsurance; deductible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost (copay; individual cap; family cap; coinsurance; deductible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other). (defined for API consistency)
    property applicability : TFhirCodeableConcept read FApplicability write SetApplicability;
    // Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other).
    property applicabilityElement : TFhirCodeableConcept read FApplicability write SetApplicability;

    // Additional information about the cost, such as information about funding sources (e.g. HSA, HRA, FSA, RRA).
    property qualifiersList : TFhirCodeableConceptList read GetQualifiersList;
    property hasQualifiersList : boolean read GetHasQualifiersList;

    // Typed access to The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance). (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance).
    property valueElement : TFhirQuantity read FValue write SetValue;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCostList; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCostList; overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
    
    //  Add a FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefitCost) : Integer;
    
    // Insert FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefitCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlanPlanSpecificCostBenefitCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetItemN write SetItemN; default;
  End;

  // Details of a Health Insurance product/plan provided by an organization.
  TFhirInsurancePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FPeriod : TFhirPeriod;
    FOwnedBy : TFhirReference;
    FAdministeredBy : TFhirReference;
    FcoverageAreaList : TFhirReferenceList;
    FcontactList : TFhirInsurancePlanContactList;
    FendpointList : TFhirReferenceList;
    FnetworkList : TFhirReferenceList;
    FcoverageList : TFhirInsurancePlanCoverageList;
    FplanList : TFhirInsurancePlanPlanList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetOwnedBy(value : TFhirReference);
    procedure SetAdministeredBy(value : TFhirReference);
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetContactList : TFhirInsurancePlanContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetCoverageList : TFhirInsurancePlanCoverageList;
    function GetHasCoverageList : Boolean;
    function GetPlanList : TFhirInsurancePlanPlanList;
    function GetHasPlanList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlan; overload;
    function Clone : TFhirInsurancePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this health insurance product which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the health insurance product.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The kind of health insurance product.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Official name of the health insurance product as designated by the owner.
    property name : String read GetNameST write SetNameST;
    // Official name of the health insurance product as designated by the owner.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the product is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The period of time that the health insurance product is available. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the health insurance product is available.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'. (defined for API consistency)
    property ownedBy : TFhirReference read FOwnedBy write SetOwnedBy;
    // The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'.
    property ownedByElement : TFhirReference read FOwnedBy write SetOwnedBy;

    // Typed access to An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner. (defined for API consistency)
    property administeredBy : TFhirReference read FAdministeredBy write SetAdministeredBy;
    // An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner.
    property administeredByElement : TFhirReference read FAdministeredBy write SetAdministeredBy;

    // The geographic region in which a health insurance product's benefits apply.
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The contact for the health insurance product for a certain purpose.
    property contactList : TFhirInsurancePlanContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The technical endpoints providing access to services operated for the health insurance product.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Reference to the network included in the health insurance product.
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Details about the coverage offered by the insurance product.
    property coverageList : TFhirInsurancePlanCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Details about an insurance plan.
    property planList : TFhirInsurancePlanPlanList read GetPlanList;
    property hasPlanList : boolean read GetHasPlanList;

  end;

  TFhirInsurancePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanList;
    function GetCurrent : TFhirInsurancePlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlan read GetCurrent;
  end;

  TFhirInsurancePlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInsurancePlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInsurancePlanList; overload;
    function Clone : TFhirInsurancePlanList; overload;
    function GetEnumerator : TFhirInsurancePlanListEnumerator;
    
    //  Add a FhirInsurancePlan to the end of the list.
    function Append : TFhirInsurancePlan;
    
    // Add an already existing FhirInsurancePlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlan); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlan) : Integer;
    
    // Insert FhirInsurancePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlan;
    
    // Insert an existing FhirInsurancePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlan);
    
    // Get the iIndexth FhirInsurancePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInsurancePlans[index : Integer] : TFhirInsurancePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  // Indicates who or what performed or participated in the charged service.
  TFhirInvoiceParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceParticipant; overload;
    function Clone : TFhirInvoiceParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirInvoiceParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceParticipantList;
    function GetCurrent : TFhirInvoiceParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceParticipant read GetCurrent;
  end;

  TFhirInvoiceParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceParticipant;
    procedure SetItemN(index : Integer; value : TFhirInvoiceParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceParticipantList; overload;
    function Clone : TFhirInvoiceParticipantList; overload;
    function GetEnumerator : TFhirInvoiceParticipantListEnumerator;
    
    //  Add a FhirInvoiceParticipant to the end of the list.
    function Append : TFhirInvoiceParticipant;
    
    // Add an already existing FhirInvoiceParticipant to the end of the list.
    procedure AddItem(value : TFhirInvoiceParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceParticipant) : Integer;
    
    // Insert FhirInvoiceParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceParticipant;
    
    // Insert an existing FhirInvoiceParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceParticipant);
    
    // Get the iIndexth FhirInvoiceParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceParticipants[index : Integer] : TFhirInvoiceParticipant read GetItemN write SetItemN; default;
  End;

  // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
  TFhirInvoiceLineItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FChargeItem : TFhirDataType;
    FpriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    procedure SetSequence(value : TFhirPositiveInt);
    function GetSequenceST : String;
    procedure SetSequenceST(value : String);
    procedure SetChargeItem(value : TFhirDataType);
    function GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasPriceComponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItem; overload;
    function Clone : TFhirInvoiceLineItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Sequence in which the items appear on the invoice.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence in which the items appear on the invoice.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference. (defined for API consistency)
    property chargeItem : TFhirDataType read FChargeItem write SetChargeItem;
    // The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference.
    property chargeItemElement : TFhirDataType read FChargeItem write SetChargeItem;

    // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
    property priceComponentList : TFhirInvoiceLineItemPriceComponentList read GetPriceComponentList;
    property hasPriceComponentList : boolean read GetHasPriceComponentList;

  end;

  TFhirInvoiceLineItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemList;
    function GetCurrent : TFhirInvoiceLineItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItem read GetCurrent;
  end;

  TFhirInvoiceLineItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceLineItem;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceLineItemList; overload;
    function Clone : TFhirInvoiceLineItemList; overload;
    function GetEnumerator : TFhirInvoiceLineItemListEnumerator;
    
    //  Add a FhirInvoiceLineItem to the end of the list.
    function Append : TFhirInvoiceLineItem;
    
    // Add an already existing FhirInvoiceLineItem to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItem); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItem) : Integer;
    
    // Insert FhirInvoiceLineItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItem;
    
    // Insert an existing FhirInvoiceLineItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItem);
    
    // Get the iIndexth FhirInvoiceLineItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceLineItems[index : Integer] : TFhirInvoiceLineItem read GetItemN write SetItemN; default;
  End;

  // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
  TFhirInvoiceLineItemPriceComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FFactor : TFhirDecimal;
    FAmount : TFhirMoney;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirInvoicePriceComponentTypeEnum;
    procedure SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItemPriceComponent; overload;
    function Clone : TFhirInvoiceLineItemPriceComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This code identifies the type of the component.
    property type_ : TFhirInvoicePriceComponentTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The factor that has been applied on the base price for calculating this component.
    property factor : String read GetFactorST write SetFactorST;
    // The factor that has been applied on the base price for calculating this component.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The amount calculated for this component. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount calculated for this component.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirInvoiceLineItemPriceComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemPriceComponentList;
    function GetCurrent : TFhirInvoiceLineItemPriceComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemPriceComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItemPriceComponent read GetCurrent;
  end;

  TFhirInvoiceLineItemPriceComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceLineItemPriceComponentList; overload;
    function Clone : TFhirInvoiceLineItemPriceComponentList; overload;
    function GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
    
    //  Add a FhirInvoiceLineItemPriceComponent to the end of the list.
    function Append : TFhirInvoiceLineItemPriceComponent;
    
    // Add an already existing FhirInvoiceLineItemPriceComponent to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItemPriceComponent); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItemPriceComponent) : Integer;
    
    // Insert FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    
    // Insert an existing FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // Get the iIndexth FhirInvoiceLineItemPriceComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoiceLineItemPriceComponents[index : Integer] : TFhirInvoiceLineItemPriceComponent read GetItemN write SetItemN; default;
  End;

  // Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
  TFhirInvoice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCancelledReason : TFhirString;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FRecipient : TFhirReference;
    FDate : TFhirDateTime;
    FparticipantList : TFhirInvoiceParticipantList;
    FIssuer : TFhirReference;
    FAccount : TFhirReference;
    FlineItemList : TFhirInvoiceLineItemList;
    FtotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    FTotalNet : TFhirMoney;
    FTotalGross : TFhirMoney;
    FPaymentTerms : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirInvoiceStatusEnum;
    procedure SetStatusST(value : TFhirInvoiceStatusEnum);
    procedure SetCancelledReason(value : TFhirString);
    function GetCancelledReasonST : String;
    procedure SetCancelledReasonST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetParticipantList : TFhirInvoiceParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetIssuer(value : TFhirReference);
    procedure SetAccount(value : TFhirReference);
    function GetLineItemList : TFhirInvoiceLineItemList;
    function GetHasLineItemList : Boolean;
    function GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasTotalPriceComponentList : Boolean;
    procedure SetTotalNet(value : TFhirMoney);
    procedure SetTotalGross(value : TFhirMoney);
    procedure SetPaymentTerms(value : TFhirMarkdown);
    function GetPaymentTermsST : String;
    procedure SetPaymentTermsST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoice; overload;
    function Clone : TFhirInvoice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier of this Invoice, often used for reference in correspondence about this invoice or for tracking of payments.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the Invoice.
    property status : TFhirInvoiceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReason : String read GetCancelledReasonST write SetCancelledReasonST;
    // In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReasonElement : TFhirString read FCancelledReason write SetCancelledReason;

    // Typed access to Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The individual or set of individuals receiving the goods and services billed in this invoice. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The individual or set of individuals receiving the goods and services billed in this invoice.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The individual or Organization responsible for balancing of this invoice. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // The individual or Organization responsible for balancing of this invoice.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Typed access to Date/time(s) of when this Invoice was posted.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date/time(s) of when this Invoice was posted.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Indicates who or what performed or participated in the charged service.
    property participantList : TFhirInvoiceParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The organizationissuing the Invoice. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // The organizationissuing the Invoice.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

    // Typed access to Account which is supposed to be balanced with this Invoice. (defined for API consistency)
    property account : TFhirReference read FAccount write SetAccount;
    // Account which is supposed to be balanced with this Invoice.
    property accountElement : TFhirReference read FAccount write SetAccount;

    // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
    property lineItemList : TFhirInvoiceLineItemList read GetLineItemList;
    property hasLineItemList : boolean read GetHasLineItemList;

    // The total amount for the Invoice may be calculated as the sum of the line items with surcharges/deductions that apply in certain conditions.  The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the total price was calculated.
    property totalPriceComponentList : TFhirInvoiceLineItemPriceComponentList read GetTotalPriceComponentList;
    property hasTotalPriceComponentList : boolean read GetHasTotalPriceComponentList;

    // Typed access to Invoice total , taxes excluded. (defined for API consistency)
    property totalNet : TFhirMoney read FTotalNet write SetTotalNet;
    // Invoice total , taxes excluded.
    property totalNetElement : TFhirMoney read FTotalNet write SetTotalNet;

    // Typed access to Invoice total, tax included. (defined for API consistency)
    property totalGross : TFhirMoney read FTotalGross write SetTotalGross;
    // Invoice total, tax included.
    property totalGrossElement : TFhirMoney read FTotalGross write SetTotalGross;

    // Typed access to Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTerms : String read GetPaymentTermsST write SetPaymentTermsST;
    // Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTermsElement : TFhirMarkdown read FPaymentTerms write SetPaymentTerms;

    // Comments made about the invoice by the issuer, subject, or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirInvoiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceList;
    function GetCurrent : TFhirInvoice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoice read GetCurrent;
  end;

  TFhirInvoiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirInvoice;
    procedure SetItemN(index : Integer; value : TFhirInvoice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirInvoiceList; overload;
    function Clone : TFhirInvoiceList; overload;
    function GetEnumerator : TFhirInvoiceListEnumerator;
    
    //  Add a FhirInvoice to the end of the list.
    function Append : TFhirInvoice;
    
    // Add an already existing FhirInvoice to the end of the list.
    procedure AddItem(value : TFhirInvoice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoice) : Integer;
    
    // Insert FhirInvoice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoice;
    
    // Insert an existing FhirInvoice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoice);
    
    // Get the iIndexth FhirInvoice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirInvoices[index : Integer] : TFhirInvoice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
  // This resource provides the status of the payment for goods and services rendered, and the request and response resource references.
  TFhirPaymentNotice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference;
    FResponse : TFhirReference;
    FCreated : TFhirDateTime;
    FProvider : TFhirReference;
    FPayment : TFhirReference;
    FPaymentDate : TFhirDate;
    FPayee : TFhirReference;
    FRecipient : TFhirReference;
    FAmount : TFhirMoney;
    FPaymentStatus : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetRequest(value : TFhirReference);
    procedure SetResponse(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetProvider(value : TFhirReference);
    procedure SetPayment(value : TFhirReference);
    procedure SetPaymentDate(value : TFhirDate);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetPayee(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    procedure SetAmount(value : TFhirMoney);
    procedure SetPaymentStatus(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentNotice; overload;
    function Clone : TFhirPaymentNotice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this payment notice.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Reference of resource for which payment is being made. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Reference of resource for which payment is being made.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to Reference of response to resource for which payment is being made. (defined for API consistency)
    property response : TFhirReference read FResponse write SetResponse;
    // Reference of response to resource for which payment is being made.
    property responseElement : TFhirReference read FResponse write SetResponse;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference read FProvider write SetProvider;

    // Typed access to A reference to the payment which is the subject of this notice. (defined for API consistency)
    property payment : TFhirReference read FPayment write SetPayment;
    // A reference to the payment which is the subject of this notice.
    property paymentElement : TFhirReference read FPayment write SetPayment;

    // Typed access to The date when the above payment action occurred.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date when the above payment action occurred.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to The party who will receive or has received payment that is the subject of this notification. (defined for API consistency)
    property payee : TFhirReference read FPayee write SetPayee;
    // The party who will receive or has received payment that is the subject of this notification.
    property payeeElement : TFhirReference read FPayee write SetPayee;

    // Typed access to The party who is notified of the payment status. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // The party who is notified of the payment status.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Typed access to The amount sent to the payee. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount sent to the payee.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A code indicating whether payment has been sent or cleared. (defined for API consistency)
    property paymentStatus : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;
    // A code indicating whether payment has been sent or cleared.
    property paymentStatusElement : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;

  end;

  TFhirPaymentNoticeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentNoticeList;
    function GetCurrent : TFhirPaymentNotice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentNoticeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentNotice read GetCurrent;
  end;

  TFhirPaymentNoticeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentNotice;
    procedure SetItemN(index : Integer; value : TFhirPaymentNotice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentNoticeList; overload;
    function Clone : TFhirPaymentNoticeList; overload;
    function GetEnumerator : TFhirPaymentNoticeListEnumerator;
    
    //  Add a FhirPaymentNotice to the end of the list.
    function Append : TFhirPaymentNotice;
    
    // Add an already existing FhirPaymentNotice to the end of the list.
    procedure AddItem(value : TFhirPaymentNotice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentNotice) : Integer;
    
    // Insert FhirPaymentNotice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentNotice;
    
    // Insert an existing FhirPaymentNotice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentNotice);
    
    // Get the iIndexth FhirPaymentNotice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentNotice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentNotice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentNotices[index : Integer] : TFhirPaymentNotice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  // Distribution of the payment amount for a previously acknowledged payable.
  TFhirPaymentReconciliationDetail = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FPredecessor : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FRequest : TFhirReference;
    FSubmitter : TFhirReference;
    FResponse : TFhirReference;
    FDate : TFhirDate;
    FResponsible : TFhirReference;
    FPayee : TFhirReference;
    FAmount : TFhirMoney;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetPredecessor(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRequest(value : TFhirReference);
    procedure SetSubmitter(value : TFhirReference);
    procedure SetResponse(value : TFhirReference);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetResponsible(value : TFhirReference);
    procedure SetPayee(value : TFhirReference);
    procedure SetAmount(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationDetail; overload;
    function Clone : TFhirPaymentReconciliationDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for the current payment item for the referenced payable. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for the current payment item for the referenced payable.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Unique identifier for the prior payment item for the referenced payable. (defined for API consistency)
    property predecessor : TFhirIdentifier read FPredecessor write SetPredecessor;
    // Unique identifier for the prior payment item for the referenced payable.
    property predecessorElement : TFhirIdentifier read FPredecessor write SetPredecessor;

    // Typed access to Code to indicate the nature of the payment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code to indicate the nature of the payment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A resource, such as a Claim, the evaluation of which could lead to payment. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // A resource, such as a Claim, the evaluation of which could lead to payment.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to The party which submitted the claim or financial transaction. (defined for API consistency)
    property submitter : TFhirReference read FSubmitter write SetSubmitter;
    // The party which submitted the claim or financial transaction.
    property submitterElement : TFhirReference read FSubmitter write SetSubmitter;

    // Typed access to A resource, such as a ClaimResponse, which contains a commitment to payment. (defined for API consistency)
    property response : TFhirReference read FResponse write SetResponse;
    // A resource, such as a ClaimResponse, which contains a commitment to payment.
    property responseElement : TFhirReference read FResponse write SetResponse;

    // Typed access to The date from the response resource containing a commitment to pay.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date from the response resource containing a commitment to pay.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A reference to the individual who is responsible for inquiries regarding the response and its payment. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // A reference to the individual who is responsible for inquiries regarding the response and its payment.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to The party which is receiving the payment. (defined for API consistency)
    property payee : TFhirReference read FPayee write SetPayee;
    // The party which is receiving the payment.
    property payeeElement : TFhirReference read FPayee write SetPayee;

    // Typed access to The monetary amount allocated from the total payment to the payable. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The monetary amount allocated from the total payment to the payable.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirPaymentReconciliationDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationDetailList;
    function GetCurrent : TFhirPaymentReconciliationDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationDetail read GetCurrent;
  end;

  TFhirPaymentReconciliationDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliationDetail;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationDetailList; overload;
    function Clone : TFhirPaymentReconciliationDetailList; overload;
    function GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
    
    //  Add a FhirPaymentReconciliationDetail to the end of the list.
    function Append : TFhirPaymentReconciliationDetail;
    
    // Add an already existing FhirPaymentReconciliationDetail to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationDetail); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationDetail) : Integer;
    
    // Insert FhirPaymentReconciliationDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationDetail;
    
    // Insert an existing FhirPaymentReconciliationDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // Get the iIndexth FhirPaymentReconciliationDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliationDetails[index : Integer] : TFhirPaymentReconciliationDetail read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains the processing in a human readable form.
  TFhirPaymentReconciliationProcessNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FText : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirNoteTypeEnum;
    procedure SetType_ST(value : TFhirNoteTypeEnum);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationProcessNote; overload;
    function Clone : TFhirPaymentReconciliationProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirPaymentReconciliationProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationProcessNoteList;
    function GetCurrent : TFhirPaymentReconciliationProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationProcessNote read GetCurrent;
  end;

  TFhirPaymentReconciliationProcessNoteList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliationProcessNote;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationProcessNoteList; overload;
    function Clone : TFhirPaymentReconciliationProcessNoteList; overload;
    function GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
    
    //  Add a FhirPaymentReconciliationProcessNote to the end of the list.
    function Append : TFhirPaymentReconciliationProcessNote;
    
    // Add an already existing FhirPaymentReconciliationProcessNote to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationProcessNote); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationProcessNote) : Integer;
    
    // Insert FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationProcessNote;
    
    // Insert an existing FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // Get the iIndexth FhirPaymentReconciliationProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationProcessNote;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliationProcessNotes[index : Integer] : TFhirPaymentReconciliationProcessNote read GetItemN write SetItemN; default;
  End;

  // This resource provides the details including amount of a payment and allocates the payment items being paid.
  TFhirPaymentReconciliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FPaymentIssuer : TFhirReference;
    FRequest : TFhirReference;
    FRequestor : TFhirReference;
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPaymentDate : TFhirDate;
    FPaymentAmount : TFhirMoney;
    FPaymentIdentifier : TFhirIdentifier;
    FdetailList : TFhirPaymentReconciliationDetailList;
    FFormCode : TFhirCodeableConcept;
    FprocessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetPaymentIssuer(value : TFhirReference);
    procedure SetRequest(value : TFhirReference);
    procedure SetRequestor(value : TFhirReference);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirClaimProcessingCodesEnum;
    procedure SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
    procedure SetDisposition(value : TFhirString);
    function GetDispositionST : String;
    procedure SetDispositionST(value : String);
    procedure SetPaymentDate(value : TFhirDate);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetPaymentAmount(value : TFhirMoney);
    procedure SetPaymentIdentifier(value : TFhirIdentifier);
    function GetDetailList : TFhirPaymentReconciliationDetailList;
    function GetHasDetailList : Boolean;
    procedure SetFormCode(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetHasProcessNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliation; overload;
    function Clone : TFhirPaymentReconciliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this payment reconciliation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period of time for which payments have been gathered into this bulk payment for settlement. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time for which payments have been gathered into this bulk payment for settlement.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The date when the resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party who generated the payment. (defined for API consistency)
    property paymentIssuer : TFhirReference read FPaymentIssuer write SetPaymentIssuer;
    // The party who generated the payment.
    property paymentIssuerElement : TFhirReference read FPaymentIssuer write SetPaymentIssuer;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestor : TFhirReference read FRequestor write SetRequestor;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestorElement : TFhirReference read FRequestor write SetRequestor;

    // The outcome of a request for a reconciliation.
    property outcome : TFhirClaimProcessingCodesEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the request for the reconciliation.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the request for the reconciliation.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date of payment as indicated on the financial instrument.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date of payment as indicated on the financial instrument.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to Total payment amount as indicated on the financial instrument. (defined for API consistency)
    property paymentAmount : TFhirMoney read FPaymentAmount write SetPaymentAmount;
    // Total payment amount as indicated on the financial instrument.
    property paymentAmountElement : TFhirMoney read FPaymentAmount write SetPaymentAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property paymentIdentifier : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property paymentIdentifierElement : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;

    // Distribution of the payment amount for a previously acknowledged payable.
    property detailList : TFhirPaymentReconciliationDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // A note that describes or explains the processing in a human readable form.
    property processNoteList : TFhirPaymentReconciliationProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

  end;

  TFhirPaymentReconciliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationList;
    function GetCurrent : TFhirPaymentReconciliation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliation read GetCurrent;
  end;

  TFhirPaymentReconciliationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPaymentReconciliation;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPaymentReconciliationList; overload;
    function Clone : TFhirPaymentReconciliationList; overload;
    function GetEnumerator : TFhirPaymentReconciliationListEnumerator;
    
    //  Add a FhirPaymentReconciliation to the end of the list.
    function Append : TFhirPaymentReconciliation;
    
    // Add an already existing FhirPaymentReconciliation to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliation) : Integer;
    
    // Insert FhirPaymentReconciliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliation;
    
    // Insert an existing FhirPaymentReconciliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliation);
    
    // Get the iIndexth FhirPaymentReconciliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPaymentReconciliations[index : Integer] : TFhirPaymentReconciliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

implementation

uses
  fhir5_utilities;

{$IFDEF FHIR_ACCOUNT}
{ TFhirAccountCoverage }

constructor TFhirAccountCoverage.Create;
begin
  inherited;
end;

destructor TFhirAccountCoverage.Destroy;
begin
  FCoverage.free;
  FPriority.free;
  inherited;
end;

procedure TFhirAccountCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirAccountCoverage(oSource).coverage.Clone;
  priorityElement := TFhirAccountCoverage(oSource).priorityElement.Clone;
end;

procedure TFhirAccountCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirAccountCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'positiveInt', false, TFhirPositiveInt, FPriority.Link)); {L1172}
end;

function TFhirAccountCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'priority') then result := TFhirPositiveInt.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'priority') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'priority') then PriorityElement := asPositiveInt(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountCoverage.fhirType : string;
begin
  result := 'Account.coverage';
end;

function TFhirAccountCoverage.Link : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Link);
end;

function TFhirAccountCoverage.Clone : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Clone);
end;

function TFhirAccountCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirAccountCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountCoverage)) then
    result := false
  else
  begin
    o := TFhirAccountCoverage(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirAccountCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FPriority);
end;

procedure TFhirAccountCoverage.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirAccountCoverage.SetPriority(value : TFhirPositiveInt);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

function TFhirAccountCoverage.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirAccountCoverage.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirPositiveInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

procedure TFhirAccountCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('priority');
end;

function TFhirAccountCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
end;

{ TFhirAccountCoverageListEnumerator }

constructor TFhirAccountCoverageListEnumerator.Create(list : TFhirAccountCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountCoverageListEnumerator.GetCurrent : TFhirAccountCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirAccountCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountCoverageList }

procedure TFhirAccountCoverageList.AddItem(value: TFhirAccountCoverage);
begin
  assert(value.ClassName = 'TFhirAccountCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountCoverage');
  add(value);
end;

function TFhirAccountCoverageList.Append: TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirAccountCoverageList.GetEnumerator : TFhirAccountCoverageListEnumerator;
begin
  result := TFhirAccountCoverageListEnumerator.Create(self.link);
end;

function TFhirAccountCoverageList.Clone: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Clone);
end;

function TFhirAccountCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountCoverageList.GetItemN(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountCoverage;
end;
function TFhirAccountCoverageList.IndexOf(value: TFhirAccountCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountCoverageList.Insert(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.InsertItem(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  Inherited Insert(index, value);
end;

function TFhirAccountCoverageList.Item(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.Link: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Link);
end;

procedure TFhirAccountCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountCoverageList.SetItemByIndex(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  FhirAccountCoverages[index] := value;
end;

procedure TFhirAccountCoverageList.SetItemN(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirAccountGuarantor }

constructor TFhirAccountGuarantor.Create;
begin
  inherited;
end;

destructor TFhirAccountGuarantor.Destroy;
begin
  FParty.free;
  FOnHold.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAccountGuarantor.Assign(oSource : TFslObject);
begin
  inherited;
  party := TFhirAccountGuarantor(oSource).party.Clone;
  onHoldElement := TFhirAccountGuarantor(oSource).onHoldElement.Clone;
  period := TFhirAccountGuarantor(oSource).period.Clone;
end;

procedure TFhirAccountGuarantor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'onHold') Then
     list.add(self.link, 'onHold', FOnHold.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAccountGuarantor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'onHold', 'boolean', false, TFhirBoolean, FOnHold.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirAccountGuarantor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'party') then
  begin
    Party := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'onHold') then
  begin
    OnHoldElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountGuarantor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountGuarantor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'party') then result := TFhirReference.create() {L1203}
  else if (propName = 'onHold') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountGuarantor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'party') then result := 'Reference'
  else if (propName = 'onHold') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountGuarantor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := nil
  else if (propName = 'onHold') then OnHoldElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountGuarantor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := new as TFhirReference {L1195}
  else if (propName = 'onHold') then OnHoldElement := asBoolean(new) {L1222}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountGuarantor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountGuarantor.fhirType : string;
begin
  result := 'Account.guarantor';
end;

function TFhirAccountGuarantor.Link : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Link);
end;

function TFhirAccountGuarantor.Clone : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Clone);
end;

function TFhirAccountGuarantor.equals(other : TObject) : boolean; 
var
  o : TFhirAccountGuarantor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountGuarantor)) then
    result := false
  else
  begin
    o := TFhirAccountGuarantor(other);
    result := compareDeep(partyElement, o.partyElement, true) and compareDeep(onHoldElement, o.onHoldElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAccountGuarantor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FParty) and isEmptyProp(FOnHold) and isEmptyProp(FPeriod);
end;

procedure TFhirAccountGuarantor.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value; {L1134}
end;

procedure TFhirAccountGuarantor.SetOnHold(value : TFhirBoolean);
begin
  FOnHold.free;
  FOnHold := value; {L1134}
end;

function TFhirAccountGuarantor.GetOnHoldST : Boolean;
begin
  if FOnHold = nil then
    result := false
  else
    result := FOnHold.value;
end;

procedure TFhirAccountGuarantor.SetOnHoldST(value : Boolean);
begin
  if FOnHold = nil then
    FOnHold := TFhirBoolean.create;
  FOnHold.value := value
end;

procedure TFhirAccountGuarantor.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirAccountGuarantor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('party');
  fields.add('onHold');
  fields.add('period');
end;

function TFhirAccountGuarantor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FParty.sizeInBytes);
  inc(result, FOnHold.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirAccountGuarantorListEnumerator }

constructor TFhirAccountGuarantorListEnumerator.Create(list : TFhirAccountGuarantorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountGuarantorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountGuarantorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountGuarantorListEnumerator.GetCurrent : TFhirAccountGuarantor;
begin
  Result := FList[FIndex];
end;

function TFhirAccountGuarantorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountGuarantorList }

procedure TFhirAccountGuarantorList.AddItem(value: TFhirAccountGuarantor);
begin
  assert(value.ClassName = 'TFhirAccountGuarantor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountGuarantor');
  add(value);
end;

function TFhirAccountGuarantorList.Append: TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.ClearItems;
begin
  Clear;
end;

function TFhirAccountGuarantorList.GetEnumerator : TFhirAccountGuarantorListEnumerator;
begin
  result := TFhirAccountGuarantorListEnumerator.Create(self.link);
end;

function TFhirAccountGuarantorList.Clone: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Clone);
end;

function TFhirAccountGuarantorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountGuarantorList.GetItemN(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountGuarantor;
end;
function TFhirAccountGuarantorList.IndexOf(value: TFhirAccountGuarantor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountGuarantorList.Insert(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.InsertItem(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  Inherited Insert(index, value);
end;

function TFhirAccountGuarantorList.Item(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.Link: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Link);
end;

procedure TFhirAccountGuarantorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountGuarantorList.SetItemByIndex(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  FhirAccountGuarantors[index] := value;
end;

procedure TFhirAccountGuarantorList.SetItemN(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  ObjectByIndex[index] := value;
end;

{ TFhirAccount }

constructor TFhirAccount.Create;
begin
  inherited;
end;

destructor TFhirAccount.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FName.free;
  FSubjectList.Free;
  FServicePeriod.free;
  FCoverageList.Free;
  FOwner.free;
  FDescription.free;
  FGuarantorList.Free;
  FPartOf.free;
  inherited;
end;

procedure TFhirAccount.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAccount(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAccount(oSource).FIdentifierList);
  end;
  statusElement := TFhirAccount(oSource).statusElement.Clone;
  type_ := TFhirAccount(oSource).type_.Clone;
  nameElement := TFhirAccount(oSource).nameElement.Clone;
  if (TFhirAccount(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirAccount(oSource).FSubjectList);
  end;
  servicePeriod := TFhirAccount(oSource).servicePeriod.Clone;
  if (TFhirAccount(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirAccountCoverageList.Create;
    FCoverageList.Assign(TFhirAccount(oSource).FCoverageList);
  end;
  owner := TFhirAccount(oSource).owner.Clone;
  descriptionElement := TFhirAccount(oSource).descriptionElement.Clone;
  if (TFhirAccount(oSource).FGuarantorList = nil) then
  begin
    FGuarantorList.free;
    FGuarantorList := nil;
  end
  else
  begin
    if FGuarantorList = nil then
      FGuarantorList := TFhirAccountGuarantorList.Create;
    FGuarantorList.Assign(TFhirAccount(oSource).FGuarantorList);
  end;
  partOf := TFhirAccount(oSource).partOf.Clone;
end;

function TFhirAccount.GetResourceType : TFhirResourceType;
begin
  result := frtAccount;
end;

procedure TFhirAccount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'servicePeriod') Then
     list.add(self.link, 'servicePeriod', FServicePeriod.Link);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'guarantor') Then
    list.addAll(self, 'guarantor', FGuarantorList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
end;

procedure TFhirAccount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'servicePeriod', 'Period', false, TFhirPeriod, FServicePeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'BackboneElement', true, TFhirAccountCoverage, FCoverageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'guarantor', 'BackboneElement', true, TFhirAccountGuarantor, FGuarantorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link)); {L1172}
end;

function TFhirAccount.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'servicePeriod') then
  begin
    ServicePeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirAccountCoverage) {L1048};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'guarantor') then
  begin
    GuarantorList.add(propValue as TFhirAccountGuarantor) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirAccountCoverage) {L1049}
  else if (propName = 'guarantor') then GuarantorList.insertItem(index, propValue as TFhirAccountGuarantor) {L1049}
  else inherited;
end;

function TFhirAccount.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirAccountStatusEnum[AccountStatusNull], CODES_TFhirAccountStatusEnum[AccountStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'subject') then result := SubjectList.new() {L1053}
  else if (propName = 'servicePeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'coverage') then result := CoverageList.new() {L1053}
  else if (propName = 'owner') then result := TFhirReference.create() {L1203}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'guarantor') then result := GuarantorList.new() {L1053}
  else if (propName = 'partOf') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccount.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'servicePeriod') then result := 'Period'
  else if (propName = 'coverage') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'guarantor') then result := 'BackboneElement'
  else if (propName = 'partOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccount.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {L1054}
  else if (propName = 'servicePeriod') then ServicePeriodElement := nil
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {L1054}
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'guarantor') then deletePropertyValue('guarantor', GuarantorList, value) {L1054}
  else if (propName = 'partOf') then PartOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {L1055}
  else if (propName = 'servicePeriod') then ServicePeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {L1055}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference {L1195}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'guarantor') then replacePropertyValue('guarantor', GuarantorList, existing, new) {L1055}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccount.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'subject') then SubjectList.move(source, destination) {L1050}
  else if (propName = 'coverage') then CoverageList.move(source, destination) {L1050}
  else if (propName = 'guarantor') then GuarantorList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAccount.fhirType : string;
begin
  result := 'Account';
end;

function TFhirAccount.Link : TFhirAccount;
begin
  result := TFhirAccount(inherited Link);
end;

function TFhirAccount.Clone : TFhirAccount;
begin
  result := TFhirAccount(inherited Clone);
end;

function TFhirAccount.equals(other : TObject) : boolean; 
var
  o : TFhirAccount;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccount)) then
    result := false
  else
  begin
    o := TFhirAccount(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(subjectList, o.subjectList, true) and compareDeep(servicePeriodElement, o.servicePeriodElement, true) and 
      compareDeep(coverageList, o.coverageList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(guarantorList, o.guarantorList, true) and 
      compareDeep(partOfElement, o.partOfElement, true);
  end;
end;

function TFhirAccount.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FsubjectList) and isEmptyProp(FServicePeriod) and isEmptyProp(FcoverageList) and isEmptyProp(FOwner) and isEmptyProp(FDescription) and isEmptyProp(FguarantorList) and isEmptyProp(FPartOf);
end;

function TFhirAccount.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAccount.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAccount.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAccount.GetStatusST : TFhirAccountStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAccountStatusEnum(0)
  else
    result := TFhirAccountStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAccountStatusEnum, FStatus.value));
end;

procedure TFhirAccount.SetStatusST(value : TFhirAccountStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAccountStatusEnum[value], CODES_TFhirAccountStatusEnum[value]);
end;

procedure TFhirAccount.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirAccount.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirAccount.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirAccount.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirAccount.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirAccount.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirAccount.SetServicePeriod(value : TFhirPeriod);
begin
  FServicePeriod.free;
  FServicePeriod := value; {L1134}
end;

function TFhirAccount.GetCoverageList : TFhirAccountCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirAccountCoverageList.Create;
  result := FCoverageList;
end;

function TFhirAccount.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

procedure TFhirAccount.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value; {L1134}
end;

procedure TFhirAccount.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirAccount.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAccount.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirAccount.GetGuarantorList : TFhirAccountGuarantorList;
begin
  if FGuarantorList = nil then
    FGuarantorList := TFhirAccountGuarantorList.Create;
  result := FGuarantorList;
end;

function TFhirAccount.GetHasGuarantorList : boolean;
begin
  result := (FGuarantorList <> nil) and (FGuarantorList.count > 0);
end;

procedure TFhirAccount.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value; {L1134}
end;

procedure TFhirAccount.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('subject');
  fields.add('servicePeriod');
  fields.add('coverage');
  fields.add('owner');
  fields.add('description');
  fields.add('guarantor');
  fields.add('partOf');
end;

function TFhirAccount.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FServicePeriod.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FguarantorList.sizeInBytes);
  inc(result, FPartOf.sizeInBytes);
end;

{ TFhirAccountListEnumerator }

constructor TFhirAccountListEnumerator.Create(list : TFhirAccountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountListEnumerator.GetCurrent : TFhirAccount;
begin
  Result := FList[FIndex];
end;

function TFhirAccountListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountList }

procedure TFhirAccountList.AddItem(value: TFhirAccount);
begin
  assert(value.ClassName = 'TFhirAccount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccount');
  add(value);
end;

function TFhirAccountList.Append: TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.ClearItems;
begin
  Clear;
end;

function TFhirAccountList.GetEnumerator : TFhirAccountListEnumerator;
begin
  result := TFhirAccountListEnumerator.Create(self.link);
end;

function TFhirAccountList.Clone: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Clone);
end;

function TFhirAccountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountList.GetItemN(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccount;
end;
function TFhirAccountList.IndexOf(value: TFhirAccount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountList.Insert(index: Integer): TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.InsertItem(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  Inherited Insert(index, value);
end;

function TFhirAccountList.Item(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.Link: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Link);
end;

procedure TFhirAccountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountList.SetItemByIndex(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  FhirAccounts[index] := value;
end;

procedure TFhirAccountList.SetItemN(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_CHARGEITEM}
{ TFhirChargeItemPerformer }

constructor TFhirChargeItemPerformer.Create;
begin
  inherited;
end;

destructor TFhirChargeItemPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirChargeItemPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirChargeItemPerformer(oSource).function_.Clone;
  actor := TFhirChargeItemPerformer(oSource).actor.Clone;
end;

procedure TFhirChargeItemPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirChargeItemPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirChargeItemPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemPerformer.fhirType : string;
begin
  result := 'ChargeItem.performer';
end;

function TFhirChargeItemPerformer.Link : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Link);
end;

function TFhirChargeItemPerformer.Clone : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Clone);
end;

function TFhirChargeItemPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemPerformer)) then
    result := false
  else
  begin
    o := TFhirChargeItemPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirChargeItemPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirChargeItemPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value; {L1134}
end;

procedure TFhirChargeItemPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirChargeItemPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirChargeItemPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirChargeItemPerformerListEnumerator }

constructor TFhirChargeItemPerformerListEnumerator.Create(list : TFhirChargeItemPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemPerformerListEnumerator.GetCurrent : TFhirChargeItemPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemPerformerList }

procedure TFhirChargeItemPerformerList.AddItem(value: TFhirChargeItemPerformer);
begin
  assert(value.ClassName = 'TFhirChargeItemPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemPerformer');
  add(value);
end;

function TFhirChargeItemPerformerList.Append: TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemPerformerList.GetEnumerator : TFhirChargeItemPerformerListEnumerator;
begin
  result := TFhirChargeItemPerformerListEnumerator.Create(self.link);
end;

function TFhirChargeItemPerformerList.Clone: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Clone);
end;

function TFhirChargeItemPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemPerformerList.GetItemN(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemPerformer;
end;
function TFhirChargeItemPerformerList.IndexOf(value: TFhirChargeItemPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemPerformerList.Insert(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.InsertItem(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  Inherited Insert(index, value);
end;

function TFhirChargeItemPerformerList.Item(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.Link: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Link);
end;

procedure TFhirChargeItemPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemPerformerList.SetItemByIndex(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  FhirChargeItemPerformers[index] := value;
end;

procedure TFhirChargeItemPerformerList.SetItemN(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItem }

constructor TFhirChargeItem.Create;
begin
  inherited;
end;

destructor TFhirChargeItem.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionUriList.Free;
  FDefinitionCanonicalList.Free;
  FStatus.free;
  FPartOfList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FPerformerList.Free;
  FPerformingOrganization.free;
  FRequestingOrganization.free;
  FCostCenter.free;
  FQuantity.free;
  FBodysiteList.Free;
  FFactorOverride.free;
  FPriceOverride.free;
  FOverrideReason.free;
  FEnterer.free;
  FEnteredDate.free;
  FReasonList.Free;
  FServiceList.Free;
  FProduct.free;
  FAccountList.Free;
  FNoteList.Free;
  FSupportingInformationList.Free;
  inherited;
end;

procedure TFhirChargeItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirChargeItem(oSource).FIdentifierList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionUriList = nil) then
  begin
    FDefinitionUriList.free;
    FDefinitionUriList := nil;
  end
  else
  begin
    if FDefinitionUriList = nil then
      FDefinitionUriList := TFhirUriList.Create;
    FDefinitionUriList.Assign(TFhirChargeItem(oSource).FDefinitionUriList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionCanonicalList = nil) then
  begin
    FDefinitionCanonicalList.free;
    FDefinitionCanonicalList := nil;
  end
  else
  begin
    if FDefinitionCanonicalList = nil then
      FDefinitionCanonicalList := TFhirCanonicalList.Create;
    FDefinitionCanonicalList.Assign(TFhirChargeItem(oSource).FDefinitionCanonicalList);
  end;
  statusElement := TFhirChargeItem(oSource).statusElement.Clone;
  if (TFhirChargeItem(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirChargeItem(oSource).FPartOfList);
  end;
  code := TFhirChargeItem(oSource).code.Clone;
  subject := TFhirChargeItem(oSource).subject.Clone;
  context := TFhirChargeItem(oSource).context.Clone;
  occurrence := TFhirChargeItem(oSource).occurrence.Clone;
  if (TFhirChargeItem(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirChargeItemPerformerList.Create;
    FPerformerList.Assign(TFhirChargeItem(oSource).FPerformerList);
  end;
  performingOrganization := TFhirChargeItem(oSource).performingOrganization.Clone;
  requestingOrganization := TFhirChargeItem(oSource).requestingOrganization.Clone;
  costCenter := TFhirChargeItem(oSource).costCenter.Clone;
  quantity := TFhirChargeItem(oSource).quantity.Clone;
  if (TFhirChargeItem(oSource).FBodysiteList = nil) then
  begin
    FBodysiteList.free;
    FBodysiteList := nil;
  end
  else
  begin
    if FBodysiteList = nil then
      FBodysiteList := TFhirCodeableConceptList.Create;
    FBodysiteList.Assign(TFhirChargeItem(oSource).FBodysiteList);
  end;
  factorOverrideElement := TFhirChargeItem(oSource).factorOverrideElement.Clone;
  priceOverride := TFhirChargeItem(oSource).priceOverride.Clone;
  overrideReasonElement := TFhirChargeItem(oSource).overrideReasonElement.Clone;
  enterer := TFhirChargeItem(oSource).enterer.Clone;
  enteredDateElement := TFhirChargeItem(oSource).enteredDateElement.Clone;
  if (TFhirChargeItem(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirChargeItem(oSource).FReasonList);
  end;
  if (TFhirChargeItem(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirReferenceList.Create;
    FServiceList.Assign(TFhirChargeItem(oSource).FServiceList);
  end;
  product := TFhirChargeItem(oSource).product.Clone;
  if (TFhirChargeItem(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirChargeItem(oSource).FAccountList);
  end;
  if (TFhirChargeItem(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirChargeItem(oSource).FNoteList);
  end;
  if (TFhirChargeItem(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirChargeItem(oSource).FSupportingInformationList);
  end;
end;

function TFhirChargeItem.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItem;
end;

procedure TFhirChargeItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definitionUri') Then
    list.addAll(self, 'definitionUri', FDefinitionUriList);
  if (child_name = 'definitionCanonical') Then
    list.addAll(self, 'definitionCanonical', FDefinitionCanonicalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'performingOrganization') Then
     list.add(self.link, 'performingOrganization', FPerformingOrganization.Link);
  if (child_name = 'requestingOrganization') Then
     list.add(self.link, 'requestingOrganization', FRequestingOrganization.Link);
  if (child_name = 'costCenter') Then
     list.add(self.link, 'costCenter', FCostCenter.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'bodysite') Then
    list.addAll(self, 'bodysite', FBodysiteList);
  if (child_name = 'factorOverride') Then
     list.add(self.link, 'factorOverride', FFactorOverride.Link);
  if (child_name = 'priceOverride') Then
     list.add(self.link, 'priceOverride', FPriceOverride.Link);
  if (child_name = 'overrideReason') Then
     list.add(self.link, 'overrideReason', FOverrideReason.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'enteredDate') Then
     list.add(self.link, 'enteredDate', FEnteredDate.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
end;

procedure TFhirChargeItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'definitionUri', 'uri', true, TFhirUri, FDefinitionUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'definitionCanonical', 'canonical', true, TFhirCanonical, FDefinitionCanonicalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirChargeItemPerformer, FPerformerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'performingOrganization', 'Reference', false, TFhirReference, FPerformingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requestingOrganization', 'Reference', false, TFhirReference, FRequestingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'costCenter', 'Reference', false, TFhirReference, FCostCenter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'bodysite', 'CodeableConcept', true, TFhirCodeableConcept, FBodysiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'factorOverride', 'decimal', false, TFhirDecimal, FFactorOverride.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priceOverride', 'Money', false, TFhirMoney, FPriceOverride.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'overrideReason', 'string', false, TFhirString, FOverrideReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'enteredDate', 'dateTime', false, TFhirDateTime, FEnteredDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'service', 'Reference', true, TFhirReference, FServiceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference|CodeableConcept', false, TFhirDataType, FProduct.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link)) {L1039};
end;

function TFhirChargeItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'definitionUri') then
  begin
    DefinitionUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'definitionCanonical') then
  begin
    DefinitionCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirChargeItemStatusEnum, CODES_TFhirChargeItemStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirChargeItemPerformer) {L1048};
    result := propValue;
  end
  else if (propName = 'performingOrganization') then
  begin
    PerformingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'requestingOrganization') then
  begin
    RequestingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'costCenter') then
  begin
    CostCenter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'bodysite') then
  begin
    BodysiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'factorOverride') then
  begin
    FactorOverrideElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'priceOverride') then
  begin
    PriceOverride := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'overrideReason') then
  begin
    OverrideReasonElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'enteredDate') then
  begin
    EnteredDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'definitionUri') then DefinitionUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirChargeItemPerformer) {L1049}
  else if (propName = 'bodysite') then BodysiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirChargeItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'definitionUri') then result := DefinitionUriList.new() {L1053}
  else if (propName = 'definitionCanonical') then result := DefinitionCanonicalList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirChargeItemStatusEnum[ChargeItemStatusNull], CODES_TFhirChargeItemStatusEnum[ChargeItemStatusNull])  {L1211}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'context') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence') {L1191}
  else if (propName = 'performer') then result := PerformerList.new() {L1053}
  else if (propName = 'performingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'requestingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'costCenter') then result := TFhirReference.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'bodysite') then result := BodysiteList.new() {L1053}
  else if (propName = 'factorOverride') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'priceOverride') then result := TFhirMoney.create() {L1203}
  else if (propName = 'overrideReason') then result := TFhirString.create() {L1223}
  else if (propName = 'enterer') then result := TFhirReference.create() {L1203}
  else if (propName = 'enteredDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'service') then result := ServiceList.new() {L1053}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product') {L1191}
  else if (propName = 'account') then result := AccountList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definitionUri') then result := 'uri'
  else if (propName = 'definitionCanonical') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'performingOrganization') then result := 'Reference'
  else if (propName = 'requestingOrganization') then result := 'Reference'
  else if (propName = 'costCenter') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'bodysite') then result := 'CodeableConcept'
  else if (propName = 'factorOverride') then result := 'decimal'
  else if (propName = 'priceOverride') then result := 'Money'
  else if (propName = 'overrideReason') then result := 'string'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'enteredDate') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'definitionUri') then deletePropertyValue('definitionUri', DefinitionUriList, value) {L1054}
  else if (propName = 'definitionCanonical') then deletePropertyValue('definitionCanonical', DefinitionCanonicalList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil {L1189}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {L1054}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := nil
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := nil
  else if (propName = 'costCenter') then CostCenterElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'bodysite') then deletePropertyValue('bodysite', BodysiteList, value) {L1054}
  else if (propName = 'factorOverride') then FactorOverrideElement := nil
  else if (propName = 'priceOverride') then PriceOverrideElement := nil
  else if (propName = 'overrideReason') then OverrideReasonElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'enteredDate') then EnteredDateElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value) {L1054}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil {L1189}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'definitionUri') then replacePropertyValue('definitionUri', DefinitionUriList, existing, new) {L1055}
  else if (propName = 'definitionCanonical') then replacePropertyValue('definitionCanonical', DefinitionCanonicalList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirChargeItemStatusEnum, CODES_TFhirChargeItemStatusEnum, new) {L1210}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'context') then ContextElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType {L1190}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {L1055}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'costCenter') then CostCenterElement := new as TFhirReference {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'bodysite') then replacePropertyValue('bodysite', BodysiteList, existing, new) {L1055}
  else if (propName = 'factorOverride') then FactorOverrideElement := asDecimal(new) {L1222}
  else if (propName = 'priceOverride') then PriceOverrideElement := new as TFhirMoney {L1195}
  else if (propName = 'overrideReason') then OverrideReasonElement := asString(new) {L1222}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference {L1195}
  else if (propName = 'enteredDate') then EnteredDateElement := asDateTime(new) {L1222}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new) {L1055}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirDataType {L1190}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'definitionUri') then DefinitionUriList.move(source, destination) {L1046}
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.move(source, destination) {L1046}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1050}
  else if (propName = 'performer') then PerformerList.move(source, destination) {L1050}
  else if (propName = 'bodysite') then BodysiteList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'service') then ServiceList.move(source, destination) {L1050}
  else if (propName = 'account') then AccountList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItem.fhirType : string;
begin
  result := 'ChargeItem';
end;

function TFhirChargeItem.Link : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Link);
end;

function TFhirChargeItem.Clone : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Clone);
end;

function TFhirChargeItem.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItem)) then
    result := false
  else
  begin
    o := TFhirChargeItem(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionUriList, o.definitionUriList, true) and 
      compareDeep(definitionCanonicalList, o.definitionCanonicalList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(performingOrganizationElement, o.performingOrganizationElement, true) and 
      compareDeep(requestingOrganizationElement, o.requestingOrganizationElement, true) and 
      compareDeep(costCenterElement, o.costCenterElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(bodysiteList, o.bodysiteList, true) and compareDeep(factorOverrideElement, o.factorOverrideElement, true) and 
      compareDeep(priceOverrideElement, o.priceOverrideElement, true) and compareDeep(overrideReasonElement, o.overrideReasonElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(enteredDateElement, o.enteredDateElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(serviceList, o.serviceList, true) and 
      compareDeep(productElement, o.productElement, true) and compareDeep(accountList, o.accountList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(supportingInformationList, o.supportingInformationList, true);
  end;
end;

function TFhirChargeItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionUriList) and isEmptyProp(FdefinitionCanonicalList) and isEmptyProp(FStatus) and isEmptyProp(FpartOfList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FperformerList) and isEmptyProp(FPerformingOrganization) and isEmptyProp(FRequestingOrganization) and isEmptyProp(FCostCenter) and isEmptyProp(FQuantity) and isEmptyProp(FbodysiteList) and isEmptyProp(FFactorOverride) and isEmptyProp(FPriceOverride) and isEmptyProp(FOverrideReason) and isEmptyProp(FEnterer) and isEmptyProp(FEnteredDate) and isEmptyProp(FreasonList) and isEmptyProp(FserviceList) and isEmptyProp(FProduct) and isEmptyProp(FaccountList) and isEmptyProp(FnoteList) and isEmptyProp(FsupportingInformationList);
end;

function TFhirChargeItem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirChargeItem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirChargeItem.GetDefinitionUriList : TFhirUriList;
begin
  if FDefinitionUriList = nil then
    FDefinitionUriList := TFhirUriList.Create;
  result := FDefinitionUriList;
end;

function TFhirChargeItem.GetHasDefinitionUriList : boolean;
begin
  result := (FDefinitionUriList <> nil) and (FDefinitionUriList.count > 0);
end;

function TFhirChargeItem.GetDefinitionCanonicalList : TFhirCanonicalList;
begin
  if FDefinitionCanonicalList = nil then
    FDefinitionCanonicalList := TFhirCanonicalList.Create;
  result := FDefinitionCanonicalList;
end;

function TFhirChargeItem.GetHasDefinitionCanonicalList : boolean;
begin
  result := (FDefinitionCanonicalList <> nil) and (FDefinitionCanonicalList.count > 0);
end;

procedure TFhirChargeItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirChargeItem.GetStatusST : TFhirChargeItemStatusEnum;
begin
  if FStatus = nil then
    result := TFhirChargeItemStatusEnum(0)
  else
    result := TFhirChargeItemStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirChargeItemStatusEnum, FStatus.value));
end;

procedure TFhirChargeItem.SetStatusST(value : TFhirChargeItemStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirChargeItemStatusEnum[value], CODES_TFhirChargeItemStatusEnum[value]);
end;

function TFhirChargeItem.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirChargeItem.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirChargeItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirChargeItem.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirChargeItem.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value; {L1134}
end;

procedure TFhirChargeItem.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value; {L1134}
end;

function TFhirChargeItem.GetPerformerList : TFhirChargeItemPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirChargeItemPerformerList.Create;
  result := FPerformerList;
end;

function TFhirChargeItem.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirChargeItem.SetPerformingOrganization(value : TFhirReference);
begin
  FPerformingOrganization.free;
  FPerformingOrganization := value; {L1134}
end;

procedure TFhirChargeItem.SetRequestingOrganization(value : TFhirReference);
begin
  FRequestingOrganization.free;
  FRequestingOrganization := value; {L1134}
end;

procedure TFhirChargeItem.SetCostCenter(value : TFhirReference);
begin
  FCostCenter.free;
  FCostCenter := value; {L1134}
end;

procedure TFhirChargeItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirChargeItem.GetBodysiteList : TFhirCodeableConceptList;
begin
  if FBodysiteList = nil then
    FBodysiteList := TFhirCodeableConceptList.Create;
  result := FBodysiteList;
end;

function TFhirChargeItem.GetHasBodysiteList : boolean;
begin
  result := (FBodysiteList <> nil) and (FBodysiteList.count > 0);
end;

procedure TFhirChargeItem.SetFactorOverride(value : TFhirDecimal);
begin
  FFactorOverride.free;
  FFactorOverride := value; {L1134}
end;

function TFhirChargeItem.GetFactorOverrideST : String;
begin
  if FFactorOverride = nil then
    result := ''
  else
    result := FFactorOverride.value;
end;

procedure TFhirChargeItem.SetFactorOverrideST(value : String);
begin
  if value <> '' then
  begin
    if FFactorOverride = nil then
      FFactorOverride := TFhirDecimal.create;
    FFactorOverride.value := value
  end
  else if FFactorOverride <> nil then
    FFactorOverride.value := '';
end;

procedure TFhirChargeItem.SetPriceOverride(value : TFhirMoney);
begin
  FPriceOverride.free;
  FPriceOverride := value; {L1134}
end;

procedure TFhirChargeItem.SetOverrideReason(value : TFhirString);
begin
  FOverrideReason.free;
  FOverrideReason := value; {L1134}
end;

function TFhirChargeItem.GetOverrideReasonST : String;
begin
  if FOverrideReason = nil then
    result := ''
  else
    result := FOverrideReason.value;
end;

procedure TFhirChargeItem.SetOverrideReasonST(value : String);
begin
  if value <> '' then
  begin
    if FOverrideReason = nil then
      FOverrideReason := TFhirString.create;
    FOverrideReason.value := value
  end
  else if FOverrideReason <> nil then
    FOverrideReason.value := '';
end;

procedure TFhirChargeItem.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value; {L1134}
end;

procedure TFhirChargeItem.SetEnteredDate(value : TFhirDateTime);
begin
  FEnteredDate.free;
  FEnteredDate := value; {L1134}
end;

function TFhirChargeItem.GetEnteredDateST : TFslDateTime;
begin
  if FEnteredDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnteredDate.value;
end;

procedure TFhirChargeItem.SetEnteredDateST(value : TFslDateTime);
begin
  if FEnteredDate = nil then
    FEnteredDate := TFhirDateTime.create;
  FEnteredDate.value := value
end;

function TFhirChargeItem.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirChargeItem.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirChargeItem.GetServiceList : TFhirReferenceList;
begin
  if FServiceList = nil then
    FServiceList := TFhirReferenceList.Create;
  result := FServiceList;
end;

function TFhirChargeItem.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

procedure TFhirChargeItem.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value; {L1134}
end;

function TFhirChargeItem.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirChargeItem.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

function TFhirChargeItem.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirChargeItem.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirChargeItem.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirChargeItem.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirChargeItem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definitionUri');
  fields.add('definitionCanonical');
  fields.add('status');
  fields.add('partOf');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('performer');
  fields.add('performingOrganization');
  fields.add('requestingOrganization');
  fields.add('costCenter');
  fields.add('quantity');
  fields.add('bodysite');
  fields.add('factorOverride');
  fields.add('priceOverride');
  fields.add('overrideReason');
  fields.add('enterer');
  fields.add('enteredDate');
  fields.add('reason');
  fields.add('service');
  fields.add('product[x]');
  fields.add('account');
  fields.add('note');
  fields.add('supportingInformation');
end;

function TFhirChargeItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionUriList.sizeInBytes);
  inc(result, FdefinitionCanonicalList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FPerformingOrganization.sizeInBytes);
  inc(result, FRequestingOrganization.sizeInBytes);
  inc(result, FCostCenter.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FbodysiteList.sizeInBytes);
  inc(result, FFactorOverride.sizeInBytes);
  inc(result, FPriceOverride.sizeInBytes);
  inc(result, FOverrideReason.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FEnteredDate.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FserviceList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FaccountList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
end;

{ TFhirChargeItemListEnumerator }

constructor TFhirChargeItemListEnumerator.Create(list : TFhirChargeItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemListEnumerator.GetCurrent : TFhirChargeItem;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemList }

procedure TFhirChargeItemList.AddItem(value: TFhirChargeItem);
begin
  assert(value.ClassName = 'TFhirChargeItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItem');
  add(value);
end;

function TFhirChargeItemList.Append: TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemList.GetEnumerator : TFhirChargeItemListEnumerator;
begin
  result := TFhirChargeItemListEnumerator.Create(self.link);
end;

function TFhirChargeItemList.Clone: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Clone);
end;

function TFhirChargeItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemList.GetItemN(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItem;
end;
function TFhirChargeItemList.IndexOf(value: TFhirChargeItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemList.Insert(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.InsertItem(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  Inherited Insert(index, value);
end;

function TFhirChargeItemList.Item(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.Link: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Link);
end;

procedure TFhirChargeItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemList.SetItemByIndex(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  FhirChargeItems[index] := value;
end;

procedure TFhirChargeItemList.SetItemN(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CHARGEITEMDEFINITION}
{ TFhirChargeItemDefinitionApplicability }

constructor TFhirChargeItemDefinitionApplicability.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionApplicability.Destroy;
begin
  FDescription.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirChargeItemDefinitionApplicability.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirChargeItemDefinitionApplicability(oSource).descriptionElement.Clone;
  languageElement := TFhirChargeItemDefinitionApplicability(oSource).languageElement.Clone;
  expressionElement := TFhirChargeItemDefinitionApplicability(oSource).expressionElement.Clone;
end;

procedure TFhirChargeItemDefinitionApplicability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirChargeItemDefinitionApplicability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link)); {L1172}
end;

function TFhirChargeItemDefinitionApplicability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionApplicability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemDefinitionApplicability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'language') then result := TFhirString.create() {L1223}
  else if (propName = 'expression') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionApplicability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionApplicability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionApplicability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'language') then LanguageElement := asString(new) {L1222}
  else if (propName = 'expression') then ExpressionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionApplicability.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionApplicability.fhirType : string;
begin
  result := 'ChargeItemDefinition.applicability';
end;

function TFhirChargeItemDefinitionApplicability.Link : TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(inherited Link);
end;

function TFhirChargeItemDefinitionApplicability.Clone : TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(inherited Clone);
end;

function TFhirChargeItemDefinitionApplicability.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionApplicability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionApplicability)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionApplicability(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirChargeItemDefinitionApplicability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirChargeItemDefinitionApplicability.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirChargeItemDefinitionApplicability.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirChargeItemDefinitionApplicability.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

function TFhirChargeItemDefinitionApplicability.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

procedure TFhirChargeItemDefinitionApplicability.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value; {L1134}
end;

function TFhirChargeItemDefinitionApplicability.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

procedure TFhirChargeItemDefinitionApplicability.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

procedure TFhirChargeItemDefinitionApplicability.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('language');
  fields.add('expression');
end;

function TFhirChargeItemDefinitionApplicability.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirChargeItemDefinitionApplicabilityListEnumerator }

constructor TFhirChargeItemDefinitionApplicabilityListEnumerator.Create(list : TFhirChargeItemDefinitionApplicabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionApplicabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.GetCurrent : TFhirChargeItemDefinitionApplicability;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionApplicabilityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionApplicabilityList }

procedure TFhirChargeItemDefinitionApplicabilityList.AddItem(value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionApplicability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionApplicability');
  add(value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Append: TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionApplicabilityList.GetEnumerator : TFhirChargeItemDefinitionApplicabilityListEnumerator;
begin
  result := TFhirChargeItemDefinitionApplicabilityListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionApplicabilityList.Clone: TFhirChargeItemDefinitionApplicabilityList;
begin
  result := TFhirChargeItemDefinitionApplicabilityList(inherited Clone);
end;

function TFhirChargeItemDefinitionApplicabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionApplicabilityList.GetItemN(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionApplicabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionApplicability;
end;
function TFhirChargeItemDefinitionApplicabilityList.IndexOf(value: TFhirChargeItemDefinitionApplicability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Insert(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionApplicabilityList.Item(index: Integer): TFhirChargeItemDefinitionApplicability;
begin
  result := TFhirChargeItemDefinitionApplicability(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionApplicabilityList.Link: TFhirChargeItemDefinitionApplicabilityList;
begin
  result := TFhirChargeItemDefinitionApplicabilityList(inherited Link);
end;

procedure TFhirChargeItemDefinitionApplicabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionApplicabilityList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  FhirChargeItemDefinitionApplicabilities[index] := value;
end;

procedure TFhirChargeItemDefinitionApplicabilityList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionApplicability);
begin
  assert(value is TFhirChargeItemDefinitionApplicability);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinitionPropertyGroup }

constructor TFhirChargeItemDefinitionPropertyGroup.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionPropertyGroup.Destroy;
begin
  FApplicabilityList.Free;
  FPriceComponentList.Free;
  inherited;
end;

procedure TFhirChargeItemDefinitionPropertyGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItemDefinitionPropertyGroup(oSource).FApplicabilityList = nil) then
  begin
    FApplicabilityList.free;
    FApplicabilityList := nil;
  end
  else
  begin
    if FApplicabilityList = nil then
      FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
    FApplicabilityList.Assign(TFhirChargeItemDefinitionPropertyGroup(oSource).FApplicabilityList);
  end;
  if (TFhirChargeItemDefinitionPropertyGroup(oSource).FPriceComponentList = nil) then
  begin
    FPriceComponentList.free;
    FPriceComponentList := nil;
  end
  else
  begin
    if FPriceComponentList = nil then
      FPriceComponentList := TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Create;
    FPriceComponentList.Assign(TFhirChargeItemDefinitionPropertyGroup(oSource).FPriceComponentList);
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'applicability') Then
    list.addAll(self, 'applicability', FApplicabilityList);
  if (child_name = 'priceComponent') Then
    list.addAll(self, 'priceComponent', FPriceComponentList);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'applicability', '', true, TFhirChargeItemDefinitionApplicability, FApplicabilityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'priceComponent', 'BackboneElement', true, TFhirChargeItemDefinitionPropertyGroupPriceComponent, FPriceComponentList.Link)) {L1039};
end;

function TFhirChargeItemDefinitionPropertyGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'applicability') then
  begin
    ApplicabilityList.add(propValue as TFhirChargeItemDefinitionApplicability) {L1048};
    result := propValue;
  end
  else if (propName = 'priceComponent') then
  begin
    PriceComponentList.add(propValue as TFhirChargeItemDefinitionPropertyGroupPriceComponent) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'applicability') then ApplicabilityList.insertItem(index, propValue as TFhirChargeItemDefinitionApplicability) {L1049}
  else if (propName = 'priceComponent') then PriceComponentList.insertItem(index, propValue as TFhirChargeItemDefinitionPropertyGroupPriceComponent) {L1049}
  else inherited;
end;

function TFhirChargeItemDefinitionPropertyGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'applicability') then result := ApplicabilityList.new() {L1053}
  else if (propName = 'priceComponent') then result := PriceComponentList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionPropertyGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'applicability') then result := ''
  else if (propName = 'priceComponent') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'applicability') then deletePropertyValue('applicability', ApplicabilityList, value) {L1054}
  else if (propName = 'priceComponent') then deletePropertyValue('priceComponent', PriceComponentList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'applicability') then replacePropertyValue('applicability', ApplicabilityList, existing, new) {L1055}
  else if (propName = 'priceComponent') then replacePropertyValue('priceComponent', PriceComponentList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'applicability') then ApplicabilityList.move(source, destination) {L1050}
  else if (propName = 'priceComponent') then PriceComponentList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionPropertyGroup.fhirType : string;
begin
  result := 'ChargeItemDefinition.propertyGroup';
end;

function TFhirChargeItemDefinitionPropertyGroup.Link : TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(inherited Link);
end;

function TFhirChargeItemDefinitionPropertyGroup.Clone : TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroup.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionPropertyGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionPropertyGroup)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionPropertyGroup(other);
    result := compareDeep(applicabilityList, o.applicabilityList, true) and compareDeep(priceComponentList, o.priceComponentList, true);
  end;
end;

function TFhirChargeItemDefinitionPropertyGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FapplicabilityList) and isEmptyProp(FpriceComponentList);
end;

function TFhirChargeItemDefinitionPropertyGroup.GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
begin
  if FApplicabilityList = nil then
    FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
  result := FApplicabilityList;
end;

function TFhirChargeItemDefinitionPropertyGroup.GetHasApplicabilityList : boolean;
begin
  result := (FApplicabilityList <> nil) and (FApplicabilityList.count > 0);
end;

function TFhirChargeItemDefinitionPropertyGroup.GetPriceComponentList : TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  if FPriceComponentList = nil then
    FPriceComponentList := TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Create;
  result := FPriceComponentList;
end;

function TFhirChargeItemDefinitionPropertyGroup.GetHasPriceComponentList : boolean;
begin
  result := (FPriceComponentList <> nil) and (FPriceComponentList.count > 0);
end;

procedure TFhirChargeItemDefinitionPropertyGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('applicability');
  fields.add('priceComponent');
end;

function TFhirChargeItemDefinitionPropertyGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FapplicabilityList.sizeInBytes);
  inc(result, FpriceComponentList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionPropertyGroupListEnumerator }

constructor TFhirChargeItemDefinitionPropertyGroupListEnumerator.Create(list : TFhirChargeItemDefinitionPropertyGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionPropertyGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.GetCurrent : TFhirChargeItemDefinitionPropertyGroup;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionPropertyGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionPropertyGroupList }

procedure TFhirChargeItemDefinitionPropertyGroupList.AddItem(value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionPropertyGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionPropertyGroup');
  add(value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Append: TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionPropertyGroupList.GetEnumerator : TFhirChargeItemDefinitionPropertyGroupListEnumerator;
begin
  result := TFhirChargeItemDefinitionPropertyGroupListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Clone: TFhirChargeItemDefinitionPropertyGroupList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupList(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionPropertyGroupList.GetItemN(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionPropertyGroup;
end;
function TFhirChargeItemDefinitionPropertyGroupList.IndexOf(value: TFhirChargeItemDefinitionPropertyGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Insert(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Item(index: Integer): TFhirChargeItemDefinitionPropertyGroup;
begin
  result := TFhirChargeItemDefinitionPropertyGroup(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupList.Link: TFhirChargeItemDefinitionPropertyGroupList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupList(inherited Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  FhirChargeItemDefinitionPropertyGroups[index] := value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionPropertyGroup);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponent }

constructor TFhirChargeItemDefinitionPropertyGroupPriceComponent.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinitionPropertyGroupPriceComponent.Destroy;
begin
  FType_.free;
  FCode.free;
  FFactor.free;
  FAmount.free;
  inherited;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).type_Element.Clone;
  code := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).code.Clone;
  factorElement := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).factorElement.Clone;
  amount := TFhirChargeItemDefinitionPropertyGroupPriceComponent(oSource).amount.Clone;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull], CODES_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull])  {L1211}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, new) {L1210}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.fhirType : string;
begin
  result := 'ChargeItemDefinition.propertyGroup.priceComponent';
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.Link : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(inherited Link);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.Clone : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinitionPropertyGroupPriceComponent)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinitionPropertyGroupPriceComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FCode) and isEmptyProp(FFactor) and isEmptyProp(FAmount);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetType_ST : TFhirInvoicePriceComponentTypeEnum;
begin
  if FType_ = nil then
    result := TFhirInvoicePriceComponentTypeEnum(0)
  else
    result := TFhirInvoicePriceComponentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoicePriceComponentTypeEnum, FType_.value));
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[value], CODES_TFhirInvoicePriceComponentTypeEnum[value]);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('code');
  fields.add('factor');
  fields.add('amount');
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator }

constructor TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Create(list : TFhirChargeItemDefinitionPropertyGroupPriceComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.GetCurrent : TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionPropertyGroupPriceComponentList }

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.AddItem(value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinitionPropertyGroupPriceComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinitionPropertyGroupPriceComponent');
  add(value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Append: TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.GetEnumerator : TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Clone: TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentList(inherited Clone);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.GetItemN(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent;
end;
function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.IndexOf(value: TFhirChargeItemDefinitionPropertyGroupPriceComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Insert(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.InsertItem(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Item(index: Integer): TFhirChargeItemDefinitionPropertyGroupPriceComponent;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponent(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Link: TFhirChargeItemDefinitionPropertyGroupPriceComponentList;
begin
  result := TFhirChargeItemDefinitionPropertyGroupPriceComponentList(inherited Link);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  FhirChargeItemDefinitionPropertyGroupPriceComponents[index] := value;
end;

procedure TFhirChargeItemDefinitionPropertyGroupPriceComponentList.SetItemN(index: Integer; value: TFhirChargeItemDefinitionPropertyGroupPriceComponent);
begin
  assert(value is TFhirChargeItemDefinitionPropertyGroupPriceComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItemDefinition }

constructor TFhirChargeItemDefinition.Create;
begin
  inherited;
end;

destructor TFhirChargeItemDefinition.Destroy;
begin
  FDerivedFromUriList.Free;
  FPartOfList.Free;
  FReplacesList.Free;
  FCode.free;
  FInstanceList.Free;
  FApplicabilityList.Free;
  FPropertyGroupList.Free;
  inherited;
end;

procedure TFhirChargeItemDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItemDefinition(oSource).FDerivedFromUriList = nil) then
  begin
    FDerivedFromUriList.free;
    FDerivedFromUriList := nil;
  end
  else
  begin
    if FDerivedFromUriList = nil then
      FDerivedFromUriList := TFhirUriList.Create;
    FDerivedFromUriList.Assign(TFhirChargeItemDefinition(oSource).FDerivedFromUriList);
  end;
  if (TFhirChargeItemDefinition(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirCanonicalList.Create;
    FPartOfList.Assign(TFhirChargeItemDefinition(oSource).FPartOfList);
  end;
  if (TFhirChargeItemDefinition(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirCanonicalList.Create;
    FReplacesList.Assign(TFhirChargeItemDefinition(oSource).FReplacesList);
  end;
  code := TFhirChargeItemDefinition(oSource).code.Clone;
  if (TFhirChargeItemDefinition(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirReferenceList.Create;
    FInstanceList.Assign(TFhirChargeItemDefinition(oSource).FInstanceList);
  end;
  if (TFhirChargeItemDefinition(oSource).FApplicabilityList = nil) then
  begin
    FApplicabilityList.free;
    FApplicabilityList := nil;
  end
  else
  begin
    if FApplicabilityList = nil then
      FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
    FApplicabilityList.Assign(TFhirChargeItemDefinition(oSource).FApplicabilityList);
  end;
  if (TFhirChargeItemDefinition(oSource).FPropertyGroupList = nil) then
  begin
    FPropertyGroupList.free;
    FPropertyGroupList := nil;
  end
  else
  begin
    if FPropertyGroupList = nil then
      FPropertyGroupList := TFhirChargeItemDefinitionPropertyGroupList.Create;
    FPropertyGroupList.Assign(TFhirChargeItemDefinition(oSource).FPropertyGroupList);
  end;
end;

function TFhirChargeItemDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItemDefinition;
end;

procedure TFhirChargeItemDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'derivedFromUri') Then
    list.addAll(self, 'derivedFromUri', FDerivedFromUriList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'applicability') Then
    list.addAll(self, 'applicability', FApplicabilityList);
  if (child_name = 'propertyGroup') Then
    list.addAll(self, 'propertyGroup', FPropertyGroupList);
end;

procedure TFhirChargeItemDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'derivedFromUri', 'uri', true, TFhirUri, FDerivedFromUriList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'canonical', true, TFhirCanonical, FPartOfList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'replaces', 'canonical', true, TFhirCanonical, FReplacesList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'instance', 'Reference', true, TFhirReference, FInstanceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'applicability', 'BackboneElement', true, TFhirChargeItemDefinitionApplicability, FApplicabilityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'propertyGroup', 'BackboneElement', true, TFhirChargeItemDefinitionPropertyGroup, FPropertyGroupList.Link)) {L1039};
end;

function TFhirChargeItemDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'derivedFromUri') then
  begin
    DerivedFromUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'applicability') then
  begin
    ApplicabilityList.add(propValue as TFhirChargeItemDefinitionApplicability) {L1048};
    result := propValue;
  end
  else if (propName = 'propertyGroup') then
  begin
    PropertyGroupList.add(propValue as TFhirChargeItemDefinitionPropertyGroup) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'derivedFromUri') then DerivedFromUriList.insertItem(index, asUri(propValue)) {L1045}
  else if (propName = 'partOf') then PartOfList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, asCanonical(propValue)) {L1045}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'applicability') then ApplicabilityList.insertItem(index, propValue as TFhirChargeItemDefinitionApplicability) {L1049}
  else if (propName = 'propertyGroup') then PropertyGroupList.insertItem(index, propValue as TFhirChargeItemDefinitionPropertyGroup) {L1049}
  else inherited;
end;

function TFhirChargeItemDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'derivedFromUri') then result := DerivedFromUriList.new() {L1053}
  else if (propName = 'partOf') then result := PartOfList.new() {L1053}
  else if (propName = 'replaces') then result := ReplacesList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'instance') then result := InstanceList.new() {L1053}
  else if (propName = 'applicability') then result := ApplicabilityList.new() {L1053}
  else if (propName = 'propertyGroup') then result := PropertyGroupList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'derivedFromUri') then result := 'uri'
  else if (propName = 'partOf') then result := 'canonical'
  else if (propName = 'replaces') then result := 'canonical'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'instance') then result := 'Reference'
  else if (propName = 'applicability') then result := 'BackboneElement'
  else if (propName = 'propertyGroup') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'derivedFromUri') then deletePropertyValue('derivedFromUri', DerivedFromUriList, value) {L1054}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {L1054}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {L1054}
  else if (propName = 'applicability') then deletePropertyValue('applicability', ApplicabilityList, value) {L1054}
  else if (propName = 'propertyGroup') then deletePropertyValue('propertyGroup', PropertyGroupList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'derivedFromUri') then replacePropertyValue('derivedFromUri', DerivedFromUriList, existing, new) {L1055}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {L1055}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {L1055}
  else if (propName = 'applicability') then replacePropertyValue('applicability', ApplicabilityList, existing, new) {L1055}
  else if (propName = 'propertyGroup') then replacePropertyValue('propertyGroup', PropertyGroupList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'derivedFromUri') then DerivedFromUriList.move(source, destination) {L1046}
  else if (propName = 'partOf') then PartOfList.move(source, destination) {L1046}
  else if (propName = 'replaces') then ReplacesList.move(source, destination) {L1046}
  else if (propName = 'instance') then InstanceList.move(source, destination) {L1050}
  else if (propName = 'applicability') then ApplicabilityList.move(source, destination) {L1050}
  else if (propName = 'propertyGroup') then PropertyGroupList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemDefinition.fhirType : string;
begin
  result := 'ChargeItemDefinition';
end;

function TFhirChargeItemDefinition.Link : TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(inherited Link);
end;

function TFhirChargeItemDefinition.Clone : TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(inherited Clone);
end;

function TFhirChargeItemDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemDefinition)) then
    result := false
  else
  begin
    o := TFhirChargeItemDefinition(other);
    result := compareDeep(derivedFromUriList, o.derivedFromUriList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(instanceList, o.instanceList, true) and compareDeep(applicabilityList, o.applicabilityList, true) and 
      compareDeep(propertyGroupList, o.propertyGroupList, true);
  end;
end;

function TFhirChargeItemDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FderivedFromUriList) and isEmptyProp(FpartOfList) and isEmptyProp(FreplacesList) and isEmptyProp(FCode) and isEmptyProp(FinstanceList) and isEmptyProp(FapplicabilityList) and isEmptyProp(FpropertyGroupList);
end;

procedure TFhirChargeItemDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value; {L1134}
end;

function TFhirChargeItemDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirChargeItemDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirChargeItemDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirChargeItemDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value; {L1134}
end;

function TFhirChargeItemDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirChargeItemDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirChargeItemDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirChargeItemDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirChargeItemDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirChargeItemDefinition.GetDerivedFromUriList : TFhirUriList;
begin
  if FDerivedFromUriList = nil then
    FDerivedFromUriList := TFhirUriList.Create;
  result := FDerivedFromUriList;
end;

function TFhirChargeItemDefinition.GetHasDerivedFromUriList : boolean;
begin
  result := (FDerivedFromUriList <> nil) and (FDerivedFromUriList.count > 0);
end;

function TFhirChargeItemDefinition.GetPartOfList : TFhirCanonicalList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirCanonicalList.Create;
  result := FPartOfList;
end;

function TFhirChargeItemDefinition.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

function TFhirChargeItemDefinition.GetReplacesList : TFhirCanonicalList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirCanonicalList.Create;
  result := FReplacesList;
end;

function TFhirChargeItemDefinition.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirChargeItemDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirChargeItemDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirChargeItemDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value; {L1134}
end;

function TFhirChargeItemDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirChargeItemDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirChargeItemDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirChargeItemDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirChargeItemDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirChargeItemDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value; {L1134}
end;

function TFhirChargeItemDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirChargeItemDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirChargeItemDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirChargeItemDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirChargeItemDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirChargeItemDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirChargeItemDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirChargeItemDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirChargeItemDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirChargeItemDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirChargeItemDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value; {L1134}
end;

function TFhirChargeItemDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirChargeItemDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirChargeItemDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value; {L1134}
end;

function TFhirChargeItemDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirChargeItemDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirChargeItemDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value; {L1134}
end;

function TFhirChargeItemDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirChargeItemDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirChargeItemDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value; {L1134}
end;

procedure TFhirChargeItemDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

function TFhirChargeItemDefinition.GetInstanceList : TFhirReferenceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirReferenceList.Create;
  result := FInstanceList;
end;

function TFhirChargeItemDefinition.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirChargeItemDefinition.GetApplicabilityList : TFhirChargeItemDefinitionApplicabilityList;
begin
  if FApplicabilityList = nil then
    FApplicabilityList := TFhirChargeItemDefinitionApplicabilityList.Create;
  result := FApplicabilityList;
end;

function TFhirChargeItemDefinition.GetHasApplicabilityList : boolean;
begin
  result := (FApplicabilityList <> nil) and (FApplicabilityList.count > 0);
end;

function TFhirChargeItemDefinition.GetPropertyGroupList : TFhirChargeItemDefinitionPropertyGroupList;
begin
  if FPropertyGroupList = nil then
    FPropertyGroupList := TFhirChargeItemDefinitionPropertyGroupList.Create;
  result := FPropertyGroupList;
end;

function TFhirChargeItemDefinition.GetHasPropertyGroupList : boolean;
begin
  result := (FPropertyGroupList <> nil) and (FPropertyGroupList.count > 0);
end;

procedure TFhirChargeItemDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('title');
  fields.add('derivedFromUri');
  fields.add('partOf');
  fields.add('replaces');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('code');
  fields.add('instance');
  fields.add('applicability');
  fields.add('propertyGroup');
end;

function TFhirChargeItemDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FderivedFromUriList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
  inc(result, FapplicabilityList.sizeInBytes);
  inc(result, FpropertyGroupList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionListEnumerator }

constructor TFhirChargeItemDefinitionListEnumerator.Create(list : TFhirChargeItemDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemDefinitionListEnumerator.GetCurrent : TFhirChargeItemDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemDefinitionList }

procedure TFhirChargeItemDefinitionList.AddItem(value: TFhirChargeItemDefinition);
begin
  assert(value.ClassName = 'TFhirChargeItemDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemDefinition');
  add(value);
end;

function TFhirChargeItemDefinitionList.Append: TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemDefinitionList.GetEnumerator : TFhirChargeItemDefinitionListEnumerator;
begin
  result := TFhirChargeItemDefinitionListEnumerator.Create(self.link);
end;

function TFhirChargeItemDefinitionList.Clone: TFhirChargeItemDefinitionList;
begin
  result := TFhirChargeItemDefinitionList(inherited Clone);
end;

function TFhirChargeItemDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemDefinitionList.GetItemN(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemDefinition;
end;
function TFhirChargeItemDefinitionList.IndexOf(value: TFhirChargeItemDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemDefinitionList.Insert(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemDefinitionList.InsertItem(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  Inherited Insert(index, value);
end;

function TFhirChargeItemDefinitionList.Item(index: Integer): TFhirChargeItemDefinition;
begin
  result := TFhirChargeItemDefinition(ObjectByIndex[index]);
end;

function TFhirChargeItemDefinitionList.Link: TFhirChargeItemDefinitionList;
begin
  result := TFhirChargeItemDefinitionList(inherited Link);
end;

procedure TFhirChargeItemDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemDefinitionList.SetItemByIndex(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  FhirChargeItemDefinitions[index] := value;
end;

procedure TFhirChargeItemDefinitionList.SetItemN(index: Integer; value: TFhirChargeItemDefinition);
begin
  assert(value is TFhirChargeItemDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEMDEFINITION}
{$IFDEF FHIR_CITATION}
{ TFhirCitationSummary }

constructor TFhirCitationSummary.Create;
begin
  inherited;
end;

destructor TFhirCitationSummary.Destroy;
begin
  FStyle.free;
  FText.free;
  inherited;
end;

procedure TFhirCitationSummary.Assign(oSource : TFslObject);
begin
  inherited;
  style := TFhirCitationSummary(oSource).style.Clone;
  textElement := TFhirCitationSummary(oSource).textElement.Clone;
end;

procedure TFhirCitationSummary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'style') Then
     list.add(self.link, 'style', FStyle.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCitationSummary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'style', 'CodeableConcept', false, TFhirCodeableConcept, FStyle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'text', 'markdown', false, TFhirMarkdown, FText.Link)); {L1172}
end;

function TFhirCitationSummary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'style') then
  begin
    Style := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationSummary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationSummary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'style') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'text') then result := TFhirMarkdown.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationSummary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'style') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationSummary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'style') then StyleElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationSummary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'style') then StyleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'text') then TextElement := asMarkdown(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationSummary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationSummary.fhirType : string;
begin
  result := 'Citation.summary';
end;

function TFhirCitationSummary.Link : TFhirCitationSummary;
begin
  result := TFhirCitationSummary(inherited Link);
end;

function TFhirCitationSummary.Clone : TFhirCitationSummary;
begin
  result := TFhirCitationSummary(inherited Clone);
end;

function TFhirCitationSummary.equals(other : TObject) : boolean; 
var
  o : TFhirCitationSummary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationSummary)) then
    result := false
  else
  begin
    o := TFhirCitationSummary(other);
    result := compareDeep(styleElement, o.styleElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCitationSummary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStyle) and isEmptyProp(FText);
end;

procedure TFhirCitationSummary.SetStyle(value : TFhirCodeableConcept);
begin
  FStyle.free;
  FStyle := value; {L1134}
end;

procedure TFhirCitationSummary.SetText(value : TFhirMarkdown);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirCitationSummary.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationSummary.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirMarkdown.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirCitationSummary.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('style');
  fields.add('text');
end;

function TFhirCitationSummary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStyle.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirCitationSummaryListEnumerator }

constructor TFhirCitationSummaryListEnumerator.Create(list : TFhirCitationSummaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationSummaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationSummaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationSummaryListEnumerator.GetCurrent : TFhirCitationSummary;
begin
  Result := FList[FIndex];
end;

function TFhirCitationSummaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationSummaryList }

procedure TFhirCitationSummaryList.AddItem(value: TFhirCitationSummary);
begin
  assert(value.ClassName = 'TFhirCitationSummary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationSummary');
  add(value);
end;

function TFhirCitationSummaryList.Append: TFhirCitationSummary;
begin
  result := TFhirCitationSummary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationSummaryList.ClearItems;
begin
  Clear;
end;

function TFhirCitationSummaryList.GetEnumerator : TFhirCitationSummaryListEnumerator;
begin
  result := TFhirCitationSummaryListEnumerator.Create(self.link);
end;

function TFhirCitationSummaryList.Clone: TFhirCitationSummaryList;
begin
  result := TFhirCitationSummaryList(inherited Clone);
end;

function TFhirCitationSummaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationSummaryList.GetItemN(index: Integer): TFhirCitationSummary;
begin
  result := TFhirCitationSummary(ObjectByIndex[index]);
end;

function TFhirCitationSummaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationSummary;
end;
function TFhirCitationSummaryList.IndexOf(value: TFhirCitationSummary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationSummaryList.Insert(index: Integer): TFhirCitationSummary;
begin
  result := TFhirCitationSummary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationSummaryList.InsertItem(index: Integer; value: TFhirCitationSummary);
begin
  assert(value is TFhirCitationSummary);
  Inherited Insert(index, value);
end;

function TFhirCitationSummaryList.Item(index: Integer): TFhirCitationSummary;
begin
  result := TFhirCitationSummary(ObjectByIndex[index]);
end;

function TFhirCitationSummaryList.Link: TFhirCitationSummaryList;
begin
  result := TFhirCitationSummaryList(inherited Link);
end;

procedure TFhirCitationSummaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationSummaryList.SetItemByIndex(index: Integer; value: TFhirCitationSummary);
begin
  assert(value is TFhirCitationSummary);
  FhirCitationSummaries[index] := value;
end;

procedure TFhirCitationSummaryList.SetItemN(index: Integer; value: TFhirCitationSummary);
begin
  assert(value is TFhirCitationSummary);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationVariantCitation }

constructor TFhirCitationVariantCitation.Create;
begin
  inherited;
end;

destructor TFhirCitationVariantCitation.Destroy;
begin
  FType_.free;
  FValue.free;
  FBaseCitation.free;
  inherited;
end;

procedure TFhirCitationVariantCitation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationVariantCitation(oSource).type_.Clone;
  valueElement := TFhirCitationVariantCitation(oSource).valueElement.Clone;
  baseCitation := TFhirCitationVariantCitation(oSource).baseCitation.Clone;
end;

procedure TFhirCitationVariantCitation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'baseCitation') Then
     list.add(self.link, 'baseCitation', FBaseCitation.Link);
end;

procedure TFhirCitationVariantCitation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'baseCitation', 'Reference', false, TFhirReference, FBaseCitation.Link)); {L1172}
end;

function TFhirCitationVariantCitation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'baseCitation') then
  begin
    BaseCitation := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationVariantCitation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationVariantCitation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'value') then result := TFhirString.create() {L1223}
  else if (propName = 'baseCitation') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationVariantCitation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'baseCitation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationVariantCitation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'baseCitation') then BaseCitationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationVariantCitation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'value') then ValueElement := asString(new) {L1222}
  else if (propName = 'baseCitation') then BaseCitationElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationVariantCitation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationVariantCitation.fhirType : string;
begin
  result := 'Citation.variantCitation';
end;

function TFhirCitationVariantCitation.Link : TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation(inherited Link);
end;

function TFhirCitationVariantCitation.Clone : TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation(inherited Clone);
end;

function TFhirCitationVariantCitation.equals(other : TObject) : boolean; 
var
  o : TFhirCitationVariantCitation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationVariantCitation)) then
    result := false
  else
  begin
    o := TFhirCitationVariantCitation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(baseCitationElement, o.baseCitationElement, true);
  end;
end;

function TFhirCitationVariantCitation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FBaseCitation);
end;

procedure TFhirCitationVariantCitation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationVariantCitation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirCitationVariantCitation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationVariantCitation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCitationVariantCitation.SetBaseCitation(value : TFhirReference);
begin
  FBaseCitation.free;
  FBaseCitation := value; {L1134}
end;

procedure TFhirCitationVariantCitation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('baseCitation');
end;

function TFhirCitationVariantCitation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FBaseCitation.sizeInBytes);
end;

{ TFhirCitationVariantCitationListEnumerator }

constructor TFhirCitationVariantCitationListEnumerator.Create(list : TFhirCitationVariantCitationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationVariantCitationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationVariantCitationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationVariantCitationListEnumerator.GetCurrent : TFhirCitationVariantCitation;
begin
  Result := FList[FIndex];
end;

function TFhirCitationVariantCitationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationVariantCitationList }

procedure TFhirCitationVariantCitationList.AddItem(value: TFhirCitationVariantCitation);
begin
  assert(value.ClassName = 'TFhirCitationVariantCitation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationVariantCitation');
  add(value);
end;

function TFhirCitationVariantCitationList.Append: TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationVariantCitationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationVariantCitationList.GetEnumerator : TFhirCitationVariantCitationListEnumerator;
begin
  result := TFhirCitationVariantCitationListEnumerator.Create(self.link);
end;

function TFhirCitationVariantCitationList.Clone: TFhirCitationVariantCitationList;
begin
  result := TFhirCitationVariantCitationList(inherited Clone);
end;

function TFhirCitationVariantCitationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationVariantCitationList.GetItemN(index: Integer): TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation(ObjectByIndex[index]);
end;

function TFhirCitationVariantCitationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationVariantCitation;
end;
function TFhirCitationVariantCitationList.IndexOf(value: TFhirCitationVariantCitation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationVariantCitationList.Insert(index: Integer): TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationVariantCitationList.InsertItem(index: Integer; value: TFhirCitationVariantCitation);
begin
  assert(value is TFhirCitationVariantCitation);
  Inherited Insert(index, value);
end;

function TFhirCitationVariantCitationList.Item(index: Integer): TFhirCitationVariantCitation;
begin
  result := TFhirCitationVariantCitation(ObjectByIndex[index]);
end;

function TFhirCitationVariantCitationList.Link: TFhirCitationVariantCitationList;
begin
  result := TFhirCitationVariantCitationList(inherited Link);
end;

procedure TFhirCitationVariantCitationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationVariantCitationList.SetItemByIndex(index: Integer; value: TFhirCitationVariantCitation);
begin
  assert(value is TFhirCitationVariantCitation);
  FhirCitationVariantCitations[index] := value;
end;

procedure TFhirCitationVariantCitationList.SetItemN(index: Integer; value: TFhirCitationVariantCitation);
begin
  assert(value is TFhirCitationVariantCitation);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationJournal }

constructor TFhirCitationJournal.Create;
begin
  inherited;
end;

destructor TFhirCitationJournal.Destroy;
begin
  FIdentifierList.Free;
  FCountry.free;
  FJournalIssue.free;
  FTitle.free;
  inherited;
end;

procedure TFhirCitationJournal.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCitationJournal(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationJournal(oSource).FIdentifierList);
  end;
  countryElement := TFhirCitationJournal(oSource).countryElement.Clone;
  journalIssue := TFhirCitationJournal(oSource).journalIssue.Clone;
  titleElement := TFhirCitationJournal(oSource).titleElement.Clone;
end;

procedure TFhirCitationJournal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'journalIssue') Then
     list.add(self.link, 'journalIssue', FJournalIssue.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
end;

procedure TFhirCitationJournal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'country', 'string', false, TFhirString, FCountry.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'journalIssue', 'BackboneElement', false, TFhirCitationJournalJournalIssue, FJournalIssue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link)); {L1172}
end;

function TFhirCitationJournal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'journalIssue') then
  begin
    JournalIssue := propValue as TFhirCitationJournalJournalIssue {L1199};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationJournal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirCitationJournal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'country') then result := TFhirString.create() {L1223}
  else if (propName = 'journalIssue') then result := TFhirCitationJournalJournalIssue.create() {L1203}
  else if (propName = 'title') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationJournal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'country') then result := 'string'
  else if (propName = 'journalIssue') then result := 'BackboneElement'
  else if (propName = 'title') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationJournal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'country') then CountryElement := nil
  else if (propName = 'journalIssue') then JournalIssueElement := nil
  else if (propName = 'title') then TitleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationJournal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'country') then CountryElement := asString(new) {L1222}
  else if (propName = 'journalIssue') then JournalIssueElement := new as TFhirCitationJournalJournalIssue {L1195}
  else if (propName = 'title') then TitleElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationJournal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationJournal.fhirType : string;
begin
  result := 'Citation.journal';
end;

function TFhirCitationJournal.Link : TFhirCitationJournal;
begin
  result := TFhirCitationJournal(inherited Link);
end;

function TFhirCitationJournal.Clone : TFhirCitationJournal;
begin
  result := TFhirCitationJournal(inherited Clone);
end;

function TFhirCitationJournal.equals(other : TObject) : boolean; 
var
  o : TFhirCitationJournal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationJournal)) then
    result := false
  else
  begin
    o := TFhirCitationJournal(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(countryElement, o.countryElement, true) and 
      compareDeep(journalIssueElement, o.journalIssueElement, true) and compareDeep(titleElement, o.titleElement, true);
  end;
end;

function TFhirCitationJournal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCountry) and isEmptyProp(FJournalIssue) and isEmptyProp(FTitle);
end;

function TFhirCitationJournal.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationJournal.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitationJournal.SetCountry(value : TFhirString);
begin
  FCountry.free;
  FCountry := value; {L1134}
end;

function TFhirCitationJournal.GetCountryST : String;
begin
  if FCountry = nil then
    result := ''
  else
    result := FCountry.value;
end;

procedure TFhirCitationJournal.SetCountryST(value : String);
begin
  if value <> '' then
  begin
    if FCountry = nil then
      FCountry := TFhirString.create;
    FCountry.value := value
  end
  else if FCountry <> nil then
    FCountry.value := '';
end;

procedure TFhirCitationJournal.SetJournalIssue(value : TFhirCitationJournalJournalIssue);
begin
  FJournalIssue.free;
  FJournalIssue := value; {L1134}
end;

procedure TFhirCitationJournal.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirCitationJournal.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCitationJournal.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCitationJournal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('country');
  fields.add('journalIssue');
  fields.add('title');
end;

function TFhirCitationJournal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCountry.sizeInBytes);
  inc(result, FJournalIssue.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
end;

{ TFhirCitationJournalListEnumerator }

constructor TFhirCitationJournalListEnumerator.Create(list : TFhirCitationJournalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationJournalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationJournalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationJournalListEnumerator.GetCurrent : TFhirCitationJournal;
begin
  Result := FList[FIndex];
end;

function TFhirCitationJournalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationJournalList }

procedure TFhirCitationJournalList.AddItem(value: TFhirCitationJournal);
begin
  assert(value.ClassName = 'TFhirCitationJournal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationJournal');
  add(value);
end;

function TFhirCitationJournalList.Append: TFhirCitationJournal;
begin
  result := TFhirCitationJournal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalList.ClearItems;
begin
  Clear;
end;

function TFhirCitationJournalList.GetEnumerator : TFhirCitationJournalListEnumerator;
begin
  result := TFhirCitationJournalListEnumerator.Create(self.link);
end;

function TFhirCitationJournalList.Clone: TFhirCitationJournalList;
begin
  result := TFhirCitationJournalList(inherited Clone);
end;

function TFhirCitationJournalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationJournalList.GetItemN(index: Integer): TFhirCitationJournal;
begin
  result := TFhirCitationJournal(ObjectByIndex[index]);
end;

function TFhirCitationJournalList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationJournal;
end;
function TFhirCitationJournalList.IndexOf(value: TFhirCitationJournal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationJournalList.Insert(index: Integer): TFhirCitationJournal;
begin
  result := TFhirCitationJournal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalList.InsertItem(index: Integer; value: TFhirCitationJournal);
begin
  assert(value is TFhirCitationJournal);
  Inherited Insert(index, value);
end;

function TFhirCitationJournalList.Item(index: Integer): TFhirCitationJournal;
begin
  result := TFhirCitationJournal(ObjectByIndex[index]);
end;

function TFhirCitationJournalList.Link: TFhirCitationJournalList;
begin
  result := TFhirCitationJournalList(inherited Link);
end;

procedure TFhirCitationJournalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationJournalList.SetItemByIndex(index: Integer; value: TFhirCitationJournal);
begin
  assert(value is TFhirCitationJournal);
  FhirCitationJournals[index] := value;
end;

procedure TFhirCitationJournalList.SetItemN(index: Integer; value: TFhirCitationJournal);
begin
  assert(value is TFhirCitationJournal);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationJournalJournalIssue }

constructor TFhirCitationJournalJournalIssue.Create;
begin
  inherited;
end;

destructor TFhirCitationJournalJournalIssue.Destroy;
begin
  FCitedMedium.free;
  FVolume.free;
  FIssue.free;
  FPublicationDate.free;
  inherited;
end;

procedure TFhirCitationJournalJournalIssue.Assign(oSource : TFslObject);
begin
  inherited;
  citedMedium := TFhirCitationJournalJournalIssue(oSource).citedMedium.Clone;
  volumeElement := TFhirCitationJournalJournalIssue(oSource).volumeElement.Clone;
  issueElement := TFhirCitationJournalJournalIssue(oSource).issueElement.Clone;
  publicationDate := TFhirCitationJournalJournalIssue(oSource).publicationDate.Clone;
end;

procedure TFhirCitationJournalJournalIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'citedMedium') Then
     list.add(self.link, 'citedMedium', FCitedMedium.Link);
  if (child_name = 'volume') Then
     list.add(self.link, 'volume', FVolume.Link);
  if (child_name = 'issue') Then
     list.add(self.link, 'issue', FIssue.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
end;

procedure TFhirCitationJournalJournalIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'citedMedium', 'CodeableConcept', false, TFhirCodeableConcept, FCitedMedium.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'volume', 'string', false, TFhirString, FVolume.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issue', 'string', false, TFhirString, FIssue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'BackboneElement', false, TFhirCitationJournalJournalIssuePublicationDate, FPublicationDate.Link)); {L1172}
end;

function TFhirCitationJournalJournalIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'citedMedium') then
  begin
    CitedMedium := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'volume') then
  begin
    VolumeElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'issue') then
  begin
    IssueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDate := propValue as TFhirCitationJournalJournalIssuePublicationDate {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationJournalJournalIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationJournalJournalIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'citedMedium') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'volume') then result := TFhirString.create() {L1223}
  else if (propName = 'issue') then result := TFhirString.create() {L1223}
  else if (propName = 'publicationDate') then result := TFhirCitationJournalJournalIssuePublicationDate.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationJournalJournalIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'citedMedium') then result := 'CodeableConcept'
  else if (propName = 'volume') then result := 'string'
  else if (propName = 'issue') then result := 'string'
  else if (propName = 'publicationDate') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationJournalJournalIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := nil
  else if (propName = 'volume') then VolumeElement := nil
  else if (propName = 'issue') then IssueElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationJournalJournalIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'volume') then VolumeElement := asString(new) {L1222}
  else if (propName = 'issue') then IssueElement := asString(new) {L1222}
  else if (propName = 'publicationDate') then PublicationDateElement := new as TFhirCitationJournalJournalIssuePublicationDate {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationJournalJournalIssue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationJournalJournalIssue.fhirType : string;
begin
  result := 'Citation.journal.journalIssue';
end;

function TFhirCitationJournalJournalIssue.Link : TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue(inherited Link);
end;

function TFhirCitationJournalJournalIssue.Clone : TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue(inherited Clone);
end;

function TFhirCitationJournalJournalIssue.equals(other : TObject) : boolean; 
var
  o : TFhirCitationJournalJournalIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationJournalJournalIssue)) then
    result := false
  else
  begin
    o := TFhirCitationJournalJournalIssue(other);
    result := compareDeep(citedMediumElement, o.citedMediumElement, true) and compareDeep(volumeElement, o.volumeElement, true) and 
      compareDeep(issueElement, o.issueElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true);
  end;
end;

function TFhirCitationJournalJournalIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCitedMedium) and isEmptyProp(FVolume) and isEmptyProp(FIssue) and isEmptyProp(FPublicationDate);
end;

procedure TFhirCitationJournalJournalIssue.SetCitedMedium(value : TFhirCodeableConcept);
begin
  FCitedMedium.free;
  FCitedMedium := value; {L1134}
end;

procedure TFhirCitationJournalJournalIssue.SetVolume(value : TFhirString);
begin
  FVolume.free;
  FVolume := value; {L1134}
end;

function TFhirCitationJournalJournalIssue.GetVolumeST : String;
begin
  if FVolume = nil then
    result := ''
  else
    result := FVolume.value;
end;

procedure TFhirCitationJournalJournalIssue.SetVolumeST(value : String);
begin
  if value <> '' then
  begin
    if FVolume = nil then
      FVolume := TFhirString.create;
    FVolume.value := value
  end
  else if FVolume <> nil then
    FVolume.value := '';
end;

procedure TFhirCitationJournalJournalIssue.SetIssue(value : TFhirString);
begin
  FIssue.free;
  FIssue := value; {L1134}
end;

function TFhirCitationJournalJournalIssue.GetIssueST : String;
begin
  if FIssue = nil then
    result := ''
  else
    result := FIssue.value;
end;

procedure TFhirCitationJournalJournalIssue.SetIssueST(value : String);
begin
  if value <> '' then
  begin
    if FIssue = nil then
      FIssue := TFhirString.create;
    FIssue.value := value
  end
  else if FIssue <> nil then
    FIssue.value := '';
end;

procedure TFhirCitationJournalJournalIssue.SetPublicationDate(value : TFhirCitationJournalJournalIssuePublicationDate);
begin
  FPublicationDate.free;
  FPublicationDate := value; {L1134}
end;

procedure TFhirCitationJournalJournalIssue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('citedMedium');
  fields.add('volume');
  fields.add('issue');
  fields.add('publicationDate');
end;

function TFhirCitationJournalJournalIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCitedMedium.sizeInBytes);
  inc(result, FVolume.sizeInBytes);
  inc(result, FIssue.sizeInBytes);
  inc(result, FPublicationDate.sizeInBytes);
end;

{ TFhirCitationJournalJournalIssueListEnumerator }

constructor TFhirCitationJournalJournalIssueListEnumerator.Create(list : TFhirCitationJournalJournalIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationJournalJournalIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationJournalJournalIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationJournalJournalIssueListEnumerator.GetCurrent : TFhirCitationJournalJournalIssue;
begin
  Result := FList[FIndex];
end;

function TFhirCitationJournalJournalIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationJournalJournalIssueList }

procedure TFhirCitationJournalJournalIssueList.AddItem(value: TFhirCitationJournalJournalIssue);
begin
  assert(value.ClassName = 'TFhirCitationJournalJournalIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationJournalJournalIssue');
  add(value);
end;

function TFhirCitationJournalJournalIssueList.Append: TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalJournalIssueList.ClearItems;
begin
  Clear;
end;

function TFhirCitationJournalJournalIssueList.GetEnumerator : TFhirCitationJournalJournalIssueListEnumerator;
begin
  result := TFhirCitationJournalJournalIssueListEnumerator.Create(self.link);
end;

function TFhirCitationJournalJournalIssueList.Clone: TFhirCitationJournalJournalIssueList;
begin
  result := TFhirCitationJournalJournalIssueList(inherited Clone);
end;

function TFhirCitationJournalJournalIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationJournalJournalIssueList.GetItemN(index: Integer): TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue(ObjectByIndex[index]);
end;

function TFhirCitationJournalJournalIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationJournalJournalIssue;
end;
function TFhirCitationJournalJournalIssueList.IndexOf(value: TFhirCitationJournalJournalIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationJournalJournalIssueList.Insert(index: Integer): TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalJournalIssueList.InsertItem(index: Integer; value: TFhirCitationJournalJournalIssue);
begin
  assert(value is TFhirCitationJournalJournalIssue);
  Inherited Insert(index, value);
end;

function TFhirCitationJournalJournalIssueList.Item(index: Integer): TFhirCitationJournalJournalIssue;
begin
  result := TFhirCitationJournalJournalIssue(ObjectByIndex[index]);
end;

function TFhirCitationJournalJournalIssueList.Link: TFhirCitationJournalJournalIssueList;
begin
  result := TFhirCitationJournalJournalIssueList(inherited Link);
end;

procedure TFhirCitationJournalJournalIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationJournalJournalIssueList.SetItemByIndex(index: Integer; value: TFhirCitationJournalJournalIssue);
begin
  assert(value is TFhirCitationJournalJournalIssue);
  FhirCitationJournalJournalIssues[index] := value;
end;

procedure TFhirCitationJournalJournalIssueList.SetItemN(index: Integer; value: TFhirCitationJournalJournalIssue);
begin
  assert(value is TFhirCitationJournalJournalIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationJournalJournalIssuePublicationDate }

constructor TFhirCitationJournalJournalIssuePublicationDate.Create;
begin
  inherited;
end;

destructor TFhirCitationJournalJournalIssuePublicationDate.Destroy;
begin
  FDate.free;
  FYear.free;
  FMonth.free;
  FDay.free;
  FSeason.free;
  FText.free;
  inherited;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).dateElement.Clone;
  yearElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).yearElement.Clone;
  monthElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).monthElement.Clone;
  dayElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).dayElement.Clone;
  seasonElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).seasonElement.Clone;
  textElement := TFhirCitationJournalJournalIssuePublicationDate(oSource).textElement.Clone;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'year') Then
     list.add(self.link, 'year', FYear.Link);
  if (child_name = 'month') Then
     list.add(self.link, 'month', FMonth.Link);
  if (child_name = 'day') Then
     list.add(self.link, 'day', FDay.Link);
  if (child_name = 'season') Then
     list.add(self.link, 'season', FSeason.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'year', 'string', false, TFhirString, FYear.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'month', 'string', false, TFhirString, FMonth.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'day', 'string', false, TFhirString, FDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'season', 'string', false, TFhirString, FSeason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
end;

function TFhirCitationJournalJournalIssuePublicationDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'year') then
  begin
    YearElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'month') then
  begin
    MonthElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'day') then
  begin
    DayElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'season') then
  begin
    SeasonElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationJournalJournalIssuePublicationDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'year') then result := TFhirString.create() {L1223}
  else if (propName = 'month') then result := TFhirString.create() {L1223}
  else if (propName = 'day') then result := TFhirString.create() {L1223}
  else if (propName = 'season') then result := TFhirString.create() {L1223}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationJournalJournalIssuePublicationDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'year') then result := 'string'
  else if (propName = 'month') then result := 'string'
  else if (propName = 'day') then result := 'string'
  else if (propName = 'season') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'year') then YearElement := nil
  else if (propName = 'month') then MonthElement := nil
  else if (propName = 'day') then DayElement := nil
  else if (propName = 'season') then SeasonElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'year') then YearElement := asString(new) {L1222}
  else if (propName = 'month') then MonthElement := asString(new) {L1222}
  else if (propName = 'day') then DayElement := asString(new) {L1222}
  else if (propName = 'season') then SeasonElement := asString(new) {L1222}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationJournalJournalIssuePublicationDate.fhirType : string;
begin
  result := 'Citation.journal.journalIssue.publicationDate';
end;

function TFhirCitationJournalJournalIssuePublicationDate.Link : TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate(inherited Link);
end;

function TFhirCitationJournalJournalIssuePublicationDate.Clone : TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate(inherited Clone);
end;

function TFhirCitationJournalJournalIssuePublicationDate.equals(other : TObject) : boolean; 
var
  o : TFhirCitationJournalJournalIssuePublicationDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationJournalJournalIssuePublicationDate)) then
    result := false
  else
  begin
    o := TFhirCitationJournalJournalIssuePublicationDate(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(yearElement, o.yearElement, true) and 
      compareDeep(monthElement, o.monthElement, true) and compareDeep(dayElement, o.dayElement, true) and 
      compareDeep(seasonElement, o.seasonElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCitationJournalJournalIssuePublicationDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FYear) and isEmptyProp(FMonth) and isEmptyProp(FDay) and isEmptyProp(FSeason) and isEmptyProp(FText);
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetYear(value : TFhirString);
begin
  FYear.free;
  FYear := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetYearST : String;
begin
  if FYear = nil then
    result := ''
  else
    result := FYear.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetYearST(value : String);
begin
  if value <> '' then
  begin
    if FYear = nil then
      FYear := TFhirString.create;
    FYear.value := value
  end
  else if FYear <> nil then
    FYear.value := '';
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetMonth(value : TFhirString);
begin
  FMonth.free;
  FMonth := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetMonthST : String;
begin
  if FMonth = nil then
    result := ''
  else
    result := FMonth.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetMonthST(value : String);
begin
  if value <> '' then
  begin
    if FMonth = nil then
      FMonth := TFhirString.create;
    FMonth.value := value
  end
  else if FMonth <> nil then
    FMonth.value := '';
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetDay(value : TFhirString);
begin
  FDay.free;
  FDay := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetDayST : String;
begin
  if FDay = nil then
    result := ''
  else
    result := FDay.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetDayST(value : String);
begin
  if value <> '' then
  begin
    if FDay = nil then
      FDay := TFhirString.create;
    FDay.value := value
  end
  else if FDay <> nil then
    FDay.value := '';
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetSeason(value : TFhirString);
begin
  FSeason.free;
  FSeason := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetSeasonST : String;
begin
  if FSeason = nil then
    result := ''
  else
    result := FSeason.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetSeasonST(value : String);
begin
  if value <> '' then
  begin
    if FSeason = nil then
      FSeason := TFhirString.create;
    FSeason.value := value
  end
  else if FSeason <> nil then
    FSeason.value := '';
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirCitationJournalJournalIssuePublicationDate.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirCitationJournalJournalIssuePublicationDate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('year');
  fields.add('month');
  fields.add('day');
  fields.add('season');
  fields.add('text');
end;

function TFhirCitationJournalJournalIssuePublicationDate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FYear.sizeInBytes);
  inc(result, FMonth.sizeInBytes);
  inc(result, FDay.sizeInBytes);
  inc(result, FSeason.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirCitationJournalJournalIssuePublicationDateListEnumerator }

constructor TFhirCitationJournalJournalIssuePublicationDateListEnumerator.Create(list : TFhirCitationJournalJournalIssuePublicationDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationJournalJournalIssuePublicationDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationJournalJournalIssuePublicationDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationJournalJournalIssuePublicationDateListEnumerator.GetCurrent : TFhirCitationJournalJournalIssuePublicationDate;
begin
  Result := FList[FIndex];
end;

function TFhirCitationJournalJournalIssuePublicationDateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationJournalJournalIssuePublicationDateList }

procedure TFhirCitationJournalJournalIssuePublicationDateList.AddItem(value: TFhirCitationJournalJournalIssuePublicationDate);
begin
  assert(value.ClassName = 'TFhirCitationJournalJournalIssuePublicationDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationJournalJournalIssuePublicationDate');
  add(value);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Append: TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalJournalIssuePublicationDateList.ClearItems;
begin
  Clear;
end;

function TFhirCitationJournalJournalIssuePublicationDateList.GetEnumerator : TFhirCitationJournalJournalIssuePublicationDateListEnumerator;
begin
  result := TFhirCitationJournalJournalIssuePublicationDateListEnumerator.Create(self.link);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Clone: TFhirCitationJournalJournalIssuePublicationDateList;
begin
  result := TFhirCitationJournalJournalIssuePublicationDateList(inherited Clone);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationJournalJournalIssuePublicationDateList.GetItemN(index: Integer): TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate(ObjectByIndex[index]);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate;
end;
function TFhirCitationJournalJournalIssuePublicationDateList.IndexOf(value: TFhirCitationJournalJournalIssuePublicationDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Insert(index: Integer): TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationJournalJournalIssuePublicationDateList.InsertItem(index: Integer; value: TFhirCitationJournalJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationJournalJournalIssuePublicationDate);
  Inherited Insert(index, value);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Item(index: Integer): TFhirCitationJournalJournalIssuePublicationDate;
begin
  result := TFhirCitationJournalJournalIssuePublicationDate(ObjectByIndex[index]);
end;

function TFhirCitationJournalJournalIssuePublicationDateList.Link: TFhirCitationJournalJournalIssuePublicationDateList;
begin
  result := TFhirCitationJournalJournalIssuePublicationDateList(inherited Link);
end;

procedure TFhirCitationJournalJournalIssuePublicationDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationJournalJournalIssuePublicationDateList.SetItemByIndex(index: Integer; value: TFhirCitationJournalJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationJournalJournalIssuePublicationDate);
  FhirCitationJournalJournalIssuePublicationDates[index] := value;
end;

procedure TFhirCitationJournalJournalIssuePublicationDateList.SetItemN(index: Integer; value: TFhirCitationJournalJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationJournalJournalIssuePublicationDate);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationPublicationInfo }

constructor TFhirCitationPublicationInfo.Create;
begin
  inherited;
end;

destructor TFhirCitationPublicationInfo.Destroy;
begin
  FPublishedIn.free;
  FEntryDate.free;
  FRevisionDate.free;
  FPageCount.free;
  inherited;
end;

procedure TFhirCitationPublicationInfo.Assign(oSource : TFslObject);
begin
  inherited;
  publishedIn := TFhirCitationPublicationInfo(oSource).publishedIn.Clone;
  entryDateElement := TFhirCitationPublicationInfo(oSource).entryDateElement.Clone;
  revisionDateElement := TFhirCitationPublicationInfo(oSource).revisionDateElement.Clone;
  pageCountElement := TFhirCitationPublicationInfo(oSource).pageCountElement.Clone;
end;

procedure TFhirCitationPublicationInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'publishedIn') Then
     list.add(self.link, 'publishedIn', FPublishedIn.Link);
  if (child_name = 'entryDate') Then
     list.add(self.link, 'entryDate', FEntryDate.Link);
  if (child_name = 'revisionDate') Then
     list.add(self.link, 'revisionDate', FRevisionDate.Link);
  if (child_name = 'pageCount') Then
     list.add(self.link, 'pageCount', FPageCount.Link);
end;

procedure TFhirCitationPublicationInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'publishedIn', 'BackboneElement', false, TFhirCitationPublicationInfoPublishedIn, FPublishedIn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entryDate', 'dateTime', false, TFhirDateTime, FEntryDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revisionDate', 'dateTime', false, TFhirDateTime, FRevisionDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pageCount', 'string', false, TFhirString, FPageCount.Link)); {L1172}
end;

function TFhirCitationPublicationInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'publishedIn') then
  begin
    PublishedIn := propValue as TFhirCitationPublicationInfoPublishedIn {L1199};
    result := propValue;
  end
  else if (propName = 'entryDate') then
  begin
    EntryDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revisionDate') then
  begin
    RevisionDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'pageCount') then
  begin
    PageCountElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationPublicationInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationPublicationInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'publishedIn') then result := TFhirCitationPublicationInfoPublishedIn.create() {L1203}
  else if (propName = 'entryDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'revisionDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'pageCount') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationPublicationInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'publishedIn') then result := 'BackboneElement'
  else if (propName = 'entryDate') then result := 'dateTime'
  else if (propName = 'revisionDate') then result := 'dateTime'
  else if (propName = 'pageCount') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationPublicationInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := nil
  else if (propName = 'entryDate') then EntryDateElement := nil
  else if (propName = 'revisionDate') then RevisionDateElement := nil
  else if (propName = 'pageCount') then PageCountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationPublicationInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := new as TFhirCitationPublicationInfoPublishedIn {L1195}
  else if (propName = 'entryDate') then EntryDateElement := asDateTime(new) {L1222}
  else if (propName = 'revisionDate') then RevisionDateElement := asDateTime(new) {L1222}
  else if (propName = 'pageCount') then PageCountElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationPublicationInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationPublicationInfo.fhirType : string;
begin
  result := 'Citation.publicationInfo';
end;

function TFhirCitationPublicationInfo.Link : TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo(inherited Link);
end;

function TFhirCitationPublicationInfo.Clone : TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo(inherited Clone);
end;

function TFhirCitationPublicationInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationPublicationInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationPublicationInfo)) then
    result := false
  else
  begin
    o := TFhirCitationPublicationInfo(other);
    result := compareDeep(publishedInElement, o.publishedInElement, true) and compareDeep(entryDateElement, o.entryDateElement, true) and 
      compareDeep(revisionDateElement, o.revisionDateElement, true) and compareDeep(pageCountElement, o.pageCountElement, true);
  end;
end;

function TFhirCitationPublicationInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPublishedIn) and isEmptyProp(FEntryDate) and isEmptyProp(FRevisionDate) and isEmptyProp(FPageCount);
end;

procedure TFhirCitationPublicationInfo.SetPublishedIn(value : TFhirCitationPublicationInfoPublishedIn);
begin
  FPublishedIn.free;
  FPublishedIn := value; {L1134}
end;

procedure TFhirCitationPublicationInfo.SetEntryDate(value : TFhirDateTime);
begin
  FEntryDate.free;
  FEntryDate := value; {L1134}
end;

function TFhirCitationPublicationInfo.GetEntryDateST : TFslDateTime;
begin
  if FEntryDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEntryDate.value;
end;

procedure TFhirCitationPublicationInfo.SetEntryDateST(value : TFslDateTime);
begin
  if FEntryDate = nil then
    FEntryDate := TFhirDateTime.create;
  FEntryDate.value := value
end;

procedure TFhirCitationPublicationInfo.SetRevisionDate(value : TFhirDateTime);
begin
  FRevisionDate.free;
  FRevisionDate := value; {L1134}
end;

function TFhirCitationPublicationInfo.GetRevisionDateST : TFslDateTime;
begin
  if FRevisionDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRevisionDate.value;
end;

procedure TFhirCitationPublicationInfo.SetRevisionDateST(value : TFslDateTime);
begin
  if FRevisionDate = nil then
    FRevisionDate := TFhirDateTime.create;
  FRevisionDate.value := value
end;

procedure TFhirCitationPublicationInfo.SetPageCount(value : TFhirString);
begin
  FPageCount.free;
  FPageCount := value; {L1134}
end;

function TFhirCitationPublicationInfo.GetPageCountST : String;
begin
  if FPageCount = nil then
    result := ''
  else
    result := FPageCount.value;
end;

procedure TFhirCitationPublicationInfo.SetPageCountST(value : String);
begin
  if value <> '' then
  begin
    if FPageCount = nil then
      FPageCount := TFhirString.create;
    FPageCount.value := value
  end
  else if FPageCount <> nil then
    FPageCount.value := '';
end;

procedure TFhirCitationPublicationInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('publishedIn');
  fields.add('entryDate');
  fields.add('revisionDate');
  fields.add('pageCount');
end;

function TFhirCitationPublicationInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPublishedIn.sizeInBytes);
  inc(result, FEntryDate.sizeInBytes);
  inc(result, FRevisionDate.sizeInBytes);
  inc(result, FPageCount.sizeInBytes);
end;

{ TFhirCitationPublicationInfoListEnumerator }

constructor TFhirCitationPublicationInfoListEnumerator.Create(list : TFhirCitationPublicationInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationPublicationInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationPublicationInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationPublicationInfoListEnumerator.GetCurrent : TFhirCitationPublicationInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationPublicationInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationPublicationInfoList }

procedure TFhirCitationPublicationInfoList.AddItem(value: TFhirCitationPublicationInfo);
begin
  assert(value.ClassName = 'TFhirCitationPublicationInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationPublicationInfo');
  add(value);
end;

function TFhirCitationPublicationInfoList.Append: TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPublicationInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCitationPublicationInfoList.GetEnumerator : TFhirCitationPublicationInfoListEnumerator;
begin
  result := TFhirCitationPublicationInfoListEnumerator.Create(self.link);
end;

function TFhirCitationPublicationInfoList.Clone: TFhirCitationPublicationInfoList;
begin
  result := TFhirCitationPublicationInfoList(inherited Clone);
end;

function TFhirCitationPublicationInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationPublicationInfoList.GetItemN(index: Integer): TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo(ObjectByIndex[index]);
end;

function TFhirCitationPublicationInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationPublicationInfo;
end;
function TFhirCitationPublicationInfoList.IndexOf(value: TFhirCitationPublicationInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationPublicationInfoList.Insert(index: Integer): TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPublicationInfoList.InsertItem(index: Integer; value: TFhirCitationPublicationInfo);
begin
  assert(value is TFhirCitationPublicationInfo);
  Inherited Insert(index, value);
end;

function TFhirCitationPublicationInfoList.Item(index: Integer): TFhirCitationPublicationInfo;
begin
  result := TFhirCitationPublicationInfo(ObjectByIndex[index]);
end;

function TFhirCitationPublicationInfoList.Link: TFhirCitationPublicationInfoList;
begin
  result := TFhirCitationPublicationInfoList(inherited Link);
end;

procedure TFhirCitationPublicationInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationPublicationInfoList.SetItemByIndex(index: Integer; value: TFhirCitationPublicationInfo);
begin
  assert(value is TFhirCitationPublicationInfo);
  FhirCitationPublicationInfos[index] := value;
end;

procedure TFhirCitationPublicationInfoList.SetItemN(index: Integer; value: TFhirCitationPublicationInfo);
begin
  assert(value is TFhirCitationPublicationInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationPublicationInfoPublishedIn }

constructor TFhirCitationPublicationInfoPublishedIn.Create;
begin
  inherited;
end;

destructor TFhirCitationPublicationInfoPublishedIn.Destroy;
begin
  FType_.free;
  FIdentifierList.Free;
  FName.free;
  FPublisher.free;
  FPublisherLocation.free;
  FStartDate.free;
  inherited;
end;

procedure TFhirCitationPublicationInfoPublishedIn.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationPublicationInfoPublishedIn(oSource).type_.Clone;
  if (TFhirCitationPublicationInfoPublishedIn(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationPublicationInfoPublishedIn(oSource).FIdentifierList);
  end;
  nameElement := TFhirCitationPublicationInfoPublishedIn(oSource).nameElement.Clone;
  publisher := TFhirCitationPublicationInfoPublishedIn(oSource).publisher.Clone;
  publisherLocationElement := TFhirCitationPublicationInfoPublishedIn(oSource).publisherLocationElement.Clone;
  startDateElement := TFhirCitationPublicationInfoPublishedIn(oSource).startDateElement.Clone;
end;

procedure TFhirCitationPublicationInfoPublishedIn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publisherLocation') Then
     list.add(self.link, 'publisherLocation', FPublisherLocation.Link);
  if (child_name = 'startDate') Then
     list.add(self.link, 'startDate', FStartDate.Link);
end;

procedure TFhirCitationPublicationInfoPublishedIn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publisherLocation', 'string', false, TFhirString, FPublisherLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'startDate', 'date', false, TFhirDate, FStartDate.Link)); {L1172}
end;

function TFhirCitationPublicationInfoPublishedIn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'publisherLocation') then
  begin
    PublisherLocationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'startDate') then
  begin
    StartDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationPublicationInfoPublishedIn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirCitationPublicationInfoPublishedIn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'publisher') then result := TFhirReference.create() {L1203}
  else if (propName = 'publisherLocation') then result := TFhirString.create() {L1223}
  else if (propName = 'startDate') then result := TFhirDate.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationPublicationInfoPublishedIn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publisherLocation') then result := 'string'
  else if (propName = 'startDate') then result := 'date'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationPublicationInfoPublishedIn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publisherLocation') then PublisherLocationElement := nil
  else if (propName = 'startDate') then StartDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationPublicationInfoPublishedIn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference {L1195}
  else if (propName = 'publisherLocation') then PublisherLocationElement := asString(new) {L1222}
  else if (propName = 'startDate') then StartDateElement := asDate(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationPublicationInfoPublishedIn.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationPublicationInfoPublishedIn.fhirType : string;
begin
  result := 'Citation.publicationInfo.publishedIn';
end;

function TFhirCitationPublicationInfoPublishedIn.Link : TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn(inherited Link);
end;

function TFhirCitationPublicationInfoPublishedIn.Clone : TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn(inherited Clone);
end;

function TFhirCitationPublicationInfoPublishedIn.equals(other : TObject) : boolean; 
var
  o : TFhirCitationPublicationInfoPublishedIn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationPublicationInfoPublishedIn)) then
    result := false
  else
  begin
    o := TFhirCitationPublicationInfoPublishedIn(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(publisherLocationElement, o.publisherLocationElement, true) and compareDeep(startDateElement, o.startDateElement, true);
  end;
end;

function TFhirCitationPublicationInfoPublishedIn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FPublisher) and isEmptyProp(FPublisherLocation) and isEmptyProp(FStartDate);
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirCitationPublicationInfoPublishedIn.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationPublicationInfoPublishedIn.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCitationPublicationInfoPublishedIn.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value; {L1134}
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetPublisherLocation(value : TFhirString);
begin
  FPublisherLocation.free;
  FPublisherLocation := value; {L1134}
end;

function TFhirCitationPublicationInfoPublishedIn.GetPublisherLocationST : String;
begin
  if FPublisherLocation = nil then
    result := ''
  else
    result := FPublisherLocation.value;
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetPublisherLocationST(value : String);
begin
  if value <> '' then
  begin
    if FPublisherLocation = nil then
      FPublisherLocation := TFhirString.create;
    FPublisherLocation.value := value
  end
  else if FPublisherLocation <> nil then
    FPublisherLocation.value := '';
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetStartDate(value : TFhirDate);
begin
  FStartDate.free;
  FStartDate := value; {L1134}
end;

function TFhirCitationPublicationInfoPublishedIn.GetStartDateST : TFslDateTime;
begin
  if FStartDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStartDate.value;
end;

procedure TFhirCitationPublicationInfoPublishedIn.SetStartDateST(value : TFslDateTime);
begin
  if FStartDate = nil then
    FStartDate := TFhirDate.create;
  FStartDate.value := value
end;

procedure TFhirCitationPublicationInfoPublishedIn.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('identifier');
  fields.add('name');
  fields.add('publisher');
  fields.add('publisherLocation');
  fields.add('startDate');
end;

function TFhirCitationPublicationInfoPublishedIn.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FPublisherLocation.sizeInBytes);
  inc(result, FStartDate.sizeInBytes);
end;

{ TFhirCitationPublicationInfoPublishedInListEnumerator }

constructor TFhirCitationPublicationInfoPublishedInListEnumerator.Create(list : TFhirCitationPublicationInfoPublishedInList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationPublicationInfoPublishedInListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationPublicationInfoPublishedInListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationPublicationInfoPublishedInListEnumerator.GetCurrent : TFhirCitationPublicationInfoPublishedIn;
begin
  Result := FList[FIndex];
end;

function TFhirCitationPublicationInfoPublishedInListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationPublicationInfoPublishedInList }

procedure TFhirCitationPublicationInfoPublishedInList.AddItem(value: TFhirCitationPublicationInfoPublishedIn);
begin
  assert(value.ClassName = 'TFhirCitationPublicationInfoPublishedIn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationPublicationInfoPublishedIn');
  add(value);
end;

function TFhirCitationPublicationInfoPublishedInList.Append: TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPublicationInfoPublishedInList.ClearItems;
begin
  Clear;
end;

function TFhirCitationPublicationInfoPublishedInList.GetEnumerator : TFhirCitationPublicationInfoPublishedInListEnumerator;
begin
  result := TFhirCitationPublicationInfoPublishedInListEnumerator.Create(self.link);
end;

function TFhirCitationPublicationInfoPublishedInList.Clone: TFhirCitationPublicationInfoPublishedInList;
begin
  result := TFhirCitationPublicationInfoPublishedInList(inherited Clone);
end;

function TFhirCitationPublicationInfoPublishedInList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationPublicationInfoPublishedInList.GetItemN(index: Integer): TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationPublicationInfoPublishedInList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationPublicationInfoPublishedIn;
end;
function TFhirCitationPublicationInfoPublishedInList.IndexOf(value: TFhirCitationPublicationInfoPublishedIn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationPublicationInfoPublishedInList.Insert(index: Integer): TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPublicationInfoPublishedInList.InsertItem(index: Integer; value: TFhirCitationPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationPublicationInfoPublishedIn);
  Inherited Insert(index, value);
end;

function TFhirCitationPublicationInfoPublishedInList.Item(index: Integer): TFhirCitationPublicationInfoPublishedIn;
begin
  result := TFhirCitationPublicationInfoPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationPublicationInfoPublishedInList.Link: TFhirCitationPublicationInfoPublishedInList;
begin
  result := TFhirCitationPublicationInfoPublishedInList(inherited Link);
end;

procedure TFhirCitationPublicationInfoPublishedInList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationPublicationInfoPublishedInList.SetItemByIndex(index: Integer; value: TFhirCitationPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationPublicationInfoPublishedIn);
  FhirCitationPublicationInfoPublishedIns[index] := value;
end;

procedure TFhirCitationPublicationInfoPublishedInList.SetItemN(index: Integer; value: TFhirCitationPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationPublicationInfoPublishedIn);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeTitle }

constructor TFhirCitationAlternativeTitle.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeTitle.Destroy;
begin
  FType_.free;
  FLanguage.free;
  FTitle.free;
  inherited;
end;

procedure TFhirCitationAlternativeTitle.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationAlternativeTitle(oSource).type_.Clone;
  language := TFhirCitationAlternativeTitle(oSource).language.Clone;
  titleElement := TFhirCitationAlternativeTitle(oSource).titleElement.Clone;
end;

procedure TFhirCitationAlternativeTitle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
end;

procedure TFhirCitationAlternativeTitle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'title', 'markdown', false, TFhirMarkdown, FTitle.Link)); {L1172}
end;

function TFhirCitationAlternativeTitle.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeTitle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeTitle.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'title') then result := TFhirMarkdown.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeTitle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'title') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeTitle.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'title') then TitleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeTitle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'title') then TitleElement := asMarkdown(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeTitle.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeTitle.fhirType : string;
begin
  result := 'Citation.alternativeTitle';
end;

function TFhirCitationAlternativeTitle.Link : TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle(inherited Link);
end;

function TFhirCitationAlternativeTitle.Clone : TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle(inherited Clone);
end;

function TFhirCitationAlternativeTitle.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeTitle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeTitle)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeTitle(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(titleElement, o.titleElement, true);
  end;
end;

function TFhirCitationAlternativeTitle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLanguage) and isEmptyProp(FTitle);
end;

procedure TFhirCitationAlternativeTitle.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationAlternativeTitle.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirCitationAlternativeTitle.SetTitle(value : TFhirMarkdown);
begin
  FTitle.free;
  FTitle := value; {L1134}
end;

function TFhirCitationAlternativeTitle.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCitationAlternativeTitle.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirMarkdown.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCitationAlternativeTitle.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('language');
  fields.add('title');
end;

function TFhirCitationAlternativeTitle.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
end;

{ TFhirCitationAlternativeTitleListEnumerator }

constructor TFhirCitationAlternativeTitleListEnumerator.Create(list : TFhirCitationAlternativeTitleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeTitleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeTitleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeTitleListEnumerator.GetCurrent : TFhirCitationAlternativeTitle;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeTitleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeTitleList }

procedure TFhirCitationAlternativeTitleList.AddItem(value: TFhirCitationAlternativeTitle);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeTitle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeTitle');
  add(value);
end;

function TFhirCitationAlternativeTitleList.Append: TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeTitleList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeTitleList.GetEnumerator : TFhirCitationAlternativeTitleListEnumerator;
begin
  result := TFhirCitationAlternativeTitleListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeTitleList.Clone: TFhirCitationAlternativeTitleList;
begin
  result := TFhirCitationAlternativeTitleList(inherited Clone);
end;

function TFhirCitationAlternativeTitleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeTitleList.GetItemN(index: Integer): TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeTitleList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeTitle;
end;
function TFhirCitationAlternativeTitleList.IndexOf(value: TFhirCitationAlternativeTitle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeTitleList.Insert(index: Integer): TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeTitleList.InsertItem(index: Integer; value: TFhirCitationAlternativeTitle);
begin
  assert(value is TFhirCitationAlternativeTitle);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeTitleList.Item(index: Integer): TFhirCitationAlternativeTitle;
begin
  result := TFhirCitationAlternativeTitle(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeTitleList.Link: TFhirCitationAlternativeTitleList;
begin
  result := TFhirCitationAlternativeTitleList(inherited Link);
end;

procedure TFhirCitationAlternativeTitleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeTitleList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeTitle);
begin
  assert(value is TFhirCitationAlternativeTitle);
  FhirCitationAlternativeTitles[index] := value;
end;

procedure TFhirCitationAlternativeTitleList.SetItemN(index: Integer; value: TFhirCitationAlternativeTitle);
begin
  assert(value is TFhirCitationAlternativeTitle);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationPagination }

constructor TFhirCitationPagination.Create;
begin
  inherited;
end;

destructor TFhirCitationPagination.Destroy;
begin
  FPageString.free;
  FFirstPage.free;
  FLastPage.free;
  inherited;
end;

procedure TFhirCitationPagination.Assign(oSource : TFslObject);
begin
  inherited;
  pageStringElement := TFhirCitationPagination(oSource).pageStringElement.Clone;
  firstPageElement := TFhirCitationPagination(oSource).firstPageElement.Clone;
  lastPageElement := TFhirCitationPagination(oSource).lastPageElement.Clone;
end;

procedure TFhirCitationPagination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'pageString') Then
     list.add(self.link, 'pageString', FPageString.Link);
  if (child_name = 'firstPage') Then
     list.add(self.link, 'firstPage', FFirstPage.Link);
  if (child_name = 'lastPage') Then
     list.add(self.link, 'lastPage', FLastPage.Link);
end;

procedure TFhirCitationPagination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'pageString', 'string', false, TFhirString, FPageString.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'firstPage', 'string', false, TFhirString, FFirstPage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lastPage', 'string', false, TFhirString, FLastPage.Link)); {L1172}
end;

function TFhirCitationPagination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'pageString') then
  begin
    PageStringElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'firstPage') then
  begin
    FirstPageElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'lastPage') then
  begin
    LastPageElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationPagination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationPagination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'pageString') then result := TFhirString.create() {L1223}
  else if (propName = 'firstPage') then result := TFhirString.create() {L1223}
  else if (propName = 'lastPage') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationPagination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'pageString') then result := 'string'
  else if (propName = 'firstPage') then result := 'string'
  else if (propName = 'lastPage') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationPagination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'pageString') then PageStringElement := nil
  else if (propName = 'firstPage') then FirstPageElement := nil
  else if (propName = 'lastPage') then LastPageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationPagination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'pageString') then PageStringElement := asString(new) {L1222}
  else if (propName = 'firstPage') then FirstPageElement := asString(new) {L1222}
  else if (propName = 'lastPage') then LastPageElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationPagination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationPagination.fhirType : string;
begin
  result := 'Citation.pagination';
end;

function TFhirCitationPagination.Link : TFhirCitationPagination;
begin
  result := TFhirCitationPagination(inherited Link);
end;

function TFhirCitationPagination.Clone : TFhirCitationPagination;
begin
  result := TFhirCitationPagination(inherited Clone);
end;

function TFhirCitationPagination.equals(other : TObject) : boolean; 
var
  o : TFhirCitationPagination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationPagination)) then
    result := false
  else
  begin
    o := TFhirCitationPagination(other);
    result := compareDeep(pageStringElement, o.pageStringElement, true) and compareDeep(firstPageElement, o.firstPageElement, true) and 
      compareDeep(lastPageElement, o.lastPageElement, true);
  end;
end;

function TFhirCitationPagination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPageString) and isEmptyProp(FFirstPage) and isEmptyProp(FLastPage);
end;

procedure TFhirCitationPagination.SetPageString(value : TFhirString);
begin
  FPageString.free;
  FPageString := value; {L1134}
end;

function TFhirCitationPagination.GetPageStringST : String;
begin
  if FPageString = nil then
    result := ''
  else
    result := FPageString.value;
end;

procedure TFhirCitationPagination.SetPageStringST(value : String);
begin
  if value <> '' then
  begin
    if FPageString = nil then
      FPageString := TFhirString.create;
    FPageString.value := value
  end
  else if FPageString <> nil then
    FPageString.value := '';
end;

procedure TFhirCitationPagination.SetFirstPage(value : TFhirString);
begin
  FFirstPage.free;
  FFirstPage := value; {L1134}
end;

function TFhirCitationPagination.GetFirstPageST : String;
begin
  if FFirstPage = nil then
    result := ''
  else
    result := FFirstPage.value;
end;

procedure TFhirCitationPagination.SetFirstPageST(value : String);
begin
  if value <> '' then
  begin
    if FFirstPage = nil then
      FFirstPage := TFhirString.create;
    FFirstPage.value := value
  end
  else if FFirstPage <> nil then
    FFirstPage.value := '';
end;

procedure TFhirCitationPagination.SetLastPage(value : TFhirString);
begin
  FLastPage.free;
  FLastPage := value; {L1134}
end;

function TFhirCitationPagination.GetLastPageST : String;
begin
  if FLastPage = nil then
    result := ''
  else
    result := FLastPage.value;
end;

procedure TFhirCitationPagination.SetLastPageST(value : String);
begin
  if value <> '' then
  begin
    if FLastPage = nil then
      FLastPage := TFhirString.create;
    FLastPage.value := value
  end
  else if FLastPage <> nil then
    FLastPage.value := '';
end;

procedure TFhirCitationPagination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('pageString');
  fields.add('firstPage');
  fields.add('lastPage');
end;

function TFhirCitationPagination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPageString.sizeInBytes);
  inc(result, FFirstPage.sizeInBytes);
  inc(result, FLastPage.sizeInBytes);
end;

{ TFhirCitationPaginationListEnumerator }

constructor TFhirCitationPaginationListEnumerator.Create(list : TFhirCitationPaginationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationPaginationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationPaginationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationPaginationListEnumerator.GetCurrent : TFhirCitationPagination;
begin
  Result := FList[FIndex];
end;

function TFhirCitationPaginationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationPaginationList }

procedure TFhirCitationPaginationList.AddItem(value: TFhirCitationPagination);
begin
  assert(value.ClassName = 'TFhirCitationPagination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationPagination');
  add(value);
end;

function TFhirCitationPaginationList.Append: TFhirCitationPagination;
begin
  result := TFhirCitationPagination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPaginationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationPaginationList.GetEnumerator : TFhirCitationPaginationListEnumerator;
begin
  result := TFhirCitationPaginationListEnumerator.Create(self.link);
end;

function TFhirCitationPaginationList.Clone: TFhirCitationPaginationList;
begin
  result := TFhirCitationPaginationList(inherited Clone);
end;

function TFhirCitationPaginationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationPaginationList.GetItemN(index: Integer): TFhirCitationPagination;
begin
  result := TFhirCitationPagination(ObjectByIndex[index]);
end;

function TFhirCitationPaginationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationPagination;
end;
function TFhirCitationPaginationList.IndexOf(value: TFhirCitationPagination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationPaginationList.Insert(index: Integer): TFhirCitationPagination;
begin
  result := TFhirCitationPagination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationPaginationList.InsertItem(index: Integer; value: TFhirCitationPagination);
begin
  assert(value is TFhirCitationPagination);
  Inherited Insert(index, value);
end;

function TFhirCitationPaginationList.Item(index: Integer): TFhirCitationPagination;
begin
  result := TFhirCitationPagination(ObjectByIndex[index]);
end;

function TFhirCitationPaginationList.Link: TFhirCitationPaginationList;
begin
  result := TFhirCitationPaginationList(inherited Link);
end;

procedure TFhirCitationPaginationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationPaginationList.SetItemByIndex(index: Integer; value: TFhirCitationPagination);
begin
  assert(value is TFhirCitationPagination);
  FhirCitationPaginations[index] := value;
end;

procedure TFhirCitationPaginationList.SetItemN(index: Integer; value: TFhirCitationPagination);
begin
  assert(value is TFhirCitationPagination);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationArticleUrl }

constructor TFhirCitationArticleUrl.Create;
begin
  inherited;
end;

destructor TFhirCitationArticleUrl.Destroy;
begin
  FType_.free;
  FUrl.free;
  inherited;
end;

procedure TFhirCitationArticleUrl.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationArticleUrl(oSource).type_.Clone;
  urlElement := TFhirCitationArticleUrl(oSource).urlElement.Clone;
end;

procedure TFhirCitationArticleUrl.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirCitationArticleUrl.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link)); {L1172}
end;

function TFhirCitationArticleUrl.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationArticleUrl.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationArticleUrl.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'url') then result := TFhirUri.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationArticleUrl.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationArticleUrl.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationArticleUrl.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'url') then UrlElement := asUri(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationArticleUrl.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationArticleUrl.fhirType : string;
begin
  result := 'Citation.articleUrl';
end;

function TFhirCitationArticleUrl.Link : TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl(inherited Link);
end;

function TFhirCitationArticleUrl.Clone : TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl(inherited Clone);
end;

function TFhirCitationArticleUrl.equals(other : TObject) : boolean; 
var
  o : TFhirCitationArticleUrl;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationArticleUrl)) then
    result := false
  else
  begin
    o := TFhirCitationArticleUrl(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirCitationArticleUrl.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUrl);
end;

procedure TFhirCitationArticleUrl.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationArticleUrl.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value; {L1134}
end;

function TFhirCitationArticleUrl.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCitationArticleUrl.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirCitationArticleUrl.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('url');
end;

function TFhirCitationArticleUrl.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirCitationArticleUrlListEnumerator }

constructor TFhirCitationArticleUrlListEnumerator.Create(list : TFhirCitationArticleUrlList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationArticleUrlListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationArticleUrlListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationArticleUrlListEnumerator.GetCurrent : TFhirCitationArticleUrl;
begin
  Result := FList[FIndex];
end;

function TFhirCitationArticleUrlListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationArticleUrlList }

procedure TFhirCitationArticleUrlList.AddItem(value: TFhirCitationArticleUrl);
begin
  assert(value.ClassName = 'TFhirCitationArticleUrl', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationArticleUrl');
  add(value);
end;

function TFhirCitationArticleUrlList.Append: TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationArticleUrlList.ClearItems;
begin
  Clear;
end;

function TFhirCitationArticleUrlList.GetEnumerator : TFhirCitationArticleUrlListEnumerator;
begin
  result := TFhirCitationArticleUrlListEnumerator.Create(self.link);
end;

function TFhirCitationArticleUrlList.Clone: TFhirCitationArticleUrlList;
begin
  result := TFhirCitationArticleUrlList(inherited Clone);
end;

function TFhirCitationArticleUrlList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationArticleUrlList.GetItemN(index: Integer): TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl(ObjectByIndex[index]);
end;

function TFhirCitationArticleUrlList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationArticleUrl;
end;
function TFhirCitationArticleUrlList.IndexOf(value: TFhirCitationArticleUrl): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationArticleUrlList.Insert(index: Integer): TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationArticleUrlList.InsertItem(index: Integer; value: TFhirCitationArticleUrl);
begin
  assert(value is TFhirCitationArticleUrl);
  Inherited Insert(index, value);
end;

function TFhirCitationArticleUrlList.Item(index: Integer): TFhirCitationArticleUrl;
begin
  result := TFhirCitationArticleUrl(ObjectByIndex[index]);
end;

function TFhirCitationArticleUrlList.Link: TFhirCitationArticleUrlList;
begin
  result := TFhirCitationArticleUrlList(inherited Link);
end;

procedure TFhirCitationArticleUrlList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationArticleUrlList.SetItemByIndex(index: Integer; value: TFhirCitationArticleUrl);
begin
  assert(value is TFhirCitationArticleUrl);
  FhirCitationArticleUrls[index] := value;
end;

procedure TFhirCitationArticleUrlList.SetItemN(index: Integer; value: TFhirCitationArticleUrl);
begin
  assert(value is TFhirCitationArticleUrl);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeAbstract }

constructor TFhirCitationAlternativeAbstract.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeAbstract.Destroy;
begin
  FType_.free;
  FLanguage.free;
  FAbstract.free;
  FAbstractCopyright.free;
  inherited;
end;

procedure TFhirCitationAlternativeAbstract.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationAlternativeAbstract(oSource).type_.Clone;
  language := TFhirCitationAlternativeAbstract(oSource).language.Clone;
  abstractElement := TFhirCitationAlternativeAbstract(oSource).abstractElement.Clone;
  abstractCopyrightElement := TFhirCitationAlternativeAbstract(oSource).abstractCopyrightElement.Clone;
end;

procedure TFhirCitationAlternativeAbstract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'abstractCopyright') Then
     list.add(self.link, 'abstractCopyright', FAbstractCopyright.Link);
end;

procedure TFhirCitationAlternativeAbstract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'abstract', 'markdown', false, TFhirMarkdown, FAbstract.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'abstractCopyright', 'markdown', false, TFhirMarkdown, FAbstractCopyright.Link)); {L1172}
end;

function TFhirCitationAlternativeAbstract.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'abstractCopyright') then
  begin
    AbstractCopyrightElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeAbstract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeAbstract.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'abstract') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'abstractCopyright') then result := TFhirMarkdown.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeAbstract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'abstract') then result := 'markdown'
  else if (propName = 'abstractCopyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeAbstract.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'abstractCopyright') then AbstractCopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeAbstract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'abstract') then AbstractElement := asMarkdown(new) {L1222}
  else if (propName = 'abstractCopyright') then AbstractCopyrightElement := asMarkdown(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeAbstract.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeAbstract.fhirType : string;
begin
  result := 'Citation.alternativeAbstract';
end;

function TFhirCitationAlternativeAbstract.Link : TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract(inherited Link);
end;

function TFhirCitationAlternativeAbstract.Clone : TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract(inherited Clone);
end;

function TFhirCitationAlternativeAbstract.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeAbstract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeAbstract)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeAbstract(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(abstractElement, o.abstractElement, true) and compareDeep(abstractCopyrightElement, o.abstractCopyrightElement, true);
  end;
end;

function TFhirCitationAlternativeAbstract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLanguage) and isEmptyProp(FAbstract) and isEmptyProp(FAbstractCopyright);
end;

procedure TFhirCitationAlternativeAbstract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationAlternativeAbstract.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirCitationAlternativeAbstract.SetAbstract(value : TFhirMarkdown);
begin
  FAbstract.free;
  FAbstract := value; {L1134}
end;

function TFhirCitationAlternativeAbstract.GetAbstractST : String;
begin
  if FAbstract = nil then
    result := ''
  else
    result := FAbstract.value;
end;

procedure TFhirCitationAlternativeAbstract.SetAbstractST(value : String);
begin
  if value <> '' then
  begin
    if FAbstract = nil then
      FAbstract := TFhirMarkdown.create;
    FAbstract.value := value
  end
  else if FAbstract <> nil then
    FAbstract.value := '';
end;

procedure TFhirCitationAlternativeAbstract.SetAbstractCopyright(value : TFhirMarkdown);
begin
  FAbstractCopyright.free;
  FAbstractCopyright := value; {L1134}
end;

function TFhirCitationAlternativeAbstract.GetAbstractCopyrightST : String;
begin
  if FAbstractCopyright = nil then
    result := ''
  else
    result := FAbstractCopyright.value;
end;

procedure TFhirCitationAlternativeAbstract.SetAbstractCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FAbstractCopyright = nil then
      FAbstractCopyright := TFhirMarkdown.create;
    FAbstractCopyright.value := value
  end
  else if FAbstractCopyright <> nil then
    FAbstractCopyright.value := '';
end;

procedure TFhirCitationAlternativeAbstract.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('language');
  fields.add('abstract');
  fields.add('abstractCopyright');
end;

function TFhirCitationAlternativeAbstract.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FAbstractCopyright.sizeInBytes);
end;

{ TFhirCitationAlternativeAbstractListEnumerator }

constructor TFhirCitationAlternativeAbstractListEnumerator.Create(list : TFhirCitationAlternativeAbstractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeAbstractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeAbstractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeAbstractListEnumerator.GetCurrent : TFhirCitationAlternativeAbstract;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeAbstractListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeAbstractList }

procedure TFhirCitationAlternativeAbstractList.AddItem(value: TFhirCitationAlternativeAbstract);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeAbstract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeAbstract');
  add(value);
end;

function TFhirCitationAlternativeAbstractList.Append: TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeAbstractList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeAbstractList.GetEnumerator : TFhirCitationAlternativeAbstractListEnumerator;
begin
  result := TFhirCitationAlternativeAbstractListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeAbstractList.Clone: TFhirCitationAlternativeAbstractList;
begin
  result := TFhirCitationAlternativeAbstractList(inherited Clone);
end;

function TFhirCitationAlternativeAbstractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeAbstractList.GetItemN(index: Integer): TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeAbstractList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeAbstract;
end;
function TFhirCitationAlternativeAbstractList.IndexOf(value: TFhirCitationAlternativeAbstract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeAbstractList.Insert(index: Integer): TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeAbstractList.InsertItem(index: Integer; value: TFhirCitationAlternativeAbstract);
begin
  assert(value is TFhirCitationAlternativeAbstract);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeAbstractList.Item(index: Integer): TFhirCitationAlternativeAbstract;
begin
  result := TFhirCitationAlternativeAbstract(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeAbstractList.Link: TFhirCitationAlternativeAbstractList;
begin
  result := TFhirCitationAlternativeAbstractList(inherited Link);
end;

procedure TFhirCitationAlternativeAbstractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeAbstractList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeAbstract);
begin
  assert(value is TFhirCitationAlternativeAbstract);
  FhirCitationAlternativeAbstracts[index] := value;
end;

procedure TFhirCitationAlternativeAbstractList.SetItemN(index: Integer; value: TFhirCitationAlternativeAbstract);
begin
  assert(value is TFhirCitationAlternativeAbstract);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationContributorship }

constructor TFhirCitationContributorship.Create;
begin
  inherited;
end;

destructor TFhirCitationContributorship.Destroy;
begin
  FComplete.free;
  FEntryList.Free;
  FSummaryList.Free;
  inherited;
end;

procedure TFhirCitationContributorship.Assign(oSource : TFslObject);
begin
  inherited;
  completeElement := TFhirCitationContributorship(oSource).completeElement.Clone;
  if (TFhirCitationContributorship(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirCitationContributorshipEntryList.Create;
    FEntryList.Assign(TFhirCitationContributorship(oSource).FEntryList);
  end;
  if (TFhirCitationContributorship(oSource).FSummaryList = nil) then
  begin
    FSummaryList.free;
    FSummaryList := nil;
  end
  else
  begin
    if FSummaryList = nil then
      FSummaryList := TFhirCitationContributorshipSummaryList.Create;
    FSummaryList.Assign(TFhirCitationContributorship(oSource).FSummaryList);
  end;
end;

procedure TFhirCitationContributorship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'complete') Then
     list.add(self.link, 'complete', FComplete.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'summary') Then
    list.addAll(self, 'summary', FSummaryList);
end;

procedure TFhirCitationContributorship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'complete', 'boolean', false, TFhirBoolean, FComplete.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirCitationContributorshipEntry, FEntryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'summary', 'BackboneElement', true, TFhirCitationContributorshipSummary, FSummaryList.Link)) {L1039};
end;

function TFhirCitationContributorship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'complete') then
  begin
    CompleteElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirCitationContributorshipEntry) {L1048};
    result := propValue;
  end
  else if (propName = 'summary') then
  begin
    SummaryList.add(propValue as TFhirCitationContributorshipSummary) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationContributorship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirCitationContributorshipEntry) {L1049}
  else if (propName = 'summary') then SummaryList.insertItem(index, propValue as TFhirCitationContributorshipSummary) {L1049}
  else inherited;
end;

function TFhirCitationContributorship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'complete') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'entry') then result := EntryList.new() {L1053}
  else if (propName = 'summary') then result := SummaryList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationContributorship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'complete') then result := 'boolean'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'summary') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationContributorship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'complete') then CompleteElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {L1054}
  else if (propName = 'summary') then deletePropertyValue('summary', SummaryList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationContributorship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'complete') then CompleteElement := asBoolean(new) {L1222}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {L1055}
  else if (propName = 'summary') then replacePropertyValue('summary', SummaryList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationContributorship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'entry') then EntryList.move(source, destination) {L1050}
  else if (propName = 'summary') then SummaryList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationContributorship.fhirType : string;
begin
  result := 'Citation.contributorship';
end;

function TFhirCitationContributorship.Link : TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship(inherited Link);
end;

function TFhirCitationContributorship.Clone : TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship(inherited Clone);
end;

function TFhirCitationContributorship.equals(other : TObject) : boolean; 
var
  o : TFhirCitationContributorship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationContributorship)) then
    result := false
  else
  begin
    o := TFhirCitationContributorship(other);
    result := compareDeep(completeElement, o.completeElement, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(summaryList, o.summaryList, true);
  end;
end;

function TFhirCitationContributorship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComplete) and isEmptyProp(FentryList) and isEmptyProp(FsummaryList);
end;

procedure TFhirCitationContributorship.SetComplete(value : TFhirBoolean);
begin
  FComplete.free;
  FComplete := value; {L1134}
end;

function TFhirCitationContributorship.GetCompleteST : Boolean;
begin
  if FComplete = nil then
    result := false
  else
    result := FComplete.value;
end;

procedure TFhirCitationContributorship.SetCompleteST(value : Boolean);
begin
  if FComplete = nil then
    FComplete := TFhirBoolean.create;
  FComplete.value := value
end;

function TFhirCitationContributorship.GetEntryList : TFhirCitationContributorshipEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirCitationContributorshipEntryList.Create;
  result := FEntryList;
end;

function TFhirCitationContributorship.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

function TFhirCitationContributorship.GetSummaryList : TFhirCitationContributorshipSummaryList;
begin
  if FSummaryList = nil then
    FSummaryList := TFhirCitationContributorshipSummaryList.Create;
  result := FSummaryList;
end;

function TFhirCitationContributorship.GetHasSummaryList : boolean;
begin
  result := (FSummaryList <> nil) and (FSummaryList.count > 0);
end;

procedure TFhirCitationContributorship.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('complete');
  fields.add('entry');
  fields.add('summary');
end;

function TFhirCitationContributorship.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComplete.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FsummaryList.sizeInBytes);
end;

{ TFhirCitationContributorshipListEnumerator }

constructor TFhirCitationContributorshipListEnumerator.Create(list : TFhirCitationContributorshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationContributorshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationContributorshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationContributorshipListEnumerator.GetCurrent : TFhirCitationContributorship;
begin
  Result := FList[FIndex];
end;

function TFhirCitationContributorshipListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationContributorshipList }

procedure TFhirCitationContributorshipList.AddItem(value: TFhirCitationContributorship);
begin
  assert(value.ClassName = 'TFhirCitationContributorship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationContributorship');
  add(value);
end;

function TFhirCitationContributorshipList.Append: TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipList.ClearItems;
begin
  Clear;
end;

function TFhirCitationContributorshipList.GetEnumerator : TFhirCitationContributorshipListEnumerator;
begin
  result := TFhirCitationContributorshipListEnumerator.Create(self.link);
end;

function TFhirCitationContributorshipList.Clone: TFhirCitationContributorshipList;
begin
  result := TFhirCitationContributorshipList(inherited Clone);
end;

function TFhirCitationContributorshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationContributorshipList.GetItemN(index: Integer): TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationContributorship;
end;
function TFhirCitationContributorshipList.IndexOf(value: TFhirCitationContributorship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationContributorshipList.Insert(index: Integer): TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipList.InsertItem(index: Integer; value: TFhirCitationContributorship);
begin
  assert(value is TFhirCitationContributorship);
  Inherited Insert(index, value);
end;

function TFhirCitationContributorshipList.Item(index: Integer): TFhirCitationContributorship;
begin
  result := TFhirCitationContributorship(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipList.Link: TFhirCitationContributorshipList;
begin
  result := TFhirCitationContributorshipList(inherited Link);
end;

procedure TFhirCitationContributorshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationContributorshipList.SetItemByIndex(index: Integer; value: TFhirCitationContributorship);
begin
  assert(value is TFhirCitationContributorship);
  FhirCitationContributorships[index] := value;
end;

procedure TFhirCitationContributorshipList.SetItemN(index: Integer; value: TFhirCitationContributorship);
begin
  assert(value is TFhirCitationContributorship);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationContributorshipEntry }

constructor TFhirCitationContributorshipEntry.Create;
begin
  inherited;
end;

destructor TFhirCitationContributorshipEntry.Destroy;
begin
  FName.free;
  FInitials.free;
  FCollectiveName.free;
  FIdentifierList.Free;
  FAffiliationInfoList.Free;
  FAddressList.Free;
  FTelecomList.Free;
  FContributionList.Free;
  FNotAnAuthor.free;
  FCorrespondingAuthor.free;
  FListOrder.free;
  inherited;
end;

procedure TFhirCitationContributorshipEntry.Assign(oSource : TFslObject);
begin
  inherited;
  name := TFhirCitationContributorshipEntry(oSource).name.Clone;
  initialsElement := TFhirCitationContributorshipEntry(oSource).initialsElement.Clone;
  collectiveNameElement := TFhirCitationContributorshipEntry(oSource).collectiveNameElement.Clone;
  if (TFhirCitationContributorshipEntry(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationContributorshipEntry(oSource).FIdentifierList);
  end;
  if (TFhirCitationContributorshipEntry(oSource).FAffiliationInfoList = nil) then
  begin
    FAffiliationInfoList.free;
    FAffiliationInfoList := nil;
  end
  else
  begin
    if FAffiliationInfoList = nil then
      FAffiliationInfoList := TFhirCitationContributorshipEntryAffiliationInfoList.Create;
    FAffiliationInfoList.Assign(TFhirCitationContributorshipEntry(oSource).FAffiliationInfoList);
  end;
  if (TFhirCitationContributorshipEntry(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirCitationContributorshipEntry(oSource).FAddressList);
  end;
  if (TFhirCitationContributorshipEntry(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirCitationContributorshipEntry(oSource).FTelecomList);
  end;
  if (TFhirCitationContributorshipEntry(oSource).FContributionList = nil) then
  begin
    FContributionList.free;
    FContributionList := nil;
  end
  else
  begin
    if FContributionList = nil then
      FContributionList := TFhirCodeableConceptList.Create;
    FContributionList.Assign(TFhirCitationContributorshipEntry(oSource).FContributionList);
  end;
  notAnAuthorElement := TFhirCitationContributorshipEntry(oSource).notAnAuthorElement.Clone;
  correspondingAuthorElement := TFhirCitationContributorshipEntry(oSource).correspondingAuthorElement.Clone;
  listOrderElement := TFhirCitationContributorshipEntry(oSource).listOrderElement.Clone;
end;

procedure TFhirCitationContributorshipEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'initials') Then
     list.add(self.link, 'initials', FInitials.Link);
  if (child_name = 'collectiveName') Then
     list.add(self.link, 'collectiveName', FCollectiveName.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'affiliationInfo') Then
    list.addAll(self, 'affiliationInfo', FAffiliationInfoList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'contribution') Then
    list.addAll(self, 'contribution', FContributionList);
  if (child_name = 'notAnAuthor') Then
     list.add(self.link, 'notAnAuthor', FNotAnAuthor.Link);
  if (child_name = 'correspondingAuthor') Then
     list.add(self.link, 'correspondingAuthor', FCorrespondingAuthor.Link);
  if (child_name = 'listOrder') Then
     list.add(self.link, 'listOrder', FListOrder.Link);
end;

procedure TFhirCitationContributorshipEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'initials', 'string', false, TFhirString, FInitials.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'collectiveName', 'string', false, TFhirString, FCollectiveName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'affiliationInfo', 'BackboneElement', true, TFhirCitationContributorshipEntryAffiliationInfo, FAffiliationInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contribution', 'CodeableConcept', true, TFhirCodeableConcept, FContributionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'notAnAuthor', 'boolean', false, TFhirBoolean, FNotAnAuthor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'correspondingAuthor', 'boolean', false, TFhirBoolean, FCorrespondingAuthor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'listOrder', 'positiveInt', false, TFhirPositiveInt, FListOrder.Link)); {L1172}
end;

function TFhirCitationContributorshipEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName {L1199};
    result := propValue;
  end
  else if (propName = 'initials') then
  begin
    InitialsElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'collectiveName') then
  begin
    CollectiveNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'affiliationInfo') then
  begin
    AffiliationInfoList.add(propValue as TFhirCitationContributorshipEntryAffiliationInfo) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'contribution') then
  begin
    ContributionList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'notAnAuthor') then
  begin
    NotAnAuthorElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'correspondingAuthor') then
  begin
    CorrespondingAuthorElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'listOrder') then
  begin
    ListOrderElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationContributorshipEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'affiliationInfo') then AffiliationInfoList.insertItem(index, propValue as TFhirCitationContributorshipEntryAffiliationInfo) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'contribution') then ContributionList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirCitationContributorshipEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirHumanName.create() {L1203}
  else if (propName = 'initials') then result := TFhirString.create() {L1223}
  else if (propName = 'collectiveName') then result := TFhirString.create() {L1223}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'affiliationInfo') then result := AffiliationInfoList.new() {L1053}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'contribution') then result := ContributionList.new() {L1053}
  else if (propName = 'notAnAuthor') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'correspondingAuthor') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'listOrder') then result := TFhirPositiveInt.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationContributorshipEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'HumanName'
  else if (propName = 'initials') then result := 'string'
  else if (propName = 'collectiveName') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'affiliationInfo') then result := 'BackboneElement'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'contribution') then result := 'CodeableConcept'
  else if (propName = 'notAnAuthor') then result := 'boolean'
  else if (propName = 'correspondingAuthor') then result := 'boolean'
  else if (propName = 'listOrder') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationContributorshipEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'initials') then InitialsElement := nil
  else if (propName = 'collectiveName') then CollectiveNameElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'affiliationInfo') then deletePropertyValue('affiliationInfo', AffiliationInfoList, value) {L1054}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'contribution') then deletePropertyValue('contribution', ContributionList, value) {L1054}
  else if (propName = 'notAnAuthor') then NotAnAuthorElement := nil
  else if (propName = 'correspondingAuthor') then CorrespondingAuthorElement := nil
  else if (propName = 'listOrder') then ListOrderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationContributorshipEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := new as TFhirHumanName {L1195}
  else if (propName = 'initials') then InitialsElement := asString(new) {L1222}
  else if (propName = 'collectiveName') then CollectiveNameElement := asString(new) {L1222}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'affiliationInfo') then replacePropertyValue('affiliationInfo', AffiliationInfoList, existing, new) {L1055}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'contribution') then replacePropertyValue('contribution', ContributionList, existing, new) {L1055}
  else if (propName = 'notAnAuthor') then NotAnAuthorElement := asBoolean(new) {L1222}
  else if (propName = 'correspondingAuthor') then CorrespondingAuthorElement := asBoolean(new) {L1222}
  else if (propName = 'listOrder') then ListOrderElement := asPositiveInt(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationContributorshipEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'affiliationInfo') then AffiliationInfoList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'contribution') then ContributionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationContributorshipEntry.fhirType : string;
begin
  result := 'Citation.contributorship.entry';
end;

function TFhirCitationContributorshipEntry.Link : TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry(inherited Link);
end;

function TFhirCitationContributorshipEntry.Clone : TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry(inherited Clone);
end;

function TFhirCitationContributorshipEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCitationContributorshipEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationContributorshipEntry)) then
    result := false
  else
  begin
    o := TFhirCitationContributorshipEntry(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(initialsElement, o.initialsElement, true) and 
      compareDeep(collectiveNameElement, o.collectiveNameElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(affiliationInfoList, o.affiliationInfoList, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(contributionList, o.contributionList, true) and 
      compareDeep(notAnAuthorElement, o.notAnAuthorElement, true) and compareDeep(correspondingAuthorElement, o.correspondingAuthorElement, true) and 
      compareDeep(listOrderElement, o.listOrderElement, true);
  end;
end;

function TFhirCitationContributorshipEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FInitials) and isEmptyProp(FCollectiveName) and isEmptyProp(FidentifierList) and isEmptyProp(FaffiliationInfoList) and isEmptyProp(FaddressList) and isEmptyProp(FtelecomList) and isEmptyProp(FcontributionList) and isEmptyProp(FNotAnAuthor) and isEmptyProp(FCorrespondingAuthor) and isEmptyProp(FListOrder);
end;

procedure TFhirCitationContributorshipEntry.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value; {L1134}
end;

procedure TFhirCitationContributorshipEntry.SetInitials(value : TFhirString);
begin
  FInitials.free;
  FInitials := value; {L1134}
end;

function TFhirCitationContributorshipEntry.GetInitialsST : String;
begin
  if FInitials = nil then
    result := ''
  else
    result := FInitials.value;
end;

procedure TFhirCitationContributorshipEntry.SetInitialsST(value : String);
begin
  if value <> '' then
  begin
    if FInitials = nil then
      FInitials := TFhirString.create;
    FInitials.value := value
  end
  else if FInitials <> nil then
    FInitials.value := '';
end;

procedure TFhirCitationContributorshipEntry.SetCollectiveName(value : TFhirString);
begin
  FCollectiveName.free;
  FCollectiveName := value; {L1134}
end;

function TFhirCitationContributorshipEntry.GetCollectiveNameST : String;
begin
  if FCollectiveName = nil then
    result := ''
  else
    result := FCollectiveName.value;
end;

procedure TFhirCitationContributorshipEntry.SetCollectiveNameST(value : String);
begin
  if value <> '' then
  begin
    if FCollectiveName = nil then
      FCollectiveName := TFhirString.create;
    FCollectiveName.value := value
  end
  else if FCollectiveName <> nil then
    FCollectiveName.value := '';
end;

function TFhirCitationContributorshipEntry.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationContributorshipEntry.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCitationContributorshipEntry.GetAffiliationInfoList : TFhirCitationContributorshipEntryAffiliationInfoList;
begin
  if FAffiliationInfoList = nil then
    FAffiliationInfoList := TFhirCitationContributorshipEntryAffiliationInfoList.Create;
  result := FAffiliationInfoList;
end;

function TFhirCitationContributorshipEntry.GetHasAffiliationInfoList : boolean;
begin
  result := (FAffiliationInfoList <> nil) and (FAffiliationInfoList.count > 0);
end;

function TFhirCitationContributorshipEntry.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirCitationContributorshipEntry.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirCitationContributorshipEntry.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirCitationContributorshipEntry.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirCitationContributorshipEntry.GetContributionList : TFhirCodeableConceptList;
begin
  if FContributionList = nil then
    FContributionList := TFhirCodeableConceptList.Create;
  result := FContributionList;
end;

function TFhirCitationContributorshipEntry.GetHasContributionList : boolean;
begin
  result := (FContributionList <> nil) and (FContributionList.count > 0);
end;

procedure TFhirCitationContributorshipEntry.SetNotAnAuthor(value : TFhirBoolean);
begin
  FNotAnAuthor.free;
  FNotAnAuthor := value; {L1134}
end;

function TFhirCitationContributorshipEntry.GetNotAnAuthorST : Boolean;
begin
  if FNotAnAuthor = nil then
    result := false
  else
    result := FNotAnAuthor.value;
end;

procedure TFhirCitationContributorshipEntry.SetNotAnAuthorST(value : Boolean);
begin
  if FNotAnAuthor = nil then
    FNotAnAuthor := TFhirBoolean.create;
  FNotAnAuthor.value := value
end;

procedure TFhirCitationContributorshipEntry.SetCorrespondingAuthor(value : TFhirBoolean);
begin
  FCorrespondingAuthor.free;
  FCorrespondingAuthor := value; {L1134}
end;

function TFhirCitationContributorshipEntry.GetCorrespondingAuthorST : Boolean;
begin
  if FCorrespondingAuthor = nil then
    result := false
  else
    result := FCorrespondingAuthor.value;
end;

procedure TFhirCitationContributorshipEntry.SetCorrespondingAuthorST(value : Boolean);
begin
  if FCorrespondingAuthor = nil then
    FCorrespondingAuthor := TFhirBoolean.create;
  FCorrespondingAuthor.value := value
end;

procedure TFhirCitationContributorshipEntry.SetListOrder(value : TFhirPositiveInt);
begin
  FListOrder.free;
  FListOrder := value; {L1134}
end;

function TFhirCitationContributorshipEntry.GetListOrderST : String;
begin
  if FListOrder = nil then
    result := ''
  else
    result := FListOrder.value;
end;

procedure TFhirCitationContributorshipEntry.SetListOrderST(value : String);
begin
  if value <> '' then
  begin
    if FListOrder = nil then
      FListOrder := TFhirPositiveInt.create;
    FListOrder.value := value
  end
  else if FListOrder <> nil then
    FListOrder.value := '';
end;

procedure TFhirCitationContributorshipEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('initials');
  fields.add('collectiveName');
  fields.add('identifier');
  fields.add('affiliationInfo');
  fields.add('address');
  fields.add('telecom');
  fields.add('contribution');
  fields.add('notAnAuthor');
  fields.add('correspondingAuthor');
  fields.add('listOrder');
end;

function TFhirCitationContributorshipEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FInitials.sizeInBytes);
  inc(result, FCollectiveName.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FaffiliationInfoList.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FcontributionList.sizeInBytes);
  inc(result, FNotAnAuthor.sizeInBytes);
  inc(result, FCorrespondingAuthor.sizeInBytes);
  inc(result, FListOrder.sizeInBytes);
end;

{ TFhirCitationContributorshipEntryListEnumerator }

constructor TFhirCitationContributorshipEntryListEnumerator.Create(list : TFhirCitationContributorshipEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationContributorshipEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationContributorshipEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationContributorshipEntryListEnumerator.GetCurrent : TFhirCitationContributorshipEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCitationContributorshipEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationContributorshipEntryList }

procedure TFhirCitationContributorshipEntryList.AddItem(value: TFhirCitationContributorshipEntry);
begin
  assert(value.ClassName = 'TFhirCitationContributorshipEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationContributorshipEntry');
  add(value);
end;

function TFhirCitationContributorshipEntryList.Append: TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCitationContributorshipEntryList.GetEnumerator : TFhirCitationContributorshipEntryListEnumerator;
begin
  result := TFhirCitationContributorshipEntryListEnumerator.Create(self.link);
end;

function TFhirCitationContributorshipEntryList.Clone: TFhirCitationContributorshipEntryList;
begin
  result := TFhirCitationContributorshipEntryList(inherited Clone);
end;

function TFhirCitationContributorshipEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationContributorshipEntryList.GetItemN(index: Integer): TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationContributorshipEntry;
end;
function TFhirCitationContributorshipEntryList.IndexOf(value: TFhirCitationContributorshipEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationContributorshipEntryList.Insert(index: Integer): TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipEntryList.InsertItem(index: Integer; value: TFhirCitationContributorshipEntry);
begin
  assert(value is TFhirCitationContributorshipEntry);
  Inherited Insert(index, value);
end;

function TFhirCitationContributorshipEntryList.Item(index: Integer): TFhirCitationContributorshipEntry;
begin
  result := TFhirCitationContributorshipEntry(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipEntryList.Link: TFhirCitationContributorshipEntryList;
begin
  result := TFhirCitationContributorshipEntryList(inherited Link);
end;

procedure TFhirCitationContributorshipEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationContributorshipEntryList.SetItemByIndex(index: Integer; value: TFhirCitationContributorshipEntry);
begin
  assert(value is TFhirCitationContributorshipEntry);
  FhirCitationContributorshipEntries[index] := value;
end;

procedure TFhirCitationContributorshipEntryList.SetItemN(index: Integer; value: TFhirCitationContributorshipEntry);
begin
  assert(value is TFhirCitationContributorshipEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationContributorshipEntryAffiliationInfo }

constructor TFhirCitationContributorshipEntryAffiliationInfo.Create;
begin
  inherited;
end;

destructor TFhirCitationContributorshipEntryAffiliationInfo.Destroy;
begin
  FAffiliation.free;
  FRole.free;
  FIdentifierList.Free;
  inherited;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.Assign(oSource : TFslObject);
begin
  inherited;
  affiliationElement := TFhirCitationContributorshipEntryAffiliationInfo(oSource).affiliationElement.Clone;
  roleElement := TFhirCitationContributorshipEntryAffiliationInfo(oSource).roleElement.Clone;
  if (TFhirCitationContributorshipEntryAffiliationInfo(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationContributorshipEntryAffiliationInfo(oSource).FIdentifierList);
  end;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'affiliation') Then
     list.add(self.link, 'affiliation', FAffiliation.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'affiliation', 'string', false, TFhirString, FAffiliation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'role', 'string', false, TFhirString, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
end;

function TFhirCitationContributorshipEntryAffiliationInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'affiliation') then
  begin
    AffiliationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirCitationContributorshipEntryAffiliationInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'affiliation') then result := TFhirString.create() {L1223}
  else if (propName = 'role') then result := TFhirString.create() {L1223}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationContributorshipEntryAffiliationInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'affiliation') then result := 'string'
  else if (propName = 'role') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'affiliation') then AffiliationElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'affiliation') then AffiliationElement := asString(new) {L1222}
  else if (propName = 'role') then RoleElement := asString(new) {L1222}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationContributorshipEntryAffiliationInfo.fhirType : string;
begin
  result := 'Citation.contributorship.entry.affiliationInfo';
end;

function TFhirCitationContributorshipEntryAffiliationInfo.Link : TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo(inherited Link);
end;

function TFhirCitationContributorshipEntryAffiliationInfo.Clone : TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo(inherited Clone);
end;

function TFhirCitationContributorshipEntryAffiliationInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationContributorshipEntryAffiliationInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationContributorshipEntryAffiliationInfo)) then
    result := false
  else
  begin
    o := TFhirCitationContributorshipEntryAffiliationInfo(other);
    result := compareDeep(affiliationElement, o.affiliationElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(identifierList, o.identifierList, true);
  end;
end;

function TFhirCitationContributorshipEntryAffiliationInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAffiliation) and isEmptyProp(FRole) and isEmptyProp(FidentifierList);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.SetAffiliation(value : TFhirString);
begin
  FAffiliation.free;
  FAffiliation := value; {L1134}
end;

function TFhirCitationContributorshipEntryAffiliationInfo.GetAffiliationST : String;
begin
  if FAffiliation = nil then
    result := ''
  else
    result := FAffiliation.value;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.SetAffiliationST(value : String);
begin
  if value <> '' then
  begin
    if FAffiliation = nil then
      FAffiliation := TFhirString.create;
    FAffiliation.value := value
  end
  else if FAffiliation <> nil then
    FAffiliation.value := '';
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.SetRole(value : TFhirString);
begin
  FRole.free;
  FRole := value; {L1134}
end;

function TFhirCitationContributorshipEntryAffiliationInfo.GetRoleST : String;
begin
  if FRole = nil then
    result := ''
  else
    result := FRole.value;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.SetRoleST(value : String);
begin
  if value <> '' then
  begin
    if FRole = nil then
      FRole := TFhirString.create;
    FRole.value := value
  end
  else if FRole <> nil then
    FRole.value := '';
end;

function TFhirCitationContributorshipEntryAffiliationInfo.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationContributorshipEntryAffiliationInfo.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('affiliation');
  fields.add('role');
  fields.add('identifier');
end;

function TFhirCitationContributorshipEntryAffiliationInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAffiliation.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
end;

{ TFhirCitationContributorshipEntryAffiliationInfoListEnumerator }

constructor TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.Create(list : TFhirCitationContributorshipEntryAffiliationInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.GetCurrent : TFhirCitationContributorshipEntryAffiliationInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationContributorshipEntryAffiliationInfoList }

procedure TFhirCitationContributorshipEntryAffiliationInfoList.AddItem(value: TFhirCitationContributorshipEntryAffiliationInfo);
begin
  assert(value.ClassName = 'TFhirCitationContributorshipEntryAffiliationInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationContributorshipEntryAffiliationInfo');
  add(value);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Append: TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.GetEnumerator : TFhirCitationContributorshipEntryAffiliationInfoListEnumerator;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfoListEnumerator.Create(self.link);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Clone: TFhirCitationContributorshipEntryAffiliationInfoList;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfoList(inherited Clone);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.GetItemN(index: Integer): TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo;
end;
function TFhirCitationContributorshipEntryAffiliationInfoList.IndexOf(value: TFhirCitationContributorshipEntryAffiliationInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Insert(index: Integer): TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfoList.InsertItem(index: Integer; value: TFhirCitationContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationContributorshipEntryAffiliationInfo);
  Inherited Insert(index, value);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Item(index: Integer): TFhirCitationContributorshipEntryAffiliationInfo;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfo(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipEntryAffiliationInfoList.Link: TFhirCitationContributorshipEntryAffiliationInfoList;
begin
  result := TFhirCitationContributorshipEntryAffiliationInfoList(inherited Link);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationContributorshipEntryAffiliationInfoList.SetItemByIndex(index: Integer; value: TFhirCitationContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationContributorshipEntryAffiliationInfo);
  FhirCitationContributorshipEntryAffiliationInfos[index] := value;
end;

procedure TFhirCitationContributorshipEntryAffiliationInfoList.SetItemN(index: Integer; value: TFhirCitationContributorshipEntryAffiliationInfo);
begin
  assert(value is TFhirCitationContributorshipEntryAffiliationInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationContributorshipSummary }

constructor TFhirCitationContributorshipSummary.Create;
begin
  inherited;
end;

destructor TFhirCitationContributorshipSummary.Destroy;
begin
  FType_.free;
  FStyle.free;
  FSource.free;
  FValue.free;
  inherited;
end;

procedure TFhirCitationContributorshipSummary.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationContributorshipSummary(oSource).type_.Clone;
  style := TFhirCitationContributorshipSummary(oSource).style.Clone;
  source := TFhirCitationContributorshipSummary(oSource).source.Clone;
  valueElement := TFhirCitationContributorshipSummary(oSource).valueElement.Clone;
end;

procedure TFhirCitationContributorshipSummary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'style') Then
     list.add(self.link, 'style', FStyle.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCitationContributorshipSummary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'style', 'CodeableConcept', false, TFhirCodeableConcept, FStyle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'CodeableConcept', false, TFhirCodeableConcept, FSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'markdown', false, TFhirMarkdown, FValue.Link)); {L1172}
end;

function TFhirCitationContributorshipSummary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'style') then
  begin
    Style := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationContributorshipSummary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationContributorshipSummary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'style') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'value') then result := TFhirMarkdown.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationContributorshipSummary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'style') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationContributorshipSummary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'style') then StyleElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationContributorshipSummary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'style') then StyleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then SourceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'value') then ValueElement := asMarkdown(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationContributorshipSummary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationContributorshipSummary.fhirType : string;
begin
  result := 'Citation.contributorship.summary';
end;

function TFhirCitationContributorshipSummary.Link : TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary(inherited Link);
end;

function TFhirCitationContributorshipSummary.Clone : TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary(inherited Clone);
end;

function TFhirCitationContributorshipSummary.equals(other : TObject) : boolean; 
var
  o : TFhirCitationContributorshipSummary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationContributorshipSummary)) then
    result := false
  else
  begin
    o := TFhirCitationContributorshipSummary(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(styleElement, o.styleElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCitationContributorshipSummary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FStyle) and isEmptyProp(FSource) and isEmptyProp(FValue);
end;

procedure TFhirCitationContributorshipSummary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationContributorshipSummary.SetStyle(value : TFhirCodeableConcept);
begin
  FStyle.free;
  FStyle := value; {L1134}
end;

procedure TFhirCitationContributorshipSummary.SetSource(value : TFhirCodeableConcept);
begin
  FSource.free;
  FSource := value; {L1134}
end;

procedure TFhirCitationContributorshipSummary.SetValue(value : TFhirMarkdown);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirCitationContributorshipSummary.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationContributorshipSummary.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirMarkdown.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCitationContributorshipSummary.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('style');
  fields.add('source');
  fields.add('value');
end;

function TFhirCitationContributorshipSummary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FStyle.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirCitationContributorshipSummaryListEnumerator }

constructor TFhirCitationContributorshipSummaryListEnumerator.Create(list : TFhirCitationContributorshipSummaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationContributorshipSummaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationContributorshipSummaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationContributorshipSummaryListEnumerator.GetCurrent : TFhirCitationContributorshipSummary;
begin
  Result := FList[FIndex];
end;

function TFhirCitationContributorshipSummaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationContributorshipSummaryList }

procedure TFhirCitationContributorshipSummaryList.AddItem(value: TFhirCitationContributorshipSummary);
begin
  assert(value.ClassName = 'TFhirCitationContributorshipSummary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationContributorshipSummary');
  add(value);
end;

function TFhirCitationContributorshipSummaryList.Append: TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipSummaryList.ClearItems;
begin
  Clear;
end;

function TFhirCitationContributorshipSummaryList.GetEnumerator : TFhirCitationContributorshipSummaryListEnumerator;
begin
  result := TFhirCitationContributorshipSummaryListEnumerator.Create(self.link);
end;

function TFhirCitationContributorshipSummaryList.Clone: TFhirCitationContributorshipSummaryList;
begin
  result := TFhirCitationContributorshipSummaryList(inherited Clone);
end;

function TFhirCitationContributorshipSummaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationContributorshipSummaryList.GetItemN(index: Integer): TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipSummaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationContributorshipSummary;
end;
function TFhirCitationContributorshipSummaryList.IndexOf(value: TFhirCitationContributorshipSummary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationContributorshipSummaryList.Insert(index: Integer): TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationContributorshipSummaryList.InsertItem(index: Integer; value: TFhirCitationContributorshipSummary);
begin
  assert(value is TFhirCitationContributorshipSummary);
  Inherited Insert(index, value);
end;

function TFhirCitationContributorshipSummaryList.Item(index: Integer): TFhirCitationContributorshipSummary;
begin
  result := TFhirCitationContributorshipSummary(ObjectByIndex[index]);
end;

function TFhirCitationContributorshipSummaryList.Link: TFhirCitationContributorshipSummaryList;
begin
  result := TFhirCitationContributorshipSummaryList(inherited Link);
end;

procedure TFhirCitationContributorshipSummaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationContributorshipSummaryList.SetItemByIndex(index: Integer; value: TFhirCitationContributorshipSummary);
begin
  assert(value is TFhirCitationContributorshipSummary);
  FhirCitationContributorshipSummaries[index] := value;
end;

procedure TFhirCitationContributorshipSummaryList.SetItemN(index: Integer; value: TFhirCitationContributorshipSummary);
begin
  assert(value is TFhirCitationContributorshipSummary);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeForm }

constructor TFhirCitationAlternativeForm.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeForm.Destroy;
begin
  FPublishingModel.free;
  FLanguage.free;
  FJournalIssue.free;
  FPagination.free;
  FPublicationInfo.free;
  inherited;
end;

procedure TFhirCitationAlternativeForm.Assign(oSource : TFslObject);
begin
  inherited;
  publishingModel := TFhirCitationAlternativeForm(oSource).publishingModel.Clone;
  language := TFhirCitationAlternativeForm(oSource).language.Clone;
  journalIssue := TFhirCitationAlternativeForm(oSource).journalIssue.Clone;
  pagination := TFhirCitationAlternativeForm(oSource).pagination.Clone;
  publicationInfo := TFhirCitationAlternativeForm(oSource).publicationInfo.Clone;
end;

procedure TFhirCitationAlternativeForm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'publishingModel') Then
     list.add(self.link, 'publishingModel', FPublishingModel.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'journalIssue') Then
     list.add(self.link, 'journalIssue', FJournalIssue.Link);
  if (child_name = 'pagination') Then
     list.add(self.link, 'pagination', FPagination.Link);
  if (child_name = 'publicationInfo') Then
     list.add(self.link, 'publicationInfo', FPublicationInfo.Link);
end;

procedure TFhirCitationAlternativeForm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'publishingModel', 'CodeableConcept', false, TFhirCodeableConcept, FPublishingModel.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'journalIssue', 'BackboneElement', false, TFhirCitationAlternativeFormJournalIssue, FJournalIssue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pagination', 'BackboneElement', false, TFhirCitationAlternativeFormPagination, FPagination.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publicationInfo', 'BackboneElement', false, TFhirCitationAlternativeFormPublicationInfo, FPublicationInfo.Link)); {L1172}
end;

function TFhirCitationAlternativeForm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'publishingModel') then
  begin
    PublishingModel := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'journalIssue') then
  begin
    JournalIssue := propValue as TFhirCitationAlternativeFormJournalIssue {L1199};
    result := propValue;
  end
  else if (propName = 'pagination') then
  begin
    Pagination := propValue as TFhirCitationAlternativeFormPagination {L1199};
    result := propValue;
  end
  else if (propName = 'publicationInfo') then
  begin
    PublicationInfo := propValue as TFhirCitationAlternativeFormPublicationInfo {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeForm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeForm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'publishingModel') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'journalIssue') then result := TFhirCitationAlternativeFormJournalIssue.create() {L1203}
  else if (propName = 'pagination') then result := TFhirCitationAlternativeFormPagination.create() {L1203}
  else if (propName = 'publicationInfo') then result := TFhirCitationAlternativeFormPublicationInfo.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeForm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'publishingModel') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'journalIssue') then result := 'BackboneElement'
  else if (propName = 'pagination') then result := 'BackboneElement'
  else if (propName = 'publicationInfo') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeForm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'publishingModel') then PublishingModelElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'journalIssue') then JournalIssueElement := nil
  else if (propName = 'pagination') then PaginationElement := nil
  else if (propName = 'publicationInfo') then PublicationInfoElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeForm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'publishingModel') then PublishingModelElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'journalIssue') then JournalIssueElement := new as TFhirCitationAlternativeFormJournalIssue {L1195}
  else if (propName = 'pagination') then PaginationElement := new as TFhirCitationAlternativeFormPagination {L1195}
  else if (propName = 'publicationInfo') then PublicationInfoElement := new as TFhirCitationAlternativeFormPublicationInfo {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeForm.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeForm.fhirType : string;
begin
  result := 'Citation.alternativeForm';
end;

function TFhirCitationAlternativeForm.Link : TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm(inherited Link);
end;

function TFhirCitationAlternativeForm.Clone : TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm(inherited Clone);
end;

function TFhirCitationAlternativeForm.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeForm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeForm)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeForm(other);
    result := compareDeep(publishingModelElement, o.publishingModelElement, true) and 
      compareDeep(languageElement, o.languageElement, true) and compareDeep(journalIssueElement, o.journalIssueElement, true) and 
      compareDeep(paginationElement, o.paginationElement, true) and compareDeep(publicationInfoElement, o.publicationInfoElement, true);
  end;
end;

function TFhirCitationAlternativeForm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPublishingModel) and isEmptyProp(FLanguage) and isEmptyProp(FJournalIssue) and isEmptyProp(FPagination) and isEmptyProp(FPublicationInfo);
end;

procedure TFhirCitationAlternativeForm.SetPublishingModel(value : TFhirCodeableConcept);
begin
  FPublishingModel.free;
  FPublishingModel := value; {L1134}
end;

procedure TFhirCitationAlternativeForm.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirCitationAlternativeForm.SetJournalIssue(value : TFhirCitationAlternativeFormJournalIssue);
begin
  FJournalIssue.free;
  FJournalIssue := value; {L1134}
end;

procedure TFhirCitationAlternativeForm.SetPagination(value : TFhirCitationAlternativeFormPagination);
begin
  FPagination.free;
  FPagination := value; {L1134}
end;

procedure TFhirCitationAlternativeForm.SetPublicationInfo(value : TFhirCitationAlternativeFormPublicationInfo);
begin
  FPublicationInfo.free;
  FPublicationInfo := value; {L1134}
end;

procedure TFhirCitationAlternativeForm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('publishingModel');
  fields.add('language');
  fields.add('journalIssue');
  fields.add('pagination');
  fields.add('publicationInfo');
end;

function TFhirCitationAlternativeForm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPublishingModel.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FJournalIssue.sizeInBytes);
  inc(result, FPagination.sizeInBytes);
  inc(result, FPublicationInfo.sizeInBytes);
end;

{ TFhirCitationAlternativeFormListEnumerator }

constructor TFhirCitationAlternativeFormListEnumerator.Create(list : TFhirCitationAlternativeFormList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormListEnumerator.GetCurrent : TFhirCitationAlternativeForm;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormList }

procedure TFhirCitationAlternativeFormList.AddItem(value: TFhirCitationAlternativeForm);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeForm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeForm');
  add(value);
end;

function TFhirCitationAlternativeFormList.Append: TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormList.GetEnumerator : TFhirCitationAlternativeFormListEnumerator;
begin
  result := TFhirCitationAlternativeFormListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormList.Clone: TFhirCitationAlternativeFormList;
begin
  result := TFhirCitationAlternativeFormList(inherited Clone);
end;

function TFhirCitationAlternativeFormList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormList.GetItemN(index: Integer): TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeForm;
end;
function TFhirCitationAlternativeFormList.IndexOf(value: TFhirCitationAlternativeForm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormList.Insert(index: Integer): TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormList.InsertItem(index: Integer; value: TFhirCitationAlternativeForm);
begin
  assert(value is TFhirCitationAlternativeForm);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormList.Item(index: Integer): TFhirCitationAlternativeForm;
begin
  result := TFhirCitationAlternativeForm(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormList.Link: TFhirCitationAlternativeFormList;
begin
  result := TFhirCitationAlternativeFormList(inherited Link);
end;

procedure TFhirCitationAlternativeFormList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeForm);
begin
  assert(value is TFhirCitationAlternativeForm);
  FhirCitationAlternativeForms[index] := value;
end;

procedure TFhirCitationAlternativeFormList.SetItemN(index: Integer; value: TFhirCitationAlternativeForm);
begin
  assert(value is TFhirCitationAlternativeForm);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeFormJournalIssue }

constructor TFhirCitationAlternativeFormJournalIssue.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeFormJournalIssue.Destroy;
begin
  FCitedMedium.free;
  FVolume.free;
  FIssue.free;
  FPublicationDate.free;
  inherited;
end;

procedure TFhirCitationAlternativeFormJournalIssue.Assign(oSource : TFslObject);
begin
  inherited;
  citedMedium := TFhirCitationAlternativeFormJournalIssue(oSource).citedMedium.Clone;
  volumeElement := TFhirCitationAlternativeFormJournalIssue(oSource).volumeElement.Clone;
  issueElement := TFhirCitationAlternativeFormJournalIssue(oSource).issueElement.Clone;
  publicationDate := TFhirCitationAlternativeFormJournalIssue(oSource).publicationDate.Clone;
end;

procedure TFhirCitationAlternativeFormJournalIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'citedMedium') Then
     list.add(self.link, 'citedMedium', FCitedMedium.Link);
  if (child_name = 'volume') Then
     list.add(self.link, 'volume', FVolume.Link);
  if (child_name = 'issue') Then
     list.add(self.link, 'issue', FIssue.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
end;

procedure TFhirCitationAlternativeFormJournalIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'citedMedium', 'CodeableConcept', false, TFhirCodeableConcept, FCitedMedium.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'volume', 'string', false, TFhirString, FVolume.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issue', 'string', false, TFhirString, FIssue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'BackboneElement', false, TFhirCitationAlternativeFormJournalIssuePublicationDate, FPublicationDate.Link)); {L1172}
end;

function TFhirCitationAlternativeFormJournalIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'citedMedium') then
  begin
    CitedMedium := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'volume') then
  begin
    VolumeElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'issue') then
  begin
    IssueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDate := propValue as TFhirCitationAlternativeFormJournalIssuePublicationDate {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeFormJournalIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeFormJournalIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'citedMedium') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'volume') then result := TFhirString.create() {L1223}
  else if (propName = 'issue') then result := TFhirString.create() {L1223}
  else if (propName = 'publicationDate') then result := TFhirCitationAlternativeFormJournalIssuePublicationDate.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeFormJournalIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'citedMedium') then result := 'CodeableConcept'
  else if (propName = 'volume') then result := 'string'
  else if (propName = 'issue') then result := 'string'
  else if (propName = 'publicationDate') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeFormJournalIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := nil
  else if (propName = 'volume') then VolumeElement := nil
  else if (propName = 'issue') then IssueElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeFormJournalIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'citedMedium') then CitedMediumElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'volume') then VolumeElement := asString(new) {L1222}
  else if (propName = 'issue') then IssueElement := asString(new) {L1222}
  else if (propName = 'publicationDate') then PublicationDateElement := new as TFhirCitationAlternativeFormJournalIssuePublicationDate {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeFormJournalIssue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeFormJournalIssue.fhirType : string;
begin
  result := 'Citation.alternativeForm.journalIssue';
end;

function TFhirCitationAlternativeFormJournalIssue.Link : TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue(inherited Link);
end;

function TFhirCitationAlternativeFormJournalIssue.Clone : TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue(inherited Clone);
end;

function TFhirCitationAlternativeFormJournalIssue.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeFormJournalIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeFormJournalIssue)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeFormJournalIssue(other);
    result := compareDeep(citedMediumElement, o.citedMediumElement, true) and compareDeep(volumeElement, o.volumeElement, true) and 
      compareDeep(issueElement, o.issueElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true);
  end;
end;

function TFhirCitationAlternativeFormJournalIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCitedMedium) and isEmptyProp(FVolume) and isEmptyProp(FIssue) and isEmptyProp(FPublicationDate);
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetCitedMedium(value : TFhirCodeableConcept);
begin
  FCitedMedium.free;
  FCitedMedium := value; {L1134}
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetVolume(value : TFhirString);
begin
  FVolume.free;
  FVolume := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssue.GetVolumeST : String;
begin
  if FVolume = nil then
    result := ''
  else
    result := FVolume.value;
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetVolumeST(value : String);
begin
  if value <> '' then
  begin
    if FVolume = nil then
      FVolume := TFhirString.create;
    FVolume.value := value
  end
  else if FVolume <> nil then
    FVolume.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetIssue(value : TFhirString);
begin
  FIssue.free;
  FIssue := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssue.GetIssueST : String;
begin
  if FIssue = nil then
    result := ''
  else
    result := FIssue.value;
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetIssueST(value : String);
begin
  if value <> '' then
  begin
    if FIssue = nil then
      FIssue := TFhirString.create;
    FIssue.value := value
  end
  else if FIssue <> nil then
    FIssue.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssue.SetPublicationDate(value : TFhirCitationAlternativeFormJournalIssuePublicationDate);
begin
  FPublicationDate.free;
  FPublicationDate := value; {L1134}
end;

procedure TFhirCitationAlternativeFormJournalIssue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('citedMedium');
  fields.add('volume');
  fields.add('issue');
  fields.add('publicationDate');
end;

function TFhirCitationAlternativeFormJournalIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCitedMedium.sizeInBytes);
  inc(result, FVolume.sizeInBytes);
  inc(result, FIssue.sizeInBytes);
  inc(result, FPublicationDate.sizeInBytes);
end;

{ TFhirCitationAlternativeFormJournalIssueListEnumerator }

constructor TFhirCitationAlternativeFormJournalIssueListEnumerator.Create(list : TFhirCitationAlternativeFormJournalIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormJournalIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormJournalIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormJournalIssueListEnumerator.GetCurrent : TFhirCitationAlternativeFormJournalIssue;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormJournalIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormJournalIssueList }

procedure TFhirCitationAlternativeFormJournalIssueList.AddItem(value: TFhirCitationAlternativeFormJournalIssue);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeFormJournalIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeFormJournalIssue');
  add(value);
end;

function TFhirCitationAlternativeFormJournalIssueList.Append: TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormJournalIssueList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormJournalIssueList.GetEnumerator : TFhirCitationAlternativeFormJournalIssueListEnumerator;
begin
  result := TFhirCitationAlternativeFormJournalIssueListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormJournalIssueList.Clone: TFhirCitationAlternativeFormJournalIssueList;
begin
  result := TFhirCitationAlternativeFormJournalIssueList(inherited Clone);
end;

function TFhirCitationAlternativeFormJournalIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormJournalIssueList.GetItemN(index: Integer): TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormJournalIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeFormJournalIssue;
end;
function TFhirCitationAlternativeFormJournalIssueList.IndexOf(value: TFhirCitationAlternativeFormJournalIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormJournalIssueList.Insert(index: Integer): TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormJournalIssueList.InsertItem(index: Integer; value: TFhirCitationAlternativeFormJournalIssue);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssue);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormJournalIssueList.Item(index: Integer): TFhirCitationAlternativeFormJournalIssue;
begin
  result := TFhirCitationAlternativeFormJournalIssue(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormJournalIssueList.Link: TFhirCitationAlternativeFormJournalIssueList;
begin
  result := TFhirCitationAlternativeFormJournalIssueList(inherited Link);
end;

procedure TFhirCitationAlternativeFormJournalIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormJournalIssueList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeFormJournalIssue);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssue);
  FhirCitationAlternativeFormJournalIssues[index] := value;
end;

procedure TFhirCitationAlternativeFormJournalIssueList.SetItemN(index: Integer; value: TFhirCitationAlternativeFormJournalIssue);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeFormJournalIssuePublicationDate }

constructor TFhirCitationAlternativeFormJournalIssuePublicationDate.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeFormJournalIssuePublicationDate.Destroy;
begin
  FDate.free;
  FYear.free;
  FMonth.free;
  FDay.free;
  FSeason.free;
  FText.free;
  inherited;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).dateElement.Clone;
  yearElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).yearElement.Clone;
  monthElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).monthElement.Clone;
  dayElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).dayElement.Clone;
  seasonElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).seasonElement.Clone;
  textElement := TFhirCitationAlternativeFormJournalIssuePublicationDate(oSource).textElement.Clone;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'year') Then
     list.add(self.link, 'year', FYear.Link);
  if (child_name = 'month') Then
     list.add(self.link, 'month', FMonth.Link);
  if (child_name = 'day') Then
     list.add(self.link, 'day', FDay.Link);
  if (child_name = 'season') Then
     list.add(self.link, 'season', FSeason.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'year', 'string', false, TFhirString, FYear.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'month', 'string', false, TFhirString, FMonth.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'day', 'string', false, TFhirString, FDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'season', 'string', false, TFhirString, FSeason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'year') then
  begin
    YearElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'month') then
  begin
    MonthElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'day') then
  begin
    DayElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'season') then
  begin
    SeasonElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'year') then result := TFhirString.create() {L1223}
  else if (propName = 'month') then result := TFhirString.create() {L1223}
  else if (propName = 'day') then result := TFhirString.create() {L1223}
  else if (propName = 'season') then result := TFhirString.create() {L1223}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'year') then result := 'string'
  else if (propName = 'month') then result := 'string'
  else if (propName = 'day') then result := 'string'
  else if (propName = 'season') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'year') then YearElement := nil
  else if (propName = 'month') then MonthElement := nil
  else if (propName = 'day') then DayElement := nil
  else if (propName = 'season') then SeasonElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'year') then YearElement := asString(new) {L1222}
  else if (propName = 'month') then MonthElement := asString(new) {L1222}
  else if (propName = 'day') then DayElement := asString(new) {L1222}
  else if (propName = 'season') then SeasonElement := asString(new) {L1222}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.fhirType : string;
begin
  result := 'Citation.alternativeForm.journalIssue.publicationDate';
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.Link : TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate(inherited Link);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.Clone : TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate(inherited Clone);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeFormJournalIssuePublicationDate)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeFormJournalIssuePublicationDate(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(yearElement, o.yearElement, true) and 
      compareDeep(monthElement, o.monthElement, true) and compareDeep(dayElement, o.dayElement, true) and 
      compareDeep(seasonElement, o.seasonElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FYear) and isEmptyProp(FMonth) and isEmptyProp(FDay) and isEmptyProp(FSeason) and isEmptyProp(FText);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetYear(value : TFhirString);
begin
  FYear.free;
  FYear := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetYearST : String;
begin
  if FYear = nil then
    result := ''
  else
    result := FYear.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetYearST(value : String);
begin
  if value <> '' then
  begin
    if FYear = nil then
      FYear := TFhirString.create;
    FYear.value := value
  end
  else if FYear <> nil then
    FYear.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetMonth(value : TFhirString);
begin
  FMonth.free;
  FMonth := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetMonthST : String;
begin
  if FMonth = nil then
    result := ''
  else
    result := FMonth.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetMonthST(value : String);
begin
  if value <> '' then
  begin
    if FMonth = nil then
      FMonth := TFhirString.create;
    FMonth.value := value
  end
  else if FMonth <> nil then
    FMonth.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetDay(value : TFhirString);
begin
  FDay.free;
  FDay := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetDayST : String;
begin
  if FDay = nil then
    result := ''
  else
    result := FDay.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetDayST(value : String);
begin
  if value <> '' then
  begin
    if FDay = nil then
      FDay := TFhirString.create;
    FDay.value := value
  end
  else if FDay <> nil then
    FDay.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetSeason(value : TFhirString);
begin
  FSeason.free;
  FSeason := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetSeasonST : String;
begin
  if FSeason = nil then
    result := ''
  else
    result := FSeason.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetSeasonST(value : String);
begin
  if value <> '' then
  begin
    if FSeason = nil then
      FSeason := TFhirString.create;
    FSeason.value := value
  end
  else if FSeason <> nil then
    FSeason.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('year');
  fields.add('month');
  fields.add('day');
  fields.add('season');
  fields.add('text');
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FYear.sizeInBytes);
  inc(result, FMonth.sizeInBytes);
  inc(result, FDay.sizeInBytes);
  inc(result, FSeason.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator }

constructor TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.Create(list : TFhirCitationAlternativeFormJournalIssuePublicationDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.GetCurrent : TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormJournalIssuePublicationDateList }

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.AddItem(value: TFhirCitationAlternativeFormJournalIssuePublicationDate);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeFormJournalIssuePublicationDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeFormJournalIssuePublicationDate');
  add(value);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Append: TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.GetEnumerator : TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDateListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Clone: TFhirCitationAlternativeFormJournalIssuePublicationDateList;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDateList(inherited Clone);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.GetItemN(index: Integer): TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate;
end;
function TFhirCitationAlternativeFormJournalIssuePublicationDateList.IndexOf(value: TFhirCitationAlternativeFormJournalIssuePublicationDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Insert(index: Integer): TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.InsertItem(index: Integer; value: TFhirCitationAlternativeFormJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssuePublicationDate);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Item(index: Integer): TFhirCitationAlternativeFormJournalIssuePublicationDate;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDate(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormJournalIssuePublicationDateList.Link: TFhirCitationAlternativeFormJournalIssuePublicationDateList;
begin
  result := TFhirCitationAlternativeFormJournalIssuePublicationDateList(inherited Link);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeFormJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssuePublicationDate);
  FhirCitationAlternativeFormJournalIssuePublicationDates[index] := value;
end;

procedure TFhirCitationAlternativeFormJournalIssuePublicationDateList.SetItemN(index: Integer; value: TFhirCitationAlternativeFormJournalIssuePublicationDate);
begin
  assert(value is TFhirCitationAlternativeFormJournalIssuePublicationDate);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeFormPagination }

constructor TFhirCitationAlternativeFormPagination.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeFormPagination.Destroy;
begin
  FPageString.free;
  FFirstPage.free;
  FLastPage.free;
  inherited;
end;

procedure TFhirCitationAlternativeFormPagination.Assign(oSource : TFslObject);
begin
  inherited;
  pageStringElement := TFhirCitationAlternativeFormPagination(oSource).pageStringElement.Clone;
  firstPageElement := TFhirCitationAlternativeFormPagination(oSource).firstPageElement.Clone;
  lastPageElement := TFhirCitationAlternativeFormPagination(oSource).lastPageElement.Clone;
end;

procedure TFhirCitationAlternativeFormPagination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'pageString') Then
     list.add(self.link, 'pageString', FPageString.Link);
  if (child_name = 'firstPage') Then
     list.add(self.link, 'firstPage', FFirstPage.Link);
  if (child_name = 'lastPage') Then
     list.add(self.link, 'lastPage', FLastPage.Link);
end;

procedure TFhirCitationAlternativeFormPagination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'pageString', 'string', false, TFhirString, FPageString.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'firstPage', 'string', false, TFhirString, FFirstPage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lastPage', 'string', false, TFhirString, FLastPage.Link)); {L1172}
end;

function TFhirCitationAlternativeFormPagination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'pageString') then
  begin
    PageStringElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'firstPage') then
  begin
    FirstPageElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'lastPage') then
  begin
    LastPageElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeFormPagination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeFormPagination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'pageString') then result := TFhirString.create() {L1223}
  else if (propName = 'firstPage') then result := TFhirString.create() {L1223}
  else if (propName = 'lastPage') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeFormPagination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'pageString') then result := 'string'
  else if (propName = 'firstPage') then result := 'string'
  else if (propName = 'lastPage') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeFormPagination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'pageString') then PageStringElement := nil
  else if (propName = 'firstPage') then FirstPageElement := nil
  else if (propName = 'lastPage') then LastPageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeFormPagination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'pageString') then PageStringElement := asString(new) {L1222}
  else if (propName = 'firstPage') then FirstPageElement := asString(new) {L1222}
  else if (propName = 'lastPage') then LastPageElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeFormPagination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeFormPagination.fhirType : string;
begin
  result := 'Citation.alternativeForm.pagination';
end;

function TFhirCitationAlternativeFormPagination.Link : TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination(inherited Link);
end;

function TFhirCitationAlternativeFormPagination.Clone : TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination(inherited Clone);
end;

function TFhirCitationAlternativeFormPagination.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeFormPagination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeFormPagination)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeFormPagination(other);
    result := compareDeep(pageStringElement, o.pageStringElement, true) and compareDeep(firstPageElement, o.firstPageElement, true) and 
      compareDeep(lastPageElement, o.lastPageElement, true);
  end;
end;

function TFhirCitationAlternativeFormPagination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPageString) and isEmptyProp(FFirstPage) and isEmptyProp(FLastPage);
end;

procedure TFhirCitationAlternativeFormPagination.SetPageString(value : TFhirString);
begin
  FPageString.free;
  FPageString := value; {L1134}
end;

function TFhirCitationAlternativeFormPagination.GetPageStringST : String;
begin
  if FPageString = nil then
    result := ''
  else
    result := FPageString.value;
end;

procedure TFhirCitationAlternativeFormPagination.SetPageStringST(value : String);
begin
  if value <> '' then
  begin
    if FPageString = nil then
      FPageString := TFhirString.create;
    FPageString.value := value
  end
  else if FPageString <> nil then
    FPageString.value := '';
end;

procedure TFhirCitationAlternativeFormPagination.SetFirstPage(value : TFhirString);
begin
  FFirstPage.free;
  FFirstPage := value; {L1134}
end;

function TFhirCitationAlternativeFormPagination.GetFirstPageST : String;
begin
  if FFirstPage = nil then
    result := ''
  else
    result := FFirstPage.value;
end;

procedure TFhirCitationAlternativeFormPagination.SetFirstPageST(value : String);
begin
  if value <> '' then
  begin
    if FFirstPage = nil then
      FFirstPage := TFhirString.create;
    FFirstPage.value := value
  end
  else if FFirstPage <> nil then
    FFirstPage.value := '';
end;

procedure TFhirCitationAlternativeFormPagination.SetLastPage(value : TFhirString);
begin
  FLastPage.free;
  FLastPage := value; {L1134}
end;

function TFhirCitationAlternativeFormPagination.GetLastPageST : String;
begin
  if FLastPage = nil then
    result := ''
  else
    result := FLastPage.value;
end;

procedure TFhirCitationAlternativeFormPagination.SetLastPageST(value : String);
begin
  if value <> '' then
  begin
    if FLastPage = nil then
      FLastPage := TFhirString.create;
    FLastPage.value := value
  end
  else if FLastPage <> nil then
    FLastPage.value := '';
end;

procedure TFhirCitationAlternativeFormPagination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('pageString');
  fields.add('firstPage');
  fields.add('lastPage');
end;

function TFhirCitationAlternativeFormPagination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPageString.sizeInBytes);
  inc(result, FFirstPage.sizeInBytes);
  inc(result, FLastPage.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPaginationListEnumerator }

constructor TFhirCitationAlternativeFormPaginationListEnumerator.Create(list : TFhirCitationAlternativeFormPaginationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormPaginationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormPaginationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormPaginationListEnumerator.GetCurrent : TFhirCitationAlternativeFormPagination;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormPaginationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPaginationList }

procedure TFhirCitationAlternativeFormPaginationList.AddItem(value: TFhirCitationAlternativeFormPagination);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeFormPagination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeFormPagination');
  add(value);
end;

function TFhirCitationAlternativeFormPaginationList.Append: TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPaginationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormPaginationList.GetEnumerator : TFhirCitationAlternativeFormPaginationListEnumerator;
begin
  result := TFhirCitationAlternativeFormPaginationListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormPaginationList.Clone: TFhirCitationAlternativeFormPaginationList;
begin
  result := TFhirCitationAlternativeFormPaginationList(inherited Clone);
end;

function TFhirCitationAlternativeFormPaginationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormPaginationList.GetItemN(index: Integer): TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPaginationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeFormPagination;
end;
function TFhirCitationAlternativeFormPaginationList.IndexOf(value: TFhirCitationAlternativeFormPagination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormPaginationList.Insert(index: Integer): TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPaginationList.InsertItem(index: Integer; value: TFhirCitationAlternativeFormPagination);
begin
  assert(value is TFhirCitationAlternativeFormPagination);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormPaginationList.Item(index: Integer): TFhirCitationAlternativeFormPagination;
begin
  result := TFhirCitationAlternativeFormPagination(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPaginationList.Link: TFhirCitationAlternativeFormPaginationList;
begin
  result := TFhirCitationAlternativeFormPaginationList(inherited Link);
end;

procedure TFhirCitationAlternativeFormPaginationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormPaginationList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeFormPagination);
begin
  assert(value is TFhirCitationAlternativeFormPagination);
  FhirCitationAlternativeFormPaginations[index] := value;
end;

procedure TFhirCitationAlternativeFormPaginationList.SetItemN(index: Integer; value: TFhirCitationAlternativeFormPagination);
begin
  assert(value is TFhirCitationAlternativeFormPagination);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeFormPublicationInfo }

constructor TFhirCitationAlternativeFormPublicationInfo.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeFormPublicationInfo.Destroy;
begin
  FPublishedIn.free;
  FEntryDate.free;
  FRevisionDate.free;
  FPageCount.free;
  inherited;
end;

procedure TFhirCitationAlternativeFormPublicationInfo.Assign(oSource : TFslObject);
begin
  inherited;
  publishedIn := TFhirCitationAlternativeFormPublicationInfo(oSource).publishedIn.Clone;
  entryDateElement := TFhirCitationAlternativeFormPublicationInfo(oSource).entryDateElement.Clone;
  revisionDateElement := TFhirCitationAlternativeFormPublicationInfo(oSource).revisionDateElement.Clone;
  pageCountElement := TFhirCitationAlternativeFormPublicationInfo(oSource).pageCountElement.Clone;
end;

procedure TFhirCitationAlternativeFormPublicationInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'publishedIn') Then
     list.add(self.link, 'publishedIn', FPublishedIn.Link);
  if (child_name = 'entryDate') Then
     list.add(self.link, 'entryDate', FEntryDate.Link);
  if (child_name = 'revisionDate') Then
     list.add(self.link, 'revisionDate', FRevisionDate.Link);
  if (child_name = 'pageCount') Then
     list.add(self.link, 'pageCount', FPageCount.Link);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'publishedIn', 'BackboneElement', false, TFhirCitationAlternativeFormPublicationInfoPublishedIn, FPublishedIn.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entryDate', 'dateTime', false, TFhirDateTime, FEntryDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revisionDate', 'dateTime', false, TFhirDateTime, FRevisionDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pageCount', 'string', false, TFhirString, FPageCount.Link)); {L1172}
end;

function TFhirCitationAlternativeFormPublicationInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'publishedIn') then
  begin
    PublishedIn := propValue as TFhirCitationAlternativeFormPublicationInfoPublishedIn {L1199};
    result := propValue;
  end
  else if (propName = 'entryDate') then
  begin
    EntryDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revisionDate') then
  begin
    RevisionDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'pageCount') then
  begin
    PageCountElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeFormPublicationInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'publishedIn') then result := TFhirCitationAlternativeFormPublicationInfoPublishedIn.create() {L1203}
  else if (propName = 'entryDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'revisionDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'pageCount') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeFormPublicationInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'publishedIn') then result := 'BackboneElement'
  else if (propName = 'entryDate') then result := 'dateTime'
  else if (propName = 'revisionDate') then result := 'dateTime'
  else if (propName = 'pageCount') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := nil
  else if (propName = 'entryDate') then EntryDateElement := nil
  else if (propName = 'revisionDate') then RevisionDateElement := nil
  else if (propName = 'pageCount') then PageCountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'publishedIn') then PublishedInElement := new as TFhirCitationAlternativeFormPublicationInfoPublishedIn {L1195}
  else if (propName = 'entryDate') then EntryDateElement := asDateTime(new) {L1222}
  else if (propName = 'revisionDate') then RevisionDateElement := asDateTime(new) {L1222}
  else if (propName = 'pageCount') then PageCountElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeFormPublicationInfo.fhirType : string;
begin
  result := 'Citation.alternativeForm.publicationInfo';
end;

function TFhirCitationAlternativeFormPublicationInfo.Link : TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo(inherited Link);
end;

function TFhirCitationAlternativeFormPublicationInfo.Clone : TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo(inherited Clone);
end;

function TFhirCitationAlternativeFormPublicationInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeFormPublicationInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeFormPublicationInfo)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeFormPublicationInfo(other);
    result := compareDeep(publishedInElement, o.publishedInElement, true) and compareDeep(entryDateElement, o.entryDateElement, true) and 
      compareDeep(revisionDateElement, o.revisionDateElement, true) and compareDeep(pageCountElement, o.pageCountElement, true);
  end;
end;

function TFhirCitationAlternativeFormPublicationInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPublishedIn) and isEmptyProp(FEntryDate) and isEmptyProp(FRevisionDate) and isEmptyProp(FPageCount);
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetPublishedIn(value : TFhirCitationAlternativeFormPublicationInfoPublishedIn);
begin
  FPublishedIn.free;
  FPublishedIn := value; {L1134}
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetEntryDate(value : TFhirDateTime);
begin
  FEntryDate.free;
  FEntryDate := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfo.GetEntryDateST : TFslDateTime;
begin
  if FEntryDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEntryDate.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetEntryDateST(value : TFslDateTime);
begin
  if FEntryDate = nil then
    FEntryDate := TFhirDateTime.create;
  FEntryDate.value := value
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetRevisionDate(value : TFhirDateTime);
begin
  FRevisionDate.free;
  FRevisionDate := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfo.GetRevisionDateST : TFslDateTime;
begin
  if FRevisionDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRevisionDate.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetRevisionDateST(value : TFslDateTime);
begin
  if FRevisionDate = nil then
    FRevisionDate := TFhirDateTime.create;
  FRevisionDate.value := value
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetPageCount(value : TFhirString);
begin
  FPageCount.free;
  FPageCount := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfo.GetPageCountST : String;
begin
  if FPageCount = nil then
    result := ''
  else
    result := FPageCount.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfo.SetPageCountST(value : String);
begin
  if value <> '' then
  begin
    if FPageCount = nil then
      FPageCount := TFhirString.create;
    FPageCount.value := value
  end
  else if FPageCount <> nil then
    FPageCount.value := '';
end;

procedure TFhirCitationAlternativeFormPublicationInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('publishedIn');
  fields.add('entryDate');
  fields.add('revisionDate');
  fields.add('pageCount');
end;

function TFhirCitationAlternativeFormPublicationInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPublishedIn.sizeInBytes);
  inc(result, FEntryDate.sizeInBytes);
  inc(result, FRevisionDate.sizeInBytes);
  inc(result, FPageCount.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPublicationInfoListEnumerator }

constructor TFhirCitationAlternativeFormPublicationInfoListEnumerator.Create(list : TFhirCitationAlternativeFormPublicationInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormPublicationInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormPublicationInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormPublicationInfoListEnumerator.GetCurrent : TFhirCitationAlternativeFormPublicationInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormPublicationInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPublicationInfoList }

procedure TFhirCitationAlternativeFormPublicationInfoList.AddItem(value: TFhirCitationAlternativeFormPublicationInfo);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeFormPublicationInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeFormPublicationInfo');
  add(value);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Append: TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPublicationInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormPublicationInfoList.GetEnumerator : TFhirCitationAlternativeFormPublicationInfoListEnumerator;
begin
  result := TFhirCitationAlternativeFormPublicationInfoListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Clone: TFhirCitationAlternativeFormPublicationInfoList;
begin
  result := TFhirCitationAlternativeFormPublicationInfoList(inherited Clone);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormPublicationInfoList.GetItemN(index: Integer): TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPublicationInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeFormPublicationInfo;
end;
function TFhirCitationAlternativeFormPublicationInfoList.IndexOf(value: TFhirCitationAlternativeFormPublicationInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Insert(index: Integer): TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPublicationInfoList.InsertItem(index: Integer; value: TFhirCitationAlternativeFormPublicationInfo);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfo);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Item(index: Integer): TFhirCitationAlternativeFormPublicationInfo;
begin
  result := TFhirCitationAlternativeFormPublicationInfo(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPublicationInfoList.Link: TFhirCitationAlternativeFormPublicationInfoList;
begin
  result := TFhirCitationAlternativeFormPublicationInfoList(inherited Link);
end;

procedure TFhirCitationAlternativeFormPublicationInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormPublicationInfoList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeFormPublicationInfo);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfo);
  FhirCitationAlternativeFormPublicationInfos[index] := value;
end;

procedure TFhirCitationAlternativeFormPublicationInfoList.SetItemN(index: Integer; value: TFhirCitationAlternativeFormPublicationInfo);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationAlternativeFormPublicationInfoPublishedIn }

constructor TFhirCitationAlternativeFormPublicationInfoPublishedIn.Create;
begin
  inherited;
end;

destructor TFhirCitationAlternativeFormPublicationInfoPublishedIn.Destroy;
begin
  FType_.free;
  FName.free;
  FPublisher.free;
  FPublisherLocation.free;
  FStartDate.free;
  inherited;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCitationAlternativeFormPublicationInfoPublishedIn(oSource).type_.Clone;
  nameElement := TFhirCitationAlternativeFormPublicationInfoPublishedIn(oSource).nameElement.Clone;
  publisher := TFhirCitationAlternativeFormPublicationInfoPublishedIn(oSource).publisher.Clone;
  publisherLocationElement := TFhirCitationAlternativeFormPublicationInfoPublishedIn(oSource).publisherLocationElement.Clone;
  startDateElement := TFhirCitationAlternativeFormPublicationInfoPublishedIn(oSource).startDateElement.Clone;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publisherLocation') Then
     list.add(self.link, 'publisherLocation', FPublisherLocation.Link);
  if (child_name = 'startDate') Then
     list.add(self.link, 'startDate', FStartDate.Link);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publisherLocation', 'string', false, TFhirString, FPublisherLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'startDate', 'date', false, TFhirDate, FStartDate.Link)); {L1172}
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'publisherLocation') then
  begin
    PublisherLocationElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'startDate') then
  begin
    StartDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'publisher') then result := TFhirReference.create() {L1203}
  else if (propName = 'publisherLocation') then result := TFhirString.create() {L1223}
  else if (propName = 'startDate') then result := TFhirDate.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publisherLocation') then result := 'string'
  else if (propName = 'startDate') then result := 'date'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publisherLocation') then PublisherLocationElement := nil
  else if (propName = 'startDate') then StartDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference {L1195}
  else if (propName = 'publisherLocation') then PublisherLocationElement := asString(new) {L1222}
  else if (propName = 'startDate') then StartDateElement := asDate(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.fhirType : string;
begin
  result := 'Citation.alternativeForm.publicationInfo.publishedIn';
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.Link : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn(inherited Link);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.Clone : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn(inherited Clone);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.equals(other : TObject) : boolean; 
var
  o : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationAlternativeFormPublicationInfoPublishedIn)) then
    result := false
  else
  begin
    o := TFhirCitationAlternativeFormPublicationInfoPublishedIn(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(publisherLocationElement, o.publisherLocationElement, true) and 
      compareDeep(startDateElement, o.startDateElement, true);
  end;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FPublisher) and isEmptyProp(FPublisherLocation) and isEmptyProp(FStartDate);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value; {L1134}
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetPublisherLocation(value : TFhirString);
begin
  FPublisherLocation.free;
  FPublisherLocation := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.GetPublisherLocationST : String;
begin
  if FPublisherLocation = nil then
    result := ''
  else
    result := FPublisherLocation.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetPublisherLocationST(value : String);
begin
  if value <> '' then
  begin
    if FPublisherLocation = nil then
      FPublisherLocation := TFhirString.create;
    FPublisherLocation.value := value
  end
  else if FPublisherLocation <> nil then
    FPublisherLocation.value := '';
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetStartDate(value : TFhirDate);
begin
  FStartDate.free;
  FStartDate := value; {L1134}
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.GetStartDateST : TFslDateTime;
begin
  if FStartDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStartDate.value;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.SetStartDateST(value : TFslDateTime);
begin
  if FStartDate = nil then
    FStartDate := TFhirDate.create;
  FStartDate.value := value
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedIn.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
  fields.add('publisher');
  fields.add('publisherLocation');
  fields.add('startDate');
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedIn.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FPublisherLocation.sizeInBytes);
  inc(result, FStartDate.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator }

constructor TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.Create(list : TFhirCitationAlternativeFormPublicationInfoPublishedInList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.GetCurrent : TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  Result := FList[FIndex];
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationAlternativeFormPublicationInfoPublishedInList }

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.AddItem(value: TFhirCitationAlternativeFormPublicationInfoPublishedIn);
begin
  assert(value.ClassName = 'TFhirCitationAlternativeFormPublicationInfoPublishedIn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationAlternativeFormPublicationInfoPublishedIn');
  add(value);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Append: TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.ClearItems;
begin
  Clear;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.GetEnumerator : TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedInListEnumerator.Create(self.link);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Clone: TFhirCitationAlternativeFormPublicationInfoPublishedInList;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedInList(inherited Clone);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.GetItemN(index: Integer): TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn;
end;
function TFhirCitationAlternativeFormPublicationInfoPublishedInList.IndexOf(value: TFhirCitationAlternativeFormPublicationInfoPublishedIn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Insert(index: Integer): TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.InsertItem(index: Integer; value: TFhirCitationAlternativeFormPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfoPublishedIn);
  Inherited Insert(index, value);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Item(index: Integer): TFhirCitationAlternativeFormPublicationInfoPublishedIn;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedIn(ObjectByIndex[index]);
end;

function TFhirCitationAlternativeFormPublicationInfoPublishedInList.Link: TFhirCitationAlternativeFormPublicationInfoPublishedInList;
begin
  result := TFhirCitationAlternativeFormPublicationInfoPublishedInList(inherited Link);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.SetItemByIndex(index: Integer; value: TFhirCitationAlternativeFormPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfoPublishedIn);
  FhirCitationAlternativeFormPublicationInfoPublishedIns[index] := value;
end;

procedure TFhirCitationAlternativeFormPublicationInfoPublishedInList.SetItemN(index: Integer; value: TFhirCitationAlternativeFormPublicationInfoPublishedIn);
begin
  assert(value is TFhirCitationAlternativeFormPublicationInfoPublishedIn);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationKeywordList }

constructor TFhirCitationKeywordList.Create;
begin
  inherited;
end;

destructor TFhirCitationKeywordList.Destroy;
begin
  FOwner.free;
  FKeywordList.Free;
  inherited;
end;

procedure TFhirCitationKeywordList.Assign(oSource : TFslObject);
begin
  inherited;
  ownerElement := TFhirCitationKeywordList(oSource).ownerElement.Clone;
  if (TFhirCitationKeywordList(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCitationKeywordListKeywordList.Create;
    FKeywordList.Assign(TFhirCitationKeywordList(oSource).FKeywordList);
  end;
end;

procedure TFhirCitationKeywordList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
end;

procedure TFhirCitationKeywordList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'owner', 'string', false, TFhirString, FOwner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'keyword', 'BackboneElement', true, TFhirCitationKeywordListKeyword, FKeywordList.Link)) {L1039};
end;

function TFhirCitationKeywordList.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'owner') then
  begin
    OwnerElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCitationKeywordListKeyword) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationKeywordList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCitationKeywordListKeyword) {L1049}
  else inherited;
end;

function TFhirCitationKeywordList.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'owner') then result := TFhirString.create() {L1223}
  else if (propName = 'keyword') then result := KeywordList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationKeywordList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'owner') then result := 'string'
  else if (propName = 'keyword') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationKeywordList.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationKeywordList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'owner') then OwnerElement := asString(new) {L1222}
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationKeywordList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'keyword') then KeywordList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationKeywordList.fhirType : string;
begin
  result := 'Citation.keywordList';
end;

function TFhirCitationKeywordList.Link : TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList(inherited Link);
end;

function TFhirCitationKeywordList.Clone : TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList(inherited Clone);
end;

function TFhirCitationKeywordList.equals(other : TObject) : boolean; 
var
  o : TFhirCitationKeywordList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationKeywordList)) then
    result := false
  else
  begin
    o := TFhirCitationKeywordList(other);
    result := compareDeep(ownerElement, o.ownerElement, true) and compareDeep(keywordList, o.keywordList, true);
  end;
end;

function TFhirCitationKeywordList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOwner) and isEmptyProp(FkeywordList);
end;

procedure TFhirCitationKeywordList.SetOwner(value : TFhirString);
begin
  FOwner.free;
  FOwner := value; {L1134}
end;

function TFhirCitationKeywordList.GetOwnerST : String;
begin
  if FOwner = nil then
    result := ''
  else
    result := FOwner.value;
end;

procedure TFhirCitationKeywordList.SetOwnerST(value : String);
begin
  if value <> '' then
  begin
    if FOwner = nil then
      FOwner := TFhirString.create;
    FOwner.value := value
  end
  else if FOwner <> nil then
    FOwner.value := '';
end;

function TFhirCitationKeywordList.GetKeywordList : TFhirCitationKeywordListKeywordList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCitationKeywordListKeywordList.Create;
  result := FKeywordList;
end;

function TFhirCitationKeywordList.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

procedure TFhirCitationKeywordList.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('owner');
  fields.add('keyword');
end;

function TFhirCitationKeywordList.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOwner.sizeInBytes);
  inc(result, FkeywordList.sizeInBytes);
end;

{ TFhirCitationKeywordListListEnumerator }

constructor TFhirCitationKeywordListListEnumerator.Create(list : TFhirCitationKeywordListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationKeywordListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationKeywordListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationKeywordListListEnumerator.GetCurrent : TFhirCitationKeywordList;
begin
  Result := FList[FIndex];
end;

function TFhirCitationKeywordListListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationKeywordListList }

procedure TFhirCitationKeywordListList.AddItem(value: TFhirCitationKeywordList);
begin
  assert(value.ClassName = 'TFhirCitationKeywordList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationKeywordList');
  add(value);
end;

function TFhirCitationKeywordListList.Append: TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationKeywordListList.ClearItems;
begin
  Clear;
end;

function TFhirCitationKeywordListList.GetEnumerator : TFhirCitationKeywordListListEnumerator;
begin
  result := TFhirCitationKeywordListListEnumerator.Create(self.link);
end;

function TFhirCitationKeywordListList.Clone: TFhirCitationKeywordListList;
begin
  result := TFhirCitationKeywordListList(inherited Clone);
end;

function TFhirCitationKeywordListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationKeywordListList.GetItemN(index: Integer): TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList(ObjectByIndex[index]);
end;

function TFhirCitationKeywordListList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationKeywordList;
end;
function TFhirCitationKeywordListList.IndexOf(value: TFhirCitationKeywordList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationKeywordListList.Insert(index: Integer): TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationKeywordListList.InsertItem(index: Integer; value: TFhirCitationKeywordList);
begin
  assert(value is TFhirCitationKeywordList);
  Inherited Insert(index, value);
end;

function TFhirCitationKeywordListList.Item(index: Integer): TFhirCitationKeywordList;
begin
  result := TFhirCitationKeywordList(ObjectByIndex[index]);
end;

function TFhirCitationKeywordListList.Link: TFhirCitationKeywordListList;
begin
  result := TFhirCitationKeywordListList(inherited Link);
end;

procedure TFhirCitationKeywordListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationKeywordListList.SetItemByIndex(index: Integer; value: TFhirCitationKeywordList);
begin
  assert(value is TFhirCitationKeywordList);
  FhirCitationKeywordLists[index] := value;
end;

procedure TFhirCitationKeywordListList.SetItemN(index: Integer; value: TFhirCitationKeywordList);
begin
  assert(value is TFhirCitationKeywordList);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationKeywordListKeyword }

constructor TFhirCitationKeywordListKeyword.Create;
begin
  inherited;
end;

destructor TFhirCitationKeywordListKeyword.Destroy;
begin
  FMajorTopic.free;
  FValue.free;
  inherited;
end;

procedure TFhirCitationKeywordListKeyword.Assign(oSource : TFslObject);
begin
  inherited;
  majorTopicElement := TFhirCitationKeywordListKeyword(oSource).majorTopicElement.Clone;
  valueElement := TFhirCitationKeywordListKeyword(oSource).valueElement.Clone;
end;

procedure TFhirCitationKeywordListKeyword.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'majorTopic') Then
     list.add(self.link, 'majorTopic', FMajorTopic.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCitationKeywordListKeyword.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'majorTopic', 'boolean', false, TFhirBoolean, FMajorTopic.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link)); {L1172}
end;

function TFhirCitationKeywordListKeyword.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'majorTopic') then
  begin
    MajorTopicElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationKeywordListKeyword.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationKeywordListKeyword.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'majorTopic') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'value') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationKeywordListKeyword.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'majorTopic') then result := 'boolean'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationKeywordListKeyword.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'majorTopic') then MajorTopicElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationKeywordListKeyword.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'majorTopic') then MajorTopicElement := asBoolean(new) {L1222}
  else if (propName = 'value') then ValueElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationKeywordListKeyword.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationKeywordListKeyword.fhirType : string;
begin
  result := 'Citation.keywordList.keyword';
end;

function TFhirCitationKeywordListKeyword.Link : TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword(inherited Link);
end;

function TFhirCitationKeywordListKeyword.Clone : TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword(inherited Clone);
end;

function TFhirCitationKeywordListKeyword.equals(other : TObject) : boolean; 
var
  o : TFhirCitationKeywordListKeyword;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationKeywordListKeyword)) then
    result := false
  else
  begin
    o := TFhirCitationKeywordListKeyword(other);
    result := compareDeep(majorTopicElement, o.majorTopicElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCitationKeywordListKeyword.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMajorTopic) and isEmptyProp(FValue);
end;

procedure TFhirCitationKeywordListKeyword.SetMajorTopic(value : TFhirBoolean);
begin
  FMajorTopic.free;
  FMajorTopic := value; {L1134}
end;

function TFhirCitationKeywordListKeyword.GetMajorTopicST : Boolean;
begin
  if FMajorTopic = nil then
    result := false
  else
    result := FMajorTopic.value;
end;

procedure TFhirCitationKeywordListKeyword.SetMajorTopicST(value : Boolean);
begin
  if FMajorTopic = nil then
    FMajorTopic := TFhirBoolean.create;
  FMajorTopic.value := value
end;

procedure TFhirCitationKeywordListKeyword.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirCitationKeywordListKeyword.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCitationKeywordListKeyword.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCitationKeywordListKeyword.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('majorTopic');
  fields.add('value');
end;

function TFhirCitationKeywordListKeyword.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMajorTopic.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirCitationKeywordListKeywordListEnumerator }

constructor TFhirCitationKeywordListKeywordListEnumerator.Create(list : TFhirCitationKeywordListKeywordList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationKeywordListKeywordListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationKeywordListKeywordListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationKeywordListKeywordListEnumerator.GetCurrent : TFhirCitationKeywordListKeyword;
begin
  Result := FList[FIndex];
end;

function TFhirCitationKeywordListKeywordListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationKeywordListKeywordList }

procedure TFhirCitationKeywordListKeywordList.AddItem(value: TFhirCitationKeywordListKeyword);
begin
  assert(value.ClassName = 'TFhirCitationKeywordListKeyword', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationKeywordListKeyword');
  add(value);
end;

function TFhirCitationKeywordListKeywordList.Append: TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationKeywordListKeywordList.ClearItems;
begin
  Clear;
end;

function TFhirCitationKeywordListKeywordList.GetEnumerator : TFhirCitationKeywordListKeywordListEnumerator;
begin
  result := TFhirCitationKeywordListKeywordListEnumerator.Create(self.link);
end;

function TFhirCitationKeywordListKeywordList.Clone: TFhirCitationKeywordListKeywordList;
begin
  result := TFhirCitationKeywordListKeywordList(inherited Clone);
end;

function TFhirCitationKeywordListKeywordList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationKeywordListKeywordList.GetItemN(index: Integer): TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword(ObjectByIndex[index]);
end;

function TFhirCitationKeywordListKeywordList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationKeywordListKeyword;
end;
function TFhirCitationKeywordListKeywordList.IndexOf(value: TFhirCitationKeywordListKeyword): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationKeywordListKeywordList.Insert(index: Integer): TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationKeywordListKeywordList.InsertItem(index: Integer; value: TFhirCitationKeywordListKeyword);
begin
  assert(value is TFhirCitationKeywordListKeyword);
  Inherited Insert(index, value);
end;

function TFhirCitationKeywordListKeywordList.Item(index: Integer): TFhirCitationKeywordListKeyword;
begin
  result := TFhirCitationKeywordListKeyword(ObjectByIndex[index]);
end;

function TFhirCitationKeywordListKeywordList.Link: TFhirCitationKeywordListKeywordList;
begin
  result := TFhirCitationKeywordListKeywordList(inherited Link);
end;

procedure TFhirCitationKeywordListKeywordList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationKeywordListKeywordList.SetItemByIndex(index: Integer; value: TFhirCitationKeywordListKeyword);
begin
  assert(value is TFhirCitationKeywordListKeyword);
  FhirCitationKeywordListKeywords[index] := value;
end;

procedure TFhirCitationKeywordListKeywordList.SetItemN(index: Integer; value: TFhirCitationKeywordListKeyword);
begin
  assert(value is TFhirCitationKeywordListKeyword);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationMedlinePubMed }

constructor TFhirCitationMedlinePubMed.Create;
begin
  inherited;
end;

destructor TFhirCitationMedlinePubMed.Destroy;
begin
  FMedlineState.free;
  FOwner.free;
  FPmid.free;
  FPmidVersion.free;
  FDateCreated.free;
  FDateCompleted.free;
  FDateRevised.free;
  FPubMedPubDateList.Free;
  FPublicationState.free;
  FRelatedArticleList.Free;
  inherited;
end;

procedure TFhirCitationMedlinePubMed.Assign(oSource : TFslObject);
begin
  inherited;
  medlineState := TFhirCitationMedlinePubMed(oSource).medlineState.Clone;
  owner := TFhirCitationMedlinePubMed(oSource).owner.Clone;
  pmidElement := TFhirCitationMedlinePubMed(oSource).pmidElement.Clone;
  pmidVersionElement := TFhirCitationMedlinePubMed(oSource).pmidVersionElement.Clone;
  dateCreatedElement := TFhirCitationMedlinePubMed(oSource).dateCreatedElement.Clone;
  dateCompletedElement := TFhirCitationMedlinePubMed(oSource).dateCompletedElement.Clone;
  dateRevisedElement := TFhirCitationMedlinePubMed(oSource).dateRevisedElement.Clone;
  if (TFhirCitationMedlinePubMed(oSource).FPubMedPubDateList = nil) then
  begin
    FPubMedPubDateList.free;
    FPubMedPubDateList := nil;
  end
  else
  begin
    if FPubMedPubDateList = nil then
      FPubMedPubDateList := TFhirCitationMedlinePubMedPubMedPubDateList.Create;
    FPubMedPubDateList.Assign(TFhirCitationMedlinePubMed(oSource).FPubMedPubDateList);
  end;
  publicationState := TFhirCitationMedlinePubMed(oSource).publicationState.Clone;
  if (TFhirCitationMedlinePubMed(oSource).FRelatedArticleList = nil) then
  begin
    FRelatedArticleList.free;
    FRelatedArticleList := nil;
  end
  else
  begin
    if FRelatedArticleList = nil then
      FRelatedArticleList := TFhirCitationMedlinePubMedRelatedArticleList.Create;
    FRelatedArticleList.Assign(TFhirCitationMedlinePubMed(oSource).FRelatedArticleList);
  end;
end;

procedure TFhirCitationMedlinePubMed.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'medlineState') Then
     list.add(self.link, 'medlineState', FMedlineState.Link);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'pmid') Then
     list.add(self.link, 'pmid', FPmid.Link);
  if (child_name = 'pmidVersion') Then
     list.add(self.link, 'pmidVersion', FPmidVersion.Link);
  if (child_name = 'dateCreated') Then
     list.add(self.link, 'dateCreated', FDateCreated.Link);
  if (child_name = 'dateCompleted') Then
     list.add(self.link, 'dateCompleted', FDateCompleted.Link);
  if (child_name = 'dateRevised') Then
     list.add(self.link, 'dateRevised', FDateRevised.Link);
  if (child_name = 'pubMedPubDate') Then
    list.addAll(self, 'pubMedPubDate', FPubMedPubDateList);
  if (child_name = 'publicationState') Then
     list.add(self.link, 'publicationState', FPublicationState.Link);
  if (child_name = 'relatedArticle') Then
    list.addAll(self, 'relatedArticle', FRelatedArticleList);
end;

procedure TFhirCitationMedlinePubMed.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'medlineState', 'CodeableConcept', false, TFhirCodeableConcept, FMedlineState.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'owner', 'CodeableConcept', false, TFhirCodeableConcept, FOwner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pmid', 'positiveInt', false, TFhirPositiveInt, FPmid.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pmidVersion', 'positiveInt', false, TFhirPositiveInt, FPmidVersion.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateCreated', 'date', false, TFhirDate, FDateCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateCompleted', 'date', false, TFhirDate, FDateCompleted.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dateRevised', 'date', false, TFhirDate, FDateRevised.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'pubMedPubDate', 'BackboneElement', true, TFhirCitationMedlinePubMedPubMedPubDate, FPubMedPubDateList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'publicationState', 'CodeableConcept', false, TFhirCodeableConcept, FPublicationState.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relatedArticle', 'BackboneElement', true, TFhirCitationMedlinePubMedRelatedArticle, FRelatedArticleList.Link)) {L1039};
end;

function TFhirCitationMedlinePubMed.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'medlineState') then
  begin
    MedlineState := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'pmid') then
  begin
    PmidElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'pmidVersion') then
  begin
    PmidVersionElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dateCreated') then
  begin
    DateCreatedElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dateCompleted') then
  begin
    DateCompletedElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'dateRevised') then
  begin
    DateRevisedElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'pubMedPubDate') then
  begin
    PubMedPubDateList.add(propValue as TFhirCitationMedlinePubMedPubMedPubDate) {L1048};
    result := propValue;
  end
  else if (propName = 'publicationState') then
  begin
    PublicationState := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'relatedArticle') then
  begin
    RelatedArticleList.add(propValue as TFhirCitationMedlinePubMedRelatedArticle) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationMedlinePubMed.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'pubMedPubDate') then PubMedPubDateList.insertItem(index, propValue as TFhirCitationMedlinePubMedPubMedPubDate) {L1049}
  else if (propName = 'relatedArticle') then RelatedArticleList.insertItem(index, propValue as TFhirCitationMedlinePubMedRelatedArticle) {L1049}
  else inherited;
end;

function TFhirCitationMedlinePubMed.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'medlineState') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'owner') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'pmid') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'pmidVersion') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'dateCreated') then result := TFhirDate.create() {L1223}
  else if (propName = 'dateCompleted') then result := TFhirDate.create() {L1223}
  else if (propName = 'dateRevised') then result := TFhirDate.create() {L1223}
  else if (propName = 'pubMedPubDate') then result := PubMedPubDateList.new() {L1053}
  else if (propName = 'publicationState') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'relatedArticle') then result := RelatedArticleList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationMedlinePubMed.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'medlineState') then result := 'CodeableConcept'
  else if (propName = 'owner') then result := 'CodeableConcept'
  else if (propName = 'pmid') then result := 'positiveInt'
  else if (propName = 'pmidVersion') then result := 'positiveInt'
  else if (propName = 'dateCreated') then result := 'date'
  else if (propName = 'dateCompleted') then result := 'date'
  else if (propName = 'dateRevised') then result := 'date'
  else if (propName = 'pubMedPubDate') then result := 'BackboneElement'
  else if (propName = 'publicationState') then result := 'CodeableConcept'
  else if (propName = 'relatedArticle') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationMedlinePubMed.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'medlineState') then MedlineStateElement := nil
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'pmid') then PmidElement := nil
  else if (propName = 'pmidVersion') then PmidVersionElement := nil
  else if (propName = 'dateCreated') then DateCreatedElement := nil
  else if (propName = 'dateCompleted') then DateCompletedElement := nil
  else if (propName = 'dateRevised') then DateRevisedElement := nil
  else if (propName = 'pubMedPubDate') then deletePropertyValue('pubMedPubDate', PubMedPubDateList, value) {L1054}
  else if (propName = 'publicationState') then PublicationStateElement := nil
  else if (propName = 'relatedArticle') then deletePropertyValue('relatedArticle', RelatedArticleList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationMedlinePubMed.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'medlineState') then MedlineStateElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'owner') then OwnerElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'pmid') then PmidElement := asPositiveInt(new) {L1222}
  else if (propName = 'pmidVersion') then PmidVersionElement := asPositiveInt(new) {L1222}
  else if (propName = 'dateCreated') then DateCreatedElement := asDate(new) {L1222}
  else if (propName = 'dateCompleted') then DateCompletedElement := asDate(new) {L1222}
  else if (propName = 'dateRevised') then DateRevisedElement := asDate(new) {L1222}
  else if (propName = 'pubMedPubDate') then replacePropertyValue('pubMedPubDate', PubMedPubDateList, existing, new) {L1055}
  else if (propName = 'publicationState') then PublicationStateElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'relatedArticle') then replacePropertyValue('relatedArticle', RelatedArticleList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationMedlinePubMed.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'pubMedPubDate') then PubMedPubDateList.move(source, destination) {L1050}
  else if (propName = 'relatedArticle') then RelatedArticleList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationMedlinePubMed.fhirType : string;
begin
  result := 'Citation.medlinePubMed';
end;

function TFhirCitationMedlinePubMed.Link : TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed(inherited Link);
end;

function TFhirCitationMedlinePubMed.Clone : TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed(inherited Clone);
end;

function TFhirCitationMedlinePubMed.equals(other : TObject) : boolean; 
var
  o : TFhirCitationMedlinePubMed;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationMedlinePubMed)) then
    result := false
  else
  begin
    o := TFhirCitationMedlinePubMed(other);
    result := compareDeep(medlineStateElement, o.medlineStateElement, true) and 
      compareDeep(ownerElement, o.ownerElement, true) and compareDeep(pmidElement, o.pmidElement, true) and 
      compareDeep(pmidVersionElement, o.pmidVersionElement, true) and compareDeep(dateCreatedElement, o.dateCreatedElement, true) and 
      compareDeep(dateCompletedElement, o.dateCompletedElement, true) and compareDeep(dateRevisedElement, o.dateRevisedElement, true) and 
      compareDeep(pubMedPubDateList, o.pubMedPubDateList, true) and compareDeep(publicationStateElement, o.publicationStateElement, true) and 
      compareDeep(relatedArticleList, o.relatedArticleList, true);
  end;
end;

function TFhirCitationMedlinePubMed.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMedlineState) and isEmptyProp(FOwner) and isEmptyProp(FPmid) and isEmptyProp(FPmidVersion) and isEmptyProp(FDateCreated) and isEmptyProp(FDateCompleted) and isEmptyProp(FDateRevised) and isEmptyProp(FpubMedPubDateList) and isEmptyProp(FPublicationState) and isEmptyProp(FrelatedArticleList);
end;

procedure TFhirCitationMedlinePubMed.SetMedlineState(value : TFhirCodeableConcept);
begin
  FMedlineState.free;
  FMedlineState := value; {L1134}
end;

procedure TFhirCitationMedlinePubMed.SetOwner(value : TFhirCodeableConcept);
begin
  FOwner.free;
  FOwner := value; {L1134}
end;

procedure TFhirCitationMedlinePubMed.SetPmid(value : TFhirPositiveInt);
begin
  FPmid.free;
  FPmid := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetPmidST : String;
begin
  if FPmid = nil then
    result := ''
  else
    result := FPmid.value;
end;

procedure TFhirCitationMedlinePubMed.SetPmidST(value : String);
begin
  if value <> '' then
  begin
    if FPmid = nil then
      FPmid := TFhirPositiveInt.create;
    FPmid.value := value
  end
  else if FPmid <> nil then
    FPmid.value := '';
end;

procedure TFhirCitationMedlinePubMed.SetPmidVersion(value : TFhirPositiveInt);
begin
  FPmidVersion.free;
  FPmidVersion := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetPmidVersionST : String;
begin
  if FPmidVersion = nil then
    result := ''
  else
    result := FPmidVersion.value;
end;

procedure TFhirCitationMedlinePubMed.SetPmidVersionST(value : String);
begin
  if value <> '' then
  begin
    if FPmidVersion = nil then
      FPmidVersion := TFhirPositiveInt.create;
    FPmidVersion.value := value
  end
  else if FPmidVersion <> nil then
    FPmidVersion.value := '';
end;

procedure TFhirCitationMedlinePubMed.SetDateCreated(value : TFhirDate);
begin
  FDateCreated.free;
  FDateCreated := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetDateCreatedST : TFslDateTime;
begin
  if FDateCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateCreated.value;
end;

procedure TFhirCitationMedlinePubMed.SetDateCreatedST(value : TFslDateTime);
begin
  if FDateCreated = nil then
    FDateCreated := TFhirDate.create;
  FDateCreated.value := value
end;

procedure TFhirCitationMedlinePubMed.SetDateCompleted(value : TFhirDate);
begin
  FDateCompleted.free;
  FDateCompleted := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetDateCompletedST : TFslDateTime;
begin
  if FDateCompleted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateCompleted.value;
end;

procedure TFhirCitationMedlinePubMed.SetDateCompletedST(value : TFslDateTime);
begin
  if FDateCompleted = nil then
    FDateCompleted := TFhirDate.create;
  FDateCompleted.value := value
end;

procedure TFhirCitationMedlinePubMed.SetDateRevised(value : TFhirDate);
begin
  FDateRevised.free;
  FDateRevised := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetDateRevisedST : TFslDateTime;
begin
  if FDateRevised = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateRevised.value;
end;

procedure TFhirCitationMedlinePubMed.SetDateRevisedST(value : TFslDateTime);
begin
  if FDateRevised = nil then
    FDateRevised := TFhirDate.create;
  FDateRevised.value := value
end;

function TFhirCitationMedlinePubMed.GetPubMedPubDateList : TFhirCitationMedlinePubMedPubMedPubDateList;
begin
  if FPubMedPubDateList = nil then
    FPubMedPubDateList := TFhirCitationMedlinePubMedPubMedPubDateList.Create;
  result := FPubMedPubDateList;
end;

function TFhirCitationMedlinePubMed.GetHasPubMedPubDateList : boolean;
begin
  result := (FPubMedPubDateList <> nil) and (FPubMedPubDateList.count > 0);
end;

procedure TFhirCitationMedlinePubMed.SetPublicationState(value : TFhirCodeableConcept);
begin
  FPublicationState.free;
  FPublicationState := value; {L1134}
end;

function TFhirCitationMedlinePubMed.GetRelatedArticleList : TFhirCitationMedlinePubMedRelatedArticleList;
begin
  if FRelatedArticleList = nil then
    FRelatedArticleList := TFhirCitationMedlinePubMedRelatedArticleList.Create;
  result := FRelatedArticleList;
end;

function TFhirCitationMedlinePubMed.GetHasRelatedArticleList : boolean;
begin
  result := (FRelatedArticleList <> nil) and (FRelatedArticleList.count > 0);
end;

procedure TFhirCitationMedlinePubMed.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('medlineState');
  fields.add('owner');
  fields.add('pmid');
  fields.add('pmidVersion');
  fields.add('dateCreated');
  fields.add('dateCompleted');
  fields.add('dateRevised');
  fields.add('pubMedPubDate');
  fields.add('publicationState');
  fields.add('relatedArticle');
end;

function TFhirCitationMedlinePubMed.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMedlineState.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FPmid.sizeInBytes);
  inc(result, FPmidVersion.sizeInBytes);
  inc(result, FDateCreated.sizeInBytes);
  inc(result, FDateCompleted.sizeInBytes);
  inc(result, FDateRevised.sizeInBytes);
  inc(result, FpubMedPubDateList.sizeInBytes);
  inc(result, FPublicationState.sizeInBytes);
  inc(result, FrelatedArticleList.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedListEnumerator }

constructor TFhirCitationMedlinePubMedListEnumerator.Create(list : TFhirCitationMedlinePubMedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationMedlinePubMedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationMedlinePubMedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationMedlinePubMedListEnumerator.GetCurrent : TFhirCitationMedlinePubMed;
begin
  Result := FList[FIndex];
end;

function TFhirCitationMedlinePubMedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedList }

procedure TFhirCitationMedlinePubMedList.AddItem(value: TFhirCitationMedlinePubMed);
begin
  assert(value.ClassName = 'TFhirCitationMedlinePubMed', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationMedlinePubMed');
  add(value);
end;

function TFhirCitationMedlinePubMedList.Append: TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedList.ClearItems;
begin
  Clear;
end;

function TFhirCitationMedlinePubMedList.GetEnumerator : TFhirCitationMedlinePubMedListEnumerator;
begin
  result := TFhirCitationMedlinePubMedListEnumerator.Create(self.link);
end;

function TFhirCitationMedlinePubMedList.Clone: TFhirCitationMedlinePubMedList;
begin
  result := TFhirCitationMedlinePubMedList(inherited Clone);
end;

function TFhirCitationMedlinePubMedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationMedlinePubMedList.GetItemN(index: Integer): TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationMedlinePubMed;
end;
function TFhirCitationMedlinePubMedList.IndexOf(value: TFhirCitationMedlinePubMed): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationMedlinePubMedList.Insert(index: Integer): TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedList.InsertItem(index: Integer; value: TFhirCitationMedlinePubMed);
begin
  assert(value is TFhirCitationMedlinePubMed);
  Inherited Insert(index, value);
end;

function TFhirCitationMedlinePubMedList.Item(index: Integer): TFhirCitationMedlinePubMed;
begin
  result := TFhirCitationMedlinePubMed(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedList.Link: TFhirCitationMedlinePubMedList;
begin
  result := TFhirCitationMedlinePubMedList(inherited Link);
end;

procedure TFhirCitationMedlinePubMedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationMedlinePubMedList.SetItemByIndex(index: Integer; value: TFhirCitationMedlinePubMed);
begin
  assert(value is TFhirCitationMedlinePubMed);
  FhirCitationMedlinePubMeds[index] := value;
end;

procedure TFhirCitationMedlinePubMedList.SetItemN(index: Integer; value: TFhirCitationMedlinePubMed);
begin
  assert(value is TFhirCitationMedlinePubMed);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationMedlinePubMedPubMedPubDate }

constructor TFhirCitationMedlinePubMedPubMedPubDate.Create;
begin
  inherited;
end;

destructor TFhirCitationMedlinePubMedPubMedPubDate.Destroy;
begin
  FPublicationState.free;
  FDate.free;
  inherited;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.Assign(oSource : TFslObject);
begin
  inherited;
  publicationState := TFhirCitationMedlinePubMedPubMedPubDate(oSource).publicationState.Clone;
  dateElement := TFhirCitationMedlinePubMedPubMedPubDate(oSource).dateElement.Clone;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'publicationState') Then
     list.add(self.link, 'publicationState', FPublicationState.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'publicationState', 'CodeableConcept', false, TFhirCodeableConcept, FPublicationState.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
end;

function TFhirCitationMedlinePubMedPubMedPubDate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'publicationState') then
  begin
    PublicationState := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCitationMedlinePubMedPubMedPubDate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'publicationState') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationMedlinePubMedPubMedPubDate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'publicationState') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'publicationState') then PublicationStateElement := nil
  else if (propName = 'date') then DateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'publicationState') then PublicationStateElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationMedlinePubMedPubMedPubDate.fhirType : string;
begin
  result := 'Citation.medlinePubMed.pubMedPubDate';
end;

function TFhirCitationMedlinePubMedPubMedPubDate.Link : TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate(inherited Link);
end;

function TFhirCitationMedlinePubMedPubMedPubDate.Clone : TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate(inherited Clone);
end;

function TFhirCitationMedlinePubMedPubMedPubDate.equals(other : TObject) : boolean; 
var
  o : TFhirCitationMedlinePubMedPubMedPubDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationMedlinePubMedPubMedPubDate)) then
    result := false
  else
  begin
    o := TFhirCitationMedlinePubMedPubMedPubDate(other);
    result := compareDeep(publicationStateElement, o.publicationStateElement, true) and 
      compareDeep(dateElement, o.dateElement, true);
  end;
end;

function TFhirCitationMedlinePubMedPubMedPubDate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPublicationState) and isEmptyProp(FDate);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.SetPublicationState(value : TFhirCodeableConcept);
begin
  FPublicationState.free;
  FPublicationState := value; {L1134}
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirCitationMedlinePubMedPubMedPubDate.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirCitationMedlinePubMedPubMedPubDate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('publicationState');
  fields.add('date');
end;

function TFhirCitationMedlinePubMedPubMedPubDate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPublicationState.sizeInBytes);
  inc(result, FDate.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedPubMedPubDateListEnumerator }

constructor TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.Create(list : TFhirCitationMedlinePubMedPubMedPubDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.GetCurrent : TFhirCitationMedlinePubMedPubMedPubDate;
begin
  Result := FList[FIndex];
end;

function TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedPubMedPubDateList }

procedure TFhirCitationMedlinePubMedPubMedPubDateList.AddItem(value: TFhirCitationMedlinePubMedPubMedPubDate);
begin
  assert(value.ClassName = 'TFhirCitationMedlinePubMedPubMedPubDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationMedlinePubMedPubMedPubDate');
  add(value);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Append: TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDateList.ClearItems;
begin
  Clear;
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.GetEnumerator : TFhirCitationMedlinePubMedPubMedPubDateListEnumerator;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDateListEnumerator.Create(self.link);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Clone: TFhirCitationMedlinePubMedPubMedPubDateList;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDateList(inherited Clone);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.GetItemN(index: Integer): TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate;
end;
function TFhirCitationMedlinePubMedPubMedPubDateList.IndexOf(value: TFhirCitationMedlinePubMedPubMedPubDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Insert(index: Integer): TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDateList.InsertItem(index: Integer; value: TFhirCitationMedlinePubMedPubMedPubDate);
begin
  assert(value is TFhirCitationMedlinePubMedPubMedPubDate);
  Inherited Insert(index, value);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Item(index: Integer): TFhirCitationMedlinePubMedPubMedPubDate;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDate(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedPubMedPubDateList.Link: TFhirCitationMedlinePubMedPubMedPubDateList;
begin
  result := TFhirCitationMedlinePubMedPubMedPubDateList(inherited Link);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationMedlinePubMedPubMedPubDateList.SetItemByIndex(index: Integer; value: TFhirCitationMedlinePubMedPubMedPubDate);
begin
  assert(value is TFhirCitationMedlinePubMedPubMedPubDate);
  FhirCitationMedlinePubMedPubMedPubDates[index] := value;
end;

procedure TFhirCitationMedlinePubMedPubMedPubDateList.SetItemN(index: Integer; value: TFhirCitationMedlinePubMedPubMedPubDate);
begin
  assert(value is TFhirCitationMedlinePubMedPubMedPubDate);
  ObjectByIndex[index] := value;
end;

{ TFhirCitationMedlinePubMedRelatedArticle }

constructor TFhirCitationMedlinePubMedRelatedArticle.Create;
begin
  inherited;
end;

destructor TFhirCitationMedlinePubMedRelatedArticle.Destroy;
begin
  FCitationReference.free;
  FCitationMarkdown.free;
  FIdentifierList.Free;
  inherited;
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.Assign(oSource : TFslObject);
begin
  inherited;
  citationReference := TFhirCitationMedlinePubMedRelatedArticle(oSource).citationReference.Clone;
  citationMarkdownElement := TFhirCitationMedlinePubMedRelatedArticle(oSource).citationMarkdownElement.Clone;
  if (TFhirCitationMedlinePubMedRelatedArticle(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCitationMedlinePubMedRelatedArticle(oSource).FIdentifierList);
  end;
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'citationReference') Then
     list.add(self.link, 'citationReference', FCitationReference.Link);
  if (child_name = 'citationMarkdown') Then
     list.add(self.link, 'citationMarkdown', FCitationMarkdown.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'citationReference', 'Reference', false, TFhirReference, FCitationReference.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'citationMarkdown', 'markdown', false, TFhirMarkdown, FCitationMarkdown.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
end;

function TFhirCitationMedlinePubMedRelatedArticle.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'citationReference') then
  begin
    CitationReference := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'citationMarkdown') then
  begin
    CitationMarkdownElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirCitationMedlinePubMedRelatedArticle.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'citationReference') then result := TFhirReference.create() {L1203}
  else if (propName = 'citationMarkdown') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitationMedlinePubMedRelatedArticle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'citationReference') then result := 'Reference'
  else if (propName = 'citationMarkdown') then result := 'markdown'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'citationReference') then CitationReferenceElement := nil
  else if (propName = 'citationMarkdown') then CitationMarkdownElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'citationReference') then CitationReferenceElement := new as TFhirReference {L1195}
  else if (propName = 'citationMarkdown') then CitationMarkdownElement := asMarkdown(new) {L1222}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitationMedlinePubMedRelatedArticle.fhirType : string;
begin
  result := 'Citation.medlinePubMed.relatedArticle';
end;

function TFhirCitationMedlinePubMedRelatedArticle.Link : TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle(inherited Link);
end;

function TFhirCitationMedlinePubMedRelatedArticle.Clone : TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle(inherited Clone);
end;

function TFhirCitationMedlinePubMedRelatedArticle.equals(other : TObject) : boolean; 
var
  o : TFhirCitationMedlinePubMedRelatedArticle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitationMedlinePubMedRelatedArticle)) then
    result := false
  else
  begin
    o := TFhirCitationMedlinePubMedRelatedArticle(other);
    result := compareDeep(citationReferenceElement, o.citationReferenceElement, true) and 
      compareDeep(citationMarkdownElement, o.citationMarkdownElement, true) and compareDeep(identifierList, o.identifierList, true);
  end;
end;

function TFhirCitationMedlinePubMedRelatedArticle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCitationReference) and isEmptyProp(FCitationMarkdown) and isEmptyProp(FidentifierList);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.SetCitationReference(value : TFhirReference);
begin
  FCitationReference.free;
  FCitationReference := value; {L1134}
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.SetCitationMarkdown(value : TFhirMarkdown);
begin
  FCitationMarkdown.free;
  FCitationMarkdown := value; {L1134}
end;

function TFhirCitationMedlinePubMedRelatedArticle.GetCitationMarkdownST : String;
begin
  if FCitationMarkdown = nil then
    result := ''
  else
    result := FCitationMarkdown.value;
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.SetCitationMarkdownST(value : String);
begin
  if value <> '' then
  begin
    if FCitationMarkdown = nil then
      FCitationMarkdown := TFhirMarkdown.create;
    FCitationMarkdown.value := value
  end
  else if FCitationMarkdown <> nil then
    FCitationMarkdown.value := '';
end;

function TFhirCitationMedlinePubMedRelatedArticle.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitationMedlinePubMedRelatedArticle.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCitationMedlinePubMedRelatedArticle.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('citationReference');
  fields.add('citationMarkdown');
  fields.add('identifier');
end;

function TFhirCitationMedlinePubMedRelatedArticle.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCitationReference.sizeInBytes);
  inc(result, FCitationMarkdown.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedRelatedArticleListEnumerator }

constructor TFhirCitationMedlinePubMedRelatedArticleListEnumerator.Create(list : TFhirCitationMedlinePubMedRelatedArticleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationMedlinePubMedRelatedArticleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationMedlinePubMedRelatedArticleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationMedlinePubMedRelatedArticleListEnumerator.GetCurrent : TFhirCitationMedlinePubMedRelatedArticle;
begin
  Result := FList[FIndex];
end;

function TFhirCitationMedlinePubMedRelatedArticleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationMedlinePubMedRelatedArticleList }

procedure TFhirCitationMedlinePubMedRelatedArticleList.AddItem(value: TFhirCitationMedlinePubMedRelatedArticle);
begin
  assert(value.ClassName = 'TFhirCitationMedlinePubMedRelatedArticle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitationMedlinePubMedRelatedArticle');
  add(value);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Append: TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedRelatedArticleList.ClearItems;
begin
  Clear;
end;

function TFhirCitationMedlinePubMedRelatedArticleList.GetEnumerator : TFhirCitationMedlinePubMedRelatedArticleListEnumerator;
begin
  result := TFhirCitationMedlinePubMedRelatedArticleListEnumerator.Create(self.link);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Clone: TFhirCitationMedlinePubMedRelatedArticleList;
begin
  result := TFhirCitationMedlinePubMedRelatedArticleList(inherited Clone);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationMedlinePubMedRelatedArticleList.GetItemN(index: Integer): TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle;
end;
function TFhirCitationMedlinePubMedRelatedArticleList.IndexOf(value: TFhirCitationMedlinePubMedRelatedArticle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Insert(index: Integer): TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationMedlinePubMedRelatedArticleList.InsertItem(index: Integer; value: TFhirCitationMedlinePubMedRelatedArticle);
begin
  assert(value is TFhirCitationMedlinePubMedRelatedArticle);
  Inherited Insert(index, value);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Item(index: Integer): TFhirCitationMedlinePubMedRelatedArticle;
begin
  result := TFhirCitationMedlinePubMedRelatedArticle(ObjectByIndex[index]);
end;

function TFhirCitationMedlinePubMedRelatedArticleList.Link: TFhirCitationMedlinePubMedRelatedArticleList;
begin
  result := TFhirCitationMedlinePubMedRelatedArticleList(inherited Link);
end;

procedure TFhirCitationMedlinePubMedRelatedArticleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationMedlinePubMedRelatedArticleList.SetItemByIndex(index: Integer; value: TFhirCitationMedlinePubMedRelatedArticle);
begin
  assert(value is TFhirCitationMedlinePubMedRelatedArticle);
  FhirCitationMedlinePubMedRelatedArticles[index] := value;
end;

procedure TFhirCitationMedlinePubMedRelatedArticleList.SetItemN(index: Integer; value: TFhirCitationMedlinePubMedRelatedArticle);
begin
  assert(value is TFhirCitationMedlinePubMedRelatedArticle);
  ObjectByIndex[index] := value;
end;

{ TFhirCitation }

constructor TFhirCitation.Create;
begin
  inherited;
end;

destructor TFhirCitation.Destroy;
begin
  FRelatedIdentifierList.Free;
  FSummaryList.Free;
  FDateCited.free;
  FVariantCitation.free;
  FPublishingModel.free;
  FJournal.free;
  FPublicationInfo.free;
  FArticleTitle.free;
  FAlternativeTitleList.Free;
  FPagination.free;
  FArticleUrlList.Free;
  FAbstract.free;
  FAbstractCopyright.free;
  FAlternativeAbstractList.Free;
  FContributorship.free;
  FArticleLanguage.free;
  FAlternativeFormList.Free;
  FClassifierList.Free;
  FKeywordListList.Free;
  FRelatedArtifactList.Free;
  FNoteList.Free;
  FMedlinePubMed.free;
  inherited;
end;

procedure TFhirCitation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCitation(oSource).FRelatedIdentifierList = nil) then
  begin
    FRelatedIdentifierList.free;
    FRelatedIdentifierList := nil;
  end
  else
  begin
    if FRelatedIdentifierList = nil then
      FRelatedIdentifierList := TFhirIdentifierList.Create;
    FRelatedIdentifierList.Assign(TFhirCitation(oSource).FRelatedIdentifierList);
  end;
  if (TFhirCitation(oSource).FSummaryList = nil) then
  begin
    FSummaryList.free;
    FSummaryList := nil;
  end
  else
  begin
    if FSummaryList = nil then
      FSummaryList := TFhirCitationSummaryList.Create;
    FSummaryList.Assign(TFhirCitation(oSource).FSummaryList);
  end;
  dateCitedElement := TFhirCitation(oSource).dateCitedElement.Clone;
  variantCitation := TFhirCitation(oSource).variantCitation.Clone;
  publishingModel := TFhirCitation(oSource).publishingModel.Clone;
  journal := TFhirCitation(oSource).journal.Clone;
  publicationInfo := TFhirCitation(oSource).publicationInfo.Clone;
  articleTitleElement := TFhirCitation(oSource).articleTitleElement.Clone;
  if (TFhirCitation(oSource).FAlternativeTitleList = nil) then
  begin
    FAlternativeTitleList.free;
    FAlternativeTitleList := nil;
  end
  else
  begin
    if FAlternativeTitleList = nil then
      FAlternativeTitleList := TFhirCitationAlternativeTitleList.Create;
    FAlternativeTitleList.Assign(TFhirCitation(oSource).FAlternativeTitleList);
  end;
  pagination := TFhirCitation(oSource).pagination.Clone;
  if (TFhirCitation(oSource).FArticleUrlList = nil) then
  begin
    FArticleUrlList.free;
    FArticleUrlList := nil;
  end
  else
  begin
    if FArticleUrlList = nil then
      FArticleUrlList := TFhirCitationArticleUrlList.Create;
    FArticleUrlList.Assign(TFhirCitation(oSource).FArticleUrlList);
  end;
  abstractElement := TFhirCitation(oSource).abstractElement.Clone;
  abstractCopyrightElement := TFhirCitation(oSource).abstractCopyrightElement.Clone;
  if (TFhirCitation(oSource).FAlternativeAbstractList = nil) then
  begin
    FAlternativeAbstractList.free;
    FAlternativeAbstractList := nil;
  end
  else
  begin
    if FAlternativeAbstractList = nil then
      FAlternativeAbstractList := TFhirCitationAlternativeAbstractList.Create;
    FAlternativeAbstractList.Assign(TFhirCitation(oSource).FAlternativeAbstractList);
  end;
  contributorship := TFhirCitation(oSource).contributorship.Clone;
  articleLanguage := TFhirCitation(oSource).articleLanguage.Clone;
  if (TFhirCitation(oSource).FAlternativeFormList = nil) then
  begin
    FAlternativeFormList.free;
    FAlternativeFormList := nil;
  end
  else
  begin
    if FAlternativeFormList = nil then
      FAlternativeFormList := TFhirCitationAlternativeFormList.Create;
    FAlternativeFormList.Assign(TFhirCitation(oSource).FAlternativeFormList);
  end;
  if (TFhirCitation(oSource).FClassifierList = nil) then
  begin
    FClassifierList.free;
    FClassifierList := nil;
  end
  else
  begin
    if FClassifierList = nil then
      FClassifierList := TFhirCodeableConceptList.Create;
    FClassifierList.Assign(TFhirCitation(oSource).FClassifierList);
  end;
  if (TFhirCitation(oSource).FKeywordListList = nil) then
  begin
    FKeywordListList.free;
    FKeywordListList := nil;
  end
  else
  begin
    if FKeywordListList = nil then
      FKeywordListList := TFhirCitationKeywordListList.Create;
    FKeywordListList.Assign(TFhirCitation(oSource).FKeywordListList);
  end;
  if (TFhirCitation(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirCitation(oSource).FRelatedArtifactList);
  end;
  if (TFhirCitation(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCitation(oSource).FNoteList);
  end;
  medlinePubMed := TFhirCitation(oSource).medlinePubMed.Clone;
end;

function TFhirCitation.GetResourceType : TFhirResourceType;
begin
  result := frtCitation;
end;

procedure TFhirCitation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relatedIdentifier') Then
    list.addAll(self, 'relatedIdentifier', FRelatedIdentifierList);
  if (child_name = 'summary') Then
    list.addAll(self, 'summary', FSummaryList);
  if (child_name = 'dateCited') Then
     list.add(self.link, 'dateCited', FDateCited.Link);
  if (child_name = 'variantCitation') Then
     list.add(self.link, 'variantCitation', FVariantCitation.Link);
  if (child_name = 'publishingModel') Then
     list.add(self.link, 'publishingModel', FPublishingModel.Link);
  if (child_name = 'journal') Then
     list.add(self.link, 'journal', FJournal.Link);
  if (child_name = 'publicationInfo') Then
     list.add(self.link, 'publicationInfo', FPublicationInfo.Link);
  if (child_name = 'articleTitle') Then
     list.add(self.link, 'articleTitle', FArticleTitle.Link);
  if (child_name = 'alternativeTitle') Then
    list.addAll(self, 'alternativeTitle', FAlternativeTitleList);
  if (child_name = 'pagination') Then
     list.add(self.link, 'pagination', FPagination.Link);
  if (child_name = 'articleUrl') Then
    list.addAll(self, 'articleUrl', FArticleUrlList);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'abstractCopyright') Then
     list.add(self.link, 'abstractCopyright', FAbstractCopyright.Link);
  if (child_name = 'alternativeAbstract') Then
    list.addAll(self, 'alternativeAbstract', FAlternativeAbstractList);
  if (child_name = 'contributorship') Then
     list.add(self.link, 'contributorship', FContributorship.Link);
  if (child_name = 'articleLanguage') Then
     list.add(self.link, 'articleLanguage', FArticleLanguage.Link);
  if (child_name = 'alternativeForm') Then
    list.addAll(self, 'alternativeForm', FAlternativeFormList);
  if (child_name = 'classifier') Then
    list.addAll(self, 'classifier', FClassifierList);
  if (child_name = 'keywordList') Then
    list.addAll(self, 'keywordList', FKeywordListList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'medlinePubMed') Then
     list.add(self.link, 'medlinePubMed', FMedlinePubMed.Link);
end;

procedure TFhirCitation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relatedIdentifier', 'Identifier', true, TFhirIdentifier, FRelatedIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'summary', 'BackboneElement', true, TFhirCitationSummary, FSummaryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'dateCited', 'dateTime', false, TFhirDateTime, FDateCited.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'variantCitation', 'BackboneElement', false, TFhirCitationVariantCitation, FVariantCitation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publishingModel', 'CodeableConcept', false, TFhirCodeableConcept, FPublishingModel.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'journal', 'BackboneElement', false, TFhirCitationJournal, FJournal.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'publicationInfo', 'BackboneElement', false, TFhirCitationPublicationInfo, FPublicationInfo.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'articleTitle', 'markdown', false, TFhirMarkdown, FArticleTitle.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alternativeTitle', 'BackboneElement', true, TFhirCitationAlternativeTitle, FAlternativeTitleList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'pagination', 'BackboneElement', false, TFhirCitationPagination, FPagination.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'articleUrl', 'BackboneElement', true, TFhirCitationArticleUrl, FArticleUrlList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'abstract', 'markdown', false, TFhirMarkdown, FAbstract.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'abstractCopyright', 'markdown', false, TFhirMarkdown, FAbstractCopyright.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alternativeAbstract', 'BackboneElement', true, TFhirCitationAlternativeAbstract, FAlternativeAbstractList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contributorship', 'BackboneElement', false, TFhirCitationContributorship, FContributorship.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'articleLanguage', 'CodeableConcept', false, TFhirCodeableConcept, FArticleLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alternativeForm', 'BackboneElement', true, TFhirCitationAlternativeForm, FAlternativeFormList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'classifier', 'CodeableConcept', true, TFhirCodeableConcept, FClassifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'keywordList', 'BackboneElement', true, TFhirCitationKeywordList, FKeywordListList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'medlinePubMed', 'BackboneElement', false, TFhirCitationMedlinePubMed, FMedlinePubMed.Link)); {L1172}
end;

function TFhirCitation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relatedIdentifier') then
  begin
    RelatedIdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'summary') then
  begin
    SummaryList.add(propValue as TFhirCitationSummary) {L1048};
    result := propValue;
  end
  else if (propName = 'dateCited') then
  begin
    DateCitedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'variantCitation') then
  begin
    VariantCitation := propValue as TFhirCitationVariantCitation {L1199};
    result := propValue;
  end
  else if (propName = 'publishingModel') then
  begin
    PublishingModel := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'journal') then
  begin
    Journal := propValue as TFhirCitationJournal {L1199};
    result := propValue;
  end
  else if (propName = 'publicationInfo') then
  begin
    PublicationInfo := propValue as TFhirCitationPublicationInfo {L1199};
    result := propValue;
  end
  else if (propName = 'articleTitle') then
  begin
    ArticleTitleElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'alternativeTitle') then
  begin
    AlternativeTitleList.add(propValue as TFhirCitationAlternativeTitle) {L1048};
    result := propValue;
  end
  else if (propName = 'pagination') then
  begin
    Pagination := propValue as TFhirCitationPagination {L1199};
    result := propValue;
  end
  else if (propName = 'articleUrl') then
  begin
    ArticleUrlList.add(propValue as TFhirCitationArticleUrl) {L1048};
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'abstractCopyright') then
  begin
    AbstractCopyrightElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'alternativeAbstract') then
  begin
    AlternativeAbstractList.add(propValue as TFhirCitationAlternativeAbstract) {L1048};
    result := propValue;
  end
  else if (propName = 'contributorship') then
  begin
    Contributorship := propValue as TFhirCitationContributorship {L1199};
    result := propValue;
  end
  else if (propName = 'articleLanguage') then
  begin
    ArticleLanguage := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'alternativeForm') then
  begin
    AlternativeFormList.add(propValue as TFhirCitationAlternativeForm) {L1048};
    result := propValue;
  end
  else if (propName = 'classifier') then
  begin
    ClassifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'keywordList') then
  begin
    KeywordListList.add(propValue as TFhirCitationKeywordList) {L1048};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact) {L1048};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'medlinePubMed') then
  begin
    MedlinePubMed := propValue as TFhirCitationMedlinePubMed {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCitation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relatedIdentifier') then RelatedIdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'summary') then SummaryList.insertItem(index, propValue as TFhirCitationSummary) {L1049}
  else if (propName = 'alternativeTitle') then AlternativeTitleList.insertItem(index, propValue as TFhirCitationAlternativeTitle) {L1049}
  else if (propName = 'articleUrl') then ArticleUrlList.insertItem(index, propValue as TFhirCitationArticleUrl) {L1049}
  else if (propName = 'alternativeAbstract') then AlternativeAbstractList.insertItem(index, propValue as TFhirCitationAlternativeAbstract) {L1049}
  else if (propName = 'alternativeForm') then AlternativeFormList.insertItem(index, propValue as TFhirCitationAlternativeForm) {L1049}
  else if (propName = 'classifier') then ClassifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'keywordList') then KeywordListList.insertItem(index, propValue as TFhirCitationKeywordList) {L1049}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirCitation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relatedIdentifier') then result := RelatedIdentifierList.new() {L1053}
  else if (propName = 'summary') then result := SummaryList.new() {L1053}
  else if (propName = 'dateCited') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'variantCitation') then result := TFhirCitationVariantCitation.create() {L1203}
  else if (propName = 'publishingModel') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'journal') then result := TFhirCitationJournal.create() {L1203}
  else if (propName = 'publicationInfo') then result := TFhirCitationPublicationInfo.create() {L1203}
  else if (propName = 'articleTitle') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'alternativeTitle') then result := AlternativeTitleList.new() {L1053}
  else if (propName = 'pagination') then result := TFhirCitationPagination.create() {L1203}
  else if (propName = 'articleUrl') then result := ArticleUrlList.new() {L1053}
  else if (propName = 'abstract') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'abstractCopyright') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'alternativeAbstract') then result := AlternativeAbstractList.new() {L1053}
  else if (propName = 'contributorship') then result := TFhirCitationContributorship.create() {L1203}
  else if (propName = 'articleLanguage') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'alternativeForm') then result := AlternativeFormList.new() {L1053}
  else if (propName = 'classifier') then result := ClassifierList.new() {L1053}
  else if (propName = 'keywordList') then result := KeywordListList.new() {L1053}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new() {L1053}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'medlinePubMed') then result := TFhirCitationMedlinePubMed.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCitation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relatedIdentifier') then result := 'Identifier'
  else if (propName = 'summary') then result := 'BackboneElement'
  else if (propName = 'dateCited') then result := 'dateTime'
  else if (propName = 'variantCitation') then result := 'BackboneElement'
  else if (propName = 'publishingModel') then result := 'CodeableConcept'
  else if (propName = 'journal') then result := 'BackboneElement'
  else if (propName = 'publicationInfo') then result := 'BackboneElement'
  else if (propName = 'articleTitle') then result := 'markdown'
  else if (propName = 'alternativeTitle') then result := 'BackboneElement'
  else if (propName = 'pagination') then result := 'BackboneElement'
  else if (propName = 'articleUrl') then result := 'BackboneElement'
  else if (propName = 'abstract') then result := 'markdown'
  else if (propName = 'abstractCopyright') then result := 'markdown'
  else if (propName = 'alternativeAbstract') then result := 'BackboneElement'
  else if (propName = 'contributorship') then result := 'BackboneElement'
  else if (propName = 'articleLanguage') then result := 'CodeableConcept'
  else if (propName = 'alternativeForm') then result := 'BackboneElement'
  else if (propName = 'classifier') then result := 'CodeableConcept'
  else if (propName = 'keywordList') then result := 'BackboneElement'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'medlinePubMed') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCitation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relatedIdentifier') then deletePropertyValue('relatedIdentifier', RelatedIdentifierList, value) {L1054}
  else if (propName = 'summary') then deletePropertyValue('summary', SummaryList, value) {L1054}
  else if (propName = 'dateCited') then DateCitedElement := nil
  else if (propName = 'variantCitation') then VariantCitationElement := nil
  else if (propName = 'publishingModel') then PublishingModelElement := nil
  else if (propName = 'journal') then JournalElement := nil
  else if (propName = 'publicationInfo') then PublicationInfoElement := nil
  else if (propName = 'articleTitle') then ArticleTitleElement := nil
  else if (propName = 'alternativeTitle') then deletePropertyValue('alternativeTitle', AlternativeTitleList, value) {L1054}
  else if (propName = 'pagination') then PaginationElement := nil
  else if (propName = 'articleUrl') then deletePropertyValue('articleUrl', ArticleUrlList, value) {L1054}
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'abstractCopyright') then AbstractCopyrightElement := nil
  else if (propName = 'alternativeAbstract') then deletePropertyValue('alternativeAbstract', AlternativeAbstractList, value) {L1054}
  else if (propName = 'contributorship') then ContributorshipElement := nil
  else if (propName = 'articleLanguage') then ArticleLanguageElement := nil
  else if (propName = 'alternativeForm') then deletePropertyValue('alternativeForm', AlternativeFormList, value) {L1054}
  else if (propName = 'classifier') then deletePropertyValue('classifier', ClassifierList, value) {L1054}
  else if (propName = 'keywordList') then deletePropertyValue('keywordList', KeywordListList, value) {L1054}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {L1054}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'medlinePubMed') then MedlinePubMedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCitation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relatedIdentifier') then replacePropertyValue('relatedIdentifier', RelatedIdentifierList, existing, new) {L1055}
  else if (propName = 'summary') then replacePropertyValue('summary', SummaryList, existing, new) {L1055}
  else if (propName = 'dateCited') then DateCitedElement := asDateTime(new) {L1222}
  else if (propName = 'variantCitation') then VariantCitationElement := new as TFhirCitationVariantCitation {L1195}
  else if (propName = 'publishingModel') then PublishingModelElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'journal') then JournalElement := new as TFhirCitationJournal {L1195}
  else if (propName = 'publicationInfo') then PublicationInfoElement := new as TFhirCitationPublicationInfo {L1195}
  else if (propName = 'articleTitle') then ArticleTitleElement := asMarkdown(new) {L1222}
  else if (propName = 'alternativeTitle') then replacePropertyValue('alternativeTitle', AlternativeTitleList, existing, new) {L1055}
  else if (propName = 'pagination') then PaginationElement := new as TFhirCitationPagination {L1195}
  else if (propName = 'articleUrl') then replacePropertyValue('articleUrl', ArticleUrlList, existing, new) {L1055}
  else if (propName = 'abstract') then AbstractElement := asMarkdown(new) {L1222}
  else if (propName = 'abstractCopyright') then AbstractCopyrightElement := asMarkdown(new) {L1222}
  else if (propName = 'alternativeAbstract') then replacePropertyValue('alternativeAbstract', AlternativeAbstractList, existing, new) {L1055}
  else if (propName = 'contributorship') then ContributorshipElement := new as TFhirCitationContributorship {L1195}
  else if (propName = 'articleLanguage') then ArticleLanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'alternativeForm') then replacePropertyValue('alternativeForm', AlternativeFormList, existing, new) {L1055}
  else if (propName = 'classifier') then replacePropertyValue('classifier', ClassifierList, existing, new) {L1055}
  else if (propName = 'keywordList') then replacePropertyValue('keywordList', KeywordListList, existing, new) {L1055}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {L1055}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'medlinePubMed') then MedlinePubMedElement := new as TFhirCitationMedlinePubMed {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCitation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relatedIdentifier') then RelatedIdentifierList.move(source, destination) {L1050}
  else if (propName = 'summary') then SummaryList.move(source, destination) {L1050}
  else if (propName = 'alternativeTitle') then AlternativeTitleList.move(source, destination) {L1050}
  else if (propName = 'articleUrl') then ArticleUrlList.move(source, destination) {L1050}
  else if (propName = 'alternativeAbstract') then AlternativeAbstractList.move(source, destination) {L1050}
  else if (propName = 'alternativeForm') then AlternativeFormList.move(source, destination) {L1050}
  else if (propName = 'classifier') then ClassifierList.move(source, destination) {L1050}
  else if (propName = 'keywordList') then KeywordListList.move(source, destination) {L1050}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCitation.fhirType : string;
begin
  result := 'Citation';
end;

function TFhirCitation.Link : TFhirCitation;
begin
  result := TFhirCitation(inherited Link);
end;

function TFhirCitation.Clone : TFhirCitation;
begin
  result := TFhirCitation(inherited Clone);
end;

function TFhirCitation.equals(other : TObject) : boolean; 
var
  o : TFhirCitation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCitation)) then
    result := false
  else
  begin
    o := TFhirCitation(other);
    result := compareDeep(relatedIdentifierList, o.relatedIdentifierList, true) and 
      compareDeep(summaryList, o.summaryList, true) and compareDeep(dateCitedElement, o.dateCitedElement, true) and 
      compareDeep(variantCitationElement, o.variantCitationElement, true) and compareDeep(publishingModelElement, o.publishingModelElement, true) and 
      compareDeep(journalElement, o.journalElement, true) and compareDeep(publicationInfoElement, o.publicationInfoElement, true) and 
      compareDeep(articleTitleElement, o.articleTitleElement, true) and compareDeep(alternativeTitleList, o.alternativeTitleList, true) and 
      compareDeep(paginationElement, o.paginationElement, true) and compareDeep(articleUrlList, o.articleUrlList, true) and 
      compareDeep(abstractElement, o.abstractElement, true) and compareDeep(abstractCopyrightElement, o.abstractCopyrightElement, true) and 
      compareDeep(alternativeAbstractList, o.alternativeAbstractList, true) and compareDeep(contributorshipElement, o.contributorshipElement, true) and 
      compareDeep(articleLanguageElement, o.articleLanguageElement, true) and compareDeep(alternativeFormList, o.alternativeFormList, true) and 
      compareDeep(classifierList, o.classifierList, true) and compareDeep(keywordListList, o.keywordListList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(medlinePubMedElement, o.medlinePubMedElement, true);
  end;
end;

function TFhirCitation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelatedIdentifierList) and isEmptyProp(FsummaryList) and isEmptyProp(FDateCited) and isEmptyProp(FVariantCitation) and isEmptyProp(FPublishingModel) and isEmptyProp(FJournal) and isEmptyProp(FPublicationInfo) and isEmptyProp(FArticleTitle) and isEmptyProp(FalternativeTitleList) and isEmptyProp(FPagination) and isEmptyProp(FarticleUrlList) and isEmptyProp(FAbstract) and isEmptyProp(FAbstractCopyright) and isEmptyProp(FalternativeAbstractList) and isEmptyProp(FContributorship) and isEmptyProp(FArticleLanguage) and isEmptyProp(FalternativeFormList) and isEmptyProp(FclassifierList) and isEmptyProp(FkeywordListList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FnoteList) and isEmptyProp(FMedlinePubMed);
end;

procedure TFhirCitation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value; {L1134}
end;

function TFhirCitation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirCitation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirCitation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCitation.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCitation.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirCitation.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirCitation.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirCitation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCitation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCitation.GetRelatedIdentifierList : TFhirIdentifierList;
begin
  if FRelatedIdentifierList = nil then
    FRelatedIdentifierList := TFhirIdentifierList.Create;
  result := FRelatedIdentifierList;
end;

function TFhirCitation.GetHasRelatedIdentifierList : boolean;
begin
  result := (FRelatedIdentifierList <> nil) and (FRelatedIdentifierList.count > 0);
end;

function TFhirCitation.GetSummaryList : TFhirCitationSummaryList;
begin
  if FSummaryList = nil then
    FSummaryList := TFhirCitationSummaryList.Create;
  result := FSummaryList;
end;

function TFhirCitation.GetHasSummaryList : boolean;
begin
  result := (FSummaryList <> nil) and (FSummaryList.count > 0);
end;

procedure TFhirCitation.SetDateCited(value : TFhirDateTime);
begin
  FDateCited.free;
  FDateCited := value; {L1134}
end;

function TFhirCitation.GetDateCitedST : TFslDateTime;
begin
  if FDateCited = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateCited.value;
end;

procedure TFhirCitation.SetDateCitedST(value : TFslDateTime);
begin
  if FDateCited = nil then
    FDateCited := TFhirDateTime.create;
  FDateCited.value := value
end;

procedure TFhirCitation.SetVariantCitation(value : TFhirCitationVariantCitation);
begin
  FVariantCitation.free;
  FVariantCitation := value; {L1134}
end;

procedure TFhirCitation.SetPublishingModel(value : TFhirCodeableConcept);
begin
  FPublishingModel.free;
  FPublishingModel := value; {L1134}
end;

procedure TFhirCitation.SetJournal(value : TFhirCitationJournal);
begin
  FJournal.free;
  FJournal := value; {L1134}
end;

procedure TFhirCitation.SetPublicationInfo(value : TFhirCitationPublicationInfo);
begin
  FPublicationInfo.free;
  FPublicationInfo := value; {L1134}
end;

procedure TFhirCitation.SetArticleTitle(value : TFhirMarkdown);
begin
  FArticleTitle.free;
  FArticleTitle := value; {L1134}
end;

function TFhirCitation.GetArticleTitleST : String;
begin
  if FArticleTitle = nil then
    result := ''
  else
    result := FArticleTitle.value;
end;

procedure TFhirCitation.SetArticleTitleST(value : String);
begin
  if value <> '' then
  begin
    if FArticleTitle = nil then
      FArticleTitle := TFhirMarkdown.create;
    FArticleTitle.value := value
  end
  else if FArticleTitle <> nil then
    FArticleTitle.value := '';
end;

function TFhirCitation.GetAlternativeTitleList : TFhirCitationAlternativeTitleList;
begin
  if FAlternativeTitleList = nil then
    FAlternativeTitleList := TFhirCitationAlternativeTitleList.Create;
  result := FAlternativeTitleList;
end;

function TFhirCitation.GetHasAlternativeTitleList : boolean;
begin
  result := (FAlternativeTitleList <> nil) and (FAlternativeTitleList.count > 0);
end;

procedure TFhirCitation.SetPagination(value : TFhirCitationPagination);
begin
  FPagination.free;
  FPagination := value; {L1134}
end;

function TFhirCitation.GetArticleUrlList : TFhirCitationArticleUrlList;
begin
  if FArticleUrlList = nil then
    FArticleUrlList := TFhirCitationArticleUrlList.Create;
  result := FArticleUrlList;
end;

function TFhirCitation.GetHasArticleUrlList : boolean;
begin
  result := (FArticleUrlList <> nil) and (FArticleUrlList.count > 0);
end;

procedure TFhirCitation.SetAbstract(value : TFhirMarkdown);
begin
  FAbstract.free;
  FAbstract := value; {L1134}
end;

function TFhirCitation.GetAbstractST : String;
begin
  if FAbstract = nil then
    result := ''
  else
    result := FAbstract.value;
end;

procedure TFhirCitation.SetAbstractST(value : String);
begin
  if value <> '' then
  begin
    if FAbstract = nil then
      FAbstract := TFhirMarkdown.create;
    FAbstract.value := value
  end
  else if FAbstract <> nil then
    FAbstract.value := '';
end;

procedure TFhirCitation.SetAbstractCopyright(value : TFhirMarkdown);
begin
  FAbstractCopyright.free;
  FAbstractCopyright := value; {L1134}
end;

function TFhirCitation.GetAbstractCopyrightST : String;
begin
  if FAbstractCopyright = nil then
    result := ''
  else
    result := FAbstractCopyright.value;
end;

procedure TFhirCitation.SetAbstractCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FAbstractCopyright = nil then
      FAbstractCopyright := TFhirMarkdown.create;
    FAbstractCopyright.value := value
  end
  else if FAbstractCopyright <> nil then
    FAbstractCopyright.value := '';
end;

function TFhirCitation.GetAlternativeAbstractList : TFhirCitationAlternativeAbstractList;
begin
  if FAlternativeAbstractList = nil then
    FAlternativeAbstractList := TFhirCitationAlternativeAbstractList.Create;
  result := FAlternativeAbstractList;
end;

function TFhirCitation.GetHasAlternativeAbstractList : boolean;
begin
  result := (FAlternativeAbstractList <> nil) and (FAlternativeAbstractList.count > 0);
end;

procedure TFhirCitation.SetContributorship(value : TFhirCitationContributorship);
begin
  FContributorship.free;
  FContributorship := value; {L1134}
end;

procedure TFhirCitation.SetArticleLanguage(value : TFhirCodeableConcept);
begin
  FArticleLanguage.free;
  FArticleLanguage := value; {L1134}
end;

function TFhirCitation.GetAlternativeFormList : TFhirCitationAlternativeFormList;
begin
  if FAlternativeFormList = nil then
    FAlternativeFormList := TFhirCitationAlternativeFormList.Create;
  result := FAlternativeFormList;
end;

function TFhirCitation.GetHasAlternativeFormList : boolean;
begin
  result := (FAlternativeFormList <> nil) and (FAlternativeFormList.count > 0);
end;

function TFhirCitation.GetClassifierList : TFhirCodeableConceptList;
begin
  if FClassifierList = nil then
    FClassifierList := TFhirCodeableConceptList.Create;
  result := FClassifierList;
end;

function TFhirCitation.GetHasClassifierList : boolean;
begin
  result := (FClassifierList <> nil) and (FClassifierList.count > 0);
end;

function TFhirCitation.GetKeywordListList : TFhirCitationKeywordListList;
begin
  if FKeywordListList = nil then
    FKeywordListList := TFhirCitationKeywordListList.Create;
  result := FKeywordListList;
end;

function TFhirCitation.GetHasKeywordListList : boolean;
begin
  result := (FKeywordListList <> nil) and (FKeywordListList.count > 0);
end;

function TFhirCitation.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirCitation.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirCitation.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCitation.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCitation.SetMedlinePubMed(value : TFhirCitationMedlinePubMed);
begin
  FMedlinePubMed.free;
  FMedlinePubMed := value; {L1134}
end;

procedure TFhirCitation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('status');
  fields.add('useContext');
  fields.add('identifier');
  fields.add('relatedIdentifier');
  fields.add('summary');
  fields.add('dateCited');
  fields.add('variantCitation');
  fields.add('publishingModel');
  fields.add('journal');
  fields.add('publicationInfo');
  fields.add('articleTitle');
  fields.add('alternativeTitle');
  fields.add('pagination');
  fields.add('articleUrl');
  fields.add('abstract');
  fields.add('abstractCopyright');
  fields.add('alternativeAbstract');
  fields.add('contributorship');
  fields.add('articleLanguage');
  fields.add('alternativeForm');
  fields.add('classifier');
  fields.add('keywordList');
  fields.add('relatedArtifact');
  fields.add('note');
  fields.add('medlinePubMed');
end;

function TFhirCitation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FrelatedIdentifierList.sizeInBytes);
  inc(result, FsummaryList.sizeInBytes);
  inc(result, FDateCited.sizeInBytes);
  inc(result, FVariantCitation.sizeInBytes);
  inc(result, FPublishingModel.sizeInBytes);
  inc(result, FJournal.sizeInBytes);
  inc(result, FPublicationInfo.sizeInBytes);
  inc(result, FArticleTitle.sizeInBytes);
  inc(result, FalternativeTitleList.sizeInBytes);
  inc(result, FPagination.sizeInBytes);
  inc(result, FarticleUrlList.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FAbstractCopyright.sizeInBytes);
  inc(result, FalternativeAbstractList.sizeInBytes);
  inc(result, FContributorship.sizeInBytes);
  inc(result, FArticleLanguage.sizeInBytes);
  inc(result, FalternativeFormList.sizeInBytes);
  inc(result, FclassifierList.sizeInBytes);
  inc(result, FkeywordListList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FMedlinePubMed.sizeInBytes);
end;

{ TFhirCitationListEnumerator }

constructor TFhirCitationListEnumerator.Create(list : TFhirCitationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCitationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCitationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCitationListEnumerator.GetCurrent : TFhirCitation;
begin
  Result := FList[FIndex];
end;

function TFhirCitationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCitationList }

procedure TFhirCitationList.AddItem(value: TFhirCitation);
begin
  assert(value.ClassName = 'TFhirCitation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCitation');
  add(value);
end;

function TFhirCitationList.Append: TFhirCitation;
begin
  result := TFhirCitation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationList.ClearItems;
begin
  Clear;
end;

function TFhirCitationList.GetEnumerator : TFhirCitationListEnumerator;
begin
  result := TFhirCitationListEnumerator.Create(self.link);
end;

function TFhirCitationList.Clone: TFhirCitationList;
begin
  result := TFhirCitationList(inherited Clone);
end;

function TFhirCitationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCitationList.GetItemN(index: Integer): TFhirCitation;
begin
  result := TFhirCitation(ObjectByIndex[index]);
end;

function TFhirCitationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCitation;
end;
function TFhirCitationList.IndexOf(value: TFhirCitation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCitationList.Insert(index: Integer): TFhirCitation;
begin
  result := TFhirCitation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCitationList.InsertItem(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  Inherited Insert(index, value);
end;

function TFhirCitationList.Item(index: Integer): TFhirCitation;
begin
  result := TFhirCitation(ObjectByIndex[index]);
end;

function TFhirCitationList.Link: TFhirCitationList;
begin
  result := TFhirCitationList(inherited Link);
end;

procedure TFhirCitationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCitationList.SetItemByIndex(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  FhirCitations[index] := value;
end;

procedure TFhirCitationList.SetItemN(index: Integer; value: TFhirCitation);
begin
  assert(value is TFhirCitation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CITATION}
{$IFDEF FHIR_CLAIM}
{ TFhirClaimRelated }

constructor TFhirClaimRelated.Create;
begin
  inherited;
end;

destructor TFhirClaimRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirClaimRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirClaimRelated(oSource).claim.Clone;
  relationship := TFhirClaimRelated(oSource).relationship.Clone;
  reference := TFhirClaimRelated(oSource).reference.Clone;
end;

procedure TFhirClaimRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirClaimRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link)); {L1172}
end;

function TFhirClaimRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference.create() {L1203}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reference') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference {L1195}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimRelated.fhirType : string;
begin
  result := 'Claim.related';
end;

function TFhirClaimRelated.Link : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Link);
end;

function TFhirClaimRelated.Clone : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Clone);
end;

function TFhirClaimRelated.equals(other : TObject) : boolean; 
var
  o : TFhirClaimRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimRelated)) then
    result := false
  else
  begin
    o := TFhirClaimRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirClaimRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirClaimRelated.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value; {L1134}
end;

procedure TFhirClaimRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value; {L1134}
end;

procedure TFhirClaimRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value; {L1134}
end;

procedure TFhirClaimRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

function TFhirClaimRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirClaimRelatedListEnumerator }

constructor TFhirClaimRelatedListEnumerator.Create(list : TFhirClaimRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimRelatedListEnumerator.GetCurrent : TFhirClaimRelated;
begin
  Result := FList[FIndex];
end;

function TFhirClaimRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimRelatedList }

procedure TFhirClaimRelatedList.AddItem(value: TFhirClaimRelated);
begin
  assert(value.ClassName = 'TFhirClaimRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimRelated');
  add(value);
end;

function TFhirClaimRelatedList.Append: TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirClaimRelatedList.GetEnumerator : TFhirClaimRelatedListEnumerator;
begin
  result := TFhirClaimRelatedListEnumerator.Create(self.link);
end;

function TFhirClaimRelatedList.Clone: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Clone);
end;

function TFhirClaimRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimRelatedList.GetItemN(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimRelated;
end;
function TFhirClaimRelatedList.IndexOf(value: TFhirClaimRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimRelatedList.Insert(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.InsertItem(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  Inherited Insert(index, value);
end;

function TFhirClaimRelatedList.Item(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.Link: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Link);
end;

procedure TFhirClaimRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimRelatedList.SetItemByIndex(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  FhirClaimRelateds[index] := value;
end;

procedure TFhirClaimRelatedList.SetItemN(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimPayee }

constructor TFhirClaimPayee.Create;
begin
  inherited;
end;

destructor TFhirClaimPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirClaimPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimPayee(oSource).type_.Clone;
  party := TFhirClaimPayee(oSource).party.Clone;
end;

procedure TFhirClaimPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirClaimPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link)); {L1172}
end;

function TFhirClaimPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'party') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'party') then PartyElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimPayee.fhirType : string;
begin
  result := 'Claim.payee';
end;

function TFhirClaimPayee.Link : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Link);
end;

function TFhirClaimPayee.Clone : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Clone);
end;

function TFhirClaimPayee.equals(other : TObject) : boolean; 
var
  o : TFhirClaimPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimPayee)) then
    result := false
  else
  begin
    o := TFhirClaimPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirClaimPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirClaimPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClaimPayee.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value; {L1134}
end;

procedure TFhirClaimPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

function TFhirClaimPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirClaimPayeeListEnumerator }

constructor TFhirClaimPayeeListEnumerator.Create(list : TFhirClaimPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimPayeeListEnumerator.GetCurrent : TFhirClaimPayee;
begin
  Result := FList[FIndex];
end;

function TFhirClaimPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimPayeeList }

procedure TFhirClaimPayeeList.AddItem(value: TFhirClaimPayee);
begin
  assert(value.ClassName = 'TFhirClaimPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimPayee');
  add(value);
end;

function TFhirClaimPayeeList.Append: TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirClaimPayeeList.GetEnumerator : TFhirClaimPayeeListEnumerator;
begin
  result := TFhirClaimPayeeListEnumerator.Create(self.link);
end;

function TFhirClaimPayeeList.Clone: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Clone);
end;

function TFhirClaimPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimPayeeList.GetItemN(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimPayee;
end;
function TFhirClaimPayeeList.IndexOf(value: TFhirClaimPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimPayeeList.Insert(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.InsertItem(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  Inherited Insert(index, value);
end;

function TFhirClaimPayeeList.Item(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.Link: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Link);
end;

procedure TFhirClaimPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimPayeeList.SetItemByIndex(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  FhirClaimPayees[index] := value;
end;

procedure TFhirClaimPayeeList.SetItemN(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimCareTeam }

constructor TFhirClaimCareTeam.Create;
begin
  inherited;
end;

destructor TFhirClaimCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirClaimCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirClaimCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirClaimCareTeam(oSource).responsibleElement.Clone;
  role := TFhirClaimCareTeam(oSource).role.Clone;
  qualification := TFhirClaimCareTeam(oSource).qualification.Clone;
end;

procedure TFhirClaimCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirClaimCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link)); {L1172}
end;

function TFhirClaimCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new) {L1222}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimCareTeam.fhirType : string;
begin
  result := 'Claim.careTeam';
end;

function TFhirClaimCareTeam.Link : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Link);
end;

function TFhirClaimCareTeam.Clone : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Clone);
end;

function TFhirClaimCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirClaimCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimCareTeam)) then
    result := false
  else
  begin
    o := TFhirClaimCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirClaimCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirClaimCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimCareTeam.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirClaimCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value; {L1134}
end;

function TFhirClaimCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

procedure TFhirClaimCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

procedure TFhirClaimCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirClaimCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value; {L1134}
end;

procedure TFhirClaimCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

function TFhirClaimCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirClaimCareTeamListEnumerator }

constructor TFhirClaimCareTeamListEnumerator.Create(list : TFhirClaimCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimCareTeamListEnumerator.GetCurrent : TFhirClaimCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirClaimCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimCareTeamList }

procedure TFhirClaimCareTeamList.AddItem(value: TFhirClaimCareTeam);
begin
  assert(value.ClassName = 'TFhirClaimCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimCareTeam');
  add(value);
end;

function TFhirClaimCareTeamList.Append: TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirClaimCareTeamList.GetEnumerator : TFhirClaimCareTeamListEnumerator;
begin
  result := TFhirClaimCareTeamListEnumerator.Create(self.link);
end;

function TFhirClaimCareTeamList.Clone: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Clone);
end;

function TFhirClaimCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimCareTeamList.GetItemN(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimCareTeam;
end;
function TFhirClaimCareTeamList.IndexOf(value: TFhirClaimCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimCareTeamList.Insert(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.InsertItem(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  Inherited Insert(index, value);
end;

function TFhirClaimCareTeamList.Item(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.Link: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Link);
end;

procedure TFhirClaimCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimCareTeamList.SetItemByIndex(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  FhirClaimCareTeams[index] := value;
end;

procedure TFhirClaimCareTeamList.SetItemN(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimSupportingInfo }

constructor TFhirClaimSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirClaimSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirClaimSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirClaimSupportingInfo(oSource).category.Clone;
  code := TFhirClaimSupportingInfo(oSource).code.Clone;
  timing := TFhirClaimSupportingInfo(oSource).timing.Clone;
  value := TFhirClaimSupportingInfo(oSource).value.Clone;
  reason := TFhirClaimSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirClaimSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirClaimSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirDataType, FTiming.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link)); {L1172}
end;

function TFhirClaimSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing') {L1191}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil {L1189}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil {L1189}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimSupportingInfo.fhirType : string;
begin
  result := 'Claim.supportingInfo';
end;

function TFhirClaimSupportingInfo.Link : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Link);
end;

function TFhirClaimSupportingInfo.Clone : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Clone);
end;

function TFhirClaimSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirClaimSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirClaimSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirClaimSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirClaimSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirClaimSupportingInfo.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value; {L1134}
end;

procedure TFhirClaimSupportingInfo.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirClaimSupportingInfo.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value; {L1134}
end;

procedure TFhirClaimSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

function TFhirClaimSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirClaimSupportingInfoListEnumerator }

constructor TFhirClaimSupportingInfoListEnumerator.Create(list : TFhirClaimSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimSupportingInfoListEnumerator.GetCurrent : TFhirClaimSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirClaimSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimSupportingInfoList }

procedure TFhirClaimSupportingInfoList.AddItem(value: TFhirClaimSupportingInfo);
begin
  assert(value.ClassName = 'TFhirClaimSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimSupportingInfo');
  add(value);
end;

function TFhirClaimSupportingInfoList.Append: TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirClaimSupportingInfoList.GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
begin
  result := TFhirClaimSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirClaimSupportingInfoList.Clone: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Clone);
end;

function TFhirClaimSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimSupportingInfoList.GetItemN(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimSupportingInfo;
end;
function TFhirClaimSupportingInfoList.IndexOf(value: TFhirClaimSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimSupportingInfoList.Insert(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.InsertItem(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirClaimSupportingInfoList.Item(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.Link: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Link);
end;

procedure TFhirClaimSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  FhirClaimSupportingInfos[index] := value;
end;

procedure TFhirClaimSupportingInfoList.SetItemN(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimDiagnosis }

constructor TFhirClaimDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirClaimDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirClaimDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirClaimDiagnosis(oSource).diagnosis.Clone;
  if (TFhirClaimDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirClaimDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirClaimDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirClaimDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirClaimDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link)); {L1172}
end;

function TFhirClaimDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirClaimDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis') {L1191}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil {L1189}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType {L1190}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimDiagnosis.fhirType : string;
begin
  result := 'Claim.diagnosis';
end;

function TFhirClaimDiagnosis.Link : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Link);
end;

function TFhirClaimDiagnosis.Clone : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Clone);
end;

function TFhirClaimDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirClaimDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimDiagnosis)) then
    result := false
  else
  begin
    o := TFhirClaimDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirClaimDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirClaimDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value; {L1134}
end;

function TFhirClaimDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirClaimDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirClaimDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value; {L1134}
end;

procedure TFhirClaimDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value; {L1134}
end;

procedure TFhirClaimDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

function TFhirClaimDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FOnAdmission.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirClaimDiagnosisListEnumerator }

constructor TFhirClaimDiagnosisListEnumerator.Create(list : TFhirClaimDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimDiagnosisListEnumerator.GetCurrent : TFhirClaimDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimDiagnosisList }

procedure TFhirClaimDiagnosisList.AddItem(value: TFhirClaimDiagnosis);
begin
  assert(value.ClassName = 'TFhirClaimDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimDiagnosis');
  add(value);
end;

function TFhirClaimDiagnosisList.Append: TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimDiagnosisList.GetEnumerator : TFhirClaimDiagnosisListEnumerator;
begin
  result := TFhirClaimDiagnosisListEnumerator.Create(self.link);
end;

function TFhirClaimDiagnosisList.Clone: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Clone);
end;

function TFhirClaimDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimDiagnosisList.GetItemN(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimDiagnosis;
end;
function TFhirClaimDiagnosisList.IndexOf(value: TFhirClaimDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimDiagnosisList.Insert(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.InsertItem(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirClaimDiagnosisList.Item(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.Link: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Link);
end;

procedure TFhirClaimDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimDiagnosisList.SetItemByIndex(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  FhirClaimDiagnoses[index] := value;
end;

procedure TFhirClaimDiagnosisList.SetItemN(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimProcedure }

constructor TFhirClaimProcedure.Create;
begin
  inherited;
end;

destructor TFhirClaimProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimProcedure(oSource).sequenceElement.Clone;
  if (TFhirClaimProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimProcedure(oSource).FType_List);
  end;
  dateElement := TFhirClaimProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirClaimProcedure(oSource).procedure_.Clone;
  if (TFhirClaimProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirClaimProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProcedure_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
end;

function TFhirClaimProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirClaimProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_') {L1191}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil {L1189}
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirDataType {L1190}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimProcedure.fhirType : string;
begin
  result := 'Claim.procedure';
end;

function TFhirClaimProcedure.Link : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Link);
end;

function TFhirClaimProcedure.Clone : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Clone);
end;

function TFhirClaimProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirClaimProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimProcedure)) then
    result := false
  else
  begin
    o := TFhirClaimProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirClaimProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirClaimProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirClaimProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirClaimProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirClaimProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirClaimProcedure.SetProcedure_(value : TFhirDataType);
begin
  FProcedure_.free;
  FProcedure_ := value; {L1134}
end;

function TFhirClaimProcedure.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirClaimProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

function TFhirClaimProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirClaimProcedureListEnumerator }

constructor TFhirClaimProcedureListEnumerator.Create(list : TFhirClaimProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimProcedureListEnumerator.GetCurrent : TFhirClaimProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirClaimProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimProcedureList }

procedure TFhirClaimProcedureList.AddItem(value: TFhirClaimProcedure);
begin
  assert(value.ClassName = 'TFhirClaimProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimProcedure');
  add(value);
end;

function TFhirClaimProcedureList.Append: TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirClaimProcedureList.GetEnumerator : TFhirClaimProcedureListEnumerator;
begin
  result := TFhirClaimProcedureListEnumerator.Create(self.link);
end;

function TFhirClaimProcedureList.Clone: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Clone);
end;

function TFhirClaimProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimProcedureList.GetItemN(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimProcedure;
end;
function TFhirClaimProcedureList.IndexOf(value: TFhirClaimProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimProcedureList.Insert(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.InsertItem(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  Inherited Insert(index, value);
end;

function TFhirClaimProcedureList.Item(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.Link: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Link);
end;

procedure TFhirClaimProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimProcedureList.SetItemByIndex(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  FhirClaimProcedures[index] := value;
end;

procedure TFhirClaimProcedureList.SetItemN(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimInsurance }

constructor TFhirClaimInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FIdentifier.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimInsurance(oSource).focalElement.Clone;
  identifier := TFhirClaimInsurance(oSource).identifier.Clone;
  coverage := TFhirClaimInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimInsurance(oSource).businessArrangementElement.Clone;
  if (TFhirClaimInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimInsurance(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link)); {L1172}
end;

function TFhirClaimInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)) {L1045}
  else inherited;
end;

function TFhirClaimInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'focal') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {L1223}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new() {L1053}
  else if (propName = 'claimResponse') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {L1054}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'focal') then FocalElement := asBoolean(new) {L1222}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new) {L1222}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {L1055}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination) {L1046}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimInsurance.fhirType : string;
begin
  result := 'Claim.insurance';
end;

function TFhirClaimInsurance.Link : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Link);
end;

function TFhirClaimInsurance.Clone : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Clone);
end;

function TFhirClaimInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true) and compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FIdentifier) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value; {L1134}
end;

function TFhirClaimInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirClaimInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirClaimInsurance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirClaimInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirClaimInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value; {L1134}
end;

function TFhirClaimInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirClaimInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

function TFhirClaimInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirClaimInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

procedure TFhirClaimInsurance.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value; {L1134}
end;

procedure TFhirClaimInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('identifier');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('preAuthRef');
  fields.add('claimResponse');
end;

function TFhirClaimInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimInsuranceListEnumerator }

constructor TFhirClaimInsuranceListEnumerator.Create(list : TFhirClaimInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimInsuranceListEnumerator.GetCurrent : TFhirClaimInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimInsuranceList }

procedure TFhirClaimInsuranceList.AddItem(value: TFhirClaimInsurance);
begin
  assert(value.ClassName = 'TFhirClaimInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimInsurance');
  add(value);
end;

function TFhirClaimInsuranceList.Append: TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimInsuranceList.GetEnumerator : TFhirClaimInsuranceListEnumerator;
begin
  result := TFhirClaimInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimInsuranceList.Clone: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Clone);
end;

function TFhirClaimInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimInsuranceList.GetItemN(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimInsurance;
end;
function TFhirClaimInsuranceList.IndexOf(value: TFhirClaimInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimInsuranceList.Insert(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.InsertItem(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimInsuranceList.Item(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.Link: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Link);
end;

procedure TFhirClaimInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  FhirClaimInsurances[index] := value;
end;

procedure TFhirClaimInsuranceList.SetItemN(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimAccident }

constructor TFhirClaimAccident.Create;
begin
  inherited;
end;

destructor TFhirClaimAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirClaimAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirClaimAccident(oSource).dateElement.Clone;
  type_ := TFhirClaimAccident(oSource).type_.Clone;
  location := TFhirClaimAccident(oSource).location.Clone;
end;

procedure TFhirClaimAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirClaimAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
end;

function TFhirClaimAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimAccident.fhirType : string;
begin
  result := 'Claim.accident';
end;

function TFhirClaimAccident.Link : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Link);
end;

function TFhirClaimAccident.Clone : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Clone);
end;

function TFhirClaimAccident.equals(other : TObject) : boolean; 
var
  o : TFhirClaimAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimAccident)) then
    result := false
  else
  begin
    o := TFhirClaimAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirClaimAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirClaimAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirClaimAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirClaimAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClaimAccident.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirClaimAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

function TFhirClaimAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirClaimAccidentListEnumerator }

constructor TFhirClaimAccidentListEnumerator.Create(list : TFhirClaimAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimAccidentListEnumerator.GetCurrent : TFhirClaimAccident;
begin
  Result := FList[FIndex];
end;

function TFhirClaimAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimAccidentList }

procedure TFhirClaimAccidentList.AddItem(value: TFhirClaimAccident);
begin
  assert(value.ClassName = 'TFhirClaimAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimAccident');
  add(value);
end;

function TFhirClaimAccidentList.Append: TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimAccidentList.GetEnumerator : TFhirClaimAccidentListEnumerator;
begin
  result := TFhirClaimAccidentListEnumerator.Create(self.link);
end;

function TFhirClaimAccidentList.Clone: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Clone);
end;

function TFhirClaimAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimAccidentList.GetItemN(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimAccident;
end;
function TFhirClaimAccidentList.IndexOf(value: TFhirClaimAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimAccidentList.Insert(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.InsertItem(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  Inherited Insert(index, value);
end;

function TFhirClaimAccidentList.Item(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.Link: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Link);
end;

procedure TFhirClaimAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimAccidentList.SetItemByIndex(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  FhirClaimAccidents[index] := value;
end;

procedure TFhirClaimAccidentList.SetItemN(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItem }

constructor TFhirClaimItem.Create;
begin
  inherited;
end;

destructor TFhirClaimItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItem(oSource).sequenceElement.Clone;
  if (TFhirClaimItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirClaimItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirClaimItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirClaimItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirClaimItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirClaimItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirClaimItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirClaimItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirClaimItem(oSource).revenue.Clone;
  category := TFhirClaimItem(oSource).category.Clone;
  productOrService := TFhirClaimItem(oSource).productOrService.Clone;
  if (TFhirClaimItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItem(oSource).FModifierList);
  end;
  if (TFhirClaimItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimItem(oSource).serviced.Clone;
  location := TFhirClaimItem(oSource).location.Clone;
  quantity := TFhirClaimItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItem(oSource).factorElement.Clone;
  net := TFhirClaimItem(oSource).net.Clone;
  if (TFhirClaimItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItem(oSource).FUdiList);
  end;
  bodySite := TFhirClaimItem(oSource).bodySite.Clone;
  if (TFhirClaimItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirClaimItem(oSource).FEncounterList);
  end;
  if (TFhirClaimItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimItemDetailList.Create;
    FDetailList.Assign(TFhirClaimItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimItemDetail, FDetailList.Link)) {L1039};
end;

function TFhirClaimItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimItemDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimItemDetail) {L1049}
  else inherited;
end;

function TFhirClaimItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new() {L1053}
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new() {L1053}
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new() {L1053}
  else if (propName = 'informationSequence') then result := InformationSequenceList.new() {L1053}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subSite') then result := SubSiteList.new() {L1053}
  else if (propName = 'encounter') then result := EncounterList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value) {L1054}
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value) {L1054}
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value) {L1054}
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value) {L1054}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil {L1189}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {L1054}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new) {L1055}
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new) {L1055}
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new) {L1055}
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new) {L1055}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {L1055}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination) {L1046}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination) {L1046}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination) {L1046}
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination) {L1046}
  else if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else if (propName = 'subSite') then SubSiteList.move(source, destination) {L1050}
  else if (propName = 'encounter') then EncounterList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItem.fhirType : string;
begin
  result := 'Claim.item';
end;

function TFhirClaimItem.Link : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Link);
end;

function TFhirClaimItem.Clone : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Clone);
end;

function TFhirClaimItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItem)) then
    result := false
  else
  begin
    o := TFhirClaimItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirClaimItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

function TFhirClaimItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

function TFhirClaimItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

function TFhirClaimItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

function TFhirClaimItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

function TFhirClaimItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

function TFhirClaimItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

function TFhirClaimItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

procedure TFhirClaimItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirClaimItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirClaimItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirClaimItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirClaimItem.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirClaimItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

function TFhirClaimItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirClaimItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirClaimItem.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirClaimItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirClaimItem.GetDetailList : TFhirClaimItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirClaimItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('detail');
end;

function TFhirClaimItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamSequenceList.sizeInBytes);
  inc(result, FdiagnosisSequenceList.sizeInBytes);
  inc(result, FprocedureSequenceList.sizeInBytes);
  inc(result, FinformationSequenceList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimItemListEnumerator }

constructor TFhirClaimItemListEnumerator.Create(list : TFhirClaimItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemListEnumerator.GetCurrent : TFhirClaimItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemList }

procedure TFhirClaimItemList.AddItem(value: TFhirClaimItem);
begin
  assert(value.ClassName = 'TFhirClaimItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItem');
  add(value);
end;

function TFhirClaimItemList.Append: TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemList.GetEnumerator : TFhirClaimItemListEnumerator;
begin
  result := TFhirClaimItemListEnumerator.Create(self.link);
end;

function TFhirClaimItemList.Clone: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Clone);
end;

function TFhirClaimItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemList.GetItemN(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItem;
end;
function TFhirClaimItemList.IndexOf(value: TFhirClaimItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemList.Insert(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.InsertItem(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  Inherited Insert(index, value);
end;

function TFhirClaimItemList.Item(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.Link: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Link);
end;

procedure TFhirClaimItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemList.SetItemByIndex(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  FhirClaimItems[index] := value;
end;

procedure TFhirClaimItemList.SetItemN(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetail }

constructor TFhirClaimItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetail(oSource).net.Clone;
  if (TFhirClaimItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItemDetail(oSource).FUdiList);
  end;
  if (TFhirClaimItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimItemDetailSubDetail, FSubDetailList.Link)) {L1039};
end;

function TFhirClaimItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimItemDetailSubDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimItemDetailSubDetail) {L1049}
  else inherited;
end;

function TFhirClaimItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else if (propName = 'subDetail') then result := SubDetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetail.fhirType : string;
begin
  result := 'Claim.item.detail';
end;

function TFhirClaimItemDetail.Link : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Link);
end;

function TFhirClaimItemDetail.Clone : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Clone);
end;

function TFhirClaimItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirClaimItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirClaimItemDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirClaimItemDetail.GetSubDetailList : TFhirClaimItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

procedure TFhirClaimItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('subDetail');
end;

function TFhirClaimItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimItemDetailListEnumerator }

constructor TFhirClaimItemDetailListEnumerator.Create(list : TFhirClaimItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailListEnumerator.GetCurrent : TFhirClaimItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailList }

procedure TFhirClaimItemDetailList.AddItem(value: TFhirClaimItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetail');
  add(value);
end;

function TFhirClaimItemDetailList.Append: TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailList.GetEnumerator : TFhirClaimItemDetailListEnumerator;
begin
  result := TFhirClaimItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailList.Clone: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Clone);
end;

function TFhirClaimItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailList.GetItemN(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetail;
end;
function TFhirClaimItemDetailList.IndexOf(value: TFhirClaimItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailList.Insert(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailList.Item(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.Link: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  FhirClaimItemDetails[index] := value;
end;

procedure TFhirClaimItemDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetailSubDetail }

constructor TFhirClaimItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirClaimItemDetailSubDetail(oSource).FUdiList);
  end;
end;

procedure TFhirClaimItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
end;

function TFhirClaimItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirClaimItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetailSubDetail.fhirType : string;
begin
  result := 'Claim.item.detail.subDetail';
end;

function TFhirClaimItemDetailSubDetail.Link : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Link);
end;

function TFhirClaimItemDetailSubDetail.Clone : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList);
end;

procedure TFhirClaimItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirClaimItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirClaimItemDetailSubDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirClaimItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirClaimItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
end;

function TFhirClaimItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailListEnumerator }

constructor TFhirClaimItemDetailSubDetailListEnumerator.Create(list : TFhirClaimItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailList }

procedure TFhirClaimItemDetailSubDetailList.AddItem(value: TFhirClaimItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetailSubDetail');
  add(value);
end;

function TFhirClaimItemDetailSubDetailList.Append: TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailSubDetailList.GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailSubDetailList.Clone: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetailSubDetail;
end;
function TFhirClaimItemDetailSubDetailList.IndexOf(value: TFhirClaimItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailSubDetailList.Insert(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailSubDetailList.Item(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.Link: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  FhirClaimItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaim }

constructor TFhirClaim.Create;
begin
  inherited;
end;

destructor TFhirClaim.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FTotal.free;
  inherited;
end;

procedure TFhirClaim.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaim(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaim(oSource).FIdentifierList);
  end;
  statusElement := TFhirClaim(oSource).statusElement.Clone;
  type_ := TFhirClaim(oSource).type_.Clone;
  subType := TFhirClaim(oSource).subType.Clone;
  useElement := TFhirClaim(oSource).useElement.Clone;
  patient := TFhirClaim(oSource).patient.Clone;
  billablePeriod := TFhirClaim(oSource).billablePeriod.Clone;
  createdElement := TFhirClaim(oSource).createdElement.Clone;
  enterer := TFhirClaim(oSource).enterer.Clone;
  insurer := TFhirClaim(oSource).insurer.Clone;
  provider := TFhirClaim(oSource).provider.Clone;
  priority := TFhirClaim(oSource).priority.Clone;
  fundsReserve := TFhirClaim(oSource).fundsReserve.Clone;
  if (TFhirClaim(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirClaimRelatedList.Create;
    FRelatedList.Assign(TFhirClaim(oSource).FRelatedList);
  end;
  prescription := TFhirClaim(oSource).prescription.Clone;
  originalPrescription := TFhirClaim(oSource).originalPrescription.Clone;
  payee := TFhirClaim(oSource).payee.Clone;
  referral := TFhirClaim(oSource).referral.Clone;
  facility := TFhirClaim(oSource).facility.Clone;
  if (TFhirClaim(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirClaimCareTeamList.Create;
    FCareTeamList.Assign(TFhirClaim(oSource).FCareTeamList);
  end;
  if (TFhirClaim(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirClaim(oSource).FSupportingInfoList);
  end;
  if (TFhirClaim(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirClaimDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirClaim(oSource).FDiagnosisList);
  end;
  if (TFhirClaim(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirClaimProcedureList.Create;
    FProcedure_List.Assign(TFhirClaim(oSource).FProcedure_List);
  end;
  if (TFhirClaim(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaim(oSource).FInsuranceList);
  end;
  accident := TFhirClaim(oSource).accident.Clone;
  if (TFhirClaim(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimItemList.Create;
    FItemList.Assign(TFhirClaim(oSource).FItemList);
  end;
  total := TFhirClaim(oSource).total.Clone;
end;

function TFhirClaim.GetResourceType : TFhirResourceType;
begin
  result := frtClaim;
end;

procedure TFhirClaim.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
end;

procedure TFhirClaim.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirClaimRelated, FRelatedList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference', false, TFhirReference, FPrescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference', false, TFhirReference, FOriginalPrescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payee', 'BackboneElement', false, TFhirClaimPayee, FPayee.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference', false, TFhirReference, FReferral.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'careTeam', 'BackboneElement', true, TFhirClaimCareTeam, FCareTeamList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirClaimSupportingInfo, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirClaimDiagnosis, FDiagnosisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirClaimProcedure, FProcedure_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirClaimInsurance, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'accident', 'BackboneElement', false, TFhirClaimAccident, FAccident.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirClaimItem, FItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'total', 'Money', false, TFhirMoney, FTotal.Link)); {L1172}
end;

function TFhirClaim.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirClaimRelated) {L1048};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirClaimPayee {L1199};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirClaimCareTeam) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirClaimSupportingInfo) {L1048};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirClaimDiagnosis) {L1048};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirClaimProcedure) {L1048};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimInsurance) {L1048};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirClaimAccident {L1199};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimItem) {L1048};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaim.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirClaimRelated) {L1049}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirClaimCareTeam) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirClaimSupportingInfo) {L1049}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirClaimDiagnosis) {L1049}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirClaimProcedure) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimInsurance) {L1049}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimItem) {L1049}
  else inherited;
end;

function TFhirClaim.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'enterer') then result := TFhirReference.create() {L1203}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'related') then result := RelatedList.new() {L1053}
  else if (propName = 'prescription') then result := TFhirReference.create() {L1203}
  else if (propName = 'originalPrescription') then result := TFhirReference.create() {L1203}
  else if (propName = 'payee') then result := TFhirClaimPayee.create() {L1203}
  else if (propName = 'referral') then result := TFhirReference.create() {L1203}
  else if (propName = 'facility') then result := TFhirReference.create() {L1203}
  else if (propName = 'careTeam') then result := CareTeamList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'diagnosis') then result := DiagnosisList.new() {L1053}
  else if (propName = 'procedure') then result := Procedure_List.new() {L1053}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'accident') then result := TFhirClaimAccident.create() {L1203}
  else if (propName = 'item') then result := ItemList.new() {L1053}
  else if (propName = 'total') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaim.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := 'BackboneElement'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := 'BackboneElement'
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'accident') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'total') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaim.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {L1054}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {L1054}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {L1054}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else if (propName = 'total') then TotalElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaim.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference {L1195}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {L1055}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference {L1195}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference {L1195}
  else if (propName = 'payee') then PayeeElement := new as TFhirClaimPayee {L1195}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference {L1195}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference {L1195}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {L1055}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {L1055}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'accident') then AccidentElement := new as TFhirClaimAccident {L1195}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else if (propName = 'total') then TotalElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaim.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'related') then RelatedList.move(source, destination) {L1050}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination) {L1050}
  else if (propName = 'procedure') then Procedure_List.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaim.fhirType : string;
begin
  result := 'Claim';
end;

function TFhirClaim.Link : TFhirClaim;
begin
  result := TFhirClaim(inherited Link);
end;

function TFhirClaim.Clone : TFhirClaim;
begin
  result := TFhirClaim(inherited Clone);
end;

function TFhirClaim.equals(other : TObject) : boolean; 
var
  o : TFhirClaim;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaim)) then
    result := false
  else
  begin
    o := TFhirClaim(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(accidentElement, o.accidentElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(totalElement, o.totalElement, true);
  end;
end;

function TFhirClaim.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident) and isEmptyProp(FitemList) and isEmptyProp(FTotal);
end;

function TFhirClaim.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClaim.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClaim.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClaim.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirClaim.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirClaim.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClaim.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value; {L1134}
end;

procedure TFhirClaim.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirClaim.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirClaim.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirClaim.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirClaim.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value; {L1134}
end;

procedure TFhirClaim.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirClaim.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirClaim.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirClaim.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value; {L1134}
end;

procedure TFhirClaim.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

procedure TFhirClaim.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirClaim.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

procedure TFhirClaim.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value; {L1134}
end;

function TFhirClaim.GetRelatedList : TFhirClaimRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirClaimRelatedList.Create;
  result := FRelatedList;
end;

function TFhirClaim.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirClaim.SetPrescription(value : TFhirReference);
begin
  FPrescription.free;
  FPrescription := value; {L1134}
end;

procedure TFhirClaim.SetOriginalPrescription(value : TFhirReference);
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value; {L1134}
end;

procedure TFhirClaim.SetPayee(value : TFhirClaimPayee);
begin
  FPayee.free;
  FPayee := value; {L1134}
end;

procedure TFhirClaim.SetReferral(value : TFhirReference);
begin
  FReferral.free;
  FReferral := value; {L1134}
end;

procedure TFhirClaim.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value; {L1134}
end;

function TFhirClaim.GetCareTeamList : TFhirClaimCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirClaimCareTeamList.Create;
  result := FCareTeamList;
end;

function TFhirClaim.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirClaim.GetSupportingInfoList : TFhirClaimSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirClaim.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirClaim.GetDiagnosisList : TFhirClaimDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirClaimDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirClaim.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirClaim.GetProcedure_List : TFhirClaimProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirClaimProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirClaim.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

function TFhirClaim.GetInsuranceList : TFhirClaimInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirClaim.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirClaim.SetAccident(value : TFhirClaimAccident);
begin
  FAccident.free;
  FAccident := value; {L1134}
end;

function TFhirClaim.GetItemList : TFhirClaimItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimItemList.Create;
  result := FItemList;
end;

function TFhirClaim.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

procedure TFhirClaim.SetTotal(value : TFhirMoney);
begin
  FTotal.free;
  FTotal := value; {L1134}
end;

procedure TFhirClaim.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('total');
end;

function TFhirClaim.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
end;

{ TFhirClaimListEnumerator }

constructor TFhirClaimListEnumerator.Create(list : TFhirClaimList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimListEnumerator.GetCurrent : TFhirClaim;
begin
  Result := FList[FIndex];
end;

function TFhirClaimListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimList }

procedure TFhirClaimList.AddItem(value: TFhirClaim);
begin
  assert(value.ClassName = 'TFhirClaim', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaim');
  add(value);
end;

function TFhirClaimList.Append: TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.ClearItems;
begin
  Clear;
end;

function TFhirClaimList.GetEnumerator : TFhirClaimListEnumerator;
begin
  result := TFhirClaimListEnumerator.Create(self.link);
end;

function TFhirClaimList.Clone: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Clone);
end;

function TFhirClaimList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimList.GetItemN(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaim;
end;
function TFhirClaimList.IndexOf(value: TFhirClaim): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimList.Insert(index: Integer): TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.InsertItem(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  Inherited Insert(index, value);
end;

function TFhirClaimList.Item(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.Link: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Link);
end;

procedure TFhirClaimList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimList.SetItemByIndex(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  FhirClaims[index] := value;
end;

procedure TFhirClaimList.SetItemN(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
{ TFhirClaimResponseItem }

constructor TFhirClaimResponseItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItem.Destroy;
begin
  FItemSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseItem(oSource).itemSequenceElement.Clone;
  if (TFhirClaimResponseItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', 'BackboneElement', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimResponseItemDetail, FDetailList.Link)) {L1039};
end;

function TFhirClaimResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseItemDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseItemDetail) {L1049}
  else inherited;
end;

function TFhirClaimResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItem.fhirType : string;
begin
  result := 'ClaimResponse.item';
end;

function TFhirClaimResponseItem.Link : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Link);
end;

function TFhirClaimResponseItem.Clone : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Clone);
end;

function TFhirClaimResponseItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItem(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseItem.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value; {L1134}
end;

function TFhirClaimResponseItem.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

procedure TFhirClaimResponseItem.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

function TFhirClaimResponseItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItem.GetDetailList : TFhirClaimResponseItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimResponseItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirClaimResponseItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirClaimResponseItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItemSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemListEnumerator }

constructor TFhirClaimResponseItemListEnumerator.Create(list : TFhirClaimResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemListEnumerator.GetCurrent : TFhirClaimResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemList }

procedure TFhirClaimResponseItemList.AddItem(value: TFhirClaimResponseItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItem');
  add(value);
end;

function TFhirClaimResponseItemList.Append: TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemList.GetEnumerator : TFhirClaimResponseItemListEnumerator;
begin
  result := TFhirClaimResponseItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemList.Clone: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Clone);
end;

function TFhirClaimResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemList.GetItemN(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItem;
end;
function TFhirClaimResponseItemList.IndexOf(value: TFhirClaimResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemList.Insert(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.InsertItem(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemList.Item(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.Link: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Link);
end;

procedure TFhirClaimResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  FhirClaimResponseItems[index] := value;
end;

procedure TFhirClaimResponseItemList.SetItemN(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemAdjudication }

constructor TFhirClaimResponseItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseItemAdjudication(oSource).category.Clone;
  reason := TFhirClaimResponseItemAdjudication(oSource).reason.Clone;
  amount := TFhirClaimResponseItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link)); {L1172}
end;

function TFhirClaimResponseItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'value') then result := TFhirDecimal.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else if (propName = 'value') then ValueElement := asDecimal(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemAdjudication.fhirType : string;
begin
  result := 'ClaimResponse.item.adjudication';
end;

function TFhirClaimResponseItemAdjudication.Link : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Link);
end;

function TFhirClaimResponseItemAdjudication.Clone : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimResponseItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value; {L1134}
end;

procedure TFhirClaimResponseItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirClaimResponseItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirClaimResponseItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirClaimResponseItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirClaimResponseItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

function TFhirClaimResponseItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationListEnumerator }

constructor TFhirClaimResponseItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationList }

procedure TFhirClaimResponseItemAdjudicationList.AddItem(value: TFhirClaimResponseItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemAdjudication');
  add(value);
end;

function TFhirClaimResponseItemAdjudicationList.Append: TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemAdjudicationList.GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemAdjudicationList.Clone: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemAdjudication;
end;
function TFhirClaimResponseItemAdjudicationList.IndexOf(value: TFhirClaimResponseItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemAdjudicationList.Item(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.Link: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  FhirClaimResponseItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetail }

constructor TFhirClaimResponseItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetail.Destroy;
begin
  FDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  detailSequenceElement := TFhirClaimResponseItemDetail(oSource).detailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimResponseItemDetailSubDetail, FSubDetailList.Link)) {L1039};
end;

function TFhirClaimResponseItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseItemDetailSubDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetail) {L1049}
  else inherited;
end;

function TFhirClaimResponseItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'detailSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'subDetail') then result := SubDetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetail.fhirType : string;
begin
  result := 'ClaimResponse.item.detail';
end;

function TFhirClaimResponseItemDetail.Link : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Link);
end;

function TFhirClaimResponseItemDetail.Clone : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetail(other);
    result := compareDeep(detailSequenceElement, o.detailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseItemDetail.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value; {L1134}
end;

function TFhirClaimResponseItemDetail.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

procedure TFhirClaimResponseItemDetail.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

function TFhirClaimResponseItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItemDetail.GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimResponseItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

procedure TFhirClaimResponseItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('detailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirClaimResponseItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDetailSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailListEnumerator }

constructor TFhirClaimResponseItemDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailList }

procedure TFhirClaimResponseItemDetailList.AddItem(value: TFhirClaimResponseItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailList.Append: TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailList.GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailList.Clone: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetail;
end;
function TFhirClaimResponseItemDetailList.IndexOf(value: TFhirClaimResponseItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailList.Insert(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailList.Item(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.Link: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  FhirClaimResponseItemDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetail }

constructor TFhirClaimResponseItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetail.Destroy;
begin
  FSubDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  subDetailSequenceElement := TFhirClaimResponseItemDetailSubDetail(oSource).subDetailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
end;

function TFhirClaimResponseItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else inherited;
end;

function TFhirClaimResponseItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetail.fhirType : string;
begin
  result := 'ClaimResponse.item.detail.subDetail';
end;

function TFhirClaimResponseItemDetailSubDetail.Link : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetail.Clone : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetail(other);
    result := compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value; {L1134}
end;

function TFhirClaimResponseItemDetailSubDetail.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

function TFhirClaimResponseItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

procedure TFhirClaimResponseItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subDetailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirClaimResponseItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubDetailSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailListEnumerator }

constructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailList }

procedure TFhirClaimResponseItemDetailSubDetailList.AddItem(value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Append: TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailList.Clone: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetail;
end;
function TFhirClaimResponseItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.Link: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  FhirClaimResponseItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItem }

constructor TFhirClaimResponseAddItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubdetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponseAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList = nil) then
  begin
    FSubdetailSequenceList.free;
    FSubdetailSequenceList := nil;
  end
  else
  begin
    if FSubdetailSequenceList = nil then
      FSubdetailSequenceList := TFhirPositiveIntList.Create;
    FSubdetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList.Create;
    FProviderList.Assign(TFhirClaimResponseAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirClaimResponseAddItem(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItem(oSource).FModifierList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimResponseAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimResponseAddItem(oSource).serviced.Clone;
  location := TFhirClaimResponseAddItem(oSource).location.Clone;
  quantity := TFhirClaimResponseAddItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItem(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItem(oSource).net.Clone;
  bodySite := TFhirClaimResponseAddItem(oSource).bodySite.Clone;
  if (TFhirClaimResponseAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimResponseAddItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseAddItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subdetailSequence') Then
    list.addAll(self, 'subdetailSequence', FSubdetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subdetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubdetailSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', true, TFhirReference, FProviderList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirClaimResponseAddItemDetail, FDetailList.Link)) {L1039};
end;

function TFhirClaimResponseAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subdetailSequence') then
  begin
    SubdetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseAddItemDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetail) {L1049}
  else inherited;
end;

function TFhirClaimResponseAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new() {L1053}
  else if (propName = 'detailSequence') then result := DetailSequenceList.new() {L1053}
  else if (propName = 'subdetailSequence') then result := SubdetailSequenceList.new() {L1053}
  else if (propName = 'provider') then result := ProviderList.new() {L1053}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subSite') then result := SubSiteList.new() {L1053}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subdetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value) {L1054}
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value) {L1054}
  else if (propName = 'subdetailSequence') then deletePropertyValue('subdetailSequence', SubdetailSequenceList, value) {L1054}
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value) {L1054}
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil {L1189}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {L1054}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new) {L1055}
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new) {L1055}
  else if (propName = 'subdetailSequence') then replacePropertyValue('subdetailSequence', SubdetailSequenceList, existing, new) {L1055}
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new) {L1055}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {L1055}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination) {L1046}
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination) {L1046}
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.move(source, destination) {L1046}
  else if (propName = 'provider') then ProviderList.move(source, destination) {L1050}
  else if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'subSite') then SubSiteList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItem.fhirType : string;
begin
  result := 'ClaimResponse.addItem';
end;

function TFhirClaimResponseAddItem.Link : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Link);
end;

function TFhirClaimResponseAddItem.Clone : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Clone);
end;

function TFhirClaimResponseAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subdetailSequenceList, o.subdetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubdetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

function TFhirClaimResponseAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetSubdetailSequenceList : TFhirPositiveIntList;
begin
  if FSubdetailSequenceList = nil then
    FSubdetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubdetailSequenceList;
end;

function TFhirClaimResponseAddItem.GetHasSubdetailSequenceList : boolean;
begin
  result := (FSubdetailSequenceList <> nil) and (FSubdetailSequenceList.count > 0);
end;

function TFhirClaimResponseAddItem.GetProviderList : TFhirReferenceList;
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList.Create;
  result := FProviderList;
end;

function TFhirClaimResponseAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

procedure TFhirClaimResponseAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimResponseAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirClaimResponseAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirClaimResponseAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirClaimResponseAddItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirClaimResponseAddItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirClaimResponseAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimResponseAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimResponseAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimResponseAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

procedure TFhirClaimResponseAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

function TFhirClaimResponseAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirClaimResponseAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirClaimResponseAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItem.GetDetailList : TFhirClaimResponseAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseAddItemDetailList.Create;
  result := FDetailList;
end;

function TFhirClaimResponseAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirClaimResponseAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subdetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirClaimResponseAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FitemSequenceList.sizeInBytes);
  inc(result, FdetailSequenceList.sizeInBytes);
  inc(result, FsubdetailSequenceList.sizeInBytes);
  inc(result, FproviderList.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemListEnumerator }

constructor TFhirClaimResponseAddItemListEnumerator.Create(list : TFhirClaimResponseAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemListEnumerator.GetCurrent : TFhirClaimResponseAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemList }

procedure TFhirClaimResponseAddItemList.AddItem(value: TFhirClaimResponseAddItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItem');
  add(value);
end;

function TFhirClaimResponseAddItemList.Append: TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemList.GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
begin
  result := TFhirClaimResponseAddItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemList.Clone: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Clone);
end;

function TFhirClaimResponseAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemList.GetItemN(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItem;
end;
function TFhirClaimResponseAddItemList.IndexOf(value: TFhirClaimResponseAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemList.Insert(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.InsertItem(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemList.Item(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.Link: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Link);
end;

procedure TFhirClaimResponseAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  FhirClaimResponseAddItems[index] := value;
end;

procedure TFhirClaimResponseAddItemList.SetItemN(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetail }

constructor TFhirClaimResponseAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirClaimResponseAddItemDetailSubDetail, FSubDetailList.Link)) {L1039};
end;

function TFhirClaimResponseAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseAddItemDetailSubDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetailSubDetail) {L1049}
  else inherited;
end;

function TFhirClaimResponseAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'subDetail') then result := SubDetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetail.fhirType : string;
begin
  result := 'ClaimResponse.addItem.detail';
end;

function TFhirClaimResponseAddItemDetail.Link : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetail.Clone : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimResponseAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimResponseAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimResponseAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimResponseAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirClaimResponseAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirClaimResponseAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirClaimResponseAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailListEnumerator }

constructor TFhirClaimResponseAddItemDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailList }

procedure TFhirClaimResponseAddItemDetailList.AddItem(value: TFhirClaimResponseAddItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailList.Append: TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailList.Clone: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetail;
end;
function TFhirClaimResponseAddItemDetailList.IndexOf(value: TFhirClaimResponseAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.Link: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  FhirClaimResponseAddItemDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetailSubDetail }

constructor TFhirClaimResponseAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
end;

function TFhirClaimResponseAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetailSubDetail.fhirType : string;
begin
  result := 'ClaimResponse.addItem.detail.subDetail';
end;

function TFhirClaimResponseAddItemDetailSubDetail.Link : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetailSubDetail.Clone : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponseAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirClaimResponseAddItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailSubDetailListEnumerator }

constructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailSubDetailList }

procedure TFhirClaimResponseAddItemDetailSubDetailList.AddItem(value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Append: TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Clone: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail;
end;
function TFhirClaimResponseAddItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Link: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  FhirClaimResponseAddItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseTotal }

constructor TFhirClaimResponseTotal.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirClaimResponseTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseTotal(oSource).category.Clone;
  amount := TFhirClaimResponseTotal(oSource).amount.Clone;
end;

procedure TFhirClaimResponseTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirClaimResponseTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
end;

function TFhirClaimResponseTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseTotal.fhirType : string;
begin
  result := 'ClaimResponse.total';
end;

function TFhirClaimResponseTotal.Link : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Link);
end;

function TFhirClaimResponseTotal.Clone : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Clone);
end;

function TFhirClaimResponseTotal.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseTotal)) then
    result := false
  else
  begin
    o := TFhirClaimResponseTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirClaimResponseTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirClaimResponseTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirClaimResponseTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirClaimResponseTotal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

function TFhirClaimResponseTotal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirClaimResponseTotalListEnumerator }

constructor TFhirClaimResponseTotalListEnumerator.Create(list : TFhirClaimResponseTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseTotalListEnumerator.GetCurrent : TFhirClaimResponseTotal;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseTotalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseTotalList }

procedure TFhirClaimResponseTotalList.AddItem(value: TFhirClaimResponseTotal);
begin
  assert(value.ClassName = 'TFhirClaimResponseTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseTotal');
  add(value);
end;

function TFhirClaimResponseTotalList.Append: TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseTotalList.GetEnumerator : TFhirClaimResponseTotalListEnumerator;
begin
  result := TFhirClaimResponseTotalListEnumerator.Create(self.link);
end;

function TFhirClaimResponseTotalList.Clone: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Clone);
end;

function TFhirClaimResponseTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseTotalList.GetItemN(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseTotal;
end;
function TFhirClaimResponseTotalList.IndexOf(value: TFhirClaimResponseTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseTotalList.Insert(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.InsertItem(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseTotalList.Item(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.Link: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Link);
end;

procedure TFhirClaimResponseTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseTotalList.SetItemByIndex(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  FhirClaimResponseTotals[index] := value;
end;

procedure TFhirClaimResponseTotalList.SetItemN(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponsePayment }

constructor TFhirClaimResponsePayment.Create;
begin
  inherited;
end;

destructor TFhirClaimResponsePayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirClaimResponsePayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimResponsePayment(oSource).type_.Clone;
  adjustment := TFhirClaimResponsePayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirClaimResponsePayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirClaimResponsePayment(oSource).dateElement.Clone;
  amount := TFhirClaimResponsePayment(oSource).amount.Clone;
  identifier := TFhirClaimResponsePayment(oSource).identifier.Clone;
end;

procedure TFhirClaimResponsePayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirClaimResponsePayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
end;

function TFhirClaimResponsePayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponsePayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponsePayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'adjustment') then result := TFhirMoney.create() {L1203}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponsePayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponsePayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponsePayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney {L1195}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponsePayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponsePayment.fhirType : string;
begin
  result := 'ClaimResponse.payment';
end;

function TFhirClaimResponsePayment.Link : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Link);
end;

function TFhirClaimResponsePayment.Clone : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Clone);
end;

function TFhirClaimResponsePayment.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponsePayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponsePayment)) then
    result := false
  else
  begin
    o := TFhirClaimResponsePayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirClaimResponsePayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirClaimResponsePayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClaimResponsePayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value; {L1134}
end;

procedure TFhirClaimResponsePayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value; {L1134}
end;

procedure TFhirClaimResponsePayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirClaimResponsePayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClaimResponsePayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirClaimResponsePayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirClaimResponsePayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirClaimResponsePayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

function TFhirClaimResponsePayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirClaimResponsePaymentListEnumerator }

constructor TFhirClaimResponsePaymentListEnumerator.Create(list : TFhirClaimResponsePaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponsePaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponsePaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponsePaymentListEnumerator.GetCurrent : TFhirClaimResponsePayment;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponsePaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponsePaymentList }

procedure TFhirClaimResponsePaymentList.AddItem(value: TFhirClaimResponsePayment);
begin
  assert(value.ClassName = 'TFhirClaimResponsePayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponsePayment');
  add(value);
end;

function TFhirClaimResponsePaymentList.Append: TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponsePaymentList.GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
begin
  result := TFhirClaimResponsePaymentListEnumerator.Create(self.link);
end;

function TFhirClaimResponsePaymentList.Clone: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Clone);
end;

function TFhirClaimResponsePaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponsePaymentList.GetItemN(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponsePayment;
end;
function TFhirClaimResponsePaymentList.IndexOf(value: TFhirClaimResponsePayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponsePaymentList.Insert(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.InsertItem(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  Inherited Insert(index, value);
end;

function TFhirClaimResponsePaymentList.Item(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.Link: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Link);
end;

procedure TFhirClaimResponsePaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponsePaymentList.SetItemByIndex(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  FhirClaimResponsePayments[index] := value;
end;

procedure TFhirClaimResponsePaymentList.SetItemN(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseProcessNote }

constructor TFhirClaimResponseProcessNote.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirClaimResponseProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirClaimResponseProcessNote(oSource).numberElement.Clone;
  type_Element := TFhirClaimResponseProcessNote(oSource).type_Element.Clone;
  textElement := TFhirClaimResponseProcessNote(oSource).textElement.Clone;
  language := TFhirClaimResponseProcessNote(oSource).language.Clone;
end;

procedure TFhirClaimResponseProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirClaimResponseProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
end;

function TFhirClaimResponseProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull])  {L1211}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new) {L1210}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseProcessNote.fhirType : string;
begin
  result := 'ClaimResponse.processNote';
end;

function TFhirClaimResponseProcessNote.Link : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Link);
end;

function TFhirClaimResponseProcessNote.Clone : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Clone);
end;

function TFhirClaimResponseProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseProcessNote)) then
    result := false
  else
  begin
    o := TFhirClaimResponseProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirClaimResponseProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirClaimResponseProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value; {L1134}
end;

function TFhirClaimResponseProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirClaimResponseProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirClaimResponseProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirClaimResponseProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirClaimResponseProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirClaimResponseProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirClaimResponseProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirClaimResponseProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirClaimResponseProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirClaimResponseProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

function TFhirClaimResponseProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteListEnumerator }

constructor TFhirClaimResponseProcessNoteListEnumerator.Create(list : TFhirClaimResponseProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseProcessNoteListEnumerator.GetCurrent : TFhirClaimResponseProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteList }

procedure TFhirClaimResponseProcessNoteList.AddItem(value: TFhirClaimResponseProcessNote);
begin
  assert(value.ClassName = 'TFhirClaimResponseProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseProcessNote');
  add(value);
end;

function TFhirClaimResponseProcessNoteList.Append: TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseProcessNoteList.GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
begin
  result := TFhirClaimResponseProcessNoteListEnumerator.Create(self.link);
end;

function TFhirClaimResponseProcessNoteList.Clone: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Clone);
end;

function TFhirClaimResponseProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseProcessNoteList.GetItemN(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseProcessNote;
end;
function TFhirClaimResponseProcessNoteList.IndexOf(value: TFhirClaimResponseProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseProcessNoteList.Insert(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.InsertItem(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseProcessNoteList.Item(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.Link: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Link);
end;

procedure TFhirClaimResponseProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseProcessNoteList.SetItemByIndex(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  FhirClaimResponseProcessNotes[index] := value;
end;

procedure TFhirClaimResponseProcessNoteList.SetItemN(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseInsurance }

constructor TFhirClaimResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimResponseInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimResponseInsurance(oSource).focalElement.Clone;
  coverage := TFhirClaimResponseInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimResponseInsurance(oSource).businessArrangementElement.Clone;
  claimResponse := TFhirClaimResponseInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link)); {L1172}
end;

function TFhirClaimResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'focal') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {L1223}
  else if (propName = 'claimResponse') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'focal') then FocalElement := asBoolean(new) {L1222}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new) {L1222}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseInsurance.fhirType : string;
begin
  result := 'ClaimResponse.insurance';
end;

function TFhirClaimResponseInsurance.Link : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Link);
end;

function TFhirClaimResponseInsurance.Clone : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Clone);
end;

function TFhirClaimResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimResponseInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimResponseInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirClaimResponseInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirClaimResponseInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirClaimResponseInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value; {L1134}
end;

function TFhirClaimResponseInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirClaimResponseInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirClaimResponseInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirClaimResponseInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value; {L1134}
end;

function TFhirClaimResponseInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirClaimResponseInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

procedure TFhirClaimResponseInsurance.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value; {L1134}
end;

procedure TFhirClaimResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('claimResponse');
end;

function TFhirClaimResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceListEnumerator }

constructor TFhirClaimResponseInsuranceListEnumerator.Create(list : TFhirClaimResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseInsuranceListEnumerator.GetCurrent : TFhirClaimResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceList }

procedure TFhirClaimResponseInsuranceList.AddItem(value: TFhirClaimResponseInsurance);
begin
  assert(value.ClassName = 'TFhirClaimResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseInsurance');
  add(value);
end;

function TFhirClaimResponseInsuranceList.Append: TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseInsuranceList.GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
begin
  result := TFhirClaimResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimResponseInsuranceList.Clone: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Clone);
end;

function TFhirClaimResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseInsuranceList.GetItemN(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseInsurance;
end;
function TFhirClaimResponseInsuranceList.IndexOf(value: TFhirClaimResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseInsuranceList.Insert(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.InsertItem(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseInsuranceList.Item(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.Link: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Link);
end;

procedure TFhirClaimResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  FhirClaimResponseInsurances[index] := value;
end;

procedure TFhirClaimResponseInsuranceList.SetItemN(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseError }

constructor TFhirClaimResponseError.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseError.Destroy;
begin
  FItemSequence.free;
  FDetailSequence.free;
  FSubDetailSequence.free;
  FCode.free;
  inherited;
end;

procedure TFhirClaimResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseError(oSource).itemSequenceElement.Clone;
  detailSequenceElement := TFhirClaimResponseError(oSource).detailSequenceElement.Clone;
  subDetailSequenceElement := TFhirClaimResponseError(oSource).subDetailSequenceElement.Clone;
  code := TFhirClaimResponseError(oSource).code.Clone;
end;

procedure TFhirClaimResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClaimResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
end;

function TFhirClaimResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'detailSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseError.fhirType : string;
begin
  result := 'ClaimResponse.error';
end;

function TFhirClaimResponseError.Link : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Link);
end;

function TFhirClaimResponseError.Clone : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Clone);
end;

function TFhirClaimResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseError)) then
    result := false
  else
  begin
    o := TFhirClaimResponseError(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(detailSequenceElement, o.detailSequenceElement, true) and compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClaimResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FDetailSequence) and isEmptyProp(FSubDetailSequence) and isEmptyProp(FCode);
end;

procedure TFhirClaimResponseError.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value; {L1134}
end;

function TFhirClaimResponseError.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

procedure TFhirClaimResponseError.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

procedure TFhirClaimResponseError.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value; {L1134}
end;

function TFhirClaimResponseError.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

procedure TFhirClaimResponseError.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

procedure TFhirClaimResponseError.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value; {L1134}
end;

function TFhirClaimResponseError.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

procedure TFhirClaimResponseError.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

procedure TFhirClaimResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirClaimResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('code');
end;

function TFhirClaimResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItemSequence.sizeInBytes);
  inc(result, FDetailSequence.sizeInBytes);
  inc(result, FSubDetailSequence.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirClaimResponseErrorListEnumerator }

constructor TFhirClaimResponseErrorListEnumerator.Create(list : TFhirClaimResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseErrorListEnumerator.GetCurrent : TFhirClaimResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseErrorList }

procedure TFhirClaimResponseErrorList.AddItem(value: TFhirClaimResponseError);
begin
  assert(value.ClassName = 'TFhirClaimResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseError');
  add(value);
end;

function TFhirClaimResponseErrorList.Append: TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseErrorList.GetEnumerator : TFhirClaimResponseErrorListEnumerator;
begin
  result := TFhirClaimResponseErrorListEnumerator.Create(self.link);
end;

function TFhirClaimResponseErrorList.Clone: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Clone);
end;

function TFhirClaimResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseErrorList.GetItemN(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseError;
end;
function TFhirClaimResponseErrorList.IndexOf(value: TFhirClaimResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseErrorList.Insert(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.InsertItem(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseErrorList.Item(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.Link: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Link);
end;

procedure TFhirClaimResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseErrorList.SetItemByIndex(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  FhirClaimResponseErrors[index] := value;
end;

procedure TFhirClaimResponseErrorList.SetItemN(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponse }

constructor TFhirClaimResponse.Create;
begin
  inherited;
end;

destructor TFhirClaimResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FCreated.free;
  FInsurer.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRef.free;
  FPreAuthPeriod.free;
  FPayeeType.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFundsReserve.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FCommunicationRequestList.Free;
  FInsuranceList.Free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirClaimResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaimResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirClaimResponse(oSource).statusElement.Clone;
  type_ := TFhirClaimResponse(oSource).type_.Clone;
  subType := TFhirClaimResponse(oSource).subType.Clone;
  useElement := TFhirClaimResponse(oSource).useElement.Clone;
  patient := TFhirClaimResponse(oSource).patient.Clone;
  createdElement := TFhirClaimResponse(oSource).createdElement.Clone;
  insurer := TFhirClaimResponse(oSource).insurer.Clone;
  requestor := TFhirClaimResponse(oSource).requestor.Clone;
  request := TFhirClaimResponse(oSource).request.Clone;
  outcomeElement := TFhirClaimResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirClaimResponse(oSource).dispositionElement.Clone;
  preAuthRefElement := TFhirClaimResponse(oSource).preAuthRefElement.Clone;
  preAuthPeriod := TFhirClaimResponse(oSource).preAuthPeriod.Clone;
  payeeType := TFhirClaimResponse(oSource).payeeType.Clone;
  if (TFhirClaimResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimResponseItemList.Create;
    FItemList.Assign(TFhirClaimResponse(oSource).FItemList);
  end;
  if (TFhirClaimResponse(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirClaimResponseAddItemList.Create;
    FAddItemList.Assign(TFhirClaimResponse(oSource).FAddItemList);
  end;
  if (TFhirClaimResponse(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponse(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponse(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirClaimResponseTotalList.Create;
    FTotalList.Assign(TFhirClaimResponse(oSource).FTotalList);
  end;
  payment := TFhirClaimResponse(oSource).payment.Clone;
  fundsReserve := TFhirClaimResponse(oSource).fundsReserve.Clone;
  formCode := TFhirClaimResponse(oSource).formCode.Clone;
  form := TFhirClaimResponse(oSource).form.Clone;
  if (TFhirClaimResponse(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirClaimResponse(oSource).FProcessNoteList);
  end;
  if (TFhirClaimResponse(oSource).FCommunicationRequestList = nil) then
  begin
    FCommunicationRequestList.free;
    FCommunicationRequestList := nil;
  end
  else
  begin
    if FCommunicationRequestList = nil then
      FCommunicationRequestList := TFhirReferenceList.Create;
    FCommunicationRequestList.Assign(TFhirClaimResponse(oSource).FCommunicationRequestList);
  end;
  if (TFhirClaimResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaimResponse(oSource).FInsuranceList);
  end;
  if (TFhirClaimResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirClaimResponseErrorList.Create;
    FErrorList.Assign(TFhirClaimResponse(oSource).FErrorList);
  end;
end;

function TFhirClaimResponse.GetResourceType : TFhirResourceType;
begin
  result := frtClaimResponse;
end;

procedure TFhirClaimResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'preAuthPeriod') Then
     list.add(self.link, 'preAuthPeriod', FPreAuthPeriod.Link);
  if (child_name = 'payeeType') Then
     list.add(self.link, 'payeeType', FPayeeType.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'communicationRequest') Then
    list.addAll(self, 'communicationRequest', FCommunicationRequestList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirClaimResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preAuthPeriod', 'Period', false, TFhirPeriod, FPreAuthPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payeeType', 'CodeableConcept', false, TFhirCodeableConcept, FPayeeType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirClaimResponseItem, FItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'addItem', 'BackboneElement', true, TFhirClaimResponseAddItem, FAddItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'total', 'BackboneElement', true, TFhirClaimResponseTotal, FTotalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'payment', 'BackboneElement', false, TFhirClaimResponsePayment, FPayment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirClaimResponseProcessNote, FProcessNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'communicationRequest', 'Reference', true, TFhirReference, FCommunicationRequestList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirClaimResponseInsurance, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'error', 'BackboneElement', true, TFhirClaimResponseError, FErrorList.Link)) {L1039};
end;

function TFhirClaimResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'preAuthPeriod') then
  begin
    PreAuthPeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'payeeType') then
  begin
    PayeeType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimResponseItem) {L1048};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirClaimResponseAddItem) {L1048};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirClaimResponseTotal) {L1048};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirClaimResponsePayment {L1199};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirClaimResponseProcessNote) {L1048};
    result := propValue;
  end
  else if (propName = 'communicationRequest') then
  begin
    CommunicationRequestList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimResponseInsurance) {L1048};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirClaimResponseError) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimResponseItem) {L1049}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirClaimResponseAddItem) {L1049}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication) {L1049}
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirClaimResponseTotal) {L1049}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirClaimResponseProcessNote) {L1049}
  else if (propName = 'communicationRequest') then CommunicationRequestList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimResponseInsurance) {L1049}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirClaimResponseError) {L1049}
  else inherited;
end;

function TFhirClaimResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'requestor') then result := TFhirReference.create() {L1203}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull])  {L1211}
  else if (propName = 'disposition') then result := TFhirString.create() {L1223}
  else if (propName = 'preAuthRef') then result := TFhirString.create() {L1223}
  else if (propName = 'preAuthPeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'payeeType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'item') then result := ItemList.new() {L1053}
  else if (propName = 'addItem') then result := AddItemList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'total') then result := TotalList.new() {L1053}
  else if (propName = 'payment') then result := TFhirClaimResponsePayment.create() {L1203}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'form') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'processNote') then result := ProcessNoteList.new() {L1053}
  else if (propName = 'communicationRequest') then result := CommunicationRequestList.new() {L1053}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'error') then result := ErrorList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthPeriod') then result := 'Period'
  else if (propName = 'payeeType') then result := 'CodeableConcept'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'addItem') then result := 'BackboneElement'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'total') then result := 'BackboneElement'
  else if (propName = 'payment') then result := 'BackboneElement'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else if (propName = 'communicationRequest') then result := 'Reference'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'error') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := nil
  else if (propName = 'payeeType') then PayeeTypeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value) {L1054}
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {L1054}
  else if (propName = 'communicationRequest') then deletePropertyValue('communicationRequest', CommunicationRequestList, value) {L1054}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference {L1195}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new) {L1210}
  else if (propName = 'disposition') then DispositionElement := asString(new) {L1222}
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new) {L1222}
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'payeeType') then PayeeTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new) {L1055}
  else if (propName = 'payment') then PaymentElement := new as TFhirClaimResponsePayment {L1195}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'form') then FormElement := new as TFhirAttachment {L1195}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {L1055}
  else if (propName = 'communicationRequest') then replacePropertyValue('communicationRequest', CommunicationRequestList, existing, new) {L1055}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else if (propName = 'addItem') then AddItemList.move(source, destination) {L1050}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'total') then TotalList.move(source, destination) {L1050}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination) {L1050}
  else if (propName = 'communicationRequest') then CommunicationRequestList.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'error') then ErrorList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponse.fhirType : string;
begin
  result := 'ClaimResponse';
end;

function TFhirClaimResponse.Link : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Link);
end;

function TFhirClaimResponse.Clone : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Clone);
end;

function TFhirClaimResponse.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponse)) then
    result := false
  else
  begin
    o := TFhirClaimResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(preAuthPeriodElement, o.preAuthPeriodElement, true) and 
      compareDeep(payeeTypeElement, o.payeeTypeElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(addItemList, o.addItemList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(totalList, o.totalList, true) and compareDeep(paymentElement, o.paymentElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(communicationRequestList, o.communicationRequestList, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirClaimResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPreAuthRef) and isEmptyProp(FPreAuthPeriod) and isEmptyProp(FPayeeType) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFundsReserve) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FcommunicationRequestList) and isEmptyProp(FinsuranceList) and isEmptyProp(FerrorList);
end;

function TFhirClaimResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClaimResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClaimResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClaimResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirClaimResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirClaimResponse.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirClaimResponse.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value; {L1134}
end;

procedure TFhirClaimResponse.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirClaimResponse.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirClaimResponse.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirClaimResponse.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirClaimResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirClaimResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirClaimResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirClaimResponse.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

procedure TFhirClaimResponse.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value; {L1134}
end;

procedure TFhirClaimResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirClaimResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirClaimResponse.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirClaimResponse.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirClaimResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value; {L1134}
end;

function TFhirClaimResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirClaimResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirClaimResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value; {L1134}
end;

function TFhirClaimResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

procedure TFhirClaimResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

procedure TFhirClaimResponse.SetPreAuthPeriod(value : TFhirPeriod);
begin
  FPreAuthPeriod.free;
  FPreAuthPeriod := value; {L1134}
end;

procedure TFhirClaimResponse.SetPayeeType(value : TFhirCodeableConcept);
begin
  FPayeeType.free;
  FPayeeType := value; {L1134}
end;

function TFhirClaimResponse.GetItemList : TFhirClaimResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimResponseItemList.Create;
  result := FItemList;
end;

function TFhirClaimResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirClaimResponse.GetAddItemList : TFhirClaimResponseAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirClaimResponseAddItemList.Create;
  result := FAddItemList;
end;

function TFhirClaimResponse.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

function TFhirClaimResponse.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirClaimResponse.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponse.GetTotalList : TFhirClaimResponseTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirClaimResponseTotalList.Create;
  result := FTotalList;
end;

function TFhirClaimResponse.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

procedure TFhirClaimResponse.SetPayment(value : TFhirClaimResponsePayment);
begin
  FPayment.free;
  FPayment := value; {L1134}
end;

procedure TFhirClaimResponse.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value; {L1134}
end;

procedure TFhirClaimResponse.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value; {L1134}
end;

procedure TFhirClaimResponse.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value; {L1134}
end;

function TFhirClaimResponse.GetProcessNoteList : TFhirClaimResponseProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirClaimResponse.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

function TFhirClaimResponse.GetCommunicationRequestList : TFhirReferenceList;
begin
  if FCommunicationRequestList = nil then
    FCommunicationRequestList := TFhirReferenceList.Create;
  result := FCommunicationRequestList;
end;

function TFhirClaimResponse.GetHasCommunicationRequestList : boolean;
begin
  result := (FCommunicationRequestList <> nil) and (FCommunicationRequestList.count > 0);
end;

function TFhirClaimResponse.GetInsuranceList : TFhirClaimResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimResponseInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirClaimResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirClaimResponse.GetErrorList : TFhirClaimResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirClaimResponseErrorList.Create;
  result := FErrorList;
end;

function TFhirClaimResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

procedure TFhirClaimResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('created');
  fields.add('insurer');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthPeriod');
  fields.add('payeeType');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('fundsReserve');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('communicationRequest');
  fields.add('insurance');
  fields.add('error');
end;

function TFhirClaimResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPreAuthRef.sizeInBytes);
  inc(result, FPreAuthPeriod.sizeInBytes);
  inc(result, FPayeeType.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FtotalList.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FcommunicationRequestList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirClaimResponseListEnumerator }

constructor TFhirClaimResponseListEnumerator.Create(list : TFhirClaimResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseListEnumerator.GetCurrent : TFhirClaimResponse;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseList }

procedure TFhirClaimResponseList.AddItem(value: TFhirClaimResponse);
begin
  assert(value.ClassName = 'TFhirClaimResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponse');
  add(value);
end;

function TFhirClaimResponseList.Append: TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseList.GetEnumerator : TFhirClaimResponseListEnumerator;
begin
  result := TFhirClaimResponseListEnumerator.Create(self.link);
end;

function TFhirClaimResponseList.Clone: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Clone);
end;

function TFhirClaimResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseList.GetItemN(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponse;
end;
function TFhirClaimResponseList.IndexOf(value: TFhirClaimResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseList.Insert(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.InsertItem(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseList.Item(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.Link: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Link);
end;

procedure TFhirClaimResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseList.SetItemByIndex(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  FhirClaimResponses[index] := value;
end;

procedure TFhirClaimResponseList.SetItemN(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
{ TFhirCoverageClass }

constructor TFhirCoverageClass.Create;
begin
  inherited;
end;

destructor TFhirCoverageClass.Destroy;
begin
  FType_.free;
  FValue.free;
  FName.free;
  inherited;
end;

procedure TFhirCoverageClass.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageClass(oSource).type_.Clone;
  valueElement := TFhirCoverageClass(oSource).valueElement.Clone;
  nameElement := TFhirCoverageClass(oSource).nameElement.Clone;
end;

procedure TFhirCoverageClass.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirCoverageClass.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
end;

function TFhirCoverageClass.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageClass.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageClass.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'value') then result := TFhirString.create() {L1223}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageClass.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageClass.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageClass.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'value') then ValueElement := asString(new) {L1222}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageClass.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageClass.fhirType : string;
begin
  result := 'Coverage.class';
end;

function TFhirCoverageClass.Link : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Link);
end;

function TFhirCoverageClass.Clone : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Clone);
end;

function TFhirCoverageClass.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageClass;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageClass)) then
    result := false
  else
  begin
    o := TFhirCoverageClass(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirCoverageClass.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FName);
end;

procedure TFhirCoverageClass.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCoverageClass.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirCoverageClass.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirCoverageClass.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirCoverageClass.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCoverageClass.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCoverageClass.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCoverageClass.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('name');
end;

function TFhirCoverageClass.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FName.sizeInBytes);
end;

{ TFhirCoverageClassListEnumerator }

constructor TFhirCoverageClassListEnumerator.Create(list : TFhirCoverageClassList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageClassListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageClassListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageClassListEnumerator.GetCurrent : TFhirCoverageClass;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageClassListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageClassList }

procedure TFhirCoverageClassList.AddItem(value: TFhirCoverageClass);
begin
  assert(value.ClassName = 'TFhirCoverageClass', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageClass');
  add(value);
end;

function TFhirCoverageClassList.Append: TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageClassList.GetEnumerator : TFhirCoverageClassListEnumerator;
begin
  result := TFhirCoverageClassListEnumerator.Create(self.link);
end;

function TFhirCoverageClassList.Clone: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Clone);
end;

function TFhirCoverageClassList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageClassList.GetItemN(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageClass;
end;
function TFhirCoverageClassList.IndexOf(value: TFhirCoverageClass): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageClassList.Insert(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.InsertItem(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  Inherited Insert(index, value);
end;

function TFhirCoverageClassList.Item(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.Link: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Link);
end;

procedure TFhirCoverageClassList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageClassList.SetItemByIndex(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  FhirCoverageClasses[index] := value;
end;

procedure TFhirCoverageClassList.SetItemN(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiary }

constructor TFhirCoverageCostToBeneficiary.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiary.Destroy;
begin
  FType_.free;
  FValue.free;
  FExceptionList.Free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiary.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiary(oSource).type_.Clone;
  value := TFhirCoverageCostToBeneficiary(oSource).value.Clone;
  if (TFhirCoverageCostToBeneficiary(oSource).FExceptionList = nil) then
  begin
    FExceptionList.free;
    FExceptionList := nil;
  end
  else
  begin
    if FExceptionList = nil then
      FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
    FExceptionList.Assign(TFhirCoverageCostToBeneficiary(oSource).FExceptionList);
  end;
end;

procedure TFhirCoverageCostToBeneficiary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exception') Then
    list.addAll(self, 'exception', FExceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|Money', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'exception', 'BackboneElement', true, TFhirCoverageCostToBeneficiaryException, FExceptionList.Link)) {L1039};
end;

function TFhirCoverageCostToBeneficiary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'exception') then
  begin
    ExceptionList.add(propValue as TFhirCoverageCostToBeneficiaryException) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'exception') then ExceptionList.insertItem(index, propValue as TFhirCoverageCostToBeneficiaryException) {L1049}
  else inherited;
end;

function TFhirCoverageCostToBeneficiary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'exception') then result := ExceptionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|Money'
  else if (propName = 'exception') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := nil {L1189}
  else if (propName = 'exception') then deletePropertyValue('exception', ExceptionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'exception') then replacePropertyValue('exception', ExceptionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiary.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'exception') then ExceptionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiary.fhirType : string;
begin
  result := 'Coverage.costToBeneficiary';
end;

function TFhirCoverageCostToBeneficiary.Link : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Link);
end;

function TFhirCoverageCostToBeneficiary.Clone : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Clone);
end;

function TFhirCoverageCostToBeneficiary.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiary)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiary(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(exceptionList, o.exceptionList, true);
  end;
end;

function TFhirCoverageCostToBeneficiary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FexceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCoverageCostToBeneficiary.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirCoverageCostToBeneficiary.GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
begin
  if FExceptionList = nil then
    FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
  result := FExceptionList;
end;

function TFhirCoverageCostToBeneficiary.GetHasExceptionList : boolean;
begin
  result := (FExceptionList <> nil) and (FExceptionList.count > 0);
end;

procedure TFhirCoverageCostToBeneficiary.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('exception');
end;

function TFhirCoverageCostToBeneficiary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FexceptionList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryListEnumerator }

constructor TFhirCoverageCostToBeneficiaryListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiary;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryList }

procedure TFhirCoverageCostToBeneficiaryList.AddItem(value: TFhirCoverageCostToBeneficiary);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiary');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryList.Append: TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryList.GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryList.Clone: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiary;
end;
function TFhirCoverageCostToBeneficiaryList.IndexOf(value: TFhirCoverageCostToBeneficiary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryList.Insert(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryList.Item(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.Link: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  FhirCoverageCostToBeneficiaries[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiaryException }

constructor TFhirCoverageCostToBeneficiaryException.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiaryException.Destroy;
begin
  FType_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiaryException.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiaryException(oSource).type_.Clone;
  period := TFhirCoverageCostToBeneficiaryException(oSource).period.Clone;
end;

procedure TFhirCoverageCostToBeneficiaryException.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCoverageCostToBeneficiaryException.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirCoverageCostToBeneficiaryException.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiaryException.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageCostToBeneficiaryException.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiaryException.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiaryException.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiaryException.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiaryException.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiaryException.fhirType : string;
begin
  result := 'Coverage.costToBeneficiary.exception';
end;

function TFhirCoverageCostToBeneficiaryException.Link : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Link);
end;

function TFhirCoverageCostToBeneficiaryException.Clone : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryException.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiaryException;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiaryException)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiaryException(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCoverageCostToBeneficiaryException.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod);
end;

procedure TFhirCoverageCostToBeneficiaryException.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCoverageCostToBeneficiaryException.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirCoverageCostToBeneficiaryException.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
end;

function TFhirCoverageCostToBeneficiaryException.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryExceptionListEnumerator }

constructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiaryException;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryExceptionList }

procedure TFhirCoverageCostToBeneficiaryExceptionList.AddItem(value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiaryException', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiaryException');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Append: TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Clone: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiaryException;
end;
function TFhirCoverageCostToBeneficiaryExceptionList.IndexOf(value: TFhirCoverageCostToBeneficiaryException): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Insert(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Item(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Link: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  FhirCoverageCostToBeneficiaryExceptions[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverage }

constructor TFhirCoverage.Create;
begin
  inherited;
end;

destructor TFhirCoverage.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FPolicyHolder.free;
  FSubscriber.free;
  FSubscriberId.free;
  FBeneficiary.free;
  FDependent.free;
  FRelationship.free;
  FPeriod.free;
  FPayorList.Free;
  FClass_List.Free;
  FOrder.free;
  FNetwork.free;
  FCostToBeneficiaryList.Free;
  FSubrogation.free;
  FContractList.Free;
  inherited;
end;

procedure TFhirCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverage(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverage(oSource).statusElement.Clone;
  type_ := TFhirCoverage(oSource).type_.Clone;
  policyHolder := TFhirCoverage(oSource).policyHolder.Clone;
  subscriber := TFhirCoverage(oSource).subscriber.Clone;
  subscriberId := TFhirCoverage(oSource).subscriberId.Clone;
  beneficiary := TFhirCoverage(oSource).beneficiary.Clone;
  dependentElement := TFhirCoverage(oSource).dependentElement.Clone;
  relationship := TFhirCoverage(oSource).relationship.Clone;
  period := TFhirCoverage(oSource).period.Clone;
  if (TFhirCoverage(oSource).FPayorList = nil) then
  begin
    FPayorList.free;
    FPayorList := nil;
  end
  else
  begin
    if FPayorList = nil then
      FPayorList := TFhirReferenceList.Create;
    FPayorList.Assign(TFhirCoverage(oSource).FPayorList);
  end;
  if (TFhirCoverage(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCoverageClassList.Create;
    FClass_List.Assign(TFhirCoverage(oSource).FClass_List);
  end;
  orderElement := TFhirCoverage(oSource).orderElement.Clone;
  networkElement := TFhirCoverage(oSource).networkElement.Clone;
  if (TFhirCoverage(oSource).FCostToBeneficiaryList = nil) then
  begin
    FCostToBeneficiaryList.free;
    FCostToBeneficiaryList := nil;
  end
  else
  begin
    if FCostToBeneficiaryList = nil then
      FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
    FCostToBeneficiaryList.Assign(TFhirCoverage(oSource).FCostToBeneficiaryList);
  end;
  subrogationElement := TFhirCoverage(oSource).subrogationElement.Clone;
  if (TFhirCoverage(oSource).FContractList = nil) then
  begin
    FContractList.free;
    FContractList := nil;
  end
  else
  begin
    if FContractList = nil then
      FContractList := TFhirReferenceList.Create;
    FContractList.Assign(TFhirCoverage(oSource).FContractList);
  end;
end;

function TFhirCoverage.GetResourceType : TFhirResourceType;
begin
  result := frtCoverage;
end;

procedure TFhirCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'policyHolder') Then
     list.add(self.link, 'policyHolder', FPolicyHolder.Link);
  if (child_name = 'subscriber') Then
     list.add(self.link, 'subscriber', FSubscriber.Link);
  if (child_name = 'subscriberId') Then
     list.add(self.link, 'subscriberId', FSubscriberId.Link);
  if (child_name = 'beneficiary') Then
     list.add(self.link, 'beneficiary', FBeneficiary.Link);
  if (child_name = 'dependent') Then
     list.add(self.link, 'dependent', FDependent.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payor') Then
    list.addAll(self, 'payor', FPayorList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'costToBeneficiary') Then
    list.addAll(self, 'costToBeneficiary', FCostToBeneficiaryList);
  if (child_name = 'subrogation') Then
     list.add(self.link, 'subrogation', FSubrogation.Link);
  if (child_name = 'contract') Then
    list.addAll(self, 'contract', FContractList);
end;

procedure TFhirCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'policyHolder', 'Reference', false, TFhirReference, FPolicyHolder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subscriber', 'Reference', false, TFhirReference, FSubscriber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subscriberId', 'Identifier', false, TFhirIdentifier, FSubscriberId.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'beneficiary', 'Reference', false, TFhirReference, FBeneficiary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dependent', 'string', false, TFhirString, FDependent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payor', 'Reference', true, TFhirReference, FPayorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'class', 'BackboneElement', true, TFhirCoverageClass, FClass_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'order', 'positiveInt', false, TFhirPositiveInt, FOrder.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'network', 'string', false, TFhirString, FNetwork.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'costToBeneficiary', 'BackboneElement', true, TFhirCoverageCostToBeneficiary, FCostToBeneficiaryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subrogation', 'boolean', false, TFhirBoolean, FSubrogation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference', true, TFhirReference, FContractList.Link)) {L1039};
end;

function TFhirCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'policyHolder') then
  begin
    PolicyHolder := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'subscriber') then
  begin
    Subscriber := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'subscriberId') then
  begin
    SubscriberId := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'beneficiary') then
  begin
    Beneficiary := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'payor') then
  begin
    PayorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoverageClass) {L1048};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    OrderElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'costToBeneficiary') then
  begin
    CostToBeneficiaryList.add(propValue as TFhirCoverageCostToBeneficiary) {L1048};
    result := propValue;
  end
  else if (propName = 'subrogation') then
  begin
    SubrogationElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    ContractList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'payor') then PayorList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoverageClass) {L1049}
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.insertItem(index, propValue as TFhirCoverageCostToBeneficiary) {L1049}
  else if (propName = 'contract') then ContractList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'policyHolder') then result := TFhirReference.create() {L1203}
  else if (propName = 'subscriber') then result := TFhirReference.create() {L1203}
  else if (propName = 'subscriberId') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'beneficiary') then result := TFhirReference.create() {L1203}
  else if (propName = 'dependent') then result := TFhirString.create() {L1223}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'payor') then result := PayorList.new() {L1053}
  else if (propName = 'class') then result := Class_List.new() {L1053}
  else if (propName = 'order') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'network') then result := TFhirString.create() {L1223}
  else if (propName = 'costToBeneficiary') then result := CostToBeneficiaryList.new() {L1053}
  else if (propName = 'subrogation') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'contract') then result := ContractList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'policyHolder') then result := 'Reference'
  else if (propName = 'subscriber') then result := 'Reference'
  else if (propName = 'subscriberId') then result := 'Identifier'
  else if (propName = 'beneficiary') then result := 'Reference'
  else if (propName = 'dependent') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payor') then result := 'Reference'
  else if (propName = 'class') then result := 'BackboneElement'
  else if (propName = 'order') then result := 'positiveInt'
  else if (propName = 'network') then result := 'string'
  else if (propName = 'costToBeneficiary') then result := 'BackboneElement'
  else if (propName = 'subrogation') then result := 'boolean'
  else if (propName = 'contract') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'policyHolder') then PolicyHolderElement := nil
  else if (propName = 'subscriber') then SubscriberElement := nil
  else if (propName = 'subscriberId') then SubscriberIdElement := nil
  else if (propName = 'beneficiary') then BeneficiaryElement := nil
  else if (propName = 'dependent') then DependentElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payor') then deletePropertyValue('payor', PayorList, value) {L1054}
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value) {L1054}
  else if (propName = 'order') then OrderElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'costToBeneficiary') then deletePropertyValue('costToBeneficiary', CostToBeneficiaryList, value) {L1054}
  else if (propName = 'subrogation') then SubrogationElement := nil
  else if (propName = 'contract') then deletePropertyValue('contract', ContractList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'policyHolder') then PolicyHolderElement := new as TFhirReference {L1195}
  else if (propName = 'subscriber') then SubscriberElement := new as TFhirReference {L1195}
  else if (propName = 'subscriberId') then SubscriberIdElement := new as TFhirIdentifier {L1195}
  else if (propName = 'beneficiary') then BeneficiaryElement := new as TFhirReference {L1195}
  else if (propName = 'dependent') then DependentElement := asString(new) {L1222}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'payor') then replacePropertyValue('payor', PayorList, existing, new) {L1055}
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new) {L1055}
  else if (propName = 'order') then OrderElement := asPositiveInt(new) {L1222}
  else if (propName = 'network') then NetworkElement := asString(new) {L1222}
  else if (propName = 'costToBeneficiary') then replacePropertyValue('costToBeneficiary', CostToBeneficiaryList, existing, new) {L1055}
  else if (propName = 'subrogation') then SubrogationElement := asBoolean(new) {L1222}
  else if (propName = 'contract') then replacePropertyValue('contract', ContractList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'payor') then PayorList.move(source, destination) {L1050}
  else if (propName = 'class') then Class_List.move(source, destination) {L1050}
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.move(source, destination) {L1050}
  else if (propName = 'contract') then ContractList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverage.fhirType : string;
begin
  result := 'Coverage';
end;

function TFhirCoverage.Link : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Link);
end;

function TFhirCoverage.Clone : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Clone);
end;

function TFhirCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverage)) then
    result := false
  else
  begin
    o := TFhirCoverage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(policyHolderElement, o.policyHolderElement, true) and 
      compareDeep(subscriberElement, o.subscriberElement, true) and compareDeep(subscriberIdElement, o.subscriberIdElement, true) and 
      compareDeep(beneficiaryElement, o.beneficiaryElement, true) and compareDeep(dependentElement, o.dependentElement, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payorList, o.payorList, true) and compareDeep(class_List, o.class_List, true) and 
      compareDeep(orderElement, o.orderElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(costToBeneficiaryList, o.costToBeneficiaryList, true) and compareDeep(subrogationElement, o.subrogationElement, true) and 
      compareDeep(contractList, o.contractList, true);
  end;
end;

function TFhirCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FPolicyHolder) and isEmptyProp(FSubscriber) and isEmptyProp(FSubscriberId) and isEmptyProp(FBeneficiary) and isEmptyProp(FDependent) and isEmptyProp(FRelationship) and isEmptyProp(FPeriod) and isEmptyProp(FpayorList) and isEmptyProp(Fclass_List) and isEmptyProp(FOrder) and isEmptyProp(FNetwork) and isEmptyProp(FcostToBeneficiaryList) and isEmptyProp(FSubrogation) and isEmptyProp(FcontractList);
end;

function TFhirCoverage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverage.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverage.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverage.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCoverage.SetPolicyHolder(value : TFhirReference);
begin
  FPolicyHolder.free;
  FPolicyHolder := value; {L1134}
end;

procedure TFhirCoverage.SetSubscriber(value : TFhirReference);
begin
  FSubscriber.free;
  FSubscriber := value; {L1134}
end;

procedure TFhirCoverage.SetSubscriberId(value : TFhirIdentifier);
begin
  FSubscriberId.free;
  FSubscriberId := value; {L1134}
end;

procedure TFhirCoverage.SetBeneficiary(value : TFhirReference);
begin
  FBeneficiary.free;
  FBeneficiary := value; {L1134}
end;

procedure TFhirCoverage.SetDependent(value : TFhirString);
begin
  FDependent.free;
  FDependent := value; {L1134}
end;

function TFhirCoverage.GetDependentST : String;
begin
  if FDependent = nil then
    result := ''
  else
    result := FDependent.value;
end;

procedure TFhirCoverage.SetDependentST(value : String);
begin
  if value <> '' then
  begin
    if FDependent = nil then
      FDependent := TFhirString.create;
    FDependent.value := value
  end
  else if FDependent <> nil then
    FDependent.value := '';
end;

procedure TFhirCoverage.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value; {L1134}
end;

procedure TFhirCoverage.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirCoverage.GetPayorList : TFhirReferenceList;
begin
  if FPayorList = nil then
    FPayorList := TFhirReferenceList.Create;
  result := FPayorList;
end;

function TFhirCoverage.GetHasPayorList : boolean;
begin
  result := (FPayorList <> nil) and (FPayorList.count > 0);
end;

function TFhirCoverage.GetClass_List : TFhirCoverageClassList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCoverageClassList.Create;
  result := FClass_List;
end;

function TFhirCoverage.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

procedure TFhirCoverage.SetOrder(value : TFhirPositiveInt);
begin
  FOrder.free;
  FOrder := value; {L1134}
end;

function TFhirCoverage.GetOrderST : String;
begin
  if FOrder = nil then
    result := ''
  else
    result := FOrder.value;
end;

procedure TFhirCoverage.SetOrderST(value : String);
begin
  if value <> '' then
  begin
    if FOrder = nil then
      FOrder := TFhirPositiveInt.create;
    FOrder.value := value
  end
  else if FOrder <> nil then
    FOrder.value := '';
end;

procedure TFhirCoverage.SetNetwork(value : TFhirString);
begin
  FNetwork.free;
  FNetwork := value; {L1134}
end;

function TFhirCoverage.GetNetworkST : String;
begin
  if FNetwork = nil then
    result := ''
  else
    result := FNetwork.value;
end;

procedure TFhirCoverage.SetNetworkST(value : String);
begin
  if value <> '' then
  begin
    if FNetwork = nil then
      FNetwork := TFhirString.create;
    FNetwork.value := value
  end
  else if FNetwork <> nil then
    FNetwork.value := '';
end;

function TFhirCoverage.GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
begin
  if FCostToBeneficiaryList = nil then
    FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
  result := FCostToBeneficiaryList;
end;

function TFhirCoverage.GetHasCostToBeneficiaryList : boolean;
begin
  result := (FCostToBeneficiaryList <> nil) and (FCostToBeneficiaryList.count > 0);
end;

procedure TFhirCoverage.SetSubrogation(value : TFhirBoolean);
begin
  FSubrogation.free;
  FSubrogation := value; {L1134}
end;

function TFhirCoverage.GetSubrogationST : Boolean;
begin
  if FSubrogation = nil then
    result := false
  else
    result := FSubrogation.value;
end;

procedure TFhirCoverage.SetSubrogationST(value : Boolean);
begin
  if FSubrogation = nil then
    FSubrogation := TFhirBoolean.create;
  FSubrogation.value := value
end;

function TFhirCoverage.GetContractList : TFhirReferenceList;
begin
  if FContractList = nil then
    FContractList := TFhirReferenceList.Create;
  result := FContractList;
end;

function TFhirCoverage.GetHasContractList : boolean;
begin
  result := (FContractList <> nil) and (FContractList.count > 0);
end;

procedure TFhirCoverage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('policyHolder');
  fields.add('subscriber');
  fields.add('subscriberId');
  fields.add('beneficiary');
  fields.add('dependent');
  fields.add('relationship');
  fields.add('period');
  fields.add('payor');
  fields.add('class');
  fields.add('order');
  fields.add('network');
  fields.add('costToBeneficiary');
  fields.add('subrogation');
  fields.add('contract');
end;

function TFhirCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPolicyHolder.sizeInBytes);
  inc(result, FSubscriber.sizeInBytes);
  inc(result, FSubscriberId.sizeInBytes);
  inc(result, FBeneficiary.sizeInBytes);
  inc(result, FDependent.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FpayorList.sizeInBytes);
  inc(result, Fclass_List.sizeInBytes);
  inc(result, FOrder.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FcostToBeneficiaryList.sizeInBytes);
  inc(result, FSubrogation.sizeInBytes);
  inc(result, FcontractList.sizeInBytes);
end;

{ TFhirCoverageListEnumerator }

constructor TFhirCoverageListEnumerator.Create(list : TFhirCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageListEnumerator.GetCurrent : TFhirCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageList }

procedure TFhirCoverageList.AddItem(value: TFhirCoverage);
begin
  assert(value.ClassName = 'TFhirCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverage');
  add(value);
end;

function TFhirCoverageList.Append: TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageList.GetEnumerator : TFhirCoverageListEnumerator;
begin
  result := TFhirCoverageListEnumerator.Create(self.link);
end;

function TFhirCoverageList.Clone: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Clone);
end;

function TFhirCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageList.GetItemN(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverage;
end;
function TFhirCoverageList.IndexOf(value: TFhirCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageList.Insert(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.InsertItem(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  Inherited Insert(index, value);
end;

function TFhirCoverageList.Item(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.Link: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Link);
end;

procedure TFhirCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageList.SetItemByIndex(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  FhirCoverages[index] := value;
end;

procedure TFhirCoverageList.SetItemN(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
{ TFhirCoverageEligibilityRequestSupportingInfo }

constructor TFhirCoverageEligibilityRequestSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfo.Destroy;
begin
  FSequence.free;
  FInformation.free;
  FAppliesToAll.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).sequenceElement.Clone;
  information := TFhirCoverageEligibilityRequestSupportingInfo(oSource).information.Clone;
  appliesToAllElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).appliesToAllElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'information') Then
     list.add(self.link, 'information', FInformation.Link);
  if (child_name = 'appliesToAll') Then
     list.add(self.link, 'appliesToAll', FAppliesToAll.Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'information', 'Reference', false, TFhirReference, FInformation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'appliesToAll', 'boolean', false, TFhirBoolean, FAppliesToAll.Link)); {L1172}
end;

function TFhirCoverageEligibilityRequestSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'information') then
  begin
    Information := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'appliesToAll') then
  begin
    AppliesToAllElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'information') then result := TFhirReference.create() {L1203}
  else if (propName = 'appliesToAll') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'information') then result := 'Reference'
  else if (propName = 'appliesToAll') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'information') then InformationElement := nil
  else if (propName = 'appliesToAll') then AppliesToAllElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'information') then InformationElement := new as TFhirReference {L1195}
  else if (propName = 'appliesToAll') then AppliesToAllElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.supportingInfo';
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Link : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Link);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Clone : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(informationElement, o.informationElement, true) and 
      compareDeep(appliesToAllElement, o.appliesToAllElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FInformation) and isEmptyProp(FAppliesToAll);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirCoverageEligibilityRequestSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetInformation(value : TFhirReference);
begin
  FInformation.free;
  FInformation := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAll(value : TFhirBoolean);
begin
  FAppliesToAll.free;
  FAppliesToAll := value; {L1134}
end;

function TFhirCoverageEligibilityRequestSupportingInfo.GetAppliesToAllST : Boolean;
begin
  if FAppliesToAll = nil then
    result := false
  else
    result := FAppliesToAll.value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAllST(value : Boolean);
begin
  if FAppliesToAll = nil then
    FAppliesToAll := TFhirBoolean.create;
  FAppliesToAll.value := value
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('information');
  fields.add('appliesToAll');
end;

function TFhirCoverageEligibilityRequestSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FInformation.sizeInBytes);
  inc(result, FAppliesToAll.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestSupportingInfoListEnumerator }

constructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestSupportingInfoList }

procedure TFhirCoverageEligibilityRequestSupportingInfoList.AddItem(value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestSupportingInfo');
  add(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Append: TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Clone: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo;
end;
function TFhirCoverageEligibilityRequestSupportingInfoList.IndexOf(value: TFhirCoverageEligibilityRequestSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Insert(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Item(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Link: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  FhirCoverageEligibilityRequestSupportingInfos[index] := value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestInsurance }

constructor TFhirCoverageEligibilityRequestInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirCoverageEligibilityRequestInsurance(oSource).focalElement.Clone;
  coverage := TFhirCoverageEligibilityRequestInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirCoverageEligibilityRequestInsurance(oSource).businessArrangementElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
end;

procedure TFhirCoverageEligibilityRequestInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link)); {L1172}
end;

function TFhirCoverageEligibilityRequestInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new) {L1222}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestInsurance.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.insurance';
end;

function TFhirCoverageEligibilityRequestInsurance.Link : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Link);
end;

function TFhirCoverageEligibilityRequestInsurance.Clone : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement);
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value; {L1134}
end;

function TFhirCoverageEligibilityRequestInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value; {L1134}
end;

function TFhirCoverageEligibilityRequestInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

procedure TFhirCoverageEligibilityRequestInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
end;

function TFhirCoverageEligibilityRequestInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestInsuranceListEnumerator }

constructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityRequestInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestInsuranceList }

procedure TFhirCoverageEligibilityRequestInsuranceList.AddItem(value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestInsurance');
  add(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Append: TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Clone: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestInsurance;
end;
function TFhirCoverageEligibilityRequestInsuranceList.IndexOf(value: TFhirCoverageEligibilityRequestInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Item(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Link: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  FhirCoverageEligibilityRequestInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItem }

constructor TFhirCoverageEligibilityRequestItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItem.Destroy;
begin
  FSupportingInfoSequenceList.Free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FQuantity.free;
  FUnitPrice.free;
  FFacility.free;
  FDiagnosisList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList = nil) then
  begin
    FSupportingInfoSequenceList.free;
    FSupportingInfoSequenceList := nil;
  end
  else
  begin
    if FSupportingInfoSequenceList = nil then
      FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
    FSupportingInfoSequenceList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList);
  end;
  category := TFhirCoverageEligibilityRequestItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityRequestItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityRequestItem(oSource).provider.Clone;
  quantity := TFhirCoverageEligibilityRequestItem(oSource).quantity.Clone;
  unitPrice := TFhirCoverageEligibilityRequestItem(oSource).unitPrice.Clone;
  facility := TFhirCoverageEligibilityRequestItem(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList);
  end;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDetailList);
  end;
end;

procedure TFhirCoverageEligibilityRequestItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'supportingInfoSequence') Then
    list.addAll(self, 'supportingInfoSequence', FSupportingInfoSequenceList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCoverageEligibilityRequestItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'supportingInfoSequence', 'positiveInt', true, TFhirPositiveInt, FSupportingInfoSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirCoverageEligibilityRequestItemDiagnosis, FDiagnosisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link)) {L1039};
end;

function TFhirCoverageEligibilityRequestItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then
  begin
    SupportingInfoSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirCoverageEligibilityRequestItemDiagnosis) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItemDiagnosis) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirCoverageEligibilityRequestItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then result := SupportingInfoSequenceList.new() {L1053}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'facility') then result := TFhirReference.create() {L1203}
  else if (propName = 'diagnosis') then result := DiagnosisList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'supportingInfoSequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then deletePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, value) {L1054}
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then replacePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, existing, new) {L1055}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference {L1195}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.move(source, destination) {L1046}
  else if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItem.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.item';
end;

function TFhirCoverageEligibilityRequestItem.Link : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Link);
end;

function TFhirCoverageEligibilityRequestItem.Clone : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItem(other);
    result := compareDeep(supportingInfoSequenceList, o.supportingInfoSequenceList, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCoverageEligibilityRequestItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsupportingInfoSequenceList) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFacility) and isEmptyProp(FdiagnosisList) and isEmptyProp(FdetailList);
end;

function TFhirCoverageEligibilityRequestItem.GetSupportingInfoSequenceList : TFhirPositiveIntList;
begin
  if FSupportingInfoSequenceList = nil then
    FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
  result := FSupportingInfoSequenceList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasSupportingInfoSequenceList : boolean;
begin
  result := (FSupportingInfoSequenceList <> nil) and (FSupportingInfoSequenceList.count > 0);
end;

procedure TFhirCoverageEligibilityRequestItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirCoverageEligibilityRequestItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirCoverageEligibilityRequestItem.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestItem.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value; {L1134}
end;

function TFhirCoverageEligibilityRequestItem.GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirCoverageEligibilityRequestItem.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirCoverageEligibilityRequestItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirCoverageEligibilityRequestItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('supportingInfoSequence');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('facility');
  fields.add('diagnosis');
  fields.add('detail');
end;

function TFhirCoverageEligibilityRequestItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsupportingInfoSequenceList.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemListEnumerator }

constructor TFhirCoverageEligibilityRequestItemListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemList }

procedure TFhirCoverageEligibilityRequestItemList.AddItem(value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItem');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemList.Append: TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemList.GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemList.Clone: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItem;
end;
function TFhirCoverageEligibilityRequestItemList.IndexOf(value: TFhirCoverageEligibilityRequestItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemList.Insert(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemList.Item(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.Link: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  FhirCoverageEligibilityRequestItems[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItemDiagnosis }

constructor TFhirCoverageEligibilityRequestItemDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosis.Destroy;
begin
  FDiagnosis.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  diagnosis := TFhirCoverageEligibilityRequestItemDiagnosis(oSource).diagnosis.Clone;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link)); {L1172}
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.fhirType : string;
begin
  result := 'CoverageEligibilityRequest.item.diagnosis';
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Link : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Clone : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItemDiagnosis)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItemDiagnosis(other);
    result := compareDeep(diagnosisElement, o.diagnosisElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiagnosis);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('diagnosis[x]');
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDiagnosis.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator }

constructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisList }

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.AddItem(value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItemDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItemDiagnosis');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Append: TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Clone: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis;
end;
function TFhirCoverageEligibilityRequestItemDiagnosisList.IndexOf(value: TFhirCoverageEligibilityRequestItemDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Insert(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Item(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Link: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  FhirCoverageEligibilityRequestItemDiagnoses[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequest }

constructor TFhirCoverageEligibilityRequest.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPriority.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FEnterer.free;
  FProvider.free;
  FInsurer.free;
  FFacility.free;
  FSupportingInfoList.Free;
  FInsuranceList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverageEligibilityRequest(oSource).statusElement.Clone;
  priority := TFhirCoverageEligibilityRequest(oSource).priority.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityRequest(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityRequest(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityRequest(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityRequest(oSource).createdElement.Clone;
  enterer := TFhirCoverageEligibilityRequest(oSource).enterer.Clone;
  provider := TFhirCoverageEligibilityRequest(oSource).provider.Clone;
  insurer := TFhirCoverageEligibilityRequest(oSource).insurer.Clone;
  facility := TFhirCoverageEligibilityRequest(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityRequest(oSource).FInsuranceList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityRequestItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityRequest(oSource).FItemList);
  end;
end;

function TFhirCoverageEligibilityRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityRequest;
end;

procedure TFhirCoverageEligibilityRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFhirEnum, FPurpose.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirCoverageEligibilityRequestSupportingInfo, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirCoverageEligibilityRequestInsurance, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirCoverageEligibilityRequestItem, FItemList.Link)) {L1039};
end;

function TFhirCoverageEligibilityRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirCoverageEligibilityRequestSupportingInfo) {L1048};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityRequestInsurance) {L1048};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityRequestItem) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum, propValue)) {L995}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirCoverageEligibilityRequestSupportingInfo) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityRequestInsurance) {L1049}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItem) {L1049}
  else inherited;
end;

function TFhirCoverageEligibilityRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'enterer') then result := TFhirReference.create() {L1203}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'facility') then result := TFhirReference.create() {L1203}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'item') then result := ItemList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference {L1195}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference {L1195}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'purpose') then FPurpose.move(source, destination) {L996}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequest.fhirType : string;
begin
  result := 'CoverageEligibilityRequest';
end;

function TFhirCoverageEligibilityRequest.Link : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Link);
end;

function TFhirCoverageEligibilityRequest.Clone : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Clone);
end;

function TFhirCoverageEligibilityRequest.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequest)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPriority) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FProvider) and isEmptyProp(FInsurer) and isEmptyProp(FFacility) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FinsuranceList) and isEmptyProp(FitemList);
end;

function TFhirCoverageEligibilityRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverageEligibilityRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverageEligibilityRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverageEligibilityRequest.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverageEligibilityRequest.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirCoverageEligibilityRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

function TFhirCoverageEligibilityRequest.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
  result := FPurpose;
end;

function TFhirCoverageEligibilityRequest.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetPurposeST : TFhirEligibilityRequestPurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityRequestPurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityRequestPurposeEnum, Fpurpose[i].value))];
end;

procedure TFhirCoverageEligibilityRequest.SetPurposeST(value : TFhirEligibilityRequestPurposeEnumList);
var a : TFhirEligibilityRequestPurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityRequestPurposeEnum) to high(TFhirEligibilityRequestPurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum, CODES_TFhirEligibilityRequestPurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityRequestPurposeEnum[a], CODES_TFhirEligibilityRequestPurposeEnum[a]));
      end;
end;

procedure TFhirCoverageEligibilityRequest.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequest.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirCoverageEligibilityRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCoverageEligibilityRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCoverageEligibilityRequest.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequest.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequest.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

procedure TFhirCoverageEligibilityRequest.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value; {L1134}
end;

function TFhirCoverageEligibilityRequest.GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirCoverageEligibilityRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirCoverageEligibilityRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirCoverageEligibilityRequest.GetItemList : TFhirCoverageEligibilityRequestItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityRequestItemList.Create;
  result := FItemList;
end;

function TFhirCoverageEligibilityRequest.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

procedure TFhirCoverageEligibilityRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('priority');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('enterer');
  fields.add('provider');
  fields.add('insurer');
  fields.add('facility');
  fields.add('supportingInfo');
  fields.add('insurance');
  fields.add('item');
end;

function TFhirCoverageEligibilityRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestListEnumerator }

constructor TFhirCoverageEligibilityRequestListEnumerator.Create(list : TFhirCoverageEligibilityRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestListEnumerator.GetCurrent : TFhirCoverageEligibilityRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestList }

procedure TFhirCoverageEligibilityRequestList.AddItem(value: TFhirCoverageEligibilityRequest);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequest');
  add(value);
end;

function TFhirCoverageEligibilityRequestList.Append: TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestList.GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestList.Clone: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestList.GetItemN(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequest;
end;
function TFhirCoverageEligibilityRequestList.IndexOf(value: TFhirCoverageEligibilityRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestList.Insert(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestList.Item(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.Link: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  FhirCoverageEligibilityRequests[index] := value;
end;

procedure TFhirCoverageEligibilityRequestList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
{ TFhirCoverageEligibilityResponseInsurance }

constructor TFhirCoverageEligibilityResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsurance.Destroy;
begin
  FCoverage.free;
  FInforce.free;
  FBenefitPeriod.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirCoverageEligibilityResponseInsurance(oSource).coverage.Clone;
  inforceElement := TFhirCoverageEligibilityResponseInsurance(oSource).inforceElement.Clone;
  benefitPeriod := TFhirCoverageEligibilityResponseInsurance(oSource).benefitPeriod.Clone;
  if (TFhirCoverageEligibilityResponseInsurance(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityResponseInsurance(oSource).FItemList);
  end;
end;

procedure TFhirCoverageEligibilityResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'inforce') Then
     list.add(self.link, 'inforce', FInforce.Link);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'inforce', 'boolean', false, TFhirBoolean, FInforce.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsuranceItem, FItemList.Link)) {L1039};
end;

function TFhirCoverageEligibilityResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'inforce') then
  begin
    InforceElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItem) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItem) {L1049}
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'inforce') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'item') then result := ItemList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'inforce') then result := 'boolean'
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'inforce') then InforceElement := nil
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'inforce') then InforceElement := asBoolean(new) {L1222}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsurance.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance';
end;

function TFhirCoverageEligibilityResponseInsurance.Link : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsurance.Clone : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsurance(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(inforceElement, o.inforceElement, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FInforce) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FitemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetInforce(value : TFhirBoolean);
begin
  FInforce.free;
  FInforce := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsurance.GetInforceST : Boolean;
begin
  if FInforce = nil then
    result := false
  else
    result := FInforce.value;
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetInforceST(value : Boolean);
begin
  if FInforce = nil then
    FInforce := TFhirBoolean.create;
  FInforce.value := value
end;

procedure TFhirCoverageEligibilityResponseInsurance.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsurance.GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
  result := FItemList;
end;

function TFhirCoverageEligibilityResponseInsurance.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('inforce');
  fields.add('benefitPeriod');
  fields.add('item');
end;

function TFhirCoverageEligibilityResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FInforce.sizeInBytes);
  inc(result, FBenefitPeriod.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceList }

procedure TFhirCoverageEligibilityResponseInsuranceList.AddItem(value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsurance');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Append: TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Clone: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsurance;
end;
function TFhirCoverageEligibilityResponseInsuranceList.IndexOf(value: TFhirCoverageEligibilityResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Item(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Link: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  FhirCoverageEligibilityResponseInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItem }

constructor TFhirCoverageEligibilityResponseInsuranceItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItem.Destroy;
begin
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FBenefitList.Free;
  FAuthorizationRequired.free;
  FAuthorizationSupportingList.Free;
  FAuthorizationUrl.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirCoverageEligibilityResponseInsuranceItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityResponseInsuranceItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityResponseInsuranceItem(oSource).provider.Clone;
  excludedElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).excludedElement.Clone;
  nameElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).nameElement.Clone;
  descriptionElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).descriptionElement.Clone;
  network := TFhirCoverageEligibilityResponseInsuranceItem(oSource).network.Clone;
  unit_ := TFhirCoverageEligibilityResponseInsuranceItem(oSource).unit_.Clone;
  term := TFhirCoverageEligibilityResponseInsuranceItem(oSource).term.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
    FBenefitList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList);
  end;
  authorizationRequiredElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationRequiredElement.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList = nil) then
  begin
    FAuthorizationSupportingList.free;
    FAuthorizationSupportingList := nil;
  end
  else
  begin
    if FAuthorizationSupportingList = nil then
      FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
    FAuthorizationSupportingList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList);
  end;
  authorizationUrlElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationUrlElement.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
  if (child_name = 'authorizationRequired') Then
     list.add(self.link, 'authorizationRequired', FAuthorizationRequired.Link);
  if (child_name = 'authorizationSupporting') Then
    list.addAll(self, 'authorizationSupporting', FAuthorizationSupportingList);
  if (child_name = 'authorizationUrl') Then
     list.add(self.link, 'authorizationUrl', FAuthorizationUrl.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsuranceItemBenefit, FBenefitList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'authorizationRequired', 'boolean', false, TFhirBoolean, FAuthorizationRequired.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'authorizationSupporting', 'CodeableConcept', true, TFhirCodeableConcept, FAuthorizationSupportingList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'authorizationUrl', 'uri', false, TFhirUri, FAuthorizationUrl.Link)); {L1172}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit) {L1048};
    result := propValue;
  end
  else if (propName = 'authorizationRequired') then
  begin
    AuthorizationRequiredElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'authorizationSupporting') then
  begin
    AuthorizationSupportingList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'authorizationUrl') then
  begin
    AuthorizationUrlElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit) {L1049}
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'network') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'term') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'benefit') then result := BenefitList.new() {L1053}
  else if (propName = 'authorizationRequired') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'authorizationSupporting') then result := AuthorizationSupportingList.new() {L1053}
  else if (propName = 'authorizationUrl') then result := TFhirUri.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else if (propName = 'authorizationRequired') then result := 'boolean'
  else if (propName = 'authorizationSupporting') then result := 'CodeableConcept'
  else if (propName = 'authorizationUrl') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {L1054}
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := nil
  else if (propName = 'authorizationSupporting') then deletePropertyValue('authorizationSupporting', AuthorizationSupportingList, value) {L1054}
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new) {L1222}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {L1055}
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := asBoolean(new) {L1222}
  else if (propName = 'authorizationSupporting') then replacePropertyValue('authorizationSupporting', AuthorizationSupportingList, existing, new) {L1055}
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := asUri(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'benefit') then BenefitList.move(source, destination) {L1050}
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance.item';
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Link : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Clone : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItem(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(excludedElement, o.excludedElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(termElement, o.termElement, true) and 
      compareDeep(benefitList, o.benefitList, true) and compareDeep(authorizationRequiredElement, o.authorizationRequiredElement, true) and 
      compareDeep(authorizationSupportingList, o.authorizationSupportingList, true) and 
      compareDeep(authorizationUrlElement, o.authorizationUrlElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FbenefitList) and isEmptyProp(FAuthorizationRequired) and isEmptyProp(FauthorizationSupportingList) and isEmptyProp(FAuthorizationUrl);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
  result := FBenefitList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequired(value : TFhirBoolean);
begin
  FAuthorizationRequired.free;
  FAuthorizationRequired := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationRequiredST : Boolean;
begin
  if FAuthorizationRequired = nil then
    result := false
  else
    result := FAuthorizationRequired.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequiredST(value : Boolean);
begin
  if FAuthorizationRequired = nil then
    FAuthorizationRequired := TFhirBoolean.create;
  FAuthorizationRequired.value := value
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationSupportingList : TFhirCodeableConceptList;
begin
  if FAuthorizationSupportingList = nil then
    FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
  result := FAuthorizationSupportingList;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetHasAuthorizationSupportingList : boolean;
begin
  result := (FAuthorizationSupportingList <> nil) and (FAuthorizationSupportingList.count > 0);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrl(value : TFhirUri);
begin
  FAuthorizationUrl.free;
  FAuthorizationUrl := value; {L1134}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationUrlST : String;
begin
  if FAuthorizationUrl = nil then
    result := ''
  else
    result := FAuthorizationUrl.value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrlST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorizationUrl = nil then
      FAuthorizationUrl := TFhirUri.create;
    FAuthorizationUrl.value := value
  end
  else if FAuthorizationUrl <> nil then
    FAuthorizationUrl.value := '';
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('benefit');
  fields.add('authorizationRequired');
  fields.add('authorizationSupporting');
  fields.add('authorizationUrl');
end;

function TFhirCoverageEligibilityResponseInsuranceItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
  inc(result, FAuthorizationRequired.sizeInBytes);
  inc(result, FauthorizationSupportingList.sizeInBytes);
  inc(result, FAuthorizationUrl.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemList }

procedure TFhirCoverageEligibilityResponseInsuranceItemList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItem');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Append: TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Clone: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem;
end;
function TFhirCoverageEligibilityResponseInsuranceItemList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Link: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  FhirCoverageEligibilityResponseInsuranceItems[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefit }

constructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).type_.Clone;
  allowed := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).allowed.Clone;
  used := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).used.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirDataType, FAllowed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|string|Money', false, TFhirDataType, FUsed.Link)); {L1172}
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Used := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed') {L1191}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Used') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|string|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil {L1189}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.insurance.item.benefit';
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItemBenefit)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItemBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetUsed(value : TFhirDataType);
begin
  FUsed.free;
  FUsed := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator }

constructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitList }

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItemBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItemBenefit');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Append: TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Clone: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit;
end;
function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Link: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  FhirCoverageEligibilityResponseInsuranceItemBenefits[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseError }

constructor TFhirCoverageEligibilityResponseError.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseError.Destroy;
begin
  FCode.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirCoverageEligibilityResponseError(oSource).code.Clone;
end;

procedure TFhirCoverageEligibilityResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirCoverageEligibilityResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
end;

function TFhirCoverageEligibilityResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseError.fhirType : string;
begin
  result := 'CoverageEligibilityResponse.error';
end;

function TFhirCoverageEligibilityResponseError.Link : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Link);
end;

function TFhirCoverageEligibilityResponseError.Clone : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Clone);
end;

function TFhirCoverageEligibilityResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseError)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseError(other);
    result := compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode);
end;

procedure TFhirCoverageEligibilityResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
end;

function TFhirCoverageEligibilityResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseErrorListEnumerator }

constructor TFhirCoverageEligibilityResponseErrorListEnumerator.Create(list : TFhirCoverageEligibilityResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseErrorList }

procedure TFhirCoverageEligibilityResponseErrorList.AddItem(value: TFhirCoverageEligibilityResponseError);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseError');
  add(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Append: TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseErrorList.GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseErrorListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseErrorList.Clone: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseErrorList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseError;
end;
function TFhirCoverageEligibilityResponseErrorList.IndexOf(value: TFhirCoverageEligibilityResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Insert(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseErrorList.Item(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.Link: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  FhirCoverageEligibilityResponseErrors[index] := value;
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponse }

constructor TFhirCoverageEligibilityResponse.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FInsurer.free;
  FInsuranceList.Free;
  FPreAuthRef.free;
  FForm.free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirCoverageEligibilityResponse(oSource).statusElement.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityResponse(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityResponse(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityResponse(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityResponse(oSource).createdElement.Clone;
  requestor := TFhirCoverageEligibilityResponse(oSource).requestor.Clone;
  request := TFhirCoverageEligibilityResponse(oSource).request.Clone;
  outcomeElement := TFhirCoverageEligibilityResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirCoverageEligibilityResponse(oSource).dispositionElement.Clone;
  insurer := TFhirCoverageEligibilityResponse(oSource).insurer.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityResponse(oSource).FInsuranceList);
  end;
  preAuthRefElement := TFhirCoverageEligibilityResponse(oSource).preAuthRefElement.Clone;
  form := TFhirCoverageEligibilityResponse(oSource).form.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
    FErrorList.Assign(TFhirCoverageEligibilityResponse(oSource).FErrorList);
  end;
end;

function TFhirCoverageEligibilityResponse.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityResponse;
end;

procedure TFhirCoverageEligibilityResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirCoverageEligibilityResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFhirEnum, FPurpose.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirCoverageEligibilityResponseInsurance, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'error', 'BackboneElement', true, TFhirCoverageEligibilityResponseError, FErrorList.Link)) {L1039};
end;

function TFhirCoverageEligibilityResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityResponseInsurance) {L1048};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCoverageEligibilityResponseError) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum, propValue)) {L995}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsurance) {L1049}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCoverageEligibilityResponseError) {L1049}
  else inherited;
end;

function TFhirCoverageEligibilityResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'requestor') then result := TFhirReference.create() {L1203}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull])  {L1211}
  else if (propName = 'disposition') then result := TFhirString.create() {L1223}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'preAuthRef') then result := TFhirString.create() {L1223}
  else if (propName = 'form') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'error') then result := ErrorList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'error') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference {L1195}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new) {L1210}
  else if (propName = 'disposition') then DispositionElement := asString(new) {L1222}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new) {L1222}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'purpose') then FPurpose.move(source, destination) {L996}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'error') then ErrorList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponse.fhirType : string;
begin
  result := 'CoverageEligibilityResponse';
end;

function TFhirCoverageEligibilityResponse.Link : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Link);
end;

function TFhirCoverageEligibilityResponse.Clone : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Clone);
end;

function TFhirCoverageEligibilityResponse.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponse)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(purposeList, o.purposeList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(insurerElement, o.insurerElement, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(formElement, o.formElement, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirCoverageEligibilityResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FInsurer) and isEmptyProp(FinsuranceList) and isEmptyProp(FPreAuthRef) and isEmptyProp(FForm) and isEmptyProp(FerrorList);
end;

function TFhirCoverageEligibilityResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCoverageEligibilityResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCoverageEligibilityResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCoverageEligibilityResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirCoverageEligibilityResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

function TFhirCoverageEligibilityResponse.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFhirEnumList.Create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
  result := FPurpose;
end;

function TFhirCoverageEligibilityResponse.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

function TFhirCoverageEligibilityResponse.GetPurposeST : TFhirEligibilityResponsePurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityResponsePurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityResponsePurposeEnum, Fpurpose[i].value))];
end;

procedure TFhirCoverageEligibilityResponse.SetPurposeST(value : TFhirEligibilityResponsePurposeEnumList);
var a : TFhirEligibilityResponsePurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityResponsePurposeEnum) to high(TFhirEligibilityResponsePurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum, CODES_TFhirEligibilityResponsePurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityResponsePurposeEnum[a], CODES_TFhirEligibilityResponsePurposeEnum[a]));
      end;
end;

procedure TFhirCoverageEligibilityResponse.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponse.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirCoverageEligibilityResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCoverageEligibilityResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCoverageEligibilityResponse.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirCoverageEligibilityResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirCoverageEligibilityResponse.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirCoverageEligibilityResponse.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirCoverageEligibilityResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value; {L1134}
end;

function TFhirCoverageEligibilityResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirCoverageEligibilityResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirCoverageEligibilityResponse.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

function TFhirCoverageEligibilityResponse.GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirCoverageEligibilityResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirCoverageEligibilityResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value; {L1134}
end;

function TFhirCoverageEligibilityResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

procedure TFhirCoverageEligibilityResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

procedure TFhirCoverageEligibilityResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value; {L1134}
end;

function TFhirCoverageEligibilityResponse.GetErrorList : TFhirCoverageEligibilityResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
  result := FErrorList;
end;

function TFhirCoverageEligibilityResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

procedure TFhirCoverageEligibilityResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('insurer');
  fields.add('insurance');
  fields.add('preAuthRef');
  fields.add('form');
  fields.add('error');
end;

function TFhirCoverageEligibilityResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FPreAuthRef.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseListEnumerator }

constructor TFhirCoverageEligibilityResponseListEnumerator.Create(list : TFhirCoverageEligibilityResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseListEnumerator.GetCurrent : TFhirCoverageEligibilityResponse;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseList }

procedure TFhirCoverageEligibilityResponseList.AddItem(value: TFhirCoverageEligibilityResponse);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponse');
  add(value);
end;

function TFhirCoverageEligibilityResponseList.Append: TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseList.GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseList.Clone: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseList.GetItemN(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponse;
end;
function TFhirCoverageEligibilityResponseList.IndexOf(value: TFhirCoverageEligibilityResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseList.Insert(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseList.Item(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.Link: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  FhirCoverageEligibilityResponses[index] := value;
end;

procedure TFhirCoverageEligibilityResponseList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
{ TFhirEnrollmentRequest }

constructor TFhirEnrollmentRequest.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FInsurer.free;
  FProvider.free;
  FCandidate.free;
  FCoverage.free;
  inherited;
end;

procedure TFhirEnrollmentRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirEnrollmentRequest(oSource).statusElement.Clone;
  createdElement := TFhirEnrollmentRequest(oSource).createdElement.Clone;
  insurer := TFhirEnrollmentRequest(oSource).insurer.Clone;
  provider := TFhirEnrollmentRequest(oSource).provider.Clone;
  candidate := TFhirEnrollmentRequest(oSource).candidate.Clone;
  coverage := TFhirEnrollmentRequest(oSource).coverage.Clone;
end;

function TFhirEnrollmentRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentRequest;
end;

procedure TFhirEnrollmentRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'candidate') Then
     list.add(self.link, 'candidate', FCandidate.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
end;

procedure TFhirEnrollmentRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'candidate', 'Reference', false, TFhirReference, FCandidate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
end;

function TFhirEnrollmentRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'candidate') then
  begin
    Candidate := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEnrollmentRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirEnrollmentRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'candidate') then result := TFhirReference.create() {L1203}
  else if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'candidate') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'candidate') then CandidateElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'candidate') then CandidateElement := new as TFhirReference {L1195}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentRequest.fhirType : string;
begin
  result := 'EnrollmentRequest';
end;

function TFhirEnrollmentRequest.Link : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Link);
end;

function TFhirEnrollmentRequest.Clone : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Clone);
end;

function TFhirEnrollmentRequest.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentRequest)) then
    result := false
  else
  begin
    o := TFhirEnrollmentRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(candidateElement, o.candidateElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true);
  end;
end;

function TFhirEnrollmentRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FCandidate) and isEmptyProp(FCoverage);
end;

function TFhirEnrollmentRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEnrollmentRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEnrollmentRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEnrollmentRequest.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirEnrollmentRequest.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirEnrollmentRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirEnrollmentRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirEnrollmentRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirEnrollmentRequest.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

procedure TFhirEnrollmentRequest.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirEnrollmentRequest.SetCandidate(value : TFhirReference);
begin
  FCandidate.free;
  FCandidate := value; {L1134}
end;

procedure TFhirEnrollmentRequest.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

procedure TFhirEnrollmentRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('insurer');
  fields.add('provider');
  fields.add('candidate');
  fields.add('coverage');
end;

function TFhirEnrollmentRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FCandidate.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
end;

{ TFhirEnrollmentRequestListEnumerator }

constructor TFhirEnrollmentRequestListEnumerator.Create(list : TFhirEnrollmentRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentRequestListEnumerator.GetCurrent : TFhirEnrollmentRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentRequestList }

procedure TFhirEnrollmentRequestList.AddItem(value: TFhirEnrollmentRequest);
begin
  assert(value.ClassName = 'TFhirEnrollmentRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentRequest');
  add(value);
end;

function TFhirEnrollmentRequestList.Append: TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentRequestList.GetEnumerator : TFhirEnrollmentRequestListEnumerator;
begin
  result := TFhirEnrollmentRequestListEnumerator.Create(self.link);
end;

function TFhirEnrollmentRequestList.Clone: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Clone);
end;

function TFhirEnrollmentRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentRequestList.GetItemN(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentRequest;
end;
function TFhirEnrollmentRequestList.IndexOf(value: TFhirEnrollmentRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentRequestList.Insert(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.InsertItem(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentRequestList.Item(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.Link: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Link);
end;

procedure TFhirEnrollmentRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentRequestList.SetItemByIndex(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  FhirEnrollmentRequests[index] := value;
end;

procedure TFhirEnrollmentRequestList.SetItemN(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
{ TFhirEnrollmentResponse }

constructor TFhirEnrollmentResponse.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  inherited;
end;

procedure TFhirEnrollmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentResponse(oSource).FIdentifierList);
  end;
  statusElement := TFhirEnrollmentResponse(oSource).statusElement.Clone;
  request := TFhirEnrollmentResponse(oSource).request.Clone;
  outcomeElement := TFhirEnrollmentResponse(oSource).outcomeElement.Clone;
  dispositionElement := TFhirEnrollmentResponse(oSource).dispositionElement.Clone;
  createdElement := TFhirEnrollmentResponse(oSource).createdElement.Clone;
  organization := TFhirEnrollmentResponse(oSource).organization.Clone;
  requestProvider := TFhirEnrollmentResponse(oSource).requestProvider.Clone;
end;

function TFhirEnrollmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentResponse;
end;

procedure TFhirEnrollmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
end;

procedure TFhirEnrollmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference', false, TFhirReference, FRequestProvider.Link)); {L1172}
end;

function TFhirEnrollmentResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEnrollmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirEnrollmentResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull])  {L1211}
  else if (propName = 'disposition') then result := TFhirString.create() {L1223}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'organization') then result := TFhirReference.create() {L1203}
  else if (propName = 'requestProvider') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new) {L1210}
  else if (propName = 'disposition') then DispositionElement := asString(new) {L1222}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentResponse.fhirType : string;
begin
  result := 'EnrollmentResponse';
end;

function TFhirEnrollmentResponse.Link : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Link);
end;

function TFhirEnrollmentResponse.Clone : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Clone);
end;

function TFhirEnrollmentResponse.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentResponse)) then
    result := false
  else
  begin
    o := TFhirEnrollmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true);
  end;
end;

function TFhirEnrollmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider);
end;

function TFhirEnrollmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEnrollmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEnrollmentResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEnrollmentResponse.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirEnrollmentResponse.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirEnrollmentResponse.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirEnrollmentResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirEnrollmentResponse.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirEnrollmentResponse.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirEnrollmentResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value; {L1134}
end;

function TFhirEnrollmentResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirEnrollmentResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirEnrollmentResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirEnrollmentResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirEnrollmentResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirEnrollmentResponse.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value; {L1134}
end;

procedure TFhirEnrollmentResponse.SetRequestProvider(value : TFhirReference);
begin
  FRequestProvider.free;
  FRequestProvider := value; {L1134}
end;

procedure TFhirEnrollmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
end;

function TFhirEnrollmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
end;

{ TFhirEnrollmentResponseListEnumerator }

constructor TFhirEnrollmentResponseListEnumerator.Create(list : TFhirEnrollmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentResponseListEnumerator.GetCurrent : TFhirEnrollmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentResponseList }

procedure TFhirEnrollmentResponseList.AddItem(value: TFhirEnrollmentResponse);
begin
  assert(value.ClassName = 'TFhirEnrollmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentResponse');
  add(value);
end;

function TFhirEnrollmentResponseList.Append: TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentResponseList.GetEnumerator : TFhirEnrollmentResponseListEnumerator;
begin
  result := TFhirEnrollmentResponseListEnumerator.Create(self.link);
end;

function TFhirEnrollmentResponseList.Clone: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Clone);
end;

function TFhirEnrollmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentResponseList.GetItemN(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentResponse;
end;
function TFhirEnrollmentResponseList.IndexOf(value: TFhirEnrollmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentResponseList.Insert(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.InsertItem(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentResponseList.Item(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.Link: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Link);
end;

procedure TFhirEnrollmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentResponseList.SetItemByIndex(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  FhirEnrollmentResponses[index] := value;
end;

procedure TFhirEnrollmentResponseList.SetItemN(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
{ TFhirExplanationOfBenefitRelated }

constructor TFhirExplanationOfBenefitRelated.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirExplanationOfBenefitRelated(oSource).claim.Clone;
  relationship := TFhirExplanationOfBenefitRelated(oSource).relationship.Clone;
  reference := TFhirExplanationOfBenefitRelated(oSource).reference.Clone;
end;

procedure TFhirExplanationOfBenefitRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirExplanationOfBenefitRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link)); {L1172}
end;

function TFhirExplanationOfBenefitRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference.create() {L1203}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reference') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference {L1195}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitRelated.fhirType : string;
begin
  result := 'ExplanationOfBenefit.related';
end;

function TFhirExplanationOfBenefitRelated.Link : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Link);
end;

function TFhirExplanationOfBenefitRelated.Clone : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Clone);
end;

function TFhirExplanationOfBenefitRelated.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitRelated)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirExplanationOfBenefitRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirExplanationOfBenefitRelated.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value; {L1134}
end;

procedure TFhirExplanationOfBenefitRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value; {L1134}
end;

procedure TFhirExplanationOfBenefitRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value; {L1134}
end;

procedure TFhirExplanationOfBenefitRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

function TFhirExplanationOfBenefitRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedListEnumerator }

constructor TFhirExplanationOfBenefitRelatedListEnumerator.Create(list : TFhirExplanationOfBenefitRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.GetCurrent : TFhirExplanationOfBenefitRelated;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedList }

procedure TFhirExplanationOfBenefitRelatedList.AddItem(value: TFhirExplanationOfBenefitRelated);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitRelated');
  add(value);
end;

function TFhirExplanationOfBenefitRelatedList.Append: TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitRelatedList.GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
begin
  result := TFhirExplanationOfBenefitRelatedListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitRelatedList.Clone: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Clone);
end;

function TFhirExplanationOfBenefitRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitRelatedList.GetItemN(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitRelated;
end;
function TFhirExplanationOfBenefitRelatedList.IndexOf(value: TFhirExplanationOfBenefitRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitRelatedList.Insert(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitRelatedList.Item(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.Link: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Link);
end;

procedure TFhirExplanationOfBenefitRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  FhirExplanationOfBenefitRelateds[index] := value;
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayee }

constructor TFhirExplanationOfBenefitPayee.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayee(oSource).type_.Clone;
  party := TFhirExplanationOfBenefitPayee(oSource).party.Clone;
end;

procedure TFhirExplanationOfBenefitPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirExplanationOfBenefitPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link)); {L1172}
end;

function TFhirExplanationOfBenefitPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'party') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'party') then PartyElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayee.fhirType : string;
begin
  result := 'ExplanationOfBenefit.payee';
end;

function TFhirExplanationOfBenefitPayee.Link : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Link);
end;

function TFhirExplanationOfBenefitPayee.Clone : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Clone);
end;

function TFhirExplanationOfBenefitPayee.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayee)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirExplanationOfBenefitPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayee.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

function TFhirExplanationOfBenefitPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeListEnumerator }

constructor TFhirExplanationOfBenefitPayeeListEnumerator.Create(list : TFhirExplanationOfBenefitPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayee;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeList }

procedure TFhirExplanationOfBenefitPayeeList.AddItem(value: TFhirExplanationOfBenefitPayee);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayee');
  add(value);
end;

function TFhirExplanationOfBenefitPayeeList.Append: TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPayeeList.GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
begin
  result := TFhirExplanationOfBenefitPayeeListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPayeeList.Clone: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Clone);
end;

function TFhirExplanationOfBenefitPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPayeeList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayee;
end;
function TFhirExplanationOfBenefitPayeeList.IndexOf(value: TFhirExplanationOfBenefitPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPayeeList.Insert(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPayeeList.Item(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.Link: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  FhirExplanationOfBenefitPayees[index] := value;
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitCareTeam }

constructor TFhirExplanationOfBenefitCareTeam.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirExplanationOfBenefitCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirExplanationOfBenefitCareTeam(oSource).responsibleElement.Clone;
  role := TFhirExplanationOfBenefitCareTeam(oSource).role.Clone;
  qualification := TFhirExplanationOfBenefitCareTeam(oSource).qualification.Clone;
end;

procedure TFhirExplanationOfBenefitCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirExplanationOfBenefitCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link)); {L1172}
end;

function TFhirExplanationOfBenefitCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new) {L1222}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitCareTeam.fhirType : string;
begin
  result := 'ExplanationOfBenefit.careTeam';
end;

function TFhirExplanationOfBenefitCareTeam.Link : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Link);
end;

function TFhirExplanationOfBenefitCareTeam.Clone : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitCareTeam)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirExplanationOfBenefitCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirExplanationOfBenefitCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitCareTeam.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirExplanationOfBenefitCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value; {L1134}
end;

function TFhirExplanationOfBenefitCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

procedure TFhirExplanationOfBenefitCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

procedure TFhirExplanationOfBenefitCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirExplanationOfBenefitCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value; {L1134}
end;

procedure TFhirExplanationOfBenefitCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

function TFhirExplanationOfBenefitCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamListEnumerator }

constructor TFhirExplanationOfBenefitCareTeamListEnumerator.Create(list : TFhirExplanationOfBenefitCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.GetCurrent : TFhirExplanationOfBenefitCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamList }

procedure TFhirExplanationOfBenefitCareTeamList.AddItem(value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitCareTeam');
  add(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Append: TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitCareTeamList.GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
begin
  result := TFhirExplanationOfBenefitCareTeamListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitCareTeamList.Clone: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitCareTeamList.GetItemN(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitCareTeam;
end;
function TFhirExplanationOfBenefitCareTeamList.IndexOf(value: TFhirExplanationOfBenefitCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Insert(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitCareTeamList.Item(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.Link: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Link);
end;

procedure TFhirExplanationOfBenefitCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  FhirExplanationOfBenefitCareTeams[index] := value;
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitSupportingInfo }

constructor TFhirExplanationOfBenefitSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirExplanationOfBenefitSupportingInfo(oSource).category.Clone;
  code := TFhirExplanationOfBenefitSupportingInfo(oSource).code.Clone;
  timing := TFhirExplanationOfBenefitSupportingInfo(oSource).timing.Clone;
  value := TFhirExplanationOfBenefitSupportingInfo(oSource).value.Clone;
  reason := TFhirExplanationOfBenefitSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirDataType, FTiming.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', false, TFhirCoding, FReason.Link)); {L1172}
end;

function TFhirExplanationOfBenefitSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing') {L1191}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'reason') then result := TFhirCoding.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil {L1189}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil {L1189}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'reason') then ReasonElement := new as TFhirCoding {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitSupportingInfo.fhirType : string;
begin
  result := 'ExplanationOfBenefit.supportingInfo';
end;

function TFhirExplanationOfBenefitSupportingInfo.Link : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Link);
end;

function TFhirExplanationOfBenefitSupportingInfo.Clone : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirExplanationOfBenefitSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value; {L1134}
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirExplanationOfBenefitSupportingInfo.SetReason(value : TFhirCoding);
begin
  FReason.free;
  FReason := value; {L1134}
end;

procedure TFhirExplanationOfBenefitSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

function TFhirExplanationOfBenefitSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirExplanationOfBenefitSupportingInfoListEnumerator }

constructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(list : TFhirExplanationOfBenefitSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitSupportingInfoList }

procedure TFhirExplanationOfBenefitSupportingInfoList.AddItem(value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitSupportingInfo');
  add(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Append: TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
begin
  result := TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Clone: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetItemN(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitSupportingInfo;
end;
function TFhirExplanationOfBenefitSupportingInfoList.IndexOf(value: TFhirExplanationOfBenefitSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Insert(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Item(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Link: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  FhirExplanationOfBenefitSupportingInfos[index] := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitDiagnosis }

constructor TFhirExplanationOfBenefitDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirExplanationOfBenefitDiagnosis(oSource).diagnosis.Clone;
  if (TFhirExplanationOfBenefitDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirExplanationOfBenefitDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirExplanationOfBenefitDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirExplanationOfBenefitDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirExplanationOfBenefitDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference', false, TFhirDataType, FDiagnosis.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link)); {L1172}
end;

function TFhirExplanationOfBenefitDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis') {L1191}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil {L1189}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirDataType {L1190}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitDiagnosis.fhirType : string;
begin
  result := 'ExplanationOfBenefit.diagnosis';
end;

function TFhirExplanationOfBenefitDiagnosis.Link : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Link);
end;

function TFhirExplanationOfBenefitDiagnosis.Clone : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitDiagnosis)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirExplanationOfBenefitDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetDiagnosis(value : TFhirDataType);
begin
  FDiagnosis.free;
  FDiagnosis := value; {L1134}
end;

function TFhirExplanationOfBenefitDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirExplanationOfBenefitDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value; {L1134}
end;

procedure TFhirExplanationOfBenefitDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value; {L1134}
end;

procedure TFhirExplanationOfBenefitDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

function TFhirExplanationOfBenefitDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FOnAdmission.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisListEnumerator }

constructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(list : TFhirExplanationOfBenefitDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.GetCurrent : TFhirExplanationOfBenefitDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisList }

procedure TFhirExplanationOfBenefitDiagnosisList.AddItem(value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitDiagnosis');
  add(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Append: TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
begin
  result := TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitDiagnosisList.Clone: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetItemN(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitDiagnosis;
end;
function TFhirExplanationOfBenefitDiagnosisList.IndexOf(value: TFhirExplanationOfBenefitDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Insert(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Item(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.Link: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Link);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  FhirExplanationOfBenefitDiagnoses[index] := value;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcedure }

constructor TFhirExplanationOfBenefitProcedure.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitProcedure(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitProcedure(oSource).FType_List);
  end;
  dateElement := TFhirExplanationOfBenefitProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirExplanationOfBenefitProcedure(oSource).procedure_.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirExplanationOfBenefitProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirExplanationOfBenefitProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProcedure_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_') {L1191}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil {L1189}
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirDataType {L1190}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcedure.fhirType : string;
begin
  result := 'ExplanationOfBenefit.procedure';
end;

function TFhirExplanationOfBenefitProcedure.Link : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Link);
end;

function TFhirExplanationOfBenefitProcedure.Clone : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcedure)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirExplanationOfBenefitProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirExplanationOfBenefitProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirExplanationOfBenefitProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirExplanationOfBenefitProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirExplanationOfBenefitProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirExplanationOfBenefitProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitProcedure.SetProcedure_(value : TFhirDataType);
begin
  FProcedure_.free;
  FProcedure_ := value; {L1134}
end;

function TFhirExplanationOfBenefitProcedure.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirExplanationOfBenefitProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

function TFhirExplanationOfBenefitProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureListEnumerator }

constructor TFhirExplanationOfBenefitProcedureListEnumerator.Create(list : TFhirExplanationOfBenefitProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureList }

procedure TFhirExplanationOfBenefitProcedureList.AddItem(value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcedure');
  add(value);
end;

function TFhirExplanationOfBenefitProcedureList.Append: TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcedureList.GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcedureListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcedureList.Clone: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcedureList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcedure;
end;
function TFhirExplanationOfBenefitProcedureList.IndexOf(value: TFhirExplanationOfBenefitProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcedureList.Insert(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcedureList.Item(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.Link: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  FhirExplanationOfBenefitProcedures[index] := value;
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitInsurance }

constructor TFhirExplanationOfBenefitInsurance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FPreAuthRefList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirExplanationOfBenefitInsurance(oSource).focalElement.Clone;
  coverage := TFhirExplanationOfBenefitInsurance(oSource).coverage.Clone;
  if (TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList);
  end;
end;

procedure TFhirExplanationOfBenefitInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference', false, TFhirReference, FCoverage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)) {L1045}
  else inherited;
end;

function TFhirExplanationOfBenefitInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'coverage') then result := TFhirReference.create() {L1203}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'preAuthRef') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new) {L1222}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference {L1195}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination) {L1046}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitInsurance.fhirType : string;
begin
  result := 'ExplanationOfBenefit.insurance';
end;

function TFhirExplanationOfBenefitInsurance.Link : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Link);
end;

function TFhirExplanationOfBenefitInsurance.Clone : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Clone);
end;

function TFhirExplanationOfBenefitInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitInsurance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true);
  end;
end;

function TFhirExplanationOfBenefitInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FpreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value; {L1134}
end;

function TFhirExplanationOfBenefitInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

procedure TFhirExplanationOfBenefitInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

procedure TFhirExplanationOfBenefitInsurance.SetCoverage(value : TFhirReference);
begin
  FCoverage.free;
  FCoverage := value; {L1134}
end;

function TFhirExplanationOfBenefitInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirExplanationOfBenefitInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

procedure TFhirExplanationOfBenefitInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('preAuthRef');
end;

function TFhirExplanationOfBenefitInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceListEnumerator }

constructor TFhirExplanationOfBenefitInsuranceListEnumerator.Create(list : TFhirExplanationOfBenefitInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.GetCurrent : TFhirExplanationOfBenefitInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceList }

procedure TFhirExplanationOfBenefitInsuranceList.AddItem(value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitInsurance');
  add(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Append: TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitInsuranceList.GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
begin
  result := TFhirExplanationOfBenefitInsuranceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitInsuranceList.Clone: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Clone);
end;

function TFhirExplanationOfBenefitInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitInsuranceList.GetItemN(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitInsurance;
end;
function TFhirExplanationOfBenefitInsuranceList.IndexOf(value: TFhirExplanationOfBenefitInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Insert(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitInsuranceList.Item(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.Link: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  FhirExplanationOfBenefitInsurances[index] := value;
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAccident }

constructor TFhirExplanationOfBenefitAccident.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirExplanationOfBenefitAccident(oSource).dateElement.Clone;
  type_ := TFhirExplanationOfBenefitAccident(oSource).type_.Clone;
  location := TFhirExplanationOfBenefitAccident(oSource).location.Clone;
end;

procedure TFhirExplanationOfBenefitAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirExplanationOfBenefitAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
end;

function TFhirExplanationOfBenefitAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAccident.fhirType : string;
begin
  result := 'ExplanationOfBenefit.accident';
end;

function TFhirExplanationOfBenefitAccident.Link : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Link);
end;

function TFhirExplanationOfBenefitAccident.Clone : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Clone);
end;

function TFhirExplanationOfBenefitAccident.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAccident)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirExplanationOfBenefitAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirExplanationOfBenefitAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirExplanationOfBenefitAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAccident.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

function TFhirExplanationOfBenefitAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentListEnumerator }

constructor TFhirExplanationOfBenefitAccidentListEnumerator.Create(list : TFhirExplanationOfBenefitAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.GetCurrent : TFhirExplanationOfBenefitAccident;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentList }

procedure TFhirExplanationOfBenefitAccidentList.AddItem(value: TFhirExplanationOfBenefitAccident);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAccident');
  add(value);
end;

function TFhirExplanationOfBenefitAccidentList.Append: TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAccidentList.GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
begin
  result := TFhirExplanationOfBenefitAccidentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAccidentList.Clone: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Clone);
end;

function TFhirExplanationOfBenefitAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAccidentList.GetItemN(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAccident;
end;
function TFhirExplanationOfBenefitAccidentList.IndexOf(value: TFhirExplanationOfBenefitAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAccidentList.Insert(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAccidentList.Item(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.Link: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  FhirExplanationOfBenefitAccidents[index] := value;
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItem }

constructor TFhirExplanationOfBenefitItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItem(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirExplanationOfBenefitItem(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItem(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItem(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItem(oSource).FUdiList);
  end;
  bodySite := TFhirExplanationOfBenefitItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirExplanationOfBenefitItem(oSource).FEncounterList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', 'BackboneElement', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirExplanationOfBenefitItemDetail, FDetailList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitItemDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetail) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new() {L1053}
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new() {L1053}
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new() {L1053}
  else if (propName = 'informationSequence') then result := InformationSequenceList.new() {L1053}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subSite') then result := SubSiteList.new() {L1053}
  else if (propName = 'encounter') then result := EncounterList.new() {L1053}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value) {L1054}
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value) {L1054}
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value) {L1054}
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value) {L1054}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil {L1189}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {L1054}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {L1054}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new) {L1055}
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new) {L1055}
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new) {L1055}
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new) {L1055}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {L1055}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {L1055}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination) {L1046}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination) {L1046}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination) {L1046}
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination) {L1046}
  else if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else if (propName = 'subSite') then SubSiteList.move(source, destination) {L1050}
  else if (propName = 'encounter') then EncounterList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItem.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item';
end;

function TFhirExplanationOfBenefitItem.Link : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Link);
end;

function TFhirExplanationOfBenefitItem.Clone : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Clone);
end;

function TFhirExplanationOfBenefitItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

function TFhirExplanationOfBenefitItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

function TFhirExplanationOfBenefitItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirExplanationOfBenefitItem.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

function TFhirExplanationOfBenefitItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirExplanationOfBenefitItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirExplanationOfBenefitItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItem.GetDetailList : TFhirExplanationOfBenefitItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
  result := FDetailList;
end;

function TFhirExplanationOfBenefitItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirExplanationOfBenefitItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirExplanationOfBenefitItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamSequenceList.sizeInBytes);
  inc(result, FdiagnosisSequenceList.sizeInBytes);
  inc(result, FprocedureSequenceList.sizeInBytes);
  inc(result, FinformationSequenceList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemListEnumerator }

constructor TFhirExplanationOfBenefitItemListEnumerator.Create(list : TFhirExplanationOfBenefitItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemList }

procedure TFhirExplanationOfBenefitItemList.AddItem(value: TFhirExplanationOfBenefitItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItem');
  add(value);
end;

function TFhirExplanationOfBenefitItemList.Append: TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemList.GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemList.Clone: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItem;
end;
function TFhirExplanationOfBenefitItemList.IndexOf(value: TFhirExplanationOfBenefitItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemList.Insert(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemList.Item(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.Link: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  FhirExplanationOfBenefitItems[index] := value;
end;

procedure TFhirExplanationOfBenefitItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemAdjudication }

constructor TFhirExplanationOfBenefitItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitItemAdjudication(oSource).category.Clone;
  reason := TFhirExplanationOfBenefitItemAdjudication(oSource).reason.Clone;
  amount := TFhirExplanationOfBenefitItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirExplanationOfBenefitItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link)); {L1172}
end;

function TFhirExplanationOfBenefitItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'value') then result := TFhirDecimal.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else if (propName = 'value') then ValueElement := asDecimal(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemAdjudication.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.adjudication';
end;

function TFhirExplanationOfBenefitItemAdjudication.Link : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Link);
end;

function TFhirExplanationOfBenefitItemAdjudication.Clone : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirExplanationOfBenefitItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirExplanationOfBenefitItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirExplanationOfBenefitItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

function TFhirExplanationOfBenefitItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationListEnumerator }

constructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationList }

procedure TFhirExplanationOfBenefitItemAdjudicationList.AddItem(value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemAdjudication');
  add(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Append: TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Clone: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemAdjudication;
end;
function TFhirExplanationOfBenefitItemAdjudicationList.IndexOf(value: TFhirExplanationOfBenefitItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Insert(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Item(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Link: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  FhirExplanationOfBenefitItemAdjudications[index] := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetail }

constructor TFhirExplanationOfBenefitItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirExplanationOfBenefitItemDetailSubDetail, FSubDetailList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitItemDetailSubDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetailSubDetail) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'subDetail') then result := SubDetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.detail';
end;

function TFhirExplanationOfBenefitItemDetail.Link : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetail.Clone : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirExplanationOfBenefitItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirExplanationOfBenefitItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailListEnumerator }

constructor TFhirExplanationOfBenefitItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailList }

procedure TFhirExplanationOfBenefitItemDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Append: TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailList.Clone: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetail;
end;
function TFhirExplanationOfBenefitItemDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.Link: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  FhirExplanationOfBenefitItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

constructor TFhirExplanationOfBenefitItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference', true, TFhirReference, FUdiList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'udi') then result := UdiList.new() {L1053}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {L1054}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {L1055}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'udi') then UdiList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.item.detail.subDetail';
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Link : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Clone : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetUdiList : TFhirReferenceList;
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList.Create;
  result := FUdiList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator }

constructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailList }

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Append: TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Link: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  FhirExplanationOfBenefitItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItem }

constructor TFhirExplanationOfBenefitAddItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubDetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList = nil) then
  begin
    FSubDetailSequenceList.free;
    FSubDetailSequenceList := nil;
  end
  else
  begin
    if FSubDetailSequenceList = nil then
      FSubDetailSequenceList := TFhirPositiveIntList.Create;
    FSubDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList.Create;
    FProviderList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirExplanationOfBenefitAddItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitAddItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitAddItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitAddItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItem(oSource).net.Clone;
  bodySite := TFhirExplanationOfBenefitAddItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subDetailSequence') Then
    list.addAll(self, 'subDetailSequence', FSubDetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubDetailSequenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', true, TFhirReference, FProviderList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirDataType, FServiced.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference', false, TFhirDataType, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirExplanationOfBenefitAddItemDetail, FDetailList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetail) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new() {L1053}
  else if (propName = 'detailSequence') then result := DetailSequenceList.new() {L1053}
  else if (propName = 'subDetailSequence') then result := SubDetailSequenceList.new() {L1053}
  else if (propName = 'provider') then result := ProviderList.new() {L1053}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'programCode') then result := ProgramCodeList.new() {L1053}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced') {L1191}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location') {L1191}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subSite') then result := SubSiteList.new() {L1053}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value) {L1054}
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value) {L1054}
  else if (propName = 'subDetailSequence') then deletePropertyValue('subDetailSequence', SubDetailSequenceList, value) {L1054}
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value) {L1054}
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {L1054}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil {L1189}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil {L1189}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {L1054}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new) {L1055}
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new) {L1055}
  else if (propName = 'subDetailSequence') then replacePropertyValue('subDetailSequence', SubDetailSequenceList, existing, new) {L1055}
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new) {L1055}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {L1055}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirDataType {L1190}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {L1055}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination) {L1046}
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination) {L1046}
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.move(source, destination) {L1046}
  else if (propName = 'provider') then ProviderList.move(source, destination) {L1050}
  else if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination) {L1050}
  else if (propName = 'subSite') then SubSiteList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItem.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem';
end;

function TFhirExplanationOfBenefitAddItem.Link : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Link);
end;

function TFhirExplanationOfBenefitAddItem.Clone : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subDetailSequenceList, o.subDetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubDetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

function TFhirExplanationOfBenefitAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetSubDetailSequenceList : TFhirPositiveIntList;
begin
  if FSubDetailSequenceList = nil then
    FSubDetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubDetailSequenceList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasSubDetailSequenceList : boolean;
begin
  result := (FSubDetailSequenceList <> nil) and (FSubDetailSequenceList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetProviderList : TFhirReferenceList;
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList.Create;
  result := FProviderList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItem.SetServiced(value : TFhirDataType);
begin
  FServiced.free;
  FServiced := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItem.SetLocation(value : TFhirDataType);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
  result := FDetailList;
end;

function TFhirExplanationOfBenefitAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

function TFhirExplanationOfBenefitAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FitemSequenceList.sizeInBytes);
  inc(result, FdetailSequenceList.sizeInBytes);
  inc(result, FsubDetailSequenceList.sizeInBytes);
  inc(result, FproviderList.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemListEnumerator }

constructor TFhirExplanationOfBenefitAddItemListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemList }

procedure TFhirExplanationOfBenefitAddItemList.AddItem(value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItem');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemList.Append: TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemList.GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemList.Clone: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItem;
end;
function TFhirExplanationOfBenefitAddItemList.IndexOf(value: TFhirExplanationOfBenefitAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemList.Insert(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemList.Item(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.Link: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  FhirExplanationOfBenefitAddItems[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetail }

constructor TFhirExplanationOfBenefitAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'subDetail', 'BackboneElement', true, TFhirExplanationOfBenefitAddItemDetailSubDetail, FSubDetailList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'subDetail') then result := SubDetailList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'subDetail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem.detail';
end;

function TFhirExplanationOfBenefitAddItemDetail.Link : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetail.Clone : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

function TFhirExplanationOfBenefitAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

function TFhirExplanationOfBenefitAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailListEnumerator }

constructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailList }

procedure TFhirExplanationOfBenefitAddItemDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Append: TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Link: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  FhirExplanationOfBenefitAddItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetail }

constructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)) {L1045}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'modifier') then result := ModifierList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'unitPrice') then result := TFhirMoney.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'net') then result := TFhirMoney.create() {L1203}
  else if (propName = 'noteNumber') then result := NoteNumberList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'net') then NetElement := new as TFhirMoney {L1195}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination) {L1050}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination) {L1046}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.fhirType : string;
begin
  result := 'ExplanationOfBenefit.addItem.detail.subDetail';
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Link : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value; {L1134}
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value; {L1134}
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator }

constructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailList }

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Append: TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Link: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  FhirExplanationOfBenefitAddItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitTotal }

constructor TFhirExplanationOfBenefitTotal.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitTotal(oSource).category.Clone;
  amount := TFhirExplanationOfBenefitTotal(oSource).amount.Clone;
end;

procedure TFhirExplanationOfBenefitTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirExplanationOfBenefitTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
end;

function TFhirExplanationOfBenefitTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitTotal.fhirType : string;
begin
  result := 'ExplanationOfBenefit.total';
end;

function TFhirExplanationOfBenefitTotal.Link : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Link);
end;

function TFhirExplanationOfBenefitTotal.Clone : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Clone);
end;

function TFhirExplanationOfBenefitTotal.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitTotal)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirExplanationOfBenefitTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirExplanationOfBenefitTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirExplanationOfBenefitTotal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

function TFhirExplanationOfBenefitTotal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirExplanationOfBenefitTotalListEnumerator }

constructor TFhirExplanationOfBenefitTotalListEnumerator.Create(list : TFhirExplanationOfBenefitTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.GetCurrent : TFhirExplanationOfBenefitTotal;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitTotalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitTotalList }

procedure TFhirExplanationOfBenefitTotalList.AddItem(value: TFhirExplanationOfBenefitTotal);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitTotal');
  add(value);
end;

function TFhirExplanationOfBenefitTotalList.Append: TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitTotalList.GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
begin
  result := TFhirExplanationOfBenefitTotalListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitTotalList.Clone: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Clone);
end;

function TFhirExplanationOfBenefitTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitTotalList.GetItemN(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitTotal;
end;
function TFhirExplanationOfBenefitTotalList.IndexOf(value: TFhirExplanationOfBenefitTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitTotalList.Insert(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitTotalList.Item(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.Link: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Link);
end;

procedure TFhirExplanationOfBenefitTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  FhirExplanationOfBenefitTotals[index] := value;
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayment }

constructor TFhirExplanationOfBenefitPayment.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayment(oSource).type_.Clone;
  adjustment := TFhirExplanationOfBenefitPayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirExplanationOfBenefitPayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirExplanationOfBenefitPayment(oSource).dateElement.Clone;
  amount := TFhirExplanationOfBenefitPayment(oSource).amount.Clone;
  identifier := TFhirExplanationOfBenefitPayment(oSource).identifier.Clone;
end;

procedure TFhirExplanationOfBenefitPayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirExplanationOfBenefitPayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
end;

function TFhirExplanationOfBenefitPayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'adjustment') then result := TFhirMoney.create() {L1203}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney {L1195}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayment.fhirType : string;
begin
  result := 'ExplanationOfBenefit.payment';
end;

function TFhirExplanationOfBenefitPayment.Link : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Link);
end;

function TFhirExplanationOfBenefitPayment.Clone : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Clone);
end;

function TFhirExplanationOfBenefitPayment.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayment)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirExplanationOfBenefitPayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirExplanationOfBenefitPayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirExplanationOfBenefitPayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirExplanationOfBenefitPayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirExplanationOfBenefitPayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

function TFhirExplanationOfBenefitPayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentListEnumerator }

constructor TFhirExplanationOfBenefitPaymentListEnumerator.Create(list : TFhirExplanationOfBenefitPaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayment;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentList }

procedure TFhirExplanationOfBenefitPaymentList.AddItem(value: TFhirExplanationOfBenefitPayment);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayment');
  add(value);
end;

function TFhirExplanationOfBenefitPaymentList.Append: TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPaymentList.GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
begin
  result := TFhirExplanationOfBenefitPaymentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPaymentList.Clone: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Clone);
end;

function TFhirExplanationOfBenefitPaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPaymentList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayment;
end;
function TFhirExplanationOfBenefitPaymentList.IndexOf(value: TFhirExplanationOfBenefitPayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPaymentList.Insert(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPaymentList.Item(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.Link: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  FhirExplanationOfBenefitPayments[index] := value;
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcessNote }

constructor TFhirExplanationOfBenefitProcessNote.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirExplanationOfBenefitProcessNote(oSource).numberElement.Clone;
  type_Element := TFhirExplanationOfBenefitProcessNote(oSource).type_Element.Clone;
  textElement := TFhirExplanationOfBenefitProcessNote(oSource).textElement.Clone;
  language := TFhirExplanationOfBenefitProcessNote(oSource).language.Clone;
end;

procedure TFhirExplanationOfBenefitProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirExplanationOfBenefitProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
end;

function TFhirExplanationOfBenefitProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull])  {L1211}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new) {L1210}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcessNote.fhirType : string;
begin
  result := 'ExplanationOfBenefit.processNote';
end;

function TFhirExplanationOfBenefitProcessNote.Link : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Link);
end;

function TFhirExplanationOfBenefitProcessNote.Clone : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcessNote)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirExplanationOfBenefitProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirExplanationOfBenefitProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value; {L1134}
end;

function TFhirExplanationOfBenefitProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirExplanationOfBenefitProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirExplanationOfBenefitProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirExplanationOfBenefitProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirExplanationOfBenefitProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirExplanationOfBenefitProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirExplanationOfBenefitProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirExplanationOfBenefitProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirExplanationOfBenefitProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirExplanationOfBenefitProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

function TFhirExplanationOfBenefitProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteListEnumerator }

constructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(list : TFhirExplanationOfBenefitProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteList }

procedure TFhirExplanationOfBenefitProcessNoteList.AddItem(value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcessNote');
  add(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Append: TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcessNoteList.Clone: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcessNote;
end;
function TFhirExplanationOfBenefitProcessNoteList.IndexOf(value: TFhirExplanationOfBenefitProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Insert(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Item(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.Link: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  FhirExplanationOfBenefitProcessNotes[index] := value;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalance }

constructor TFhirExplanationOfBenefitBenefitBalance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalance.Destroy;
begin
  FCategory.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FFinancialList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitBenefitBalance(oSource).category.Clone;
  excludedElement := TFhirExplanationOfBenefitBenefitBalance(oSource).excludedElement.Clone;
  nameElement := TFhirExplanationOfBenefitBenefitBalance(oSource).nameElement.Clone;
  descriptionElement := TFhirExplanationOfBenefitBenefitBalance(oSource).descriptionElement.Clone;
  network := TFhirExplanationOfBenefitBenefitBalance(oSource).network.Clone;
  unit_ := TFhirExplanationOfBenefitBenefitBalance(oSource).unit_.Clone;
  term := TFhirExplanationOfBenefitBenefitBalance(oSource).term.Clone;
  if (TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList = nil) then
  begin
    FFinancialList.free;
    FFinancialList := nil;
  end
  else
  begin
    if FFinancialList = nil then
      FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
    FFinancialList.Assign(TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList);
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'financial') Then
    list.addAll(self, 'financial', FFinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'financial', 'BackboneElement', true, TFhirExplanationOfBenefitBenefitBalanceFinancial, FFinancialList.Link)) {L1039};
end;

function TFhirExplanationOfBenefitBenefitBalance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'financial') then
  begin
    FinancialList.add(propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'financial') then FinancialList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefitBenefitBalance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'network') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'term') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'financial') then result := FinancialList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'financial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'financial') then deletePropertyValue('financial', FinancialList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new) {L1222}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'financial') then replacePropertyValue('financial', FinancialList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'financial') then FinancialList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalance.fhirType : string;
begin
  result := 'ExplanationOfBenefit.benefitBalance';
end;

function TFhirExplanationOfBenefitBenefitBalance.Link : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalance.Clone : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalance(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(excludedElement, o.excludedElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(networkElement, o.networkElement, true) and compareDeep(unit_Element, o.unit_Element, true) and 
      compareDeep(termElement, o.termElement, true) and compareDeep(financialList, o.financialList, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FfinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value; {L1134}
end;

function TFhirExplanationOfBenefitBenefitBalance.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirExplanationOfBenefitBenefitBalance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirExplanationOfBenefitBenefitBalance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalance.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value; {L1134}
end;

function TFhirExplanationOfBenefitBenefitBalance.GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  if FFinancialList = nil then
    FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
  result := FFinancialList;
end;

function TFhirExplanationOfBenefitBenefitBalance.GetHasFinancialList : boolean;
begin
  result := (FFinancialList <> nil) and (FFinancialList.count > 0);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('financial');
end;

function TFhirExplanationOfBenefitBenefitBalance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FfinancialList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceListEnumerator }

constructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceList }

procedure TFhirExplanationOfBenefitBenefitBalanceList.AddItem(value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalance');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Append: TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Clone: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalance;
end;
function TFhirExplanationOfBenefitBenefitBalanceList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Link: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  FhirExplanationOfBenefitBenefitBalances[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).type_.Clone;
  allowed := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).allowed.Clone;
  used := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).used.Clone;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirDataType, FAllowed.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|Money', false, TFhirDataType, FUsed.Link)); {L1172}
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then
  begin
    Used := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed') {L1191}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then raise EFHIRException.create('Cannot make property Used') {L1191}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil {L1189}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := nil {L1189}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirDataType {L1190}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := new as TFhirDataType {L1190}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.fhirType : string;
begin
  result := 'ExplanationOfBenefit.benefitBalance.financial';
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Link : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalanceFinancial)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalanceFinancial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetUsed(value : TFhirDataType);
begin
  FUsed.free;
  FUsed := value; {L1134}
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialList }

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.AddItem(value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalanceFinancial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalanceFinancial');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Append: TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Clone: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial;
end;
function TFhirExplanationOfBenefitBenefitBalanceFinancialList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalanceFinancial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Link: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  FhirExplanationOfBenefitBenefitBalanceFinancials[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefit }

constructor TFhirExplanationOfBenefit.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefit.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserveRequested.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FClaim.free;
  FClaimResponse.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRefList.Free;
  FPreAuthRefPeriodList.Free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FPrecedence.free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FBenefitPeriod.free;
  FBenefitBalanceList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefit(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExplanationOfBenefit(oSource).FIdentifierList);
  end;
  statusElement := TFhirExplanationOfBenefit(oSource).statusElement.Clone;
  type_ := TFhirExplanationOfBenefit(oSource).type_.Clone;
  subType := TFhirExplanationOfBenefit(oSource).subType.Clone;
  useElement := TFhirExplanationOfBenefit(oSource).useElement.Clone;
  patient := TFhirExplanationOfBenefit(oSource).patient.Clone;
  billablePeriod := TFhirExplanationOfBenefit(oSource).billablePeriod.Clone;
  createdElement := TFhirExplanationOfBenefit(oSource).createdElement.Clone;
  enterer := TFhirExplanationOfBenefit(oSource).enterer.Clone;
  insurer := TFhirExplanationOfBenefit(oSource).insurer.Clone;
  provider := TFhirExplanationOfBenefit(oSource).provider.Clone;
  priority := TFhirExplanationOfBenefit(oSource).priority.Clone;
  fundsReserveRequested := TFhirExplanationOfBenefit(oSource).fundsReserveRequested.Clone;
  fundsReserve := TFhirExplanationOfBenefit(oSource).fundsReserve.Clone;
  if (TFhirExplanationOfBenefit(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
    FRelatedList.Assign(TFhirExplanationOfBenefit(oSource).FRelatedList);
  end;
  prescription := TFhirExplanationOfBenefit(oSource).prescription.Clone;
  originalPrescription := TFhirExplanationOfBenefit(oSource).originalPrescription.Clone;
  payee := TFhirExplanationOfBenefit(oSource).payee.Clone;
  referral := TFhirExplanationOfBenefit(oSource).referral.Clone;
  facility := TFhirExplanationOfBenefit(oSource).facility.Clone;
  claim := TFhirExplanationOfBenefit(oSource).claim.Clone;
  claimResponse := TFhirExplanationOfBenefit(oSource).claimResponse.Clone;
  outcomeElement := TFhirExplanationOfBenefit(oSource).outcomeElement.Clone;
  dispositionElement := TFhirExplanationOfBenefit(oSource).dispositionElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList = nil) then
  begin
    FPreAuthRefPeriodList.free;
    FPreAuthRefPeriodList := nil;
  end
  else
  begin
    if FPreAuthRefPeriodList = nil then
      FPreAuthRefPeriodList := TFhirPeriodList.Create;
    FPreAuthRefPeriodList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
    FCareTeamList.Assign(TFhirExplanationOfBenefit(oSource).FCareTeamList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirExplanationOfBenefit(oSource).FSupportingInfoList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirExplanationOfBenefit(oSource).FDiagnosisList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
    FProcedure_List.Assign(TFhirExplanationOfBenefit(oSource).FProcedure_List);
  end;
  precedenceElement := TFhirExplanationOfBenefit(oSource).precedenceElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
    FInsuranceList.Assign(TFhirExplanationOfBenefit(oSource).FInsuranceList);
  end;
  accident := TFhirExplanationOfBenefit(oSource).accident.Clone;
  if (TFhirExplanationOfBenefit(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirExplanationOfBenefitItemList.Create;
    FItemList.Assign(TFhirExplanationOfBenefit(oSource).FItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
    FAddItemList.Assign(TFhirExplanationOfBenefit(oSource).FAddItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefit(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirExplanationOfBenefitTotalList.Create;
    FTotalList.Assign(TFhirExplanationOfBenefit(oSource).FTotalList);
  end;
  payment := TFhirExplanationOfBenefit(oSource).payment.Clone;
  formCode := TFhirExplanationOfBenefit(oSource).formCode.Clone;
  form := TFhirExplanationOfBenefit(oSource).form.Clone;
  if (TFhirExplanationOfBenefit(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirExplanationOfBenefit(oSource).FProcessNoteList);
  end;
  benefitPeriod := TFhirExplanationOfBenefit(oSource).benefitPeriod.Clone;
  if (TFhirExplanationOfBenefit(oSource).FBenefitBalanceList = nil) then
  begin
    FBenefitBalanceList.free;
    FBenefitBalanceList := nil;
  end
  else
  begin
    if FBenefitBalanceList = nil then
      FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
    FBenefitBalanceList.Assign(TFhirExplanationOfBenefit(oSource).FBenefitBalanceList);
  end;
end;

function TFhirExplanationOfBenefit.GetResourceType : TFhirResourceType;
begin
  result := frtExplanationOfBenefit;
end;

procedure TFhirExplanationOfBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserveRequested') Then
     list.add(self.link, 'fundsReserveRequested', FFundsReserveRequested.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'preAuthRefPeriod') Then
    list.addAll(self, 'preAuthRefPeriod', FPreAuthRefPeriodList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'precedence') Then
     list.add(self.link, 'precedence', FPrecedence.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'benefitBalance') Then
    list.addAll(self, 'benefitBalance', FBenefitBalanceList);
end;

procedure TFhirExplanationOfBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFhirEnum, FUse.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference', false, TFhirReference, FInsurer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fundsReserveRequested', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserveRequested.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirExplanationOfBenefitRelated, FRelatedList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference', false, TFhirReference, FPrescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference', false, TFhirReference, FOriginalPrescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payee', 'BackboneElement', false, TFhirExplanationOfBenefitPayee, FPayee.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference', false, TFhirReference, FReferral.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference', false, TFhirReference, FFacility.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference', false, TFhirReference, FClaim.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference', false, TFhirReference, FClaimResponse.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'preAuthRefPeriod', 'Period', true, TFhirPeriod, FPreAuthRefPeriodList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'careTeam', 'BackboneElement', true, TFhirExplanationOfBenefitCareTeam, FCareTeamList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'BackboneElement', true, TFhirExplanationOfBenefitSupportingInfo, FSupportingInfoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirExplanationOfBenefitDiagnosis, FDiagnosisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'procedure', 'BackboneElement', true, TFhirExplanationOfBenefitProcedure, FProcedure_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'precedence', 'positiveInt', false, TFhirPositiveInt, FPrecedence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'insurance', 'BackboneElement', true, TFhirExplanationOfBenefitInsurance, FInsuranceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'accident', 'BackboneElement', false, TFhirExplanationOfBenefitAccident, FAccident.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirExplanationOfBenefitItem, FItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'addItem', 'BackboneElement', true, TFhirExplanationOfBenefitAddItem, FAddItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'total', 'BackboneElement', true, TFhirExplanationOfBenefitTotal, FTotalList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'payment', 'BackboneElement', false, TFhirExplanationOfBenefitPayment, FPayment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirExplanationOfBenefitProcessNote, FProcessNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'benefitBalance', 'BackboneElement', true, TFhirExplanationOfBenefitBenefitBalance, FBenefitBalanceList.Link)) {L1039};
end;

function TFhirExplanationOfBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirExplanationOfBenefitStatusEnum, CODES_TFhirExplanationOfBenefitStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'fundsReserveRequested') then
  begin
    FundsReserveRequested := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirExplanationOfBenefitRelated) {L1048};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirExplanationOfBenefitPayee {L1199};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'preAuthRefPeriod') then
  begin
    PreAuthRefPeriodList.add(propValue as TFhirPeriod) {L1048};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirExplanationOfBenefitCareTeam) {L1048};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirExplanationOfBenefitSupportingInfo) {L1048};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirExplanationOfBenefitDiagnosis) {L1048};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirExplanationOfBenefitProcedure) {L1048};
    result := propValue;
  end
  else if (propName = 'precedence') then
  begin
    PrecedenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirExplanationOfBenefitInsurance) {L1048};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirExplanationOfBenefitAccident {L1199};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirExplanationOfBenefitItem) {L1048};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirExplanationOfBenefitAddItem) {L1048};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication) {L1048};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirExplanationOfBenefitTotal) {L1048};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirExplanationOfBenefitPayment {L1199};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirExplanationOfBenefitProcessNote) {L1048};
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'benefitBalance') then
  begin
    BenefitBalanceList.add(propValue as TFhirExplanationOfBenefitBenefitBalance) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirExplanationOfBenefitRelated) {L1049}
  else if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.insertItem(index, propValue as TFhirPeriod) {L1049}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirExplanationOfBenefitCareTeam) {L1049}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirExplanationOfBenefitSupportingInfo) {L1049}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirExplanationOfBenefitDiagnosis) {L1049}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirExplanationOfBenefitProcedure) {L1049}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirExplanationOfBenefitInsurance) {L1049}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirExplanationOfBenefitItem) {L1049}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItem) {L1049}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication) {L1049}
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirExplanationOfBenefitTotal) {L1049}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirExplanationOfBenefitProcessNote) {L1049}
  else if (propName = 'benefitBalance') then BenefitBalanceList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalance) {L1049}
  else inherited;
end;

function TFhirExplanationOfBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirExplanationOfBenefitStatusEnum[ExplanationOfBenefitStatusNull], CODES_TFhirExplanationOfBenefitStatusEnum[ExplanationOfBenefitStatusNull])  {L1211}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'use') then result := TFhirEnum.create(SYSTEMS_TFhirUseEnum[UseNull], CODES_TFhirUseEnum[UseNull])  {L1211}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'enterer') then result := TFhirReference.create() {L1203}
  else if (propName = 'insurer') then result := TFhirReference.create() {L1203}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'fundsReserveRequested') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'related') then result := RelatedList.new() {L1053}
  else if (propName = 'prescription') then result := TFhirReference.create() {L1203}
  else if (propName = 'originalPrescription') then result := TFhirReference.create() {L1203}
  else if (propName = 'payee') then result := TFhirExplanationOfBenefitPayee.create() {L1203}
  else if (propName = 'referral') then result := TFhirReference.create() {L1203}
  else if (propName = 'facility') then result := TFhirReference.create() {L1203}
  else if (propName = 'claim') then result := TFhirReference.create() {L1203}
  else if (propName = 'claimResponse') then result := TFhirReference.create() {L1203}
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull])  {L1211}
  else if (propName = 'disposition') then result := TFhirString.create() {L1223}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new() {L1053}
  else if (propName = 'preAuthRefPeriod') then result := PreAuthRefPeriodList.new() {L1053}
  else if (propName = 'careTeam') then result := CareTeamList.new() {L1053}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new() {L1053}
  else if (propName = 'diagnosis') then result := DiagnosisList.new() {L1053}
  else if (propName = 'procedure') then result := Procedure_List.new() {L1053}
  else if (propName = 'precedence') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'insurance') then result := InsuranceList.new() {L1053}
  else if (propName = 'accident') then result := TFhirExplanationOfBenefitAccident.create() {L1203}
  else if (propName = 'item') then result := ItemList.new() {L1053}
  else if (propName = 'addItem') then result := AddItemList.new() {L1053}
  else if (propName = 'adjudication') then result := AdjudicationList.new() {L1053}
  else if (propName = 'total') then result := TotalList.new() {L1053}
  else if (propName = 'payment') then result := TFhirExplanationOfBenefitPayment.create() {L1203}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'form') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'processNote') then result := ProcessNoteList.new() {L1053}
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'benefitBalance') then result := BenefitBalanceList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserveRequested') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := 'BackboneElement'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := 'BackboneElement'
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'claim') then result := 'Reference'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthRefPeriod') then result := 'Period'
  else if (propName = 'careTeam') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'BackboneElement'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'procedure') then result := 'BackboneElement'
  else if (propName = 'precedence') then result := 'positiveInt'
  else if (propName = 'insurance') then result := 'BackboneElement'
  else if (propName = 'accident') then result := 'BackboneElement'
  else if (propName = 'item') then result := 'BackboneElement'
  else if (propName = 'addItem') then result := 'BackboneElement'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'total') then result := 'BackboneElement'
  else if (propName = 'payment') then result := 'BackboneElement'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'benefitBalance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {L1054}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {L1054}
  else if (propName = 'preAuthRefPeriod') then deletePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, value) {L1054}
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {L1054}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {L1054}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {L1054}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {L1054}
  else if (propName = 'precedence') then PrecedenceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {L1054}
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {L1054}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {L1054}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {L1054}
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value) {L1054}
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {L1054}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'benefitBalance') then deletePropertyValue('benefitBalance', BenefitBalanceList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirExplanationOfBenefitStatusEnum, CODES_TFhirExplanationOfBenefitStatusEnum, new) {L1210}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirUseEnum, CODES_TFhirUseEnum, new) {L1210}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference {L1195}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference {L1195}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {L1055}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference {L1195}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference {L1195}
  else if (propName = 'payee') then PayeeElement := new as TFhirExplanationOfBenefitPayee {L1195}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference {L1195}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference {L1195}
  else if (propName = 'claim') then ClaimElement := new as TFhirReference {L1195}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference {L1195}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new) {L1210}
  else if (propName = 'disposition') then DispositionElement := asString(new) {L1222}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {L1055}
  else if (propName = 'preAuthRefPeriod') then replacePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, existing, new) {L1055}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {L1055}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {L1055}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {L1055}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {L1055}
  else if (propName = 'precedence') then PrecedenceElement := asPositiveInt(new) {L1222}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {L1055}
  else if (propName = 'accident') then AccidentElement := new as TFhirExplanationOfBenefitAccident {L1195}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {L1055}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {L1055}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {L1055}
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new) {L1055}
  else if (propName = 'payment') then PaymentElement := new as TFhirExplanationOfBenefitPayment {L1195}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'form') then FormElement := new as TFhirAttachment {L1195}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {L1055}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'benefitBalance') then replacePropertyValue('benefitBalance', BenefitBalanceList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'related') then RelatedList.move(source, destination) {L1050}
  else if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination) {L1046}
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.move(source, destination) {L1050}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination) {L1050}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination) {L1050}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination) {L1050}
  else if (propName = 'procedure') then Procedure_List.move(source, destination) {L1050}
  else if (propName = 'insurance') then InsuranceList.move(source, destination) {L1050}
  else if (propName = 'item') then ItemList.move(source, destination) {L1050}
  else if (propName = 'addItem') then AddItemList.move(source, destination) {L1050}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination) {L1050}
  else if (propName = 'total') then TotalList.move(source, destination) {L1050}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination) {L1050}
  else if (propName = 'benefitBalance') then BenefitBalanceList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefit.fhirType : string;
begin
  result := 'ExplanationOfBenefit';
end;

function TFhirExplanationOfBenefit.Link : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Link);
end;

function TFhirExplanationOfBenefit.Clone : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Clone);
end;

function TFhirExplanationOfBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefit)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefit(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveRequestedElement, o.fundsReserveRequestedElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(claimElement, o.claimElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true) and 
      compareDeep(preAuthRefPeriodList, o.preAuthRefPeriodList, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(precedenceElement, o.precedenceElement, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(accidentElement, o.accidentElement, true) and 
      compareDeep(itemList, o.itemList, true) and compareDeep(addItemList, o.addItemList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(totalList, o.totalList, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(benefitBalanceList, o.benefitBalanceList, true);
  end;
end;

function TFhirExplanationOfBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserveRequested) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FClaim) and isEmptyProp(FClaimResponse) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FpreAuthRefPeriodList) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FPrecedence) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident)
       and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FbenefitBalanceList);
end;

function TFhirExplanationOfBenefit.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirExplanationOfBenefit.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirExplanationOfBenefit.GetStatusST : TFhirExplanationOfBenefitStatusEnum;
begin
  if FStatus = nil then
    result := TFhirExplanationOfBenefitStatusEnum(0)
  else
    result := TFhirExplanationOfBenefitStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirExplanationOfBenefitStatusEnum, FStatus.value));
end;

procedure TFhirExplanationOfBenefit.SetStatusST(value : TFhirExplanationOfBenefitStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirExplanationOfBenefitStatusEnum[value], CODES_TFhirExplanationOfBenefitStatusEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

function TFhirExplanationOfBenefit.GetUseST : TFhirUseEnum;
begin
  if FUse = nil then
    result := TFhirUseEnum(0)
  else
    result := TFhirUseEnum(StringArrayIndexOfSensitive(CODES_TFhirUseEnum, FUse.value));
end;

procedure TFhirExplanationOfBenefit.SetUseST(value : TFhirUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirUseEnum[value], CODES_TFhirUseEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirExplanationOfBenefit.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirExplanationOfBenefit.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetInsurer(value : TFhirReference);
begin
  FInsurer.free;
  FInsurer := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetFundsReserveRequested(value : TFhirCodeableConcept);
begin
  FFundsReserveRequested.free;
  FFundsReserveRequested := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetRelatedList : TFhirExplanationOfBenefitRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
  result := FRelatedList;
end;

function TFhirExplanationOfBenefit.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPrescription(value : TFhirReference);
begin
  FPrescription.free;
  FPrescription := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetOriginalPrescription(value : TFhirReference);
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetPayee(value : TFhirExplanationOfBenefitPayee);
begin
  FPayee.free;
  FPayee := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetReferral(value : TFhirReference);
begin
  FReferral.free;
  FReferral := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetFacility(value : TFhirReference);
begin
  FFacility.free;
  FFacility := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetClaim(value : TFhirReference);
begin
  FClaim.free;
  FClaim := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetClaimResponse(value : TFhirReference);
begin
  FClaimResponse.free;
  FClaimResponse := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirExplanationOfBenefit.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirExplanationOfBenefit.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirExplanationOfBenefit.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirExplanationOfBenefit.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

function TFhirExplanationOfBenefit.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

function TFhirExplanationOfBenefit.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

function TFhirExplanationOfBenefit.GetPreAuthRefPeriodList : TFhirPeriodList;
begin
  if FPreAuthRefPeriodList = nil then
    FPreAuthRefPeriodList := TFhirPeriodList.Create;
  result := FPreAuthRefPeriodList;
end;

function TFhirExplanationOfBenefit.GetHasPreAuthRefPeriodList : boolean;
begin
  result := (FPreAuthRefPeriodList <> nil) and (FPreAuthRefPeriodList.count > 0);
end;

function TFhirExplanationOfBenefit.GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
  result := FCareTeamList;
end;

function TFhirExplanationOfBenefit.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirExplanationOfBenefit.GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

function TFhirExplanationOfBenefit.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirExplanationOfBenefit.GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirExplanationOfBenefit.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirExplanationOfBenefit.GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
  result := FProcedure_List;
end;

function TFhirExplanationOfBenefit.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPrecedence(value : TFhirPositiveInt);
begin
  FPrecedence.free;
  FPrecedence := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetPrecedenceST : String;
begin
  if FPrecedence = nil then
    result := ''
  else
    result := FPrecedence.value;
end;

procedure TFhirExplanationOfBenefit.SetPrecedenceST(value : String);
begin
  if value <> '' then
  begin
    if FPrecedence = nil then
      FPrecedence := TFhirPositiveInt.create;
    FPrecedence.value := value
  end
  else if FPrecedence <> nil then
    FPrecedence.value := '';
end;

function TFhirExplanationOfBenefit.GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
  result := FInsuranceList;
end;

function TFhirExplanationOfBenefit.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetAccident(value : TFhirExplanationOfBenefitAccident);
begin
  FAccident.free;
  FAccident := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetItemList : TFhirExplanationOfBenefitItemList;
begin
  if FItemList = nil then
    FItemList := TFhirExplanationOfBenefitItemList.Create;
  result := FItemList;
end;

function TFhirExplanationOfBenefit.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirExplanationOfBenefit.GetAddItemList : TFhirExplanationOfBenefitAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
  result := FAddItemList;
end;

function TFhirExplanationOfBenefit.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

function TFhirExplanationOfBenefit.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

function TFhirExplanationOfBenefit.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefit.GetTotalList : TFhirExplanationOfBenefitTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirExplanationOfBenefitTotalList.Create;
  result := FTotalList;
end;

function TFhirExplanationOfBenefit.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetPayment(value : TFhirExplanationOfBenefitPayment);
begin
  FPayment.free;
  FPayment := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value; {L1134}
end;

procedure TFhirExplanationOfBenefit.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirExplanationOfBenefit.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

procedure TFhirExplanationOfBenefit.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value; {L1134}
end;

function TFhirExplanationOfBenefit.GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
begin
  if FBenefitBalanceList = nil then
    FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
  result := FBenefitBalanceList;
end;

function TFhirExplanationOfBenefit.GetHasBenefitBalanceList : boolean;
begin
  result := (FBenefitBalanceList <> nil) and (FBenefitBalanceList.count > 0);
end;

procedure TFhirExplanationOfBenefit.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserveRequested');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('claim');
  fields.add('claimResponse');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthRefPeriod');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('precedence');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('benefitPeriod');
  fields.add('benefitBalance');
end;

function TFhirExplanationOfBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserveRequested.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FClaim.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FpreAuthRefPeriodList.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FPrecedence.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FtotalList.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FBenefitPeriod.sizeInBytes);
  inc(result, FbenefitBalanceList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitListEnumerator }

constructor TFhirExplanationOfBenefitListEnumerator.Create(list : TFhirExplanationOfBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitListEnumerator.GetCurrent : TFhirExplanationOfBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitList }

procedure TFhirExplanationOfBenefitList.AddItem(value: TFhirExplanationOfBenefit);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefit');
  add(value);
end;

function TFhirExplanationOfBenefitList.Append: TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitList.GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
begin
  result := TFhirExplanationOfBenefitListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitList.Clone: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Clone);
end;

function TFhirExplanationOfBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitList.GetItemN(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefit;
end;
function TFhirExplanationOfBenefitList.IndexOf(value: TFhirExplanationOfBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitList.Insert(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.InsertItem(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitList.Item(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.Link: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Link);
end;

procedure TFhirExplanationOfBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  FhirExplanationOfBenefits[index] := value;
end;

procedure TFhirExplanationOfBenefitList.SetItemN(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
{ TFhirInsurancePlanContact }

constructor TFhirInsurancePlanContact.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  inherited;
end;

procedure TFhirInsurancePlanContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirInsurancePlanContact(oSource).purpose.Clone;
  name := TFhirInsurancePlanContact(oSource).name.Clone;
  if (TFhirInsurancePlanContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirInsurancePlanContact(oSource).FTelecomList);
  end;
  address := TFhirInsurancePlanContact(oSource).address.Clone;
end;

procedure TFhirInsurancePlanContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirInsurancePlanContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link)); {L1172}
end;

function TFhirInsurancePlanContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName {L1199};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else inherited;
end;

function TFhirInsurancePlanContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirHumanName.create() {L1203}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := TFhirAddress.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := new as TFhirHumanName {L1195}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then AddressElement := new as TFhirAddress {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanContact.fhirType : string;
begin
  result := 'InsurancePlan.contact';
end;

function TFhirInsurancePlanContact.Link : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Link);
end;

function TFhirInsurancePlanContact.Clone : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Clone);
end;

function TFhirInsurancePlanContact.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanContact)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirInsurancePlanContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirInsurancePlanContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value; {L1134}
end;

procedure TFhirInsurancePlanContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirInsurancePlanContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirInsurancePlanContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirInsurancePlanContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value; {L1134}
end;

procedure TFhirInsurancePlanContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

function TFhirInsurancePlanContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
end;

{ TFhirInsurancePlanContactListEnumerator }

constructor TFhirInsurancePlanContactListEnumerator.Create(list : TFhirInsurancePlanContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanContactListEnumerator.GetCurrent : TFhirInsurancePlanContact;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanContactList }

procedure TFhirInsurancePlanContactList.AddItem(value: TFhirInsurancePlanContact);
begin
  assert(value.ClassName = 'TFhirInsurancePlanContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanContact');
  add(value);
end;

function TFhirInsurancePlanContactList.Append: TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanContactList.GetEnumerator : TFhirInsurancePlanContactListEnumerator;
begin
  result := TFhirInsurancePlanContactListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanContactList.Clone: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Clone);
end;

function TFhirInsurancePlanContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanContactList.GetItemN(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanContact;
end;
function TFhirInsurancePlanContactList.IndexOf(value: TFhirInsurancePlanContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanContactList.Insert(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.InsertItem(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanContactList.Item(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.Link: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Link);
end;

procedure TFhirInsurancePlanContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanContactList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  FhirInsurancePlanContacts[index] := value;
end;

procedure TFhirInsurancePlanContactList.SetItemN(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverage }

constructor TFhirInsurancePlanCoverage.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverage.Destroy;
begin
  FType_.free;
  FNetworkList.Free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverage(oSource).type_.Clone;
  if (TFhirInsurancePlanCoverage(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlanCoverage(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanCoverage(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanCoverage(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirInsurancePlanCoverageBenefit, FBenefitList.Link)) {L1039};
end;

function TFhirInsurancePlanCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanCoverageBenefit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefit) {L1049}
  else inherited;
end;

function TFhirInsurancePlanCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'network') then result := NetworkList.new() {L1053}
  else if (propName = 'benefit') then result := BenefitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {L1054}
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {L1055}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'network') then NetworkList.move(source, destination) {L1050}
  else if (propName = 'benefit') then BenefitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverage.fhirType : string;
begin
  result := 'InsurancePlan.coverage';
end;

function TFhirInsurancePlanCoverage.Link : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Link);
end;

function TFhirInsurancePlanCoverage.Clone : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Clone);
end;

function TFhirInsurancePlanCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverage)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FnetworkList) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirInsurancePlanCoverage.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlanCoverage.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlanCoverage.GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
  result := FBenefitList;
end;

function TFhirInsurancePlanCoverage.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

procedure TFhirInsurancePlanCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('network');
  fields.add('benefit');
end;

function TFhirInsurancePlanCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageListEnumerator }

constructor TFhirInsurancePlanCoverageListEnumerator.Create(list : TFhirInsurancePlanCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageListEnumerator.GetCurrent : TFhirInsurancePlanCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageList }

procedure TFhirInsurancePlanCoverageList.AddItem(value: TFhirInsurancePlanCoverage);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverage');
  add(value);
end;

function TFhirInsurancePlanCoverageList.Append: TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageList.GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
begin
  result := TFhirInsurancePlanCoverageListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageList.Clone: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Clone);
end;

function TFhirInsurancePlanCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageList.GetItemN(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverage;
end;
function TFhirInsurancePlanCoverageList.IndexOf(value: TFhirInsurancePlanCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageList.Insert(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageList.Item(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.Link: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  FhirInsurancePlanCoverages[index] := value;
end;

procedure TFhirInsurancePlanCoverageList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefit }

constructor TFhirInsurancePlanCoverageBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefit.Destroy;
begin
  FType_.free;
  FRequirement.free;
  FLimitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverageBenefit(oSource).type_.Clone;
  requirementElement := TFhirInsurancePlanCoverageBenefit(oSource).requirementElement.Clone;
  if (TFhirInsurancePlanCoverageBenefit(oSource).FLimitList = nil) then
  begin
    FLimitList.free;
    FLimitList := nil;
  end
  else
  begin
    if FLimitList = nil then
      FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
    FLimitList.Assign(TFhirInsurancePlanCoverageBenefit(oSource).FLimitList);
  end;
end;

procedure TFhirInsurancePlanCoverageBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'limit') Then
    list.addAll(self, 'limit', FLimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requirement', 'string', false, TFhirString, FRequirement.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'limit', 'BackboneElement', true, TFhirInsurancePlanCoverageBenefitLimit, FLimitList.Link)) {L1039};
end;

function TFhirInsurancePlanCoverageBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    RequirementElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'limit') then
  begin
    LimitList.add(propValue as TFhirInsurancePlanCoverageBenefitLimit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'limit') then LimitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefitLimit) {L1049}
  else inherited;
end;

function TFhirInsurancePlanCoverageBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'requirement') then result := TFhirString.create() {L1223}
  else if (propName = 'limit') then result := LimitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'requirement') then result := 'string'
  else if (propName = 'limit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'limit') then deletePropertyValue('limit', LimitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'requirement') then RequirementElement := asString(new) {L1222}
  else if (propName = 'limit') then replacePropertyValue('limit', LimitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'limit') then LimitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefit.fhirType : string;
begin
  result := 'InsurancePlan.coverage.benefit';
end;

function TFhirInsurancePlanCoverageBenefit.Link : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefit.Clone : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(limitList, o.limitList, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRequirement) and isEmptyProp(FlimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirInsurancePlanCoverageBenefit.SetRequirement(value : TFhirString);
begin
  FRequirement.free;
  FRequirement := value; {L1134}
end;

function TFhirInsurancePlanCoverageBenefit.GetRequirementST : String;
begin
  if FRequirement = nil then
    result := ''
  else
    result := FRequirement.value;
end;

procedure TFhirInsurancePlanCoverageBenefit.SetRequirementST(value : String);
begin
  if value <> '' then
  begin
    if FRequirement = nil then
      FRequirement := TFhirString.create;
    FRequirement.value := value
  end
  else if FRequirement <> nil then
    FRequirement.value := '';
end;

function TFhirInsurancePlanCoverageBenefit.GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
begin
  if FLimitList = nil then
    FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
  result := FLimitList;
end;

function TFhirInsurancePlanCoverageBenefit.GetHasLimitList : boolean;
begin
  result := (FLimitList <> nil) and (FLimitList.count > 0);
end;

procedure TFhirInsurancePlanCoverageBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('requirement');
  fields.add('limit');
end;

function TFhirInsurancePlanCoverageBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRequirement.sizeInBytes);
  inc(result, FlimitList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitListEnumerator }

constructor TFhirInsurancePlanCoverageBenefitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitList }

procedure TFhirInsurancePlanCoverageBenefitList.AddItem(value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Append: TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitList.Clone: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefit;
end;
function TFhirInsurancePlanCoverageBenefitList.IndexOf(value: TFhirInsurancePlanCoverageBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.Link: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  FhirInsurancePlanCoverageBenefits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefitLimit }

constructor TFhirInsurancePlanCoverageBenefitLimit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefitLimit.Destroy;
begin
  FValue.free;
  FCode.free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirInsurancePlanCoverageBenefitLimit(oSource).value.Clone;
  code := TFhirInsurancePlanCoverageBenefitLimit(oSource).code.Clone;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
end;

function TFhirInsurancePlanCoverageBenefitLimit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefitLimit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'Quantity'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirQuantity {L1195}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefitLimit.fhirType : string;
begin
  result := 'InsurancePlan.coverage.benefit.limit';
end;

function TFhirInsurancePlanCoverageBenefitLimit.Link : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefitLimit.Clone : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefitLimit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefitLimit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefitLimit(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefitLimit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FCode);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('code');
end;

function TFhirInsurancePlanCoverageBenefitLimit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitLimitListEnumerator }

constructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitLimitList }

procedure TFhirInsurancePlanCoverageBenefitLimitList.AddItem(value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefitLimit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefitLimit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Append: TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Clone: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit;
end;
function TFhirInsurancePlanCoverageBenefitLimitList.IndexOf(value: TFhirInsurancePlanCoverageBenefitLimit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Link: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  FhirInsurancePlanCoverageBenefitLimits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlan }

constructor TFhirInsurancePlanPlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlan.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoverageAreaList.Free;
  FNetworkList.Free;
  FGeneralCostList.Free;
  FSpecificCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlanPlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlanPlan(oSource).FIdentifierList);
  end;
  type_ := TFhirInsurancePlanPlan(oSource).type_.Clone;
  if (TFhirInsurancePlanPlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlanPlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlanPlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FGeneralCostList = nil) then
  begin
    FGeneralCostList.free;
    FGeneralCostList := nil;
  end
  else
  begin
    if FGeneralCostList = nil then
      FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
    FGeneralCostList.Assign(TFhirInsurancePlanPlan(oSource).FGeneralCostList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FSpecificCostList = nil) then
  begin
    FSpecificCostList.free;
    FSpecificCostList := nil;
  end
  else
  begin
    if FSpecificCostList = nil then
      FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
    FSpecificCostList.Assign(TFhirInsurancePlanPlan(oSource).FSpecificCostList);
  end;
end;

procedure TFhirInsurancePlanPlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'generalCost') Then
    list.addAll(self, 'generalCost', FGeneralCostList);
  if (child_name = 'specificCost') Then
    list.addAll(self, 'specificCost', FSpecificCostList);
end;

procedure TFhirInsurancePlanPlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'generalCost', 'BackboneElement', true, TFhirInsurancePlanPlanGeneralCost, FGeneralCostList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specificCost', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCost, FSpecificCostList.Link)) {L1039};
end;

function TFhirInsurancePlanPlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'generalCost') then
  begin
    GeneralCostList.add(propValue as TFhirInsurancePlanPlanGeneralCost) {L1048};
    result := propValue;
  end
  else if (propName = 'specificCost') then
  begin
    SpecificCostList.add(propValue as TFhirInsurancePlanPlanSpecificCost) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'generalCost') then GeneralCostList.insertItem(index, propValue as TFhirInsurancePlanPlanGeneralCost) {L1049}
  else if (propName = 'specificCost') then SpecificCostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCost) {L1049}
  else inherited;
end;

function TFhirInsurancePlanPlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new() {L1053}
  else if (propName = 'network') then result := NetworkList.new() {L1053}
  else if (propName = 'generalCost') then result := GeneralCostList.new() {L1053}
  else if (propName = 'specificCost') then result := SpecificCostList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'generalCost') then result := 'BackboneElement'
  else if (propName = 'specificCost') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {L1054}
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {L1054}
  else if (propName = 'generalCost') then deletePropertyValue('generalCost', GeneralCostList, value) {L1054}
  else if (propName = 'specificCost') then deletePropertyValue('specificCost', SpecificCostList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {L1055}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {L1055}
  else if (propName = 'generalCost') then replacePropertyValue('generalCost', GeneralCostList, existing, new) {L1055}
  else if (propName = 'specificCost') then replacePropertyValue('specificCost', SpecificCostList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination) {L1050}
  else if (propName = 'network') then NetworkList.move(source, destination) {L1050}
  else if (propName = 'generalCost') then GeneralCostList.move(source, destination) {L1050}
  else if (propName = 'specificCost') then SpecificCostList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlan.fhirType : string;
begin
  result := 'InsurancePlan.plan';
end;

function TFhirInsurancePlanPlan.Link : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Link);
end;

function TFhirInsurancePlanPlan.Clone : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Clone);
end;

function TFhirInsurancePlanPlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(generalCostList, o.generalCostList, true) and compareDeep(specificCostList, o.specificCostList, true);
  end;
end;

function TFhirInsurancePlanPlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FnetworkList) and isEmptyProp(FgeneralCostList) and isEmptyProp(FspecificCostList);
end;

function TFhirInsurancePlanPlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInsurancePlanPlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInsurancePlanPlan.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirInsurancePlanPlan.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirInsurancePlanPlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirInsurancePlanPlan.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlanPlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlanPlan.GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
begin
  if FGeneralCostList = nil then
    FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
  result := FGeneralCostList;
end;

function TFhirInsurancePlanPlan.GetHasGeneralCostList : boolean;
begin
  result := (FGeneralCostList <> nil) and (FGeneralCostList.count > 0);
end;

function TFhirInsurancePlanPlan.GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
begin
  if FSpecificCostList = nil then
    FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
  result := FSpecificCostList;
end;

function TFhirInsurancePlanPlan.GetHasSpecificCostList : boolean;
begin
  result := (FSpecificCostList <> nil) and (FSpecificCostList.count > 0);
end;

procedure TFhirInsurancePlanPlan.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coverageArea');
  fields.add('network');
  fields.add('generalCost');
  fields.add('specificCost');
end;

function TFhirInsurancePlanPlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FcoverageAreaList.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FgeneralCostList.sizeInBytes);
  inc(result, FspecificCostList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanListEnumerator }

constructor TFhirInsurancePlanPlanListEnumerator.Create(list : TFhirInsurancePlanPlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanListEnumerator.GetCurrent : TFhirInsurancePlanPlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanList }

procedure TFhirInsurancePlanPlanList.AddItem(value: TFhirInsurancePlanPlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlan');
  add(value);
end;

function TFhirInsurancePlanPlanList.Append: TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanList.GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
begin
  result := TFhirInsurancePlanPlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanList.Clone: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Clone);
end;

function TFhirInsurancePlanPlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanList.GetItemN(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlan;
end;
function TFhirInsurancePlanPlanList.IndexOf(value: TFhirInsurancePlanPlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanList.Insert(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.InsertItem(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanList.Item(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.Link: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Link);
end;

procedure TFhirInsurancePlanPlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  FhirInsurancePlanPlans[index] := value;
end;

procedure TFhirInsurancePlanPlanList.SetItemN(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanGeneralCost }

constructor TFhirInsurancePlanPlanGeneralCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanGeneralCost.Destroy;
begin
  FType_.free;
  FGroupSize.free;
  FCost.free;
  FComment.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanGeneralCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanGeneralCost(oSource).type_.Clone;
  groupSizeElement := TFhirInsurancePlanPlanGeneralCost(oSource).groupSizeElement.Clone;
  cost := TFhirInsurancePlanPlanGeneralCost(oSource).cost.Clone;
  commentElement := TFhirInsurancePlanPlanGeneralCost(oSource).commentElement.Clone;
end;

procedure TFhirInsurancePlanPlanGeneralCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupSize') Then
     list.add(self.link, 'groupSize', FGroupSize.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirInsurancePlanPlanGeneralCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'groupSize', 'positiveInt', false, TFhirPositiveInt, FGroupSize.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cost', 'Money', false, TFhirMoney, FCost.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
end;

function TFhirInsurancePlanPlanGeneralCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'groupSize') then
  begin
    GroupSizeElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanGeneralCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'groupSize') then result := TFhirPositiveInt.create() {L1223}
  else if (propName = 'cost') then result := TFhirMoney.create() {L1203}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanGeneralCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupSize') then result := 'positiveInt'
  else if (propName = 'cost') then result := 'Money'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanGeneralCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupSize') then GroupSizeElement := nil
  else if (propName = 'cost') then CostElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanGeneralCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'groupSize') then GroupSizeElement := asPositiveInt(new) {L1222}
  else if (propName = 'cost') then CostElement := new as TFhirMoney {L1195}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanGeneralCost.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanGeneralCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.generalCost';
end;

function TFhirInsurancePlanPlanGeneralCost.Link : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Link);
end;

function TFhirInsurancePlanPlanGeneralCost.Clone : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanGeneralCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanGeneralCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanGeneralCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(groupSizeElement, o.groupSizeElement, true) and 
      compareDeep(costElement, o.costElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirInsurancePlanPlanGeneralCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FGroupSize) and isEmptyProp(FCost) and isEmptyProp(FComment);
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSize(value : TFhirPositiveInt);
begin
  FGroupSize.free;
  FGroupSize := value; {L1134}
end;

function TFhirInsurancePlanPlanGeneralCost.GetGroupSizeST : String;
begin
  if FGroupSize = nil then
    result := ''
  else
    result := FGroupSize.value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSizeST(value : String);
begin
  if value <> '' then
  begin
    if FGroupSize = nil then
      FGroupSize := TFhirPositiveInt.create;
    FGroupSize.value := value
  end
  else if FGroupSize <> nil then
    FGroupSize.value := '';
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetCost(value : TFhirMoney);
begin
  FCost.free;
  FCost := value; {L1134}
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirInsurancePlanPlanGeneralCost.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirInsurancePlanPlanGeneralCost.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirInsurancePlanPlanGeneralCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('groupSize');
  fields.add('cost');
  fields.add('comment');
end;

function TFhirInsurancePlanPlanGeneralCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FGroupSize.sizeInBytes);
  inc(result, FCost.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirInsurancePlanPlanGeneralCostListEnumerator }

constructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(list : TFhirInsurancePlanPlanGeneralCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanGeneralCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanGeneralCostList }

procedure TFhirInsurancePlanPlanGeneralCostList.AddItem(value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanGeneralCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanGeneralCost');
  add(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Append: TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanGeneralCostList.Clone: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanGeneralCost;
end;
function TFhirInsurancePlanPlanGeneralCostList.IndexOf(value: TFhirInsurancePlanPlanGeneralCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Insert(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Item(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.Link: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  FhirInsurancePlanPlanGeneralCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCost }

constructor TFhirInsurancePlanPlanSpecificCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCost.Destroy;
begin
  FCategory.free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCost.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirInsurancePlanPlanSpecificCost(oSource).category.Clone;
  if (TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'benefit', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCostBenefit, FBenefitList.Link)) {L1039};
end;

function TFhirInsurancePlanPlanSpecificCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefit) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefit) {L1049}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'benefit') then result := BenefitList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'benefit') then BenefitList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost';
end;

function TFhirInsurancePlanPlanSpecificCost.Link : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCost.Clone : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCost(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value; {L1134}
end;

function TFhirInsurancePlanPlanSpecificCost.GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
  result := FBenefitList;
end;

function TFhirInsurancePlanPlanSpecificCost.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

procedure TFhirInsurancePlanPlanSpecificCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('benefit');
end;

function TFhirInsurancePlanPlanSpecificCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostList }

procedure TFhirInsurancePlanPlanSpecificCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Append: TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostList.Clone: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCost;
end;
function TFhirInsurancePlanPlanSpecificCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.Link: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  FhirInsurancePlanPlanSpecificCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefit }

constructor TFhirInsurancePlanPlanSpecificCostBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefit.Destroy;
begin
  FType_.free;
  FCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefit(oSource).type_.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
    FCostList.Assign(TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'cost', 'BackboneElement', true, TFhirInsurancePlanPlanSpecificCostBenefitCost, FCostList.Link)) {L1039};
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost) {L1049}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'cost') then result := CostList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'cost') then CostList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost.benefit';
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Link : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Clone : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(costList, o.costList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FcostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  if FCostList = nil then
    FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
  result := FCostList;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('cost');
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FcostList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitList }

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefit');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Append: TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Link: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  FhirInsurancePlanPlanSpecificCostBenefits[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCost }

constructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Destroy;
begin
  FType_.free;
  FApplicability.free;
  FQualifiersList.Free;
  FValue.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).type_.Clone;
  applicability := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).applicability.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList = nil) then
  begin
    FQualifiersList.free;
    FQualifiersList := nil;
  end
  else
  begin
    if FQualifiersList = nil then
      FQualifiersList := TFhirCodeableConceptList.Create;
    FQualifiersList.Assign(TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList);
  end;
  value := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).value.Clone;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'applicability') Then
     list.add(self.link, 'applicability', FApplicability.Link);
  if (child_name = 'qualifiers') Then
    list.addAll(self, 'qualifiers', FQualifiersList);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'applicability', 'CodeableConcept', false, TFhirCodeableConcept, FApplicability.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'qualifiers', 'CodeableConcept', true, TFhirCodeableConcept, FQualifiersList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link)); {L1172}
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'applicability') then
  begin
    Applicability := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'qualifiers') then
  begin
    QualifiersList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'applicability') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'qualifiers') then result := QualifiersList.new() {L1053}
  else if (propName = 'value') then result := TFhirQuantity.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'applicability') then result := 'CodeableConcept'
  else if (propName = 'qualifiers') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'applicability') then ApplicabilityElement := nil
  else if (propName = 'qualifiers') then deletePropertyValue('qualifiers', QualifiersList, value) {L1054}
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'applicability') then ApplicabilityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'qualifiers') then replacePropertyValue('qualifiers', QualifiersList, existing, new) {L1055}
  else if (propName = 'value') then ValueElement := new as TFhirQuantity {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.fhirType : string;
begin
  result := 'InsurancePlan.plan.specificCost.benefit.cost';
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Link : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefitCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefitCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(applicabilityElement, o.applicabilityElement, true) and 
      compareDeep(qualifiersList, o.qualifiersList, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FApplicability) and isEmptyProp(FqualifiersList) and isEmptyProp(FValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetApplicability(value : TFhirCodeableConcept);
begin
  FApplicability.free;
  FApplicability := value; {L1134}
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetQualifiersList : TFhirCodeableConceptList;
begin
  if FQualifiersList = nil then
    FQualifiersList := TFhirCodeableConceptList.Create;
  result := FQualifiersList;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetHasQualifiersList : boolean;
begin
  result := (FQualifiersList <> nil) and (FQualifiersList.count > 0);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('applicability');
  fields.add('qualifiers');
  fields.add('value');
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FApplicability.sizeInBytes);
  inc(result, FqualifiersList.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator }

constructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostList }

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefitCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefitCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Append: TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefitCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Link: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  FhirInsurancePlanPlanSpecificCostBenefitCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlan }

constructor TFhirInsurancePlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlan.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_List.Free;
  FName.free;
  FAliasList.Free;
  FPeriod.free;
  FOwnedBy.free;
  FAdministeredBy.free;
  FCoverageAreaList.Free;
  FContactList.Free;
  FEndpointList.Free;
  FNetworkList.Free;
  FCoverageList.Free;
  FPlanList.Free;
  inherited;
end;

procedure TFhirInsurancePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlan(oSource).FIdentifierList);
  end;
  statusElement := TFhirInsurancePlan(oSource).statusElement.Clone;
  if (TFhirInsurancePlan(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirInsurancePlan(oSource).FType_List);
  end;
  nameElement := TFhirInsurancePlan(oSource).nameElement.Clone;
  if (TFhirInsurancePlan(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirInsurancePlan(oSource).FAliasList);
  end;
  period := TFhirInsurancePlan(oSource).period.Clone;
  ownedBy := TFhirInsurancePlan(oSource).ownedBy.Clone;
  administeredBy := TFhirInsurancePlan(oSource).administeredBy.Clone;
  if (TFhirInsurancePlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlan(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirInsurancePlanContactList.Create;
    FContactList.Assign(TFhirInsurancePlan(oSource).FContactList);
  end;
  if (TFhirInsurancePlan(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirInsurancePlan(oSource).FEndpointList);
  end;
  if (TFhirInsurancePlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirInsurancePlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlan(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirInsurancePlanCoverageList.Create;
    FCoverageList.Assign(TFhirInsurancePlan(oSource).FCoverageList);
  end;
  if (TFhirInsurancePlan(oSource).FPlanList = nil) then
  begin
    FPlanList.free;
    FPlanList := nil;
  end
  else
  begin
    if FPlanList = nil then
      FPlanList := TFhirInsurancePlanPlanList.Create;
    FPlanList.Assign(TFhirInsurancePlan(oSource).FPlanList);
  end;
end;

function TFhirInsurancePlan.GetResourceType : TFhirResourceType;
begin
  result := frtInsurancePlan;
end;

procedure TFhirInsurancePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'ownedBy') Then
     list.add(self.link, 'ownedBy', FOwnedBy.Link);
  if (child_name = 'administeredBy') Then
     list.add(self.link, 'administeredBy', FAdministeredBy.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'plan') Then
    list.addAll(self, 'plan', FPlanList);
end;

procedure TFhirInsurancePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'ownedBy', 'Reference', false, TFhirReference, FOwnedBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'administeredBy', 'Reference', false, TFhirReference, FAdministeredBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirInsurancePlanContact, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'coverage', 'BackboneElement', true, TFhirInsurancePlanCoverage, FCoverageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'plan', 'BackboneElement', true, TFhirInsurancePlanPlan, FPlanList.Link)) {L1039};
end;

function TFhirInsurancePlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'ownedBy') then
  begin
    OwnedBy := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'administeredBy') then
  begin
    AdministeredBy := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirInsurancePlanContact) {L1048};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirInsurancePlanCoverage) {L1048};
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanList.add(propValue as TFhirInsurancePlanPlan) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirInsurancePlanContact) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirInsurancePlanCoverage) {L1049}
  else if (propName = 'plan') then PlanList.insertItem(index, propValue as TFhirInsurancePlanPlan) {L1049}
  else inherited;
end;

function TFhirInsurancePlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull])  {L1211}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'alias') then result := AliasList.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'ownedBy') then result := TFhirReference.create() {L1203}
  else if (propName = 'administeredBy') then result := TFhirReference.create() {L1203}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new() {L1053}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else if (propName = 'network') then result := NetworkList.new() {L1053}
  else if (propName = 'coverage') then result := CoverageList.new() {L1053}
  else if (propName = 'plan') then result := PlanList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'ownedBy') then result := 'Reference'
  else if (propName = 'administeredBy') then result := 'Reference'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'coverage') then result := 'BackboneElement'
  else if (propName = 'plan') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'ownedBy') then OwnedByElement := nil
  else if (propName = 'administeredBy') then AdministeredByElement := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {L1054}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {L1054}
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {L1054}
  else if (propName = 'plan') then deletePropertyValue('plan', PlanList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new) {L1210}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'ownedBy') then OwnedByElement := new as TFhirReference {L1195}
  else if (propName = 'administeredBy') then AdministeredByElement := new as TFhirReference {L1195}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {L1055}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {L1055}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {L1055}
  else if (propName = 'plan') then replacePropertyValue('plan', PlanList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'alias') then AliasList.move(source, destination) {L1046}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else if (propName = 'network') then NetworkList.move(source, destination) {L1050}
  else if (propName = 'coverage') then CoverageList.move(source, destination) {L1050}
  else if (propName = 'plan') then PlanList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlan.fhirType : string;
begin
  result := 'InsurancePlan';
end;

function TFhirInsurancePlan.Link : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Link);
end;

function TFhirInsurancePlan.Clone : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Clone);
end;

function TFhirInsurancePlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(ownedByElement, o.ownedByElement, true) and compareDeep(administeredByElement, o.administeredByElement, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(endpointList, o.endpointList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(coverageList, o.coverageList, true) and compareDeep(planList, o.planList, true);
  end;
end;

function TFhirInsurancePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FPeriod) and isEmptyProp(FOwnedBy) and isEmptyProp(FAdministeredBy) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList) and isEmptyProp(FnetworkList) and isEmptyProp(FcoverageList) and isEmptyProp(FplanList);
end;

function TFhirInsurancePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInsurancePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInsurancePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirInsurancePlan.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirInsurancePlan.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirInsurancePlan.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirInsurancePlan.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirInsurancePlan.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirInsurancePlan.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirInsurancePlan.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirInsurancePlan.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirInsurancePlan.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirInsurancePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirInsurancePlan.SetOwnedBy(value : TFhirReference);
begin
  FOwnedBy.free;
  FOwnedBy := value; {L1134}
end;

procedure TFhirInsurancePlan.SetAdministeredBy(value : TFhirReference);
begin
  FAdministeredBy.free;
  FAdministeredBy := value; {L1134}
end;

function TFhirInsurancePlan.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirInsurancePlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirInsurancePlan.GetContactList : TFhirInsurancePlanContactList;
begin
  if FContactList = nil then
    FContactList := TFhirInsurancePlanContactList.Create;
  result := FContactList;
end;

function TFhirInsurancePlan.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirInsurancePlan.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirInsurancePlan.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirInsurancePlan.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirInsurancePlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirInsurancePlan.GetCoverageList : TFhirInsurancePlanCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirInsurancePlanCoverageList.Create;
  result := FCoverageList;
end;

function TFhirInsurancePlan.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

function TFhirInsurancePlan.GetPlanList : TFhirInsurancePlanPlanList;
begin
  if FPlanList = nil then
    FPlanList := TFhirInsurancePlanPlanList.Create;
  result := FPlanList;
end;

function TFhirInsurancePlan.GetHasPlanList : boolean;
begin
  result := (FPlanList <> nil) and (FPlanList.count > 0);
end;

procedure TFhirInsurancePlan.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('period');
  fields.add('ownedBy');
  fields.add('administeredBy');
  fields.add('coverageArea');
  fields.add('contact');
  fields.add('endpoint');
  fields.add('network');
  fields.add('coverage');
  fields.add('plan');
end;

function TFhirInsurancePlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FOwnedBy.sizeInBytes);
  inc(result, FAdministeredBy.sizeInBytes);
  inc(result, FcoverageAreaList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
  inc(result, FplanList.sizeInBytes);
end;

{ TFhirInsurancePlanListEnumerator }

constructor TFhirInsurancePlanListEnumerator.Create(list : TFhirInsurancePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanListEnumerator.GetCurrent : TFhirInsurancePlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanList }

procedure TFhirInsurancePlanList.AddItem(value: TFhirInsurancePlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlan');
  add(value);
end;

function TFhirInsurancePlanList.Append: TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanList.GetEnumerator : TFhirInsurancePlanListEnumerator;
begin
  result := TFhirInsurancePlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanList.Clone: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Clone);
end;

function TFhirInsurancePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanList.GetItemN(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlan;
end;
function TFhirInsurancePlanList.IndexOf(value: TFhirInsurancePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanList.Insert(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.InsertItem(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanList.Item(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.Link: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Link);
end;

procedure TFhirInsurancePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  FhirInsurancePlans[index] := value;
end;

procedure TFhirInsurancePlanList.SetItemN(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
{ TFhirInvoiceParticipant }

constructor TFhirInvoiceParticipant.Create;
begin
  inherited;
end;

destructor TFhirInvoiceParticipant.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirInvoiceParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirInvoiceParticipant(oSource).role.Clone;
  actor := TFhirInvoiceParticipant(oSource).actor.Clone;
end;

procedure TFhirInvoiceParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirInvoiceParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link)); {L1172}
end;

function TFhirInvoiceParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'actor') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'actor') then ActorElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceParticipant.fhirType : string;
begin
  result := 'Invoice.participant';
end;

function TFhirInvoiceParticipant.Link : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Link);
end;

function TFhirInvoiceParticipant.Clone : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Clone);
end;

function TFhirInvoiceParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceParticipant)) then
    result := false
  else
  begin
    o := TFhirInvoiceParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirInvoiceParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirInvoiceParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value; {L1134}
end;

procedure TFhirInvoiceParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value; {L1134}
end;

procedure TFhirInvoiceParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

function TFhirInvoiceParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirInvoiceParticipantListEnumerator }

constructor TFhirInvoiceParticipantListEnumerator.Create(list : TFhirInvoiceParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceParticipantListEnumerator.GetCurrent : TFhirInvoiceParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceParticipantList }

procedure TFhirInvoiceParticipantList.AddItem(value: TFhirInvoiceParticipant);
begin
  assert(value.ClassName = 'TFhirInvoiceParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceParticipant');
  add(value);
end;

function TFhirInvoiceParticipantList.Append: TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceParticipantList.GetEnumerator : TFhirInvoiceParticipantListEnumerator;
begin
  result := TFhirInvoiceParticipantListEnumerator.Create(self.link);
end;

function TFhirInvoiceParticipantList.Clone: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Clone);
end;

function TFhirInvoiceParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceParticipantList.GetItemN(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceParticipant;
end;
function TFhirInvoiceParticipantList.IndexOf(value: TFhirInvoiceParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceParticipantList.Insert(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.InsertItem(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  Inherited Insert(index, value);
end;

function TFhirInvoiceParticipantList.Item(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.Link: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Link);
end;

procedure TFhirInvoiceParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceParticipantList.SetItemByIndex(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  FhirInvoiceParticipants[index] := value;
end;

procedure TFhirInvoiceParticipantList.SetItemN(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItem }

constructor TFhirInvoiceLineItem.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItem.Destroy;
begin
  FSequence.free;
  FChargeItem.free;
  FPriceComponentList.Free;
  inherited;
end;

procedure TFhirInvoiceLineItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirInvoiceLineItem(oSource).sequenceElement.Clone;
  chargeItem := TFhirInvoiceLineItem(oSource).chargeItem.Clone;
  if (TFhirInvoiceLineItem(oSource).FPriceComponentList = nil) then
  begin
    FPriceComponentList.free;
    FPriceComponentList := nil;
  end
  else
  begin
    if FPriceComponentList = nil then
      FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FPriceComponentList.Assign(TFhirInvoiceLineItem(oSource).FPriceComponentList);
  end;
end;

procedure TFhirInvoiceLineItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'chargeItem[x]') or (child_name = 'chargeItem') Then
     list.add(self.link, 'chargeItem[x]', FChargeItem.Link);
  if (child_name = 'priceComponent') Then
    list.addAll(self, 'priceComponent', FPriceComponentList);
end;

procedure TFhirInvoiceLineItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'chargeItem[x]', 'Reference|CodeableConcept', false, TFhirDataType, FChargeItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priceComponent', 'BackboneElement', true, TFhirInvoiceLineItemPriceComponent, FPriceComponentList.Link)) {L1039};
end;

function TFhirInvoiceLineItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then
  begin
    ChargeItem := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'priceComponent') then
  begin
    PriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent) {L1049}
  else inherited;
end;

function TFhirInvoiceLineItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {L1223}
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property ChargeItem') {L1191}
  else if (propName = 'priceComponent') then result := PriceComponentList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'chargeItem[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'priceComponent') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := nil {L1189}
  else if (propName = 'priceComponent') then deletePropertyValue('priceComponent', PriceComponentList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new) {L1222}
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := new as TFhirDataType {L1190}
  else if (propName = 'priceComponent') then replacePropertyValue('priceComponent', PriceComponentList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItem.fhirType : string;
begin
  result := 'Invoice.lineItem';
end;

function TFhirInvoiceLineItem.Link : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Link);
end;

function TFhirInvoiceLineItem.Clone : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Clone);
end;

function TFhirInvoiceLineItem.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItem)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(chargeItemElement, o.chargeItemElement, true) and 
      compareDeep(priceComponentList, o.priceComponentList, true);
  end;
end;

function TFhirInvoiceLineItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FChargeItem) and isEmptyProp(FpriceComponentList);
end;

procedure TFhirInvoiceLineItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value; {L1134}
end;

function TFhirInvoiceLineItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

procedure TFhirInvoiceLineItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

procedure TFhirInvoiceLineItem.SetChargeItem(value : TFhirDataType);
begin
  FChargeItem.free;
  FChargeItem := value; {L1134}
end;

function TFhirInvoiceLineItem.GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FPriceComponentList = nil then
    FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FPriceComponentList;
end;

function TFhirInvoiceLineItem.GetHasPriceComponentList : boolean;
begin
  result := (FPriceComponentList <> nil) and (FPriceComponentList.count > 0);
end;

procedure TFhirInvoiceLineItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('chargeItem[x]');
  fields.add('priceComponent');
end;

function TFhirInvoiceLineItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FChargeItem.sizeInBytes);
  inc(result, FpriceComponentList.sizeInBytes);
end;

{ TFhirInvoiceLineItemListEnumerator }

constructor TFhirInvoiceLineItemListEnumerator.Create(list : TFhirInvoiceLineItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemListEnumerator.GetCurrent : TFhirInvoiceLineItem;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceLineItemList }

procedure TFhirInvoiceLineItemList.AddItem(value: TFhirInvoiceLineItem);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItem');
  add(value);
end;

function TFhirInvoiceLineItemList.Append: TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemList.GetEnumerator : TFhirInvoiceLineItemListEnumerator;
begin
  result := TFhirInvoiceLineItemListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemList.Clone: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Clone);
end;

function TFhirInvoiceLineItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemList.GetItemN(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItem;
end;
function TFhirInvoiceLineItemList.IndexOf(value: TFhirInvoiceLineItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemList.Insert(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.InsertItem(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemList.Item(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.Link: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Link);
end;

procedure TFhirInvoiceLineItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  FhirInvoiceLineItems[index] := value;
end;

procedure TFhirInvoiceLineItemList.SetItemN(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItemPriceComponent }

constructor TFhirInvoiceLineItemPriceComponent.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItemPriceComponent.Destroy;
begin
  FType_.free;
  FCode.free;
  FFactor.free;
  FAmount.free;
  inherited;
end;

procedure TFhirInvoiceLineItemPriceComponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirInvoiceLineItemPriceComponent(oSource).type_Element.Clone;
  code := TFhirInvoiceLineItemPriceComponent(oSource).code.Clone;
  factorElement := TFhirInvoiceLineItemPriceComponent(oSource).factorElement.Clone;
  amount := TFhirInvoiceLineItemPriceComponent(oSource).amount.Clone;
end;

procedure TFhirInvoiceLineItemPriceComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirInvoiceLineItemPriceComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
end;

function TFhirInvoiceLineItemPriceComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItemPriceComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceLineItemPriceComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull], CODES_TFhirInvoicePriceComponentTypeEnum[InvoicePriceComponentTypeNull])  {L1211}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'factor') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItemPriceComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItemPriceComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItemPriceComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, new) {L1210}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'factor') then FactorElement := asDecimal(new) {L1222}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItemPriceComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItemPriceComponent.fhirType : string;
begin
  result := 'Invoice.lineItem.priceComponent';
end;

function TFhirInvoiceLineItemPriceComponent.Link : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Link);
end;

function TFhirInvoiceLineItemPriceComponent.Clone : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponent.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItemPriceComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItemPriceComponent)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItemPriceComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirInvoiceLineItemPriceComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FCode) and isEmptyProp(FFactor) and isEmptyProp(FAmount);
end;

procedure TFhirInvoiceLineItemPriceComponent.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirInvoiceLineItemPriceComponent.GetType_ST : TFhirInvoicePriceComponentTypeEnum;
begin
  if FType_ = nil then
    result := TFhirInvoicePriceComponentTypeEnum(0)
  else
    result := TFhirInvoicePriceComponentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoicePriceComponentTypeEnum, FType_.value));
end;

procedure TFhirInvoiceLineItemPriceComponent.SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[value], CODES_TFhirInvoicePriceComponentTypeEnum[value]);
end;

procedure TFhirInvoiceLineItemPriceComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirInvoiceLineItemPriceComponent.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value; {L1134}
end;

function TFhirInvoiceLineItemPriceComponent.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirInvoiceLineItemPriceComponent.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirInvoiceLineItemPriceComponent.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirInvoiceLineItemPriceComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('code');
  fields.add('factor');
  fields.add('amount');
end;

function TFhirInvoiceLineItemPriceComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirInvoiceLineItemPriceComponentListEnumerator }

constructor TFhirInvoiceLineItemPriceComponentListEnumerator.Create(list : TFhirInvoiceLineItemPriceComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemPriceComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.GetCurrent : TFhirInvoiceLineItemPriceComponent;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceLineItemPriceComponentList }

procedure TFhirInvoiceLineItemPriceComponentList.AddItem(value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItemPriceComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItemPriceComponent');
  add(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Append: TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemPriceComponentList.GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
begin
  result := TFhirInvoiceLineItemPriceComponentListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemPriceComponentList.Clone: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemPriceComponentList.GetItemN(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItemPriceComponent;
end;
function TFhirInvoiceLineItemPriceComponentList.IndexOf(value: TFhirInvoiceLineItemPriceComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Insert(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.InsertItem(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemPriceComponentList.Item(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.Link: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Link);
end;

procedure TFhirInvoiceLineItemPriceComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  FhirInvoiceLineItemPriceComponents[index] := value;
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemN(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoice }

constructor TFhirInvoice.Create;
begin
  inherited;
end;

destructor TFhirInvoice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCancelledReason.free;
  FType_.free;
  FSubject.free;
  FRecipient.free;
  FDate.free;
  FParticipantList.Free;
  FIssuer.free;
  FAccount.free;
  FLineItemList.Free;
  FTotalPriceComponentList.Free;
  FTotalNet.free;
  FTotalGross.free;
  FPaymentTerms.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirInvoice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInvoice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInvoice(oSource).FIdentifierList);
  end;
  statusElement := TFhirInvoice(oSource).statusElement.Clone;
  cancelledReasonElement := TFhirInvoice(oSource).cancelledReasonElement.Clone;
  type_ := TFhirInvoice(oSource).type_.Clone;
  subject := TFhirInvoice(oSource).subject.Clone;
  recipient := TFhirInvoice(oSource).recipient.Clone;
  dateElement := TFhirInvoice(oSource).dateElement.Clone;
  if (TFhirInvoice(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirInvoiceParticipantList.Create;
    FParticipantList.Assign(TFhirInvoice(oSource).FParticipantList);
  end;
  issuer := TFhirInvoice(oSource).issuer.Clone;
  account := TFhirInvoice(oSource).account.Clone;
  if (TFhirInvoice(oSource).FLineItemList = nil) then
  begin
    FLineItemList.free;
    FLineItemList := nil;
  end
  else
  begin
    if FLineItemList = nil then
      FLineItemList := TFhirInvoiceLineItemList.Create;
    FLineItemList.Assign(TFhirInvoice(oSource).FLineItemList);
  end;
  if (TFhirInvoice(oSource).FTotalPriceComponentList = nil) then
  begin
    FTotalPriceComponentList.free;
    FTotalPriceComponentList := nil;
  end
  else
  begin
    if FTotalPriceComponentList = nil then
      FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FTotalPriceComponentList.Assign(TFhirInvoice(oSource).FTotalPriceComponentList);
  end;
  totalNet := TFhirInvoice(oSource).totalNet.Clone;
  totalGross := TFhirInvoice(oSource).totalGross.Clone;
  paymentTermsElement := TFhirInvoice(oSource).paymentTermsElement.Clone;
  if (TFhirInvoice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirInvoice(oSource).FNoteList);
  end;
end;

function TFhirInvoice.GetResourceType : TFhirResourceType;
begin
  result := frtInvoice;
end;

procedure TFhirInvoice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'cancelledReason') Then
     list.add(self.link, 'cancelledReason', FCancelledReason.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'account') Then
     list.add(self.link, 'account', FAccount.Link);
  if (child_name = 'lineItem') Then
    list.addAll(self, 'lineItem', FLineItemList);
  if (child_name = 'totalPriceComponent') Then
    list.addAll(self, 'totalPriceComponent', FTotalPriceComponentList);
  if (child_name = 'totalNet') Then
     list.add(self.link, 'totalNet', FTotalNet.Link);
  if (child_name = 'totalGross') Then
     list.add(self.link, 'totalGross', FTotalGross.Link);
  if (child_name = 'paymentTerms') Then
     list.add(self.link, 'paymentTerms', FPaymentTerms.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirInvoice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'cancelledReason', 'string', false, TFhirString, FCancelledReason.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirInvoiceParticipant, FParticipantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', false, TFhirReference, FAccount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lineItem', 'BackboneElement', true, TFhirInvoiceLineItem, FLineItemList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'totalPriceComponent', '', true, TFhirInvoiceLineItemPriceComponent, FTotalPriceComponentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'totalNet', 'Money', false, TFhirMoney, FTotalNet.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'totalGross', 'Money', false, TFhirMoney, FTotalGross.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentTerms', 'markdown', false, TFhirMarkdown, FPaymentTerms.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
end;

function TFhirInvoice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'cancelledReason') then
  begin
    CancelledReasonElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirInvoiceParticipant) {L1048};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    Account := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'lineItem') then
  begin
    LineItemList.add(propValue as TFhirInvoiceLineItem) {L1048};
    result := propValue;
  end
  else if (propName = 'totalPriceComponent') then
  begin
    TotalPriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent) {L1048};
    result := propValue;
  end
  else if (propName = 'totalNet') then
  begin
    TotalNet := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'totalGross') then
  begin
    TotalGross := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'paymentTerms') then
  begin
    PaymentTermsElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirInvoiceParticipant) {L1049}
  else if (propName = 'lineItem') then LineItemList.insertItem(index, propValue as TFhirInvoiceLineItem) {L1049}
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else inherited;
end;

function TFhirInvoice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirInvoiceStatusEnum[InvoiceStatusNull], CODES_TFhirInvoiceStatusEnum[InvoiceStatusNull])  {L1211}
  else if (propName = 'cancelledReason') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'recipient') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'participant') then result := ParticipantList.new() {L1053}
  else if (propName = 'issuer') then result := TFhirReference.create() {L1203}
  else if (propName = 'account') then result := TFhirReference.create() {L1203}
  else if (propName = 'lineItem') then result := LineItemList.new() {L1053}
  else if (propName = 'totalPriceComponent') then result := TotalPriceComponentList.new() {L1053}
  else if (propName = 'totalNet') then result := TFhirMoney.create() {L1203}
  else if (propName = 'totalGross') then result := TFhirMoney.create() {L1203}
  else if (propName = 'paymentTerms') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'cancelledReason') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'issuer') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'lineItem') then result := 'BackboneElement'
  else if (propName = 'totalPriceComponent') then result := ''
  else if (propName = 'totalNet') then result := 'Money'
  else if (propName = 'totalGross') then result := 'Money'
  else if (propName = 'paymentTerms') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'cancelledReason') then CancelledReasonElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {L1054}
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'account') then AccountElement := nil
  else if (propName = 'lineItem') then deletePropertyValue('lineItem', LineItemList, value) {L1054}
  else if (propName = 'totalPriceComponent') then deletePropertyValue('totalPriceComponent', TotalPriceComponentList, value) {L1054}
  else if (propName = 'totalNet') then TotalNetElement := nil
  else if (propName = 'totalGross') then TotalGrossElement := nil
  else if (propName = 'paymentTerms') then PaymentTermsElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, new) {L1210}
  else if (propName = 'cancelledReason') then CancelledReasonElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDateTime(new) {L1222}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {L1055}
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference {L1195}
  else if (propName = 'account') then AccountElement := new as TFhirReference {L1195}
  else if (propName = 'lineItem') then replacePropertyValue('lineItem', LineItemList, existing, new) {L1055}
  else if (propName = 'totalPriceComponent') then replacePropertyValue('totalPriceComponent', TotalPriceComponentList, existing, new) {L1055}
  else if (propName = 'totalNet') then TotalNetElement := new as TFhirMoney {L1195}
  else if (propName = 'totalGross') then TotalGrossElement := new as TFhirMoney {L1195}
  else if (propName = 'paymentTerms') then PaymentTermsElement := asMarkdown(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'participant') then ParticipantList.move(source, destination) {L1050}
  else if (propName = 'lineItem') then LineItemList.move(source, destination) {L1050}
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoice.fhirType : string;
begin
  result := 'Invoice';
end;

function TFhirInvoice.Link : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Link);
end;

function TFhirInvoice.Clone : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Clone);
end;

function TFhirInvoice.equals(other : TObject) : boolean; 
var
  o : TFhirInvoice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoice)) then
    result := false
  else
  begin
    o := TFhirInvoice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(cancelledReasonElement, o.cancelledReasonElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(accountElement, o.accountElement, true) and 
      compareDeep(lineItemList, o.lineItemList, true) and compareDeep(totalPriceComponentList, o.totalPriceComponentList, true) and 
      compareDeep(totalNetElement, o.totalNetElement, true) and compareDeep(totalGrossElement, o.totalGrossElement, true) and 
      compareDeep(paymentTermsElement, o.paymentTermsElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirInvoice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCancelledReason) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FRecipient) and isEmptyProp(FDate) and isEmptyProp(FparticipantList) and isEmptyProp(FIssuer) and isEmptyProp(FAccount) and isEmptyProp(FlineItemList) and isEmptyProp(FtotalPriceComponentList) and isEmptyProp(FTotalNet) and isEmptyProp(FTotalGross) and isEmptyProp(FPaymentTerms) and isEmptyProp(FnoteList);
end;

function TFhirInvoice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirInvoice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirInvoice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirInvoice.GetStatusST : TFhirInvoiceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirInvoiceStatusEnum(0)
  else
    result := TFhirInvoiceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoiceStatusEnum, FStatus.value));
end;

procedure TFhirInvoice.SetStatusST(value : TFhirInvoiceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirInvoiceStatusEnum[value], CODES_TFhirInvoiceStatusEnum[value]);
end;

procedure TFhirInvoice.SetCancelledReason(value : TFhirString);
begin
  FCancelledReason.free;
  FCancelledReason := value; {L1134}
end;

function TFhirInvoice.GetCancelledReasonST : String;
begin
  if FCancelledReason = nil then
    result := ''
  else
    result := FCancelledReason.value;
end;

procedure TFhirInvoice.SetCancelledReasonST(value : String);
begin
  if value <> '' then
  begin
    if FCancelledReason = nil then
      FCancelledReason := TFhirString.create;
    FCancelledReason.value := value
  end
  else if FCancelledReason <> nil then
    FCancelledReason.value := '';
end;

procedure TFhirInvoice.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirInvoice.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirInvoice.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value; {L1134}
end;

procedure TFhirInvoice.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirInvoice.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirInvoice.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirInvoice.GetParticipantList : TFhirInvoiceParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirInvoiceParticipantList.Create;
  result := FParticipantList;
end;

function TFhirInvoice.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirInvoice.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value; {L1134}
end;

procedure TFhirInvoice.SetAccount(value : TFhirReference);
begin
  FAccount.free;
  FAccount := value; {L1134}
end;

function TFhirInvoice.GetLineItemList : TFhirInvoiceLineItemList;
begin
  if FLineItemList = nil then
    FLineItemList := TFhirInvoiceLineItemList.Create;
  result := FLineItemList;
end;

function TFhirInvoice.GetHasLineItemList : boolean;
begin
  result := (FLineItemList <> nil) and (FLineItemList.count > 0);
end;

function TFhirInvoice.GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FTotalPriceComponentList = nil then
    FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FTotalPriceComponentList;
end;

function TFhirInvoice.GetHasTotalPriceComponentList : boolean;
begin
  result := (FTotalPriceComponentList <> nil) and (FTotalPriceComponentList.count > 0);
end;

procedure TFhirInvoice.SetTotalNet(value : TFhirMoney);
begin
  FTotalNet.free;
  FTotalNet := value; {L1134}
end;

procedure TFhirInvoice.SetTotalGross(value : TFhirMoney);
begin
  FTotalGross.free;
  FTotalGross := value; {L1134}
end;

procedure TFhirInvoice.SetPaymentTerms(value : TFhirMarkdown);
begin
  FPaymentTerms.free;
  FPaymentTerms := value; {L1134}
end;

function TFhirInvoice.GetPaymentTermsST : String;
begin
  if FPaymentTerms = nil then
    result := ''
  else
    result := FPaymentTerms.value;
end;

procedure TFhirInvoice.SetPaymentTermsST(value : String);
begin
  if value <> '' then
  begin
    if FPaymentTerms = nil then
      FPaymentTerms := TFhirMarkdown.create;
    FPaymentTerms.value := value
  end
  else if FPaymentTerms <> nil then
    FPaymentTerms.value := '';
end;

function TFhirInvoice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirInvoice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirInvoice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('cancelledReason');
  fields.add('type');
  fields.add('subject');
  fields.add('recipient');
  fields.add('date');
  fields.add('participant');
  fields.add('issuer');
  fields.add('account');
  fields.add('lineItem');
  fields.add('totalPriceComponent');
  fields.add('totalNet');
  fields.add('totalGross');
  fields.add('paymentTerms');
  fields.add('note');
end;

function TFhirInvoice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCancelledReason.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FRecipient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FIssuer.sizeInBytes);
  inc(result, FAccount.sizeInBytes);
  inc(result, FlineItemList.sizeInBytes);
  inc(result, FtotalPriceComponentList.sizeInBytes);
  inc(result, FTotalNet.sizeInBytes);
  inc(result, FTotalGross.sizeInBytes);
  inc(result, FPaymentTerms.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirInvoiceListEnumerator }

constructor TFhirInvoiceListEnumerator.Create(list : TFhirInvoiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceListEnumerator.GetCurrent : TFhirInvoice;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceList }

procedure TFhirInvoiceList.AddItem(value: TFhirInvoice);
begin
  assert(value.ClassName = 'TFhirInvoice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoice');
  add(value);
end;

function TFhirInvoiceList.Append: TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceList.GetEnumerator : TFhirInvoiceListEnumerator;
begin
  result := TFhirInvoiceListEnumerator.Create(self.link);
end;

function TFhirInvoiceList.Clone: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Clone);
end;

function TFhirInvoiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceList.GetItemN(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoice;
end;
function TFhirInvoiceList.IndexOf(value: TFhirInvoice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceList.Insert(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.InsertItem(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  Inherited Insert(index, value);
end;

function TFhirInvoiceList.Item(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.Link: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Link);
end;

procedure TFhirInvoiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceList.SetItemByIndex(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  FhirInvoices[index] := value;
end;

procedure TFhirInvoiceList.SetItemN(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
{ TFhirPaymentNotice }

constructor TFhirPaymentNotice.Create;
begin
  inherited;
end;

destructor TFhirPaymentNotice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FResponse.free;
  FCreated.free;
  FProvider.free;
  FPayment.free;
  FPaymentDate.free;
  FPayee.free;
  FRecipient.free;
  FAmount.free;
  FPaymentStatus.free;
  inherited;
end;

procedure TFhirPaymentNotice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentNotice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentNotice(oSource).FIdentifierList);
  end;
  statusElement := TFhirPaymentNotice(oSource).statusElement.Clone;
  request := TFhirPaymentNotice(oSource).request.Clone;
  response := TFhirPaymentNotice(oSource).response.Clone;
  createdElement := TFhirPaymentNotice(oSource).createdElement.Clone;
  provider := TFhirPaymentNotice(oSource).provider.Clone;
  payment := TFhirPaymentNotice(oSource).payment.Clone;
  paymentDateElement := TFhirPaymentNotice(oSource).paymentDateElement.Clone;
  payee := TFhirPaymentNotice(oSource).payee.Clone;
  recipient := TFhirPaymentNotice(oSource).recipient.Clone;
  amount := TFhirPaymentNotice(oSource).amount.Clone;
  paymentStatus := TFhirPaymentNotice(oSource).paymentStatus.Clone;
end;

function TFhirPaymentNotice.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentNotice;
end;

procedure TFhirPaymentNotice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'paymentStatus') Then
     list.add(self.link, 'paymentStatus', FPaymentStatus.Link);
end;

procedure TFhirPaymentNotice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference', false, TFhirReference, FResponse.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference', false, TFhirReference, FProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payment', 'Reference', false, TFhirReference, FPayment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference', false, TFhirReference, FPayee.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentStatus', 'CodeableConcept', false, TFhirCodeableConcept, FPaymentStatus.Link)); {L1172}
end;

function TFhirPaymentNotice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'paymentStatus') then
  begin
    PaymentStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentNotice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirPaymentNotice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'response') then result := TFhirReference.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'provider') then result := TFhirReference.create() {L1203}
  else if (propName = 'payment') then result := TFhirReference.create() {L1203}
  else if (propName = 'paymentDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'payee') then result := TFhirReference.create() {L1203}
  else if (propName = 'recipient') then result := TFhirReference.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'paymentStatus') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentNotice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'payment') then result := 'Reference'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'paymentStatus') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentNotice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'paymentStatus') then PaymentStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentNotice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'response') then ResponseElement := new as TFhirReference {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference {L1195}
  else if (propName = 'payment') then PaymentElement := new as TFhirReference {L1195}
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new) {L1222}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference {L1195}
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else if (propName = 'paymentStatus') then PaymentStatusElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentNotice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentNotice.fhirType : string;
begin
  result := 'PaymentNotice';
end;

function TFhirPaymentNotice.Link : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Link);
end;

function TFhirPaymentNotice.Clone : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Clone);
end;

function TFhirPaymentNotice.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentNotice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentNotice)) then
    result := false
  else
  begin
    o := TFhirPaymentNotice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(paymentStatusElement, o.paymentStatusElement, true);
  end;
end;

function TFhirPaymentNotice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FCreated) and isEmptyProp(FProvider) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FPayee) and isEmptyProp(FRecipient) and isEmptyProp(FAmount) and isEmptyProp(FPaymentStatus);
end;

function TFhirPaymentNotice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPaymentNotice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPaymentNotice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPaymentNotice.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirPaymentNotice.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirPaymentNotice.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirPaymentNotice.SetResponse(value : TFhirReference);
begin
  FResponse.free;
  FResponse := value; {L1134}
end;

procedure TFhirPaymentNotice.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirPaymentNotice.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirPaymentNotice.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirPaymentNotice.SetProvider(value : TFhirReference);
begin
  FProvider.free;
  FProvider := value; {L1134}
end;

procedure TFhirPaymentNotice.SetPayment(value : TFhirReference);
begin
  FPayment.free;
  FPayment := value; {L1134}
end;

procedure TFhirPaymentNotice.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value; {L1134}
end;

function TFhirPaymentNotice.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirPaymentNotice.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

procedure TFhirPaymentNotice.SetPayee(value : TFhirReference);
begin
  FPayee.free;
  FPayee := value; {L1134}
end;

procedure TFhirPaymentNotice.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value; {L1134}
end;

procedure TFhirPaymentNotice.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirPaymentNotice.SetPaymentStatus(value : TFhirCodeableConcept);
begin
  FPaymentStatus.free;
  FPaymentStatus := value; {L1134}
end;

procedure TFhirPaymentNotice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('response');
  fields.add('created');
  fields.add('provider');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('payee');
  fields.add('recipient');
  fields.add('amount');
  fields.add('paymentStatus');
end;

function TFhirPaymentNotice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FRecipient.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FPaymentStatus.sizeInBytes);
end;

{ TFhirPaymentNoticeListEnumerator }

constructor TFhirPaymentNoticeListEnumerator.Create(list : TFhirPaymentNoticeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentNoticeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentNoticeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentNoticeListEnumerator.GetCurrent : TFhirPaymentNotice;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentNoticeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentNoticeList }

procedure TFhirPaymentNoticeList.AddItem(value: TFhirPaymentNotice);
begin
  assert(value.ClassName = 'TFhirPaymentNotice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentNotice');
  add(value);
end;

function TFhirPaymentNoticeList.Append: TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentNoticeList.GetEnumerator : TFhirPaymentNoticeListEnumerator;
begin
  result := TFhirPaymentNoticeListEnumerator.Create(self.link);
end;

function TFhirPaymentNoticeList.Clone: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Clone);
end;

function TFhirPaymentNoticeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentNoticeList.GetItemN(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentNotice;
end;
function TFhirPaymentNoticeList.IndexOf(value: TFhirPaymentNotice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentNoticeList.Insert(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.InsertItem(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  Inherited Insert(index, value);
end;

function TFhirPaymentNoticeList.Item(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.Link: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Link);
end;

procedure TFhirPaymentNoticeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentNoticeList.SetItemByIndex(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  FhirPaymentNotices[index] := value;
end;

procedure TFhirPaymentNoticeList.SetItemN(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
{ TFhirPaymentReconciliationDetail }

constructor TFhirPaymentReconciliationDetail.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationDetail.Destroy;
begin
  FIdentifier.free;
  FPredecessor.free;
  FType_.free;
  FRequest.free;
  FSubmitter.free;
  FResponse.free;
  FDate.free;
  FResponsible.free;
  FPayee.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPaymentReconciliationDetail.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirPaymentReconciliationDetail(oSource).identifier.Clone;
  predecessor := TFhirPaymentReconciliationDetail(oSource).predecessor.Clone;
  type_ := TFhirPaymentReconciliationDetail(oSource).type_.Clone;
  request := TFhirPaymentReconciliationDetail(oSource).request.Clone;
  submitter := TFhirPaymentReconciliationDetail(oSource).submitter.Clone;
  response := TFhirPaymentReconciliationDetail(oSource).response.Clone;
  dateElement := TFhirPaymentReconciliationDetail(oSource).dateElement.Clone;
  responsible := TFhirPaymentReconciliationDetail(oSource).responsible.Clone;
  payee := TFhirPaymentReconciliationDetail(oSource).payee.Clone;
  amount := TFhirPaymentReconciliationDetail(oSource).amount.Clone;
end;

procedure TFhirPaymentReconciliationDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'predecessor') Then
     list.add(self.link, 'predecessor', FPredecessor.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'submitter') Then
     list.add(self.link, 'submitter', FSubmitter.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPaymentReconciliationDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'predecessor', 'Identifier', false, TFhirIdentifier, FPredecessor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'submitter', 'Reference', false, TFhirReference, FSubmitter.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference', false, TFhirReference, FResponse.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference', false, TFhirReference, FPayee.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link)); {L1172}
end;

function TFhirPaymentReconciliationDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'predecessor') then
  begin
    Predecessor := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'submitter') then
  begin
    Submitter := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'predecessor') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'submitter') then result := TFhirReference.create() {L1203}
  else if (propName = 'response') then result := TFhirReference.create() {L1203}
  else if (propName = 'date') then result := TFhirDate.create() {L1223}
  else if (propName = 'responsible') then result := TFhirReference.create() {L1203}
  else if (propName = 'payee') then result := TFhirReference.create() {L1203}
  else if (propName = 'amount') then result := TFhirMoney.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'predecessor') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'submitter') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'predecessor') then PredecessorElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'submitter') then SubmitterElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'predecessor') then PredecessorElement := new as TFhirIdentifier {L1195}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'submitter') then SubmitterElement := new as TFhirReference {L1195}
  else if (propName = 'response') then ResponseElement := new as TFhirReference {L1195}
  else if (propName = 'date') then DateElement := asDate(new) {L1222}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference {L1195}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference {L1195}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationDetail.fhirType : string;
begin
  result := 'PaymentReconciliation.detail';
end;

function TFhirPaymentReconciliationDetail.Link : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Link);
end;

function TFhirPaymentReconciliationDetail.Clone : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Clone);
end;

function TFhirPaymentReconciliationDetail.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationDetail)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationDetail(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(predecessorElement, o.predecessorElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(submitterElement, o.submitterElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(responsibleElement, o.responsibleElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPaymentReconciliationDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPredecessor) and isEmptyProp(FType_) and isEmptyProp(FRequest) and isEmptyProp(FSubmitter) and isEmptyProp(FResponse) and isEmptyProp(FDate) and isEmptyProp(FResponsible) and isEmptyProp(FPayee) and isEmptyProp(FAmount);
end;

procedure TFhirPaymentReconciliationDetail.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetPredecessor(value : TFhirIdentifier);
begin
  FPredecessor.free;
  FPredecessor := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetSubmitter(value : TFhirReference);
begin
  FSubmitter.free;
  FSubmitter := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetResponse(value : TFhirReference);
begin
  FResponse.free;
  FResponse := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value; {L1134}
end;

function TFhirPaymentReconciliationDetail.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirPaymentReconciliationDetail.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirPaymentReconciliationDetail.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetPayee(value : TFhirReference);
begin
  FPayee.free;
  FPayee := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value; {L1134}
end;

procedure TFhirPaymentReconciliationDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('predecessor');
  fields.add('type');
  fields.add('request');
  fields.add('submitter');
  fields.add('response');
  fields.add('date');
  fields.add('responsible');
  fields.add('payee');
  fields.add('amount');
end;

function TFhirPaymentReconciliationDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPredecessor.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FSubmitter.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailListEnumerator }

constructor TFhirPaymentReconciliationDetailListEnumerator.Create(list : TFhirPaymentReconciliationDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationDetailListEnumerator.GetCurrent : TFhirPaymentReconciliationDetail;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailList }

procedure TFhirPaymentReconciliationDetailList.AddItem(value: TFhirPaymentReconciliationDetail);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationDetail');
  add(value);
end;

function TFhirPaymentReconciliationDetailList.Append: TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationDetailList.GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
begin
  result := TFhirPaymentReconciliationDetailListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationDetailList.Clone: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Clone);
end;

function TFhirPaymentReconciliationDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationDetailList.GetItemN(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationDetail;
end;
function TFhirPaymentReconciliationDetailList.IndexOf(value: TFhirPaymentReconciliationDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationDetailList.Insert(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.InsertItem(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationDetailList.Item(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.Link: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Link);
end;

procedure TFhirPaymentReconciliationDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationDetailList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  FhirPaymentReconciliationDetails[index] := value;
end;

procedure TFhirPaymentReconciliationDetailList.SetItemN(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliationProcessNote }

constructor TFhirPaymentReconciliationProcessNote.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationProcessNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirPaymentReconciliationProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirPaymentReconciliationProcessNote(oSource).type_Element.Clone;
  textElement := TFhirPaymentReconciliationProcessNote(oSource).textElement.Clone;
end;

procedure TFhirPaymentReconciliationProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirPaymentReconciliationProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link)); {L1172}
end;

function TFhirPaymentReconciliationProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[NoteTypeNull], CODES_TFhirNoteTypeEnum[NoteTypeNull])  {L1211}
  else if (propName = 'text') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new) {L1210}
  else if (propName = 'text') then TextElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationProcessNote.fhirType : string;
begin
  result := 'PaymentReconciliation.processNote';
end;

function TFhirPaymentReconciliationProcessNote.Link : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Link);
end;

function TFhirPaymentReconciliationProcessNote.Clone : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationProcessNote)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationProcessNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirPaymentReconciliationProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirPaymentReconciliationProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPaymentReconciliationProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

procedure TFhirPaymentReconciliationProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

procedure TFhirPaymentReconciliationProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value; {L1134}
end;

function TFhirPaymentReconciliationProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirPaymentReconciliationProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirPaymentReconciliationProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

function TFhirPaymentReconciliationProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteListEnumerator }

constructor TFhirPaymentReconciliationProcessNoteListEnumerator.Create(list : TFhirPaymentReconciliationProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.GetCurrent : TFhirPaymentReconciliationProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteList }

procedure TFhirPaymentReconciliationProcessNoteList.AddItem(value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationProcessNote');
  add(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Append: TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationProcessNoteList.GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
begin
  result := TFhirPaymentReconciliationProcessNoteListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationProcessNoteList.Clone: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationProcessNoteList.GetItemN(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationProcessNote;
end;
function TFhirPaymentReconciliationProcessNoteList.IndexOf(value: TFhirPaymentReconciliationProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Insert(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.InsertItem(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationProcessNoteList.Item(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.Link: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Link);
end;

procedure TFhirPaymentReconciliationProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  FhirPaymentReconciliationProcessNotes[index] := value;
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemN(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliation }

constructor TFhirPaymentReconciliation.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FCreated.free;
  FPaymentIssuer.free;
  FRequest.free;
  FRequestor.free;
  FOutcome.free;
  FDisposition.free;
  FPaymentDate.free;
  FPaymentAmount.free;
  FPaymentIdentifier.free;
  FDetailList.Free;
  FFormCode.free;
  FProcessNoteList.Free;
  inherited;
end;

procedure TFhirPaymentReconciliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentReconciliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentReconciliation(oSource).FIdentifierList);
  end;
  statusElement := TFhirPaymentReconciliation(oSource).statusElement.Clone;
  period := TFhirPaymentReconciliation(oSource).period.Clone;
  createdElement := TFhirPaymentReconciliation(oSource).createdElement.Clone;
  paymentIssuer := TFhirPaymentReconciliation(oSource).paymentIssuer.Clone;
  request := TFhirPaymentReconciliation(oSource).request.Clone;
  requestor := TFhirPaymentReconciliation(oSource).requestor.Clone;
  outcomeElement := TFhirPaymentReconciliation(oSource).outcomeElement.Clone;
  dispositionElement := TFhirPaymentReconciliation(oSource).dispositionElement.Clone;
  paymentDateElement := TFhirPaymentReconciliation(oSource).paymentDateElement.Clone;
  paymentAmount := TFhirPaymentReconciliation(oSource).paymentAmount.Clone;
  paymentIdentifier := TFhirPaymentReconciliation(oSource).paymentIdentifier.Clone;
  if (TFhirPaymentReconciliation(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirPaymentReconciliationDetailList.Create;
    FDetailList.Assign(TFhirPaymentReconciliation(oSource).FDetailList);
  end;
  formCode := TFhirPaymentReconciliation(oSource).formCode.Clone;
  if (TFhirPaymentReconciliation(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirPaymentReconciliation(oSource).FProcessNoteList);
  end;
end;

function TFhirPaymentReconciliation.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentReconciliation;
end;

procedure TFhirPaymentReconciliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'paymentIssuer') Then
     list.add(self.link, 'paymentIssuer', FPaymentIssuer.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'paymentAmount') Then
     list.add(self.link, 'paymentAmount', FPaymentAmount.Link);
  if (child_name = 'paymentIdentifier') Then
     list.add(self.link, 'paymentIdentifier', FPaymentIdentifier.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
end;

procedure TFhirPaymentReconciliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentIssuer', 'Reference', false, TFhirReference, FPaymentIssuer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference', false, TFhirReference, FRequestor.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentAmount', 'Money', false, TFhirMoney, FPaymentAmount.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'paymentIdentifier', 'Identifier', false, TFhirIdentifier, FPaymentIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirPaymentReconciliationDetail, FDetailList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'processNote', 'BackboneElement', true, TFhirPaymentReconciliationProcessNote, FProcessNoteList.Link)) {L1039};
end;

function TFhirPaymentReconciliation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'paymentIssuer') then
  begin
    PaymentIssuer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'paymentAmount') then
  begin
    PaymentAmount := propValue as TFhirMoney {L1199};
    result := propValue;
  end
  else if (propName = 'paymentIdentifier') then
  begin
    PaymentIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirPaymentReconciliationDetail) {L1048};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirPaymentReconciliationProcessNote) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirPaymentReconciliationDetail) {L1049}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirPaymentReconciliationProcessNote) {L1049}
  else inherited;
end;

function TFhirPaymentReconciliation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull])  {L1211}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'created') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'paymentIssuer') then result := TFhirReference.create() {L1203}
  else if (propName = 'request') then result := TFhirReference.create() {L1203}
  else if (propName = 'requestor') then result := TFhirReference.create() {L1203}
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull], CODES_TFhirClaimProcessingCodesEnum[ClaimProcessingCodesNull])  {L1211}
  else if (propName = 'disposition') then result := TFhirString.create() {L1223}
  else if (propName = 'paymentDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'paymentAmount') then result := TFhirMoney.create() {L1203}
  else if (propName = 'paymentIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'detail') then result := DetailList.new() {L1053}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'processNote') then result := ProcessNoteList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'paymentIssuer') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'paymentAmount') then result := 'Money'
  else if (propName = 'paymentIdentifier') then result := 'Identifier'
  else if (propName = 'detail') then result := 'BackboneElement'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'paymentAmount') then PaymentAmountElement := nil
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {L1054}
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new) {L1210}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'created') then CreatedElement := asDateTime(new) {L1222}
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := new as TFhirReference {L1195}
  else if (propName = 'request') then RequestElement := new as TFhirReference {L1195}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference {L1195}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirClaimProcessingCodesEnum, CODES_TFhirClaimProcessingCodesEnum, new) {L1210}
  else if (propName = 'disposition') then DispositionElement := asString(new) {L1222}
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new) {L1222}
  else if (propName = 'paymentAmount') then PaymentAmountElement := new as TFhirMoney {L1195}
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {L1055}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'detail') then DetailList.move(source, destination) {L1050}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliation.fhirType : string;
begin
  result := 'PaymentReconciliation';
end;

function TFhirPaymentReconciliation.Link : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Link);
end;

function TFhirPaymentReconciliation.Clone : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Clone);
end;

function TFhirPaymentReconciliation.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliation)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(paymentIssuerElement, o.paymentIssuerElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(paymentAmountElement, o.paymentAmountElement, true) and compareDeep(paymentIdentifierElement, o.paymentIdentifierElement, true) and 
      compareDeep(detailList, o.detailList, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(processNoteList, o.processNoteList, true);
  end;
end;

function TFhirPaymentReconciliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FPaymentIssuer) and isEmptyProp(FRequest) and isEmptyProp(FRequestor) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPaymentDate) and isEmptyProp(FPaymentAmount) and isEmptyProp(FPaymentIdentifier) and isEmptyProp(FdetailList) and isEmptyProp(FFormCode) and isEmptyProp(FprocessNoteList);
end;

function TFhirPaymentReconciliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPaymentReconciliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPaymentReconciliation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPaymentReconciliation.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirPaymentReconciliation.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirPaymentReconciliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirPaymentReconciliation.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value; {L1134}
end;

function TFhirPaymentReconciliation.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirPaymentReconciliation.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirPaymentReconciliation.SetPaymentIssuer(value : TFhirReference);
begin
  FPaymentIssuer.free;
  FPaymentIssuer := value; {L1134}
end;

procedure TFhirPaymentReconciliation.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value; {L1134}
end;

procedure TFhirPaymentReconciliation.SetRequestor(value : TFhirReference);
begin
  FRequestor.free;
  FRequestor := value; {L1134}
end;

procedure TFhirPaymentReconciliation.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirPaymentReconciliation.GetOutcomeST : TFhirClaimProcessingCodesEnum;
begin
  if FOutcome = nil then
    result := TFhirClaimProcessingCodesEnum(0)
  else
    result := TFhirClaimProcessingCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimProcessingCodesEnum, FOutcome.value));
end;

procedure TFhirPaymentReconciliation.SetOutcomeST(value : TFhirClaimProcessingCodesEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirClaimProcessingCodesEnum[value], CODES_TFhirClaimProcessingCodesEnum[value]);
end;

procedure TFhirPaymentReconciliation.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value; {L1134}
end;

function TFhirPaymentReconciliation.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

procedure TFhirPaymentReconciliation.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

procedure TFhirPaymentReconciliation.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value; {L1134}
end;

function TFhirPaymentReconciliation.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirPaymentReconciliation.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

procedure TFhirPaymentReconciliation.SetPaymentAmount(value : TFhirMoney);
begin
  FPaymentAmount.free;
  FPaymentAmount := value; {L1134}
end;

procedure TFhirPaymentReconciliation.SetPaymentIdentifier(value : TFhirIdentifier);
begin
  FPaymentIdentifier.free;
  FPaymentIdentifier := value; {L1134}
end;

function TFhirPaymentReconciliation.GetDetailList : TFhirPaymentReconciliationDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirPaymentReconciliationDetailList.Create;
  result := FDetailList;
end;

function TFhirPaymentReconciliation.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

procedure TFhirPaymentReconciliation.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value; {L1134}
end;

function TFhirPaymentReconciliation.GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
  result := FProcessNoteList;
end;

function TFhirPaymentReconciliation.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

procedure TFhirPaymentReconciliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('created');
  fields.add('paymentIssuer');
  fields.add('request');
  fields.add('requestor');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('paymentDate');
  fields.add('paymentAmount');
  fields.add('paymentIdentifier');
  fields.add('detail');
  fields.add('formCode');
  fields.add('processNote');
end;

function TFhirPaymentReconciliation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FPaymentIssuer.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FPaymentAmount.sizeInBytes);
  inc(result, FPaymentIdentifier.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
end;

{ TFhirPaymentReconciliationListEnumerator }

constructor TFhirPaymentReconciliationListEnumerator.Create(list : TFhirPaymentReconciliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationListEnumerator.GetCurrent : TFhirPaymentReconciliation;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationList }

procedure TFhirPaymentReconciliationList.AddItem(value: TFhirPaymentReconciliation);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliation');
  add(value);
end;

function TFhirPaymentReconciliationList.Append: TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationList.GetEnumerator : TFhirPaymentReconciliationListEnumerator;
begin
  result := TFhirPaymentReconciliationListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationList.Clone: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Clone);
end;

function TFhirPaymentReconciliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationList.GetItemN(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliation;
end;
function TFhirPaymentReconciliationList.IndexOf(value: TFhirPaymentReconciliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationList.Insert(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.InsertItem(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationList.Item(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.Link: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Link);
end;

procedure TFhirPaymentReconciliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  FhirPaymentReconciliations[index] := value;
end;

procedure TFhirPaymentReconciliationList.SetItemN(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

end.

