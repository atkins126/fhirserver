unit fhir5_resources_admin;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir5.inc}

interface

// Generated on Fri, Aug 21, 2020 11:27+1000 for FHIR v4.5.0

uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities, 
  fhir5_base, fhir5_enums, fhir5_types, fhir5_resources_base;

type
{$IFDEF FHIR_CATALOGENTRY}
  TFhirCatalogEntryRelatedEntry = class;
  TFhirCatalogEntryRelatedEntryList = class;
  TFhirCatalogEntry = class;
  TFhirCatalogEntryList = class;
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
  TFhirDeviceUdiCarrier = class;
  TFhirDeviceUdiCarrierList = class;
  TFhirDeviceDeviceName = class;
  TFhirDeviceDeviceNameList = class;
  TFhirDeviceSpecialization = class;
  TFhirDeviceSpecializationList = class;
  TFhirDeviceVersion = class;
  TFhirDeviceVersionList = class;
  TFhirDeviceProperty = class;
  TFhirDevicePropertyList = class;
  TFhirDeviceOperationalStatus = class;
  TFhirDeviceOperationalStatusList = class;
  TFhirDeviceAssociationStatus = class;
  TFhirDeviceAssociationStatusList = class;
  TFhirDevice = class;
  TFhirDeviceList = class;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  TFhirDeviceDefinitionUdiDeviceIdentifier = class;
  TFhirDeviceDefinitionUdiDeviceIdentifierList = class;
  TFhirDeviceDefinitionDeviceName = class;
  TFhirDeviceDefinitionDeviceNameList = class;
  TFhirDeviceDefinitionSpecialization = class;
  TFhirDeviceDefinitionSpecializationList = class;
  TFhirDeviceDefinitionCapability = class;
  TFhirDeviceDefinitionCapabilityList = class;
  TFhirDeviceDefinitionProperty = class;
  TFhirDeviceDefinitionPropertyList = class;
  TFhirDeviceDefinitionMaterial = class;
  TFhirDeviceDefinitionMaterialList = class;
  TFhirDeviceDefinition = class;
  TFhirDeviceDefinitionList = class;
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  TFhirDeviceMetricCalibration = class;
  TFhirDeviceMetricCalibrationList = class;
  TFhirDeviceMetric = class;
  TFhirDeviceMetricList = class;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  TFhirEncounterStatusHistory = class;
  TFhirEncounterStatusHistoryList = class;
  TFhirEncounterClassHistory = class;
  TFhirEncounterClassHistoryList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterDiagnosis = class;
  TFhirEncounterDiagnosisList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirEncounter = class;
  TFhirEncounterList = class;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  TFhirEndpoint = class;
  TFhirEndpointList = class;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirGroupMember = class;
  TFhirGroupMemberList = class;
  TFhirGroup = class;
  TFhirGroupList = class;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  TFhirHealthcareServiceEligibility = class;
  TFhirHealthcareServiceEligibilityList = class;
  TFhirHealthcareServiceAvailableTime = class;
  TFhirHealthcareServiceAvailableTimeList = class;
  TFhirHealthcareServiceNotAvailable = class;
  TFhirHealthcareServiceNotAvailableList = class;
  TFhirHealthcareService = class;
  TFhirHealthcareServiceList = class;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirLocationHoursOfOperation = class;
  TFhirLocationHoursOfOperationList = class;
  TFhirLocation = class;
  TFhirLocationList = class;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirOrganization = class;
  TFhirOrganizationList = class;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  TFhirOrganizationAffiliation = class;
  TFhirOrganizationAffiliationList = class;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientCommunication = class;
  TFhirPatientCommunicationList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPatient = class;
  TFhirPatientList = class;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  TFhirPersonLink = class;
  TFhirPersonLinkList = class;
  TFhirPerson = class;
  TFhirPersonList = class;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirPractitioner = class;
  TFhirPractitionerList = class;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  TFhirPractitionerRoleAvailableTime = class;
  TFhirPractitionerRoleAvailableTimeList = class;
  TFhirPractitionerRoleNotAvailable = class;
  TFhirPractitionerRoleNotAvailableList = class;
  TFhirPractitionerRole = class;
  TFhirPractitionerRoleList = class;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  TFhirRelatedPersonCommunication = class;
  TFhirRelatedPersonCommunicationList = class;
  TFhirRelatedPerson = class;
  TFhirRelatedPersonList = class;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  TFhirSchedule = class;
  TFhirScheduleList = class;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  TFhirSlot = class;
  TFhirSlotList = class;
{$ENDIF FHIR_SLOT}

{$IFDEF FHIR_CATALOGENTRY}
  // Used for example, to point to a substance, or to a device used to administer a medication.
  TFhirCatalogEntryRelatedEntry = class (TFhirBackboneElement)
  protected
    FRelationship : TFhirEnum;
    FTarget : TFhirReference;
    procedure SetRelationship(value : TFhirEnum);
    function GetRelationshipST : TFhirCatalogEntryRelationTypeEnum;
    procedure SetRelationshipST(value : TFhirCatalogEntryRelationTypeEnum);
    procedure SetTarget(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntryRelatedEntry; overload;
    function Clone : TFhirCatalogEntryRelatedEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship to the related entry.
    property relationship : TFhirCatalogEntryRelationTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to The reference to the related entry. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The reference to the related entry.
    property targetElement : TFhirReference read FTarget write SetTarget;

  end;

  TFhirCatalogEntryRelatedEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryRelatedEntryList;
    function GetCurrent : TFhirCatalogEntryRelatedEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryRelatedEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntryRelatedEntry read GetCurrent;
  end;

  TFhirCatalogEntryRelatedEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCatalogEntryRelatedEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntryRelatedEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCatalogEntryRelatedEntryList; overload;
    function Clone : TFhirCatalogEntryRelatedEntryList; overload;
    function GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
    
    //  Add a FhirCatalogEntryRelatedEntry to the end of the list.
    function Append : TFhirCatalogEntryRelatedEntry;
    
    // Add an already existing FhirCatalogEntryRelatedEntry to the end of the list.
    procedure AddItem(value : TFhirCatalogEntryRelatedEntry); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntryRelatedEntry) : Integer;
    
    // Insert FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntryRelatedEntry;
    
    // Insert an existing FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // Get the iIndexth FhirCatalogEntryRelatedEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntryRelatedEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCatalogEntryRelatedEntries[index : Integer] : TFhirCatalogEntryRelatedEntry read GetItemN write SetItemN; default;
  End;

  // Catalog entries are wrappers that contextualize items included in a catalog.
  TFhirCatalogEntry = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FType_ : TFhirEnum;
    FStatus : TFhirEnum;
    FEffectivePeriod : TFhirPeriod;
    FOrderable : TFhirBoolean;
    FReferencedItem : TFhirReference;
    FrelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    FUpdatedBy : TFhirReference;
    FnoteList : TFhirAnnotationList;
    FEstimatedDuration : TFhirDuration;
    FbillingCodeList : TFhirCodeableConceptList;
    FBillingSummary : TFhirString;
    FScheduleSummary : TFhirString;
    FLimitationSummary : TFhirString;
    FRegulatorySummary : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirCatalogEntryTypeEnum;
    procedure SetType_ST(value : TFhirCatalogEntryTypeEnum);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCatalogEntryStatusEnum;
    procedure SetStatusST(value : TFhirCatalogEntryStatusEnum);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    procedure SetOrderable(value : TFhirBoolean);
    function GetOrderableST : Boolean;
    procedure SetOrderableST(value : Boolean);
    procedure SetReferencedItem(value : TFhirReference);
    function GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    function GetHasRelatedEntryList : Boolean;
    Procedure SetUpdatedBy(value : TFhirReference);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetEstimatedDuration(value : TFhirDuration);
    function GetBillingCodeList : TFhirCodeableConceptList;
    function GetHasBillingCodeList : Boolean;
    procedure SetBillingSummary(value : TFhirString);
    function GetBillingSummaryST : String;
    procedure SetBillingSummaryST(value : String);
    procedure SetScheduleSummary(value : TFhirString);
    function GetScheduleSummaryST : String;
    procedure SetScheduleSummaryST(value : String);
    procedure SetLimitationSummary(value : TFhirString);
    function GetLimitationSummaryST : String;
    procedure SetLimitationSummaryST(value : String);
    procedure SetRegulatorySummary(value : TFhirString);
    function GetRegulatorySummaryST : String;
    procedure SetRegulatorySummaryST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntry; overload;
    function Clone : TFhirCatalogEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier uniquely assigned to the catalog entry.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The name of this catalog entry announces the item that is represented by the entry.
    property name : String read GetNameST write SetNameST;
    // The name of this catalog entry announces the item that is represented by the entry.
    property nameElement : TFhirString read FName write SetName;

    // The type of resource that is represented by this catalog entry.
    property type_ : TFhirCatalogEntryTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Indicates whether this catalog entry is open to public usage (active) or not (draft or retired).
    property status : TFhirCatalogEntryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Period of usability of the catalog entry. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // Period of usability of the catalog entry.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Typed access to Indicates whether or not the entry represents an item that is orderable.
    property orderable : Boolean read GetOrderableST write SetOrderableST;
    // Indicates whether or not the entry represents an item that is orderable.
    property orderableElement : TFhirBoolean read FOrderable write SetOrderable;

    // Typed access to The item (resource) that this entry of the catalog represents. (defined for API consistency)
    property referencedItem : TFhirReference read FReferencedItem write SetReferencedItem;
    // The item (resource) that this entry of the catalog represents.
    property referencedItemElement : TFhirReference read FReferencedItem write SetReferencedItem;

    // Used for example, to point to a substance, or to a device used to administer a medication.
    property relatedEntryList : TFhirCatalogEntryRelatedEntryList read GetRelatedEntryList;
    property hasRelatedEntryList : boolean read GetHasRelatedEntryList;

    // Typed access to Last actor who recorded (created or updated) this catalog entry. (defined for API consistency)
    property updatedBy : TFhirReference read FUpdatedBy write SetUpdatedBy;
    // Last actor who recorded (created or updated) this catalog entry.
    property updatedByElement : TFhirReference read FUpdatedBy write SetUpdatedBy;

    // Notes and comments about this catalog entry.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Estimated duration of the orderable item of this  entry of the catalog. (defined for API consistency)
    property estimatedDuration : TFhirDuration read FEstimatedDuration write SetEstimatedDuration;
    // Estimated duration of the orderable item of this  entry of the catalog.
    property estimatedDurationElement : TFhirDuration read FEstimatedDuration write SetEstimatedDuration;

    // Billing code associated to the  item in the context of this  entry of the catalog.
    property billingCodeList : TFhirCodeableConceptList read GetBillingCodeList;
    property hasBillingCodeList : boolean read GetHasBillingCodeList;

    // Typed access to Billing summary attached to the  item in the context of this  entry of the catalog.
    property billingSummary : String read GetBillingSummaryST write SetBillingSummaryST;
    // Billing summary attached to the  item in the context of this  entry of the catalog.
    property billingSummaryElement : TFhirString read FBillingSummary write SetBillingSummary;

    // Typed access to Schedule summary for the  item in the context of this  entry of the catalog.
    property scheduleSummary : String read GetScheduleSummaryST write SetScheduleSummaryST;
    // Schedule summary for the  item in the context of this  entry of the catalog.
    property scheduleSummaryElement : TFhirString read FScheduleSummary write SetScheduleSummary;

    // Typed access to Summary of limitations for the  item in the context of this  entry of the catalog.
    property limitationSummary : String read GetLimitationSummaryST write SetLimitationSummaryST;
    // Summary of limitations for the  item in the context of this  entry of the catalog.
    property limitationSummaryElement : TFhirString read FLimitationSummary write SetLimitationSummary;

    // Typed access to Regulatory summary for the  item in the context of this  entry of the catalog.
    property regulatorySummary : String read GetRegulatorySummaryST write SetRegulatorySummaryST;
    // Regulatory summary for the  item in the context of this  entry of the catalog.
    property regulatorySummaryElement : TFhirString read FRegulatorySummary write SetRegulatorySummary;

  end;

  TFhirCatalogEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryList;
    function GetCurrent : TFhirCatalogEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntry read GetCurrent;
  end;

  TFhirCatalogEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCatalogEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCatalogEntryList; overload;
    function Clone : TFhirCatalogEntryList; overload;
    function GetEnumerator : TFhirCatalogEntryListEnumerator;
    
    //  Add a FhirCatalogEntry to the end of the list.
    function Append : TFhirCatalogEntry;
    
    // Add an already existing FhirCatalogEntry to the end of the list.
    procedure AddItem(value : TFhirCatalogEntry); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntry) : Integer;
    
    // Insert FhirCatalogEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntry;
    
    // Insert an existing FhirCatalogEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntry);
    
    // Get the iIndexth FhirCatalogEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCatalogEntries[index : Integer] : TFhirCatalogEntry read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceUdiCarrier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    FCarrierAIDC : TFhirBase64Binary;
    FCarrierHRF : TFhirString;
    FEntryType : TFhirEnum;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
    procedure SetCarrierAIDC(value : TFhirBase64Binary);
    function GetCarrierAIDCST : TBytes;
    procedure SetCarrierAIDCST(value : TBytes);
    procedure SetCarrierHRF(value : TFhirString);
    function GetCarrierHRFST : String;
    procedure SetCarrierHRFST(value : String);
    procedure SetEntryType(value : TFhirEnum);
    function GetEntryTypeST : TFhirUDIEntryTypeEnum;
    procedure SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUdiCarrier; overload;
    function Clone : TFhirDeviceUdiCarrier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuer : String read GetIssuerST write SetIssuerST;
    // Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

    // Typed access to The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDC : TBytes read GetCarrierAIDCST write SetCarrierAIDCST;
    // The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDCElement : TFhirBase64Binary read FCarrierAIDC write SetCarrierAIDC;

    // Typed access to The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRF : String read GetCarrierHRFST write SetCarrierHRFST;
    // The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRFElement : TFhirString read FCarrierHRF write SetCarrierHRF;

    // A coded entry to indicate how the data was entered.
    property entryType : TFhirUDIEntryTypeEnum read GetEntryTypeST write SetEntryTypeST;
    property entryTypeElement : TFhirEnum read FEntryType write SetEntryType;

  end;

  TFhirDeviceUdiCarrierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUdiCarrierList;
    function GetCurrent : TFhirDeviceUdiCarrier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUdiCarrierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUdiCarrier read GetCurrent;
  end;

  TFhirDeviceUdiCarrierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceUdiCarrier;
    procedure SetItemN(index : Integer; value : TFhirDeviceUdiCarrier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceUdiCarrierList; overload;
    function Clone : TFhirDeviceUdiCarrierList; overload;
    function GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
    
    //  Add a FhirDeviceUdiCarrier to the end of the list.
    function Append : TFhirDeviceUdiCarrier;
    
    // Add an already existing FhirDeviceUdiCarrier to the end of the list.
    procedure AddItem(value : TFhirDeviceUdiCarrier); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUdiCarrier) : Integer;
    
    // Insert FhirDeviceUdiCarrier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUdiCarrier;
    
    // Insert an existing FhirDeviceUdiCarrier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // Get the iIndexth FhirDeviceUdiCarrier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUdiCarrier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceUdiCarriers[index : Integer] : TFhirDeviceUdiCarrier read GetItemN write SetItemN; default;
  End;

  // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
  TFhirDeviceDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDeviceName; overload;
    function Clone : TFhirDeviceDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name that identifies the device.
    property name : String read GetNameST write SetNameST;
    // The name that identifies the device.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. Note that ManufactureDeviceName means that the name is the name as given by the manufacturer, not the name of the manufacturer. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDeviceNameList;
    function GetCurrent : TFhirDeviceDeviceName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDeviceName read GetCurrent;
  end;

  TFhirDeviceDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDeviceNameList; overload;
    function Clone : TFhirDeviceDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDeviceName to the end of the list.
    function Append : TFhirDeviceDeviceName;
    
    // Add an already existing FhirDeviceDeviceName to the end of the list.
    procedure AddItem(value : TFhirDeviceDeviceName); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDeviceName) : Integer;
    
    // Insert FhirDeviceDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDeviceName;
    
    // Insert an existing FhirDeviceDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDeviceName);
    
    // Get the iIndexth FhirDeviceDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDeviceNames[index : Integer] : TFhirDeviceDeviceName read GetItemN write SetItemN; default;
  End;

  // The device function, including in some cases whether or not the functionality conforms to some standard. For example, a PHD blood pressure specialization indicates that the device conforms to the IEEE 11073-10407 Blood Pressure Specialization. This is NOT an alternate name or an additional descriptive name given by the manufacturer. That would be found in the deviceName element. In the PHD case, there are 11073 10101 nomenclature codes that define the specialization standards and that will be used, for example, in the PHD case for the specialization.systemType element. The specialization.version would be the version of the standard if the systemType referred to a standard.
  TFhirDeviceSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirCodeableConcept;
    FVersion : TFhirString;
    procedure SetSystemType(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceSpecialization; overload;
    function Clone : TFhirDeviceSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The standard that is used to operate and communicate. (defined for API consistency)
    property systemType : TFhirCodeableConcept read FSystemType write SetSystemType;
    // The standard that is used to operate and communicate.
    property systemTypeElement : TFhirCodeableConcept read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirDeviceSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceSpecializationList;
    function GetCurrent : TFhirDeviceSpecialization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceSpecialization read GetCurrent;
  end;

  TFhirDeviceSpecializationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceSpecializationList; overload;
    function Clone : TFhirDeviceSpecializationList; overload;
    function GetEnumerator : TFhirDeviceSpecializationListEnumerator;
    
    //  Add a FhirDeviceSpecialization to the end of the list.
    function Append : TFhirDeviceSpecialization;
    
    // Add an already existing FhirDeviceSpecialization to the end of the list.
    procedure AddItem(value : TFhirDeviceSpecialization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceSpecialization) : Integer;
    
    // Insert FhirDeviceSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceSpecialization;
    
    // Insert an existing FhirDeviceSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceSpecialization);
    
    // Get the iIndexth FhirDeviceSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceSpecialization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceSpecializations[index : Integer] : TFhirDeviceSpecialization read GetItemN write SetItemN; default;
  End;

  // The actual design of the device or software version running on the device.
  TFhirDeviceVersion = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FComponent : TFhirIdentifier;
    FValue : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetComponent(value : TFhirIdentifier);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceVersion; overload;
    function Clone : TFhirDeviceVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the device version, e.g. manufacturer, approved, internal. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the device version, e.g. manufacturer, approved, internal.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The hardware or software module of the device to which the version applies. (defined for API consistency)
    property component : TFhirIdentifier read FComponent write SetComponent;
    // The hardware or software module of the device to which the version applies.
    property componentElement : TFhirIdentifier read FComponent write SetComponent;

    // Typed access to The version text.
    property value : String read GetValueST write SetValueST;
    // The version text.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirDeviceVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceVersionList;
    function GetCurrent : TFhirDeviceVersion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceVersion read GetCurrent;
  end;

  TFhirDeviceVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceVersion;
    procedure SetItemN(index : Integer; value : TFhirDeviceVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceVersionList; overload;
    function Clone : TFhirDeviceVersionList; overload;
    function GetEnumerator : TFhirDeviceVersionListEnumerator;
    
    //  Add a FhirDeviceVersion to the end of the list.
    function Append : TFhirDeviceVersion;
    
    // Add an already existing FhirDeviceVersion to the end of the list.
    procedure AddItem(value : TFhirDeviceVersion); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceVersion) : Integer;
    
    // Insert FhirDeviceVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceVersion;
    
    // Insert an existing FhirDeviceVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceVersion);
    
    // Get the iIndexth FhirDeviceVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceVersions[index : Integer] : TFhirDeviceVersion read GetItemN write SetItemN; default;
  End;

  // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
  TFhirDeviceProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FvalueQuantityList : TFhirQuantityList;
    FvalueCodeList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueCodeList : TFhirCodeableConceptList;
    function GetHasValueCodeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceProperty; overload;
    function Clone : TFhirDeviceProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property being represented. No codes are specified but the MDC codes are an example: https://build.fhir.org/mdc.html. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property being represented. No codes are specified but the MDC codes are an example: https://build.fhir.org/mdc.html.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Property value as a quantity.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Property value as a code, e.g., NTP4 (synced to NTP).
    property valueCodeList : TFhirCodeableConceptList read GetValueCodeList;
    property hasValueCodeList : boolean read GetHasValueCodeList;

  end;

  TFhirDevicePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDevicePropertyList;
    function GetCurrent : TFhirDeviceProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDevicePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceProperty read GetCurrent;
  end;

  TFhirDevicePropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDevicePropertyList; overload;
    function Clone : TFhirDevicePropertyList; overload;
    function GetEnumerator : TFhirDevicePropertyListEnumerator;
    
    //  Add a FhirDeviceProperty to the end of the list.
    function Append : TFhirDeviceProperty;
    
    // Add an already existing FhirDeviceProperty to the end of the list.
    procedure AddItem(value : TFhirDeviceProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceProperty) : Integer;
    
    // Insert FhirDeviceProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceProperty;
    
    // Insert an existing FhirDeviceProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceProperty);
    
    // Get the iIndexth FhirDeviceProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceProperties[index : Integer] : TFhirDeviceProperty read GetItemN write SetItemN; default;
  End;

  // The status of the device itself - whether it is switched on, or activated, etc.
  TFhirDeviceOperationalStatus = class (TFhirBackboneElement)
  protected
    FValue : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    procedure SetValue(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceOperationalStatus; overload;
    function Clone : TFhirDeviceOperationalStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to on |off | standby. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // on |off | standby.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

    // The reasons given for the current operational status - i.e. why is the device switched on etc.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

  end;

  TFhirDeviceOperationalStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceOperationalStatusList;
    function GetCurrent : TFhirDeviceOperationalStatus;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceOperationalStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceOperationalStatus read GetCurrent;
  end;

  TFhirDeviceOperationalStatusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceOperationalStatus;
    procedure SetItemN(index : Integer; value : TFhirDeviceOperationalStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceOperationalStatusList; overload;
    function Clone : TFhirDeviceOperationalStatusList; overload;
    function GetEnumerator : TFhirDeviceOperationalStatusListEnumerator;
    
    //  Add a FhirDeviceOperationalStatus to the end of the list.
    function Append : TFhirDeviceOperationalStatus;
    
    // Add an already existing FhirDeviceOperationalStatus to the end of the list.
    procedure AddItem(value : TFhirDeviceOperationalStatus); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceOperationalStatus) : Integer;
    
    // Insert FhirDeviceOperationalStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceOperationalStatus;
    
    // Insert an existing FhirDeviceOperationalStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceOperationalStatus);
    
    // Get the iIndexth FhirDeviceOperationalStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceOperationalStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceOperationalStatus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceOperationalStatuses[index : Integer] : TFhirDeviceOperationalStatus read GetItemN write SetItemN; default;
  End;

  // The state of the usage or application of the device - whether the device is implanted, or explanted, or attached to the patient.
  TFhirDeviceAssociationStatus = class (TFhirBackboneElement)
  protected
    FValue : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    procedure SetValue(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceAssociationStatus; overload;
    function Clone : TFhirDeviceAssociationStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to implanted|explanted|attached. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // implanted|explanted|attached.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

    // The reasons given for the current association status - i.e. why is the device explanted, or attached to the patient, etc.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

  end;

  TFhirDeviceAssociationStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceAssociationStatusList;
    function GetCurrent : TFhirDeviceAssociationStatus;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceAssociationStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceAssociationStatus read GetCurrent;
  end;

  TFhirDeviceAssociationStatusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceAssociationStatus;
    procedure SetItemN(index : Integer; value : TFhirDeviceAssociationStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceAssociationStatusList; overload;
    function Clone : TFhirDeviceAssociationStatusList; overload;
    function GetEnumerator : TFhirDeviceAssociationStatusListEnumerator;
    
    //  Add a FhirDeviceAssociationStatus to the end of the list.
    function Append : TFhirDeviceAssociationStatus;
    
    // Add an already existing FhirDeviceAssociationStatus to the end of the list.
    procedure AddItem(value : TFhirDeviceAssociationStatus); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceAssociationStatus) : Integer;
    
    // Insert FhirDeviceAssociationStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceAssociationStatus;
    
    // Insert an existing FhirDeviceAssociationStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceAssociationStatus);
    
    // Get the iIndexth FhirDeviceAssociationStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceAssociationStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceAssociationStatus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceAssociationStatuses[index : Integer] : TFhirDeviceAssociationStatus read GetItemN write SetItemN; default;
  End;

  // A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
  TFhirDevice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDisplayName : TFhirString;
    FDefinition : TFhirReference;
    FudiCarrierList : TFhirDeviceUdiCarrierList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FDistinctIdentifier : TFhirString;
    FManufacturer : TFhirString;
    FManufactureDate : TFhirDateTime;
    FExpirationDate : TFhirDateTime;
    FLotNumber : TFhirString;
    FSerialNumber : TFhirString;
    FdeviceNameList : TFhirDeviceDeviceNameList;
    FModelNumber : TFhirString;
    FPartNumber : TFhirString;
    Ftype_List : TFhirCodeableConceptList;
    FspecializationList : TFhirDeviceSpecializationList;
    FversionList : TFhirDeviceVersionList;
    Fproperty_List : TFhirDevicePropertyList;
    FPatient : TFhirReference;
    FOperationalStatus : TFhirDeviceOperationalStatus;
    FAssociationStatus : TFhirDeviceAssociationStatus;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    FLocation : TFhirReference;
    FUrl : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FsafetyList : TFhirCodeableConceptList;
    FParent : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetDisplayName(value : TFhirString);
    function GetDisplayNameST : String;
    procedure SetDisplayNameST(value : String);
    procedure SetDefinition(value : TFhirReference);
    function GetUdiCarrierList : TFhirDeviceUdiCarrierList;
    function GetHasUdiCarrierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRDeviceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRDeviceStatusEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetDistinctIdentifier(value : TFhirString);
    function GetDistinctIdentifierST : String;
    procedure SetDistinctIdentifierST(value : String);
    procedure SetManufacturer(value : TFhirString);
    function GetManufacturerST : String;
    procedure SetManufacturerST(value : String);
    procedure SetManufactureDate(value : TFhirDateTime);
    function GetManufactureDateST : TFslDateTime;
    procedure SetManufactureDateST(value : TFslDateTime);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetSerialNumber(value : TFhirString);
    function GetSerialNumberST : String;
    procedure SetSerialNumberST(value : String);
    function GetDeviceNameList : TFhirDeviceDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    procedure SetPartNumber(value : TFhirString);
    function GetPartNumberST : String;
    procedure SetPartNumberST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetSpecializationList : TFhirDeviceSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetVersionList : TFhirDeviceVersionList;
    function GetHasVersionList : Boolean;
    function GetProperty_List : TFhirDevicePropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetOperationalStatus(value : TFhirDeviceOperationalStatus);
    procedure SetAssociationStatus(value : TFhirDeviceAssociationStatus);
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetLocation(value : TFhirReference);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    procedure SetParent(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDevice; overload;
    function Clone : TFhirDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by manufacturers other organizations or owners.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The name used to display by default when the device is referenced. Based on intent of use by the resource creator, this may reflect one of the names in Device.deviceName, or may be another simple name.
    property displayName : String read GetDisplayNameST write SetDisplayNameST;
    // The name used to display by default when the device is referenced. Based on intent of use by the resource creator, this may reflect one of the names in Device.deviceName, or may be another simple name.
    property displayNameElement : TFhirString read FDisplayName write SetDisplayName;

    // Typed access to The reference to the definition for the device. (defined for API consistency)
    property definition : TFhirReference read FDefinition write SetDefinition;
    // The reference to the definition for the device.
    property definitionElement : TFhirReference read FDefinition write SetDefinition;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiCarrierList : TFhirDeviceUdiCarrierList read GetUdiCarrierList;
    property hasUdiCarrierList : boolean read GetHasUdiCarrierList;

    // Status of the Device record. This is not the status of the device like availability.
    property status : TFhirFHIRDeviceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Reason for the status of the Device record. For example, why is the record not active.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifier : String read GetDistinctIdentifierST write SetDistinctIdentifierST;
    // The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifierElement : TFhirString read FDistinctIdentifier write SetDistinctIdentifier;

    // Typed access to A name of the manufacturer or entity legally responsible for the device.
    property manufacturer : String read GetManufacturerST write SetManufacturerST;
    // A name of the manufacturer or entity legally responsible for the device.
    property manufacturerElement : TFhirString read FManufacturer write SetManufacturer;

    // Typed access to The date and time when the device was manufactured.
    property manufactureDate : TFslDateTime read GetManufactureDateST write SetManufactureDateST;
    // The date and time when the device was manufactured.
    property manufactureDateElement : TFhirDateTime read FManufactureDate write SetManufactureDate;

    // Typed access to The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

    // Typed access to Lot number assigned by the manufacturer.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number assigned by the manufacturer.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The serial number assigned by the organization when the device was manufactured.
    property serialNumber : String read GetSerialNumberST write SetSerialNumberST;
    // The serial number assigned by the organization when the device was manufactured.
    property serialNumberElement : TFhirString read FSerialNumber write SetSerialNumber;

    // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
    property deviceNameList : TFhirDeviceDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The manufacturer's model number for the device.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The manufacturer's model number for the device.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to The part number or catalog number of the device.
    property partNumber : String read GetPartNumberST write SetPartNumberST;
    // The part number or catalog number of the device.
    property partNumberElement : TFhirString read FPartNumber write SetPartNumber;

    // The kind or type of device. A device instance may have more than one type - in which case those are the types that apply to the specific instance of the device.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The device function, including in some cases whether or not the functionality conforms to some standard. For example, a PHD blood pressure specialization indicates that the device conforms to the IEEE 11073-10407 Blood Pressure Specialization. This is NOT an alternate name or an additional descriptive name given by the manufacturer. That would be found in the deviceName element. In the PHD case, there are 11073 10101 nomenclature codes that define the specialization standards and that will be used, for example, in the PHD case for the specialization.systemType element. The specialization.version would be the version of the standard if the systemType referred to a standard.
    property specializationList : TFhirDeviceSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // The actual design of the device or software version running on the device.
    property versionList : TFhirDeviceVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
    property property_List : TFhirDevicePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to Patient information, if the device is affixed to, or associated to a patient for their specific use, irrespective of the procedure, use, observation, or other activity that the device is involved in. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // Patient information, if the device is affixed to, or associated to a patient for their specific use, irrespective of the procedure, use, observation, or other activity that the device is involved in.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The status of the device itself - whether it is switched on, or activated, etc. (defined for API consistency)
    property operationalStatus : TFhirDeviceOperationalStatus read FOperationalStatus write SetOperationalStatus;
    // The status of the device itself - whether it is switched on, or activated, etc.
    property operationalStatusElement : TFhirDeviceOperationalStatus read FOperationalStatus write SetOperationalStatus;

    // Typed access to The state of the usage or application of the device - whether the device is implanted, or explanted, or attached to the patient. (defined for API consistency)
    property associationStatus : TFhirDeviceAssociationStatus read FAssociationStatus write SetAssociationStatus;
    // The state of the usage or application of the device - whether the device is implanted, or explanted, or attached to the patient.
    property associationStatusElement : TFhirDeviceAssociationStatus read FAssociationStatus write SetAssociationStatus;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The place where the device can be found. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The place where the device can be found.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to A network address on which the device may be contacted directly.
    property url : String read GetUrlST write SetUrlST;
    // A network address on which the device may be contacted directly.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Provides additional safety characteristics about a medical device.  For example devices containing latex.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Typed access to The device that this device is attached to or is part of. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // The device that this device is attached to or is part of.
    property parentElement : TFhirReference read FParent write SetParent;

  end;

  TFhirDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceList;
    function GetCurrent : TFhirDevice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDevice read GetCurrent;
  end;

  TFhirDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDevice;
    procedure SetItemN(index : Integer; value : TFhirDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceList; overload;
    function Clone : TFhirDeviceList; overload;
    function GetEnumerator : TFhirDeviceListEnumerator;
    
    //  Add a FhirDevice to the end of the list.
    function Append : TFhirDevice;
    
    // Add an already existing FhirDevice to the end of the list.
    procedure AddItem(value : TFhirDevice); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDevice) : Integer;
    
    // Insert FhirDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDevice;
    
    // Insert an existing FhirDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDevice);
    
    // Get the iIndexth FhirDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDevice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDevices[index : Integer] : TFhirDevice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceDefinitionUdiDeviceIdentifier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to The organization that assigns the identifier algorithm.
    property issuer : String read GetIssuerST write SetIssuerST;
    // The organization that assigns the identifier algorithm.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The jurisdiction to which the deviceIdentifier applies.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The jurisdiction to which the deviceIdentifier applies.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionUdiDeviceIdentifier read GetCurrent;
  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
    
    //  Add a FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    function Append : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Add an already existing FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionUdiDeviceIdentifier); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionUdiDeviceIdentifier) : Integer;
    
    // Insert FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Insert an existing FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // Get the iIndexth FhirDeviceDefinitionUdiDeviceIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionUdiDeviceIdentifiers[index : Integer] : TFhirDeviceDefinitionUdiDeviceIdentifier read GetItemN write SetItemN; default;
  End;

  // The name or names of the device as given by the manufacturer.
  TFhirDeviceDefinitionDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionDeviceName; overload;
    function Clone : TFhirDeviceDefinitionDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-friendly name that is used to refer to the device - depending on the type, it can be the brand name, the common name or alias, or other.
    property name : String read GetNameST write SetNameST;
    // A human-friendly name that is used to refer to the device - depending on the type, it can be the brand name, the common name or alias, or other.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDefinitionDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionDeviceNameList;
    function GetCurrent : TFhirDeviceDefinitionDeviceName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionDeviceName read GetCurrent;
  end;

  TFhirDeviceDefinitionDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionDeviceNameList; overload;
    function Clone : TFhirDeviceDefinitionDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDefinitionDeviceName to the end of the list.
    function Append : TFhirDeviceDefinitionDeviceName;
    
    // Add an already existing FhirDeviceDefinitionDeviceName to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionDeviceName); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionDeviceName) : Integer;
    
    // Insert FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // Insert an existing FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // Get the iIndexth FhirDeviceDefinitionDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionDeviceNames[index : Integer] : TFhirDeviceDefinitionDeviceName read GetItemN write SetItemN; default;
  End;

  // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
  TFhirDeviceDefinitionSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirString;
    FVersion : TFhirString;
    procedure SetSystemType(value : TFhirString);
    function GetSystemTypeST : String;
    procedure SetSystemTypeST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionSpecialization; overload;
    function Clone : TFhirDeviceDefinitionSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The standard that is used to operate and communicate.
    property systemType : String read GetSystemTypeST write SetSystemTypeST;
    // The standard that is used to operate and communicate.
    property systemTypeElement : TFhirString read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirDeviceDefinitionSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionSpecializationList;
    function GetCurrent : TFhirDeviceDefinitionSpecialization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionSpecialization read GetCurrent;
  end;

  TFhirDeviceDefinitionSpecializationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionSpecializationList; overload;
    function Clone : TFhirDeviceDefinitionSpecializationList; overload;
    function GetEnumerator : TFhirDeviceDefinitionSpecializationListEnumerator;
    
    //  Add a FhirDeviceDefinitionSpecialization to the end of the list.
    function Append : TFhirDeviceDefinitionSpecialization;
    
    // Add an already existing FhirDeviceDefinitionSpecialization to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionSpecialization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionSpecialization) : Integer;
    
    // Insert FhirDeviceDefinitionSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionSpecialization;
    
    // Insert an existing FhirDeviceDefinitionSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionSpecialization);
    
    // Get the iIndexth FhirDeviceDefinitionSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionSpecialization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionSpecializations[index : Integer] : TFhirDeviceDefinitionSpecialization read GetItemN write SetItemN; default;
  End;

  // Additional capabilities that the device is defined or required to have e.g. "water resistant", "long life".
  TFhirDeviceDefinitionCapability = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdescriptionList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetDescriptionList : TFhirCodeableConceptList;
    function GetHasDescriptionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionCapability; overload;
    function Clone : TFhirDeviceDefinitionCapability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of capability - whether it is a physical attribute, a customization needed. For exampl e "water ingress protection". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of capability - whether it is a physical attribute, a customization needed. For exampl e "water ingress protection".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The actual capability of the device e.g. IP67.
    property descriptionList : TFhirCodeableConceptList read GetDescriptionList;
    property hasDescriptionList : boolean read GetHasDescriptionList;

  end;

  TFhirDeviceDefinitionCapabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionCapabilityList;
    function GetCurrent : TFhirDeviceDefinitionCapability;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionCapabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionCapability read GetCurrent;
  end;

  TFhirDeviceDefinitionCapabilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionCapability;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionCapability);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionCapabilityList; overload;
    function Clone : TFhirDeviceDefinitionCapabilityList; overload;
    function GetEnumerator : TFhirDeviceDefinitionCapabilityListEnumerator;
    
    //  Add a FhirDeviceDefinitionCapability to the end of the list.
    function Append : TFhirDeviceDefinitionCapability;
    
    // Add an already existing FhirDeviceDefinitionCapability to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionCapability); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionCapability) : Integer;
    
    // Insert FhirDeviceDefinitionCapability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionCapability;
    
    // Insert an existing FhirDeviceDefinitionCapability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionCapability);
    
    // Get the iIndexth FhirDeviceDefinitionCapability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionCapability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionCapability;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionCapabilities[index : Integer] : TFhirDeviceDefinitionCapability read GetItemN write SetItemN; default;
  End;

  // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
  TFhirDeviceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FvalueQuantityList : TFhirQuantityList;
    FvalueCodeList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueCodeList : TFhirCodeableConceptList;
    function GetHasValueCodeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionProperty; overload;
    function Clone : TFhirDeviceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property DeviceDefinitionPropetyCode (Extensible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Property value as a quantity.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Property value as a code, e.g., NTP4 (synced to NTP).
    property valueCodeList : TFhirCodeableConceptList read GetValueCodeList;
    property hasValueCodeList : boolean read GetHasValueCodeList;

  end;

  TFhirDeviceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionPropertyList;
    function GetCurrent : TFhirDeviceDefinitionProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionProperty read GetCurrent;
  end;

  TFhirDeviceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionPropertyList; overload;
    function Clone : TFhirDeviceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
    
    //  Add a FhirDeviceDefinitionProperty to the end of the list.
    function Append : TFhirDeviceDefinitionProperty;
    
    // Add an already existing FhirDeviceDefinitionProperty to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionProperty); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionProperty) : Integer;
    
    // Insert FhirDeviceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // Insert an existing FhirDeviceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // Get the iIndexth FhirDeviceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionProperties[index : Integer] : TFhirDeviceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // A substance used to create the material(s) of which the device is made.
  TFhirDeviceDefinitionMaterial = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FAlternate : TFhirBoolean;
    FAllergenicIndicator : TFhirBoolean;
    procedure SetSubstance(value : TFhirCodeableConcept);
    procedure SetAlternate(value : TFhirBoolean);
    function GetAlternateST : Boolean;
    procedure SetAlternateST(value : Boolean);
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionMaterial; overload;
    function Clone : TFhirDeviceDefinitionMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A substance that the device contains, may contain, or is made of - for example latex - to be used to determine patient compatibility. This is not intended to represent the composition of the device, only the clinically relevant materials. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // A substance that the device contains, may contain, or is made of - for example latex - to be used to determine patient compatibility. This is not intended to represent the composition of the device, only the clinically relevant materials.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Typed access to Indicates an alternative material of the device.
    property alternate : Boolean read GetAlternateST write SetAlternateST;
    // Indicates an alternative material of the device.
    property alternateElement : TFhirBoolean read FAlternate write SetAlternate;

    // Typed access to Whether the substance is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // Whether the substance is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

  end;

  TFhirDeviceDefinitionMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionMaterialList;
    function GetCurrent : TFhirDeviceDefinitionMaterial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionMaterial read GetCurrent;
  end;

  TFhirDeviceDefinitionMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionMaterial;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionMaterialList; overload;
    function Clone : TFhirDeviceDefinitionMaterialList; overload;
    function GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
    
    //  Add a FhirDeviceDefinitionMaterial to the end of the list.
    function Append : TFhirDeviceDefinitionMaterial;
    
    // Add an already existing FhirDeviceDefinitionMaterial to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinitionMaterial); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionMaterial) : Integer;
    
    // Insert FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // Insert an existing FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // Get the iIndexth FhirDeviceDefinitionMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionMaterials[index : Integer] : TFhirDeviceDefinitionMaterial read GetItemN write SetItemN; default;
  End;

  // The characteristics, operational status and capabilities of a medical-related component of a medical device.
  TFhirDeviceDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FudiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    FManufacturer : TFhirDataType;
    FdeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    FModelNumber : TFhirString;
    FType_ : TFhirCodeableConcept;
    FspecializationList : TFhirDeviceDefinitionSpecializationList;
    FversionList : TFhirStringList;
    FsafetyList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FPhysicalCharacteristics : TFhirProdCharacteristic;
    FlanguageCodeList : TFhirCodeableConceptList;
    FcapabilityList : TFhirDeviceDefinitionCapabilityList;
    Fproperty_List : TFhirDeviceDefinitionPropertyList;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    FOnlineInformation : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FQuantity : TFhirQuantity;
    FParentDevice : TFhirReference;
    FmaterialList : TFhirDeviceDefinitionMaterialList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetHasUdiDeviceIdentifierList : Boolean;
    procedure SetManufacturer(value : TFhirDataType);
    function GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSpecializationList : TFhirDeviceDefinitionSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetVersionList : TFhirStringList;
    function GetHasVersionList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    procedure SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
    function GetLanguageCodeList : TFhirCodeableConceptList;
    function GetHasLanguageCodeList : Boolean;
    function GetCapabilityList : TFhirDeviceDefinitionCapabilityList;
    function GetHasCapabilityList : Boolean;
    function GetProperty_List : TFhirDeviceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetOnlineInformation(value : TFhirUri);
    function GetOnlineInformationST : String;
    procedure SetOnlineInformationST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetParentDevice(value : TFhirReference);
    function GetMaterialList : TFhirDeviceDefinitionMaterialList;
    function GetHasMaterialList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinition; overload;
    function Clone : TFhirDeviceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by the software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList read GetUdiDeviceIdentifierList;
    property hasUdiDeviceIdentifierList : boolean read GetHasUdiDeviceIdentifierList;

    // Typed access to A name of the manufacturer  or legal representative e.g. labeler. Whether this is the actual manufacturer or the labeler or responsible depends on implementation and jurisdiction. (defined for API consistency)
    property manufacturer : TFhirDataType read FManufacturer write SetManufacturer;
    // A name of the manufacturer  or legal representative e.g. labeler. Whether this is the actual manufacturer or the labeler or responsible depends on implementation and jurisdiction.
    property manufacturerElement : TFhirDataType read FManufacturer write SetManufacturer;

    // The name or names of the device as given by the manufacturer.
    property deviceNameList : TFhirDeviceDefinitionDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The model number for the device for example as defined by the manufacturer or labeler, or other agency.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The model number for the device for example as defined by the manufacturer or labeler, or other agency.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to What kind of device or device system this is. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // What kind of device or device system this is.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
    property specializationList : TFhirDeviceDefinitionSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // The available versions of the device, e.g., software versions.
    property versionList : TFhirStringList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // Safety characteristics of the device.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Typed access to Physical characteristics to define or specify the product - for example dimensions, color etc. These can be defined by the manufacturer or labeler, or can be used to specify characteristics when ordering. (defined for API consistency)
    property physicalCharacteristics : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;
    // Physical characteristics to define or specify the product - for example dimensions, color etc. These can be defined by the manufacturer or labeler, or can be used to specify characteristics when ordering.
    property physicalCharacteristicsElement : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;

    // Language code for the human-readable text strings produced by the device (all supported).
    property languageCodeList : TFhirCodeableConceptList read GetLanguageCodeList;
    property hasLanguageCodeList : boolean read GetHasLanguageCodeList;

    // Additional capabilities that the device is defined or required to have e.g. "water resistant", "long life".
    property capabilityList : TFhirDeviceDefinitionCapabilityList read GetCapabilityList;
    property hasCapabilityList : boolean read GetHasCapabilityList;

    // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
    property property_List : TFhirDeviceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to Access to on-line information about the device.
    property onlineInformation : String read GetOnlineInformationST write SetOnlineInformationST;
    // Access to on-line information about the device.
    property onlineInformationElement : TFhirUri read FOnlineInformation write SetOnlineInformation;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The parent device it can be part of. (defined for API consistency)
    property parentDevice : TFhirReference read FParentDevice write SetParentDevice;
    // The parent device it can be part of.
    property parentDeviceElement : TFhirReference read FParentDevice write SetParentDevice;

    // A substance used to create the material(s) of which the device is made.
    property materialList : TFhirDeviceDefinitionMaterialList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

  end;

  TFhirDeviceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionList;
    function GetCurrent : TFhirDeviceDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinition read GetCurrent;
  end;

  TFhirDeviceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinition;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionList; overload;
    function Clone : TFhirDeviceDefinitionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionListEnumerator;
    
    //  Add a FhirDeviceDefinition to the end of the list.
    function Append : TFhirDeviceDefinition;
    
    // Add an already existing FhirDeviceDefinition to the end of the list.
    procedure AddItem(value : TFhirDeviceDefinition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinition) : Integer;
    
    // Insert FhirDeviceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinition;
    
    // Insert an existing FhirDeviceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinition);
    
    // Get the iIndexth FhirDeviceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitions[index : Integer] : TFhirDeviceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  // Describes the calibrations that have been performed or that are required to be performed.
  TFhirDeviceMetricCalibration = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FState : TFhirEnum;
    FTime : TFhirInstant;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
    procedure SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
    procedure SetState(value : TFhirEnum);
    function GetStateST : TFhirDeviceMetricCalibrationStateEnum;
    procedure SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
    procedure SetTime(value : TFhirInstant);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetricCalibration; overload;
    function Clone : TFhirDeviceMetricCalibration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Describes the type of the calibration method.
    property type_ : TFhirDeviceMetricCalibrationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Describes the state of the calibration.
    property state : TFhirDeviceMetricCalibrationStateEnum read GetStateST write SetStateST;
    property stateElement : TFhirEnum read FState write SetState;

    // Typed access to Describes the time last calibration has been performed.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // Describes the time last calibration has been performed.
    property timeElement : TFhirInstant read FTime write SetTime;

  end;

  TFhirDeviceMetricCalibrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricCalibrationList;
    function GetCurrent : TFhirDeviceMetricCalibration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricCalibrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetricCalibration read GetCurrent;
  end;

  TFhirDeviceMetricCalibrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetricCalibration;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetricCalibration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricCalibrationList; overload;
    function Clone : TFhirDeviceMetricCalibrationList; overload;
    function GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
    
    //  Add a FhirDeviceMetricCalibration to the end of the list.
    function Append : TFhirDeviceMetricCalibration;
    
    // Add an already existing FhirDeviceMetricCalibration to the end of the list.
    procedure AddItem(value : TFhirDeviceMetricCalibration); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetricCalibration) : Integer;
    
    // Insert FhirDeviceMetricCalibration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetricCalibration;
    
    // Insert an existing FhirDeviceMetricCalibration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // Get the iIndexth FhirDeviceMetricCalibration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetricCalibration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetricCalibrations[index : Integer] : TFhirDeviceMetricCalibration read GetItemN write SetItemN; default;
  End;

  // Describes a measurement, calculation or setting capability of a medical device.
  TFhirDeviceMetric = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    FParent : TFhirReference;
    FOperationalStatus : TFhirEnum;
    FColor : TFhirEnum;
    FCategory : TFhirEnum;
    FMeasurementPeriod : TFhirTiming;
    FcalibrationList : TFhirDeviceMetricCalibrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
    procedure SetParent(value : TFhirReference);
    procedure SetOperationalStatus(value : TFhirEnum);
    function GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
    procedure SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
    procedure SetColor(value : TFhirEnum);
    function GetColorST : TFhirDeviceMetricColorEnum;
    procedure SetColorST(value : TFhirDeviceMetricColorEnum);
    procedure SetCategory(value : TFhirEnum);
    function GetCategoryST : TFhirDeviceMetricCategoryEnum;
    procedure SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
    procedure SetMeasurementPeriod(value : TFhirTiming);
    function GetCalibrationList : TFhirDeviceMetricCalibrationList;
    function GetHasCalibrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetric; overload;
    function Clone : TFhirDeviceMetric; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by the device or gateway software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location.
    property parentElement : TFhirReference read FParent write SetParent;

    // Indicates current operational state of the device. For example: On, Off, Standby, etc.
    property operationalStatus : TFhirDeviceMetricOperationalStatusEnum read GetOperationalStatusST write SetOperationalStatusST;
    property operationalStatusElement : TFhirEnum read FOperationalStatus write SetOperationalStatus;

    // Describes the color representation for the metric. This is often used to aid clinicians to track and identify parameter types by color. In practice, consider a Patient Monitor that has ECG/HR and Pleth for example; the parameters are displayed in different characteristic colors, such as HR-blue, BP-green, and PR and SpO2- magenta.
    property color : TFhirDeviceMetricColorEnum read GetColorST write SetColorST;
    property colorElement : TFhirEnum read FColor write SetColor;

    // Indicates the category of the observation generation process. A DeviceMetric can be for example a setting, measurement, or calculation.
    property category : TFhirDeviceMetricCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the {$IFNDEF FPC}published{$ENDIF} observed value with the same frequency as it was measured. (defined for API consistency)
    property measurementPeriod : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;
    // Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the {$IFNDEF FPC}published{$ENDIF} observed value with the same frequency as it was measured.
    property measurementPeriodElement : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;

    // Describes the calibrations that have been performed or that are required to be performed.
    property calibrationList : TFhirDeviceMetricCalibrationList read GetCalibrationList;
    property hasCalibrationList : boolean read GetHasCalibrationList;

  end;

  TFhirDeviceMetricListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricList;
    function GetCurrent : TFhirDeviceMetric;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetric read GetCurrent;
  end;

  TFhirDeviceMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetric);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricList; overload;
    function Clone : TFhirDeviceMetricList; overload;
    function GetEnumerator : TFhirDeviceMetricListEnumerator;
    
    //  Add a FhirDeviceMetric to the end of the list.
    function Append : TFhirDeviceMetric;
    
    // Add an already existing FhirDeviceMetric to the end of the list.
    procedure AddItem(value : TFhirDeviceMetric); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetric) : Integer;
    
    // Insert FhirDeviceMetric before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetric;
    
    // Insert an existing FhirDeviceMetric before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetric);
    
    // Get the iIndexth FhirDeviceMetric. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetric);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetric;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetrics[index : Integer] : TFhirDeviceMetric read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
  TFhirEncounterStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterStatusHistory; overload;
    function Clone : TFhirEncounterStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // planned | in-progress | onhold | completed | cancelled | entered-in-error | unknown.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time that the episode was in the specified status. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified status.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterStatusHistoryList;
    function GetCurrent : TFhirEncounterStatusHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterStatusHistory read GetCurrent;
  end;

  TFhirEncounterStatusHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterStatusHistoryList; overload;
    function Clone : TFhirEncounterStatusHistoryList; overload;
    function GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
    
    //  Add a FhirEncounterStatusHistory to the end of the list.
    function Append : TFhirEncounterStatusHistory;
    
    // Add an already existing FhirEncounterStatusHistory to the end of the list.
    procedure AddItem(value : TFhirEncounterStatusHistory); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterStatusHistory) : Integer;
    
    // Insert FhirEncounterStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterStatusHistory;
    
    // Insert an existing FhirEncounterStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterStatusHistory);
    
    // Get the iIndexth FhirEncounterStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterStatusHistories[index : Integer] : TFhirEncounterStatusHistory read GetItemN write SetItemN; default;
  End;

  // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
  TFhirEncounterClassHistory = class (TFhirBackboneElement)
  protected
    FClass_ : TFhirCoding;
    FPeriod : TFhirPeriod;
    procedure SetClass_(value : TFhirCoding);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterClassHistory; overload;
    function Clone : TFhirEncounterClassHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to inpatient | outpatient | ambulatory | emergency +. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // inpatient | outpatient | ambulatory | emergency +.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // Typed access to The time that the episode was in the specified class. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified class.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterClassHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterClassHistoryList;
    function GetCurrent : TFhirEncounterClassHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterClassHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterClassHistory read GetCurrent;
  end;

  TFhirEncounterClassHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterClassHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterClassHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterClassHistoryList; overload;
    function Clone : TFhirEncounterClassHistoryList; overload;
    function GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
    
    //  Add a FhirEncounterClassHistory to the end of the list.
    function Append : TFhirEncounterClassHistory;
    
    // Add an already existing FhirEncounterClassHistory to the end of the list.
    procedure AddItem(value : TFhirEncounterClassHistory); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterClassHistory) : Integer;
    
    // Insert FhirEncounterClassHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterClassHistory;
    
    // Insert an existing FhirEncounterClassHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterClassHistory);
    
    // Get the iIndexth FhirEncounterClassHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterClassHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterClassHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterClassHistories[index : Integer] : TFhirEncounterClassHistory read GetItemN write SetItemN; default;
  End;

  // The list of people responsible for providing the service.
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FIndividual : TFhirReference;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIndividual(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in encounter.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Persons involved in the encounter other than the patient. (defined for API consistency)
    property individual : TFhirReference read FIndividual write SetIndividual;
    // Persons involved in the encounter other than the patient.
    property individualElement : TFhirReference read FIndividual write SetIndividual;

  end;

  TFhirEncounterParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterParticipantList;
    function GetCurrent : TFhirEncounterParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterParticipant read GetCurrent;
  end;

  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterParticipantList; overload;
    function Clone : TFhirEncounterParticipantList; overload;
    function GetEnumerator : TFhirEncounterParticipantListEnumerator;
    
    //  Add a FhirEncounterParticipant to the end of the list.
    function Append : TFhirEncounterParticipant;
    
    // Add an already existing FhirEncounterParticipant to the end of the list.
    procedure AddItem(value : TFhirEncounterParticipant); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    
    // Insert FhirEncounterParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterParticipant;
    
    // Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    // Get the iIndexth FhirEncounterParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this encounter.
  TFhirEncounterDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference;
    FUse : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    procedure SetCondition(value : TFhirReference);
    procedure SetUse(value : TFhirCodeableConcept);
    procedure SetRank(value : TFhirPositiveInt);
    function GetRankST : String;
    procedure SetRankST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterDiagnosis; overload;
    function Clone : TFhirEncounterDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the encounter (e.g. admission, billing, discharge …). (defined for API consistency)
    property use : TFhirCodeableConcept read FUse write SetUse;
    // Role that this diagnosis has within the encounter (e.g. admission, billing, discharge …).
    property useElement : TFhirCodeableConcept read FUse write SetUse;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEncounterDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterDiagnosisList;
    function GetCurrent : TFhirEncounterDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterDiagnosis read GetCurrent;
  end;

  TFhirEncounterDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEncounterDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterDiagnosisList; overload;
    function Clone : TFhirEncounterDiagnosisList; overload;
    function GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
    
    //  Add a FhirEncounterDiagnosis to the end of the list.
    function Append : TFhirEncounterDiagnosis;
    
    // Add an already existing FhirEncounterDiagnosis to the end of the list.
    procedure AddItem(value : TFhirEncounterDiagnosis); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterDiagnosis) : Integer;
    
    // Insert FhirEncounterDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterDiagnosis;
    
    // Insert an existing FhirEncounterDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterDiagnosis);
    
    // Get the iIndexth FhirEncounterDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterDiagnoses[index : Integer] : TFhirEncounterDiagnosis read GetItemN write SetItemN; default;
  End;

  // Details about the admission to a healthcare service.
  TFhirEncounterHospitalization = class (TFhirBackboneElement)
  protected
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirReference;
    FAdmitSource : TFhirCodeableConcept;
    FReAdmission : TFhirCodeableConcept;
    FdietPreferenceList : TFhirCodeableConceptList;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirReference;
    FDischargeDisposition : TFhirCodeableConcept;
    procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    procedure SetOrigin(value : TFhirReference);
    procedure SetAdmitSource(value : TFhirCodeableConcept);
    procedure SetReAdmission(value : TFhirCodeableConcept);
    function GetDietPreferenceList : TFhirCodeableConceptList;
    function GetHasDietPreferenceList : Boolean;
    function GetSpecialCourtesyList : TFhirCodeableConceptList;
    function GetHasSpecialCourtesyList : Boolean;
    function GetSpecialArrangementList : TFhirCodeableConceptList;
    function GetHasSpecialArrangementList : Boolean;
    procedure SetDestination(value : TFhirReference);
    procedure SetDischargeDisposition(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Pre-admission identifier. (defined for API consistency)
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;
    // Pre-admission identifier.
    property preAdmissionIdentifierElement : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    // Typed access to The location/organization from which the patient came before admission. (defined for API consistency)
    property origin : TFhirReference read FOrigin write SetOrigin;
    // The location/organization from which the patient came before admission.
    property originElement : TFhirReference read FOrigin write SetOrigin;

    // Typed access to From where patient was admitted (physician referral, transfer). (defined for API consistency)
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;
    // From where patient was admitted (physician referral, transfer).
    property admitSourceElement : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    // Typed access to Whether this hospitalization is a readmission and why if known. (defined for API consistency)
    property reAdmission : TFhirCodeableConcept read FReAdmission write SetReAdmission;
    // Whether this hospitalization is a readmission and why if known.
    property reAdmissionElement : TFhirCodeableConcept read FReAdmission write SetReAdmission;

    // Diet preferences reported by the patient.
    property dietPreferenceList : TFhirCodeableConceptList read GetDietPreferenceList;
    property hasDietPreferenceList : boolean read GetHasDietPreferenceList;

    // Special courtesies (VIP, board member).
    property specialCourtesyList : TFhirCodeableConceptList read GetSpecialCourtesyList;
    property hasSpecialCourtesyList : boolean read GetHasSpecialCourtesyList;

    // Any special requests that have been made for this hospitalization encounter, such as the provision of specific equipment or other things.
    property specialArrangementList : TFhirCodeableConceptList read GetSpecialArrangementList;
    property hasSpecialArrangementList : boolean read GetHasSpecialArrangementList;

    // Typed access to Location/organization to which the patient is discharged. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Location/organization to which the patient is discharged.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Typed access to Category or kind of location after discharge. (defined for API consistency)
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;
    // Category or kind of location after discharge.
    property dischargeDispositionElement : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

  end;

  TFhirEncounterHospitalizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterHospitalizationList;
    function GetCurrent : TFhirEncounterHospitalization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterHospitalizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterHospitalization read GetCurrent;
  end;

  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterHospitalizationList; overload;
    function Clone : TFhirEncounterHospitalizationList; overload;
    function GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
    
    //  Add a FhirEncounterHospitalization to the end of the list.
    function Append : TFhirEncounterHospitalization;
    
    // Add an already existing FhirEncounterHospitalization to the end of the list.
    procedure AddItem(value : TFhirEncounterHospitalization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    
    // Insert FhirEncounterHospitalization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    
    // Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    // Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;

  // List of locations where  the patient has been during this encounter.
  TFhirEncounterLocation = class (TFhirBackboneElement)
  protected
    FLocation : TFhirReference;
    FStatus : TFhirEnum;
    FPhysicalType : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    procedure SetLocation(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterLocationStatusEnum;
    procedure SetStatusST(value : TFhirEncounterLocationStatusEnum);
    procedure SetPhysicalType(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The location where the encounter takes place. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The location where the encounter takes place.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The status of the participants' presence at the specified location during the period specified. If the participant is no longer at the location, then the period will have an end date/time.
    property status : TFhirEncounterLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to Time period during which the patient was present at the location. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the patient was present at the location.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterLocationList;
    function GetCurrent : TFhirEncounterLocation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterLocation read GetCurrent;
  end;

  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterLocationList; overload;
    function Clone : TFhirEncounterLocationList; overload;
    function GetEnumerator : TFhirEncounterLocationListEnumerator;
    
    //  Add a FhirEncounterLocation to the end of the list.
    function Append : TFhirEncounterLocation;
    
    // Add an already existing FhirEncounterLocation to the end of the list.
    procedure AddItem(value : TFhirEncounterLocation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    
    // Insert FhirEncounterLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterLocation;
    
    // Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    // Get the iIndexth FhirEncounterLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;

  // An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
  TFhirEncounter = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEncounterStatusHistoryList;
    FClass_ : TFhirCoding;
    FclassHistoryList : TFhirEncounterClassHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FServiceType : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FSubjectStatus : TFhirCodeableConcept;
    FepisodeOfCareList : TFhirReferenceList;
    FbasedOnList : TFhirReferenceList;
    FparticipantList : TFhirEncounterParticipantList;
    FappointmentList : TFhirReferenceList;
    FPeriod : TFhirPeriod;
    FLength : TFhirDuration;
    FreasonList : TFhirCodeableReferenceList;
    FdiagnosisList : TFhirEncounterDiagnosisList;
    FaccountList : TFhirReferenceList;
    FHospitalization : TFhirEncounterHospitalization;
    FlocationList : TFhirEncounterLocationList;
    FServiceProvider : TFhirReference;
    FPartOf : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    function GetStatusHistoryList : TFhirEncounterStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    procedure SetClass_(value : TFhirCoding);
    function GetClassHistoryList : TFhirEncounterClassHistoryList;
    function GetHasClassHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetServiceType(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetSubjectStatus(value : TFhirCodeableConcept);
    function GetEpisodeOfCareList : TFhirReferenceList;
    function GetHasEpisodeOfCareList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetParticipantList : TFhirEncounterParticipantList;
    function GetHasParticipantList : Boolean;
    function GetAppointmentList : TFhirReferenceList;
    function GetHasAppointmentList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetLength(value : TFhirDuration);
    function GetReasonList : TFhirCodeableReferenceList;
    function GetHasReasonList : Boolean;
    function GetDiagnosisList : TFhirEncounterDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
    procedure SetHospitalization(value : TFhirEncounterHospitalization);
    function GetLocationList : TFhirEncounterLocationList;
    function GetHasLocationList : Boolean;
    procedure SetServiceProvider(value : TFhirReference);
    procedure SetPartOf(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounter; overload;
    function Clone : TFhirEncounter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier(s) by which this encounter is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | in-progress | onhold | completed | cancelled | entered-in-error | unknown.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
    property statusHistoryList : TFhirEncounterStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // Typed access to Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
    property classHistoryList : TFhirEncounterClassHistoryList read GetClassHistoryList;
    property hasClassHistoryList : boolean read GetHasClassHistoryList;

    // Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Broad categorization of the service that is to be provided (e.g. cardiology). (defined for API consistency)
    property serviceType : TFhirCodeableConcept read FServiceType write SetServiceType;
    // Broad categorization of the service that is to be provided (e.g. cardiology).
    property serviceTypeElement : TFhirCodeableConcept read FServiceType write SetServiceType;

    // Typed access to Indicates the urgency of the encounter. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Indicates the urgency of the encounter.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The patient or group present at the encounter. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group present at the encounter.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The subjectStatus value can be used to track the patient's status within the encounter. It details whether the patient has arrived or departed, has been triaged or is currently in a waiting status. (defined for API consistency)
    property subjectStatus : TFhirCodeableConcept read FSubjectStatus write SetSubjectStatus;
    // The subjectStatus value can be used to track the patient's status within the encounter. It details whether the patient has arrived or departed, has been triaged or is currently in a waiting status.
    property subjectStatusElement : TFhirCodeableConcept read FSubjectStatus write SetSubjectStatus;

    // Where a specific encounter should be classified as a part of a specific episode(s) of care this field should be used. This association can facilitate grouping of related encounters together for a specific purpose, such as government reporting, issue tracking, association via a common problem.  The association is recorded on the encounter as these are typically created after the episode of care and grouped on entry rather than editing the episode of care to append another encounter to it (the episode of care could span years).
    property episodeOfCareList : TFhirReferenceList read GetEpisodeOfCareList;
    property hasEpisodeOfCareList : boolean read GetHasEpisodeOfCareList;

    // The request this encounter satisfies (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The list of people responsible for providing the service.
    property participantList : TFhirEncounterParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // The appointment that scheduled this encounter.
    property appointmentList : TFhirReferenceList read GetAppointmentList;
    property hasAppointmentList : boolean read GetHasAppointmentList;

    // Typed access to The start and end time of the encounter. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The start and end time of the encounter.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Quantity of time the encounter lasted. This excludes the time during leaves of absence. (defined for API consistency)
    property length : TFhirDuration read FLength write SetLength;
    // Quantity of time the encounter lasted. This excludes the time during leaves of absence.
    property lengthElement : TFhirDuration read FLength write SetLength;

    // Reason the encounter takes place, expressed as a code or a reference to another resource. For admissions, this can be used for a coded admission diagnosis.
    property reasonList : TFhirCodeableReferenceList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The list of diagnosis relevant to this encounter.
    property diagnosisList : TFhirEncounterDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The set of accounts that may be used for billing for this Encounter.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Typed access to Details about the admission to a healthcare service. (defined for API consistency)
    property hospitalization : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;
    // Details about the admission to a healthcare service.
    property hospitalizationElement : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;

    // List of locations where  the patient has been during this encounter.
    property locationList : TFhirEncounterLocationList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy. (defined for API consistency)
    property serviceProvider : TFhirReference read FServiceProvider write SetServiceProvider;
    // The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
    property serviceProviderElement : TFhirReference read FServiceProvider write SetServiceProvider;

    // Typed access to Another Encounter of which this encounter is a part of (administratively or in time). (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Encounter of which this encounter is a part of (administratively or in time).
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

  end;

  TFhirEncounterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterList;
    function GetCurrent : TFhirEncounter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEncounterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounter read GetCurrent;
  end;

  TFhirEncounterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounter;
    procedure SetItemN(index : Integer; value : TFhirEncounter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterList; overload;
    function Clone : TFhirEncounterList; overload;
    function GetEnumerator : TFhirEncounterListEnumerator;
    
    //  Add a FhirEncounter to the end of the list.
    function Append : TFhirEncounter;
    
    // Add an already existing FhirEncounter to the end of the list.
    procedure AddItem(value : TFhirEncounter); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounter) : Integer;
    
    // Insert FhirEncounter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounter;
    
    // Insert an existing FhirEncounter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounter);
    
    // Get the iIndexth FhirEncounter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounters[index : Integer] : TFhirEncounter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  // The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
  TFhirEndpoint = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FConnectionType : TFhirCoding;
    FName : TFhirString;
    FManagingOrganization : TFhirReference;
    FcontactList : TFhirContactPointList;
    FPeriod : TFhirPeriod;
    FpayloadTypeList : TFhirCodeableConceptList;
    FpayloadMimeTypeList : TFhirCodeList;
    FAddress : TFhirUrl;
    FheaderList : TFhirStringList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEndpointStatusEnum;
    procedure SetStatusST(value : TFhirEndpointStatusEnum);
    procedure SetConnectionType(value : TFhirCoding);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetManagingOrganization(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetPayloadTypeList : TFhirCodeableConceptList;
    function GetHasPayloadTypeList : Boolean;
    function GetPayloadMimeTypeList : TFhirCodeList;
    function GetHasPayloadMimeTypeList : Boolean;
    procedure SetAddress(value : TFhirUrl);
    function GetAddressST : String;
    procedure SetAddressST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEndpoint; overload;
    function Clone : TFhirEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the endpoint across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // active | suspended | error | off | test.
    property status : TFhirEndpointStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook). (defined for API consistency)
    property connectionType : TFhirCoding read FConnectionType write SetConnectionType;
    // A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook).
    property connectionTypeElement : TFhirCoding read FConnectionType write SetConnectionType;

    // Typed access to A friendly name that this endpoint can be referred to with.
    property name : String read GetNameST write SetNameST;
    // A friendly name that this endpoint can be referred to with.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data). (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data).
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The interval during which the endpoint is expected to be operational. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the endpoint is expected to be operational.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The payload type describes the acceptable content that can be communicated on the endpoint.
    property payloadTypeList : TFhirCodeableConceptList read GetPayloadTypeList;
    property hasPayloadTypeList : boolean read GetHasPayloadTypeList;

    // The mime type to send the payload in - e.g. application/fhir+xml, application/fhir+json. If the mime type is not specified, then the sender could send any content (including no content depending on the connectionType).
    property payloadMimeTypeList : TFhirCodeList read GetPayloadMimeTypeList;
    property hasPayloadMimeTypeList : boolean read GetHasPayloadMimeTypeList;

    // Typed access to The uri that describes the actual end-point to connect to.
    property address : String read GetAddressST write SetAddressST;
    // The uri that describes the actual end-point to connect to.
    property addressElement : TFhirUrl read FAddress write SetAddress;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEndpointList;
    function GetCurrent : TFhirEndpoint;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEndpoint read GetCurrent;
  end;

  TFhirEndpointList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEndpoint;
    procedure SetItemN(index : Integer; value : TFhirEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEndpointList; overload;
    function Clone : TFhirEndpointList; overload;
    function GetEnumerator : TFhirEndpointListEnumerator;
    
    //  Add a FhirEndpoint to the end of the list.
    function Append : TFhirEndpoint;
    
    // Add an already existing FhirEndpoint to the end of the list.
    procedure AddItem(value : TFhirEndpoint); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEndpoint) : Integer;
    
    // Insert FhirEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEndpoint;
    
    // Insert an existing FhirEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEndpoint);
    
    // Get the iIndexth FhirEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEndpoint;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEndpoints[index : Integer] : TFhirEndpoint read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  // Identifies traits whose presence r absence is shared by members of the group.
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies the kind of trait being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the kind of trait being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the trait that holds (or does not hold - see 'exclude') for members of the group. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // If true, indicates the characteristic is one that is NOT held by members of the group.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to The period over which the characteristic is tested; e.g. the patient had an operation during the month of June. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirGroupCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupCharacteristicList;
    function GetCurrent : TFhirGroupCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGroupCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupCharacteristic read GetCurrent;
  end;

  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupCharacteristicList; overload;
    function Clone : TFhirGroupCharacteristicList; overload;
    function GetEnumerator : TFhirGroupCharacteristicListEnumerator;
    
    //  Add a FhirGroupCharacteristic to the end of the list.
    function Append : TFhirGroupCharacteristic;
    
    // Add an already existing FhirGroupCharacteristic to the end of the list.
    procedure AddItem(value : TFhirGroupCharacteristic); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    
    // Insert FhirGroupCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    
    // Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    // Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;

  // Identifies the resource instances that are members of the group.
  TFhirGroupMember = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference;
    FPeriod : TFhirPeriod;
    FInactive : TFhirBoolean;
    procedure SetEntity(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetInactive(value : TFhirBoolean);
    function GetInactiveST : Boolean;
    procedure SetInactiveST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupMember; overload;
    function Clone : TFhirGroupMember; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same. (defined for API consistency)
    property entity : TFhirReference read FEntity write SetEntity;
    // A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same.
    property entityElement : TFhirReference read FEntity write SetEntity;

    // Typed access to The period that the member was in the group, if known. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period that the member was in the group, if known.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

  end;

  TFhirGroupMemberListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupMemberList;
    function GetCurrent : TFhirGroupMember;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGroupMemberList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupMember read GetCurrent;
  end;

  TFhirGroupMemberList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupMember;
    procedure SetItemN(index : Integer; value : TFhirGroupMember);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupMemberList; overload;
    function Clone : TFhirGroupMemberList; overload;
    function GetEnumerator : TFhirGroupMemberListEnumerator;
    
    //  Add a FhirGroupMember to the end of the list.
    function Append : TFhirGroupMember;
    
    // Add an already existing FhirGroupMember to the end of the list.
    procedure AddItem(value : TFhirGroupMember); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupMember) : Integer;
    
    // Insert FhirGroupMember before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupMember;
    
    // Insert an existing FhirGroupMember before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupMember);
    
    // Get the iIndexth FhirGroupMember. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupMember);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupMember;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupMembers[index : Integer] : TFhirGroupMember read GetItemN write SetItemN; default;
  End;

  // Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  TFhirGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FType_ : TFhirEnum;
    FActual : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    FName : TFhirString;
    FQuantity : TFhirUnsignedInt;
    FManagingEntity : TFhirReference;
    FcharacteristicList : TFhirGroupCharacteristicList;
    FmemberList : TFhirGroupMemberList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirGroupTypeEnum;
    procedure SetType_ST(value : TFhirGroupTypeEnum);
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetQuantity(value : TFhirUnsignedInt);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    procedure SetManagingEntity(value : TFhirReference);
    function GetCharacteristicList : TFhirGroupCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetMemberList : TFhirGroupMemberList;
    function GetHasMemberList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroup; overload;
    function Clone : TFhirGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique business identifier for this group.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Identifies the broad classification of the kind of resources the group includes.
    property type_ : TFhirGroupTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actual : Boolean read GetActualST write SetActualST;
    // If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A label assigned to the group for human identification and communication.
    property name : String read GetNameST write SetNameST;
    // A label assigned to the group for human identification and communication.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A count of the number of resource instances that are part of the group.
    property quantity : String read GetQuantityST write SetQuantityST;
    // A count of the number of resource instances that are part of the group.
    property quantityElement : TFhirUnsignedInt read FQuantity write SetQuantity;

    // Typed access to Entity responsible for defining and maintaining Group characteristics and/or registered members. (defined for API consistency)
    property managingEntity : TFhirReference read FManagingEntity write SetManagingEntity;
    // Entity responsible for defining and maintaining Group characteristics and/or registered members.
    property managingEntityElement : TFhirReference read FManagingEntity write SetManagingEntity;

    // Identifies traits whose presence r absence is shared by members of the group.
    property characteristicList : TFhirGroupCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Identifies the resource instances that are members of the group.
    property memberList : TFhirGroupMemberList read GetMemberList;
    property hasMemberList : boolean read GetHasMemberList;

  end;

  TFhirGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupList;
    function GetCurrent : TFhirGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroup read GetCurrent;
  end;

  TFhirGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroup;
    procedure SetItemN(index : Integer; value : TFhirGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupList; overload;
    function Clone : TFhirGroupList; overload;
    function GetEnumerator : TFhirGroupListEnumerator;
    
    //  Add a FhirGroup to the end of the list.
    function Append : TFhirGroup;
    
    // Add an already existing FhirGroup to the end of the list.
    procedure AddItem(value : TFhirGroup); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroup) : Integer;
    
    // Insert FhirGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroup;
    
    // Insert an existing FhirGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroup);
    
    // Get the iIndexth FhirGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroups[index : Integer] : TFhirGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  // Does this service have specific eligibility requirements that need to be met in order to use the service?
  TFhirHealthcareServiceEligibility = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FComment : TFhirMarkdown;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetComment(value : TFhirMarkdown);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceEligibility; overload;
    function Clone : TFhirHealthcareServiceEligibility; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded value for the eligibility. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded value for the eligibility.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Describes the eligibility conditions for the service.
    property comment : String read GetCommentST write SetCommentST;
    // Describes the eligibility conditions for the service.
    property commentElement : TFhirMarkdown read FComment write SetComment;

  end;

  TFhirHealthcareServiceEligibilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceEligibilityList;
    function GetCurrent : TFhirHealthcareServiceEligibility;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceEligibilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceEligibility read GetCurrent;
  end;

  TFhirHealthcareServiceEligibilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceEligibility;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceEligibility);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceEligibilityList; overload;
    function Clone : TFhirHealthcareServiceEligibilityList; overload;
    function GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
    
    //  Add a FhirHealthcareServiceEligibility to the end of the list.
    function Append : TFhirHealthcareServiceEligibility;
    
    // Add an already existing FhirHealthcareServiceEligibility to the end of the list.
    procedure AddItem(value : TFhirHealthcareServiceEligibility); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceEligibility) : Integer;
    
    // Insert FhirHealthcareServiceEligibility before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // Insert an existing FhirHealthcareServiceEligibility before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // Get the iIndexth FhirHealthcareServiceEligibility. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceEligibilities[index : Integer] : TFhirHealthcareServiceEligibility read GetItemN write SetItemN; default;
  End;

  // A collection of times that the Service Site is available.
  TFhirHealthcareServiceAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetAvailableStartTime(value : TFhirTime);
    function GetAvailableStartTimeST : String;
    procedure SetAvailableStartTimeST(value : String);
    procedure SetAvailableEndTime(value : TFhirTime);
    function GetAvailableEndTimeST : String;
    procedure SetAvailableEndTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceAvailableTime; overload;
    function Clone : TFhirHealthcareServiceAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirHealthcareServiceAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceAvailableTimeList;
    function GetCurrent : TFhirHealthcareServiceAvailableTime;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceAvailableTime read GetCurrent;
  end;

  TFhirHealthcareServiceAvailableTimeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceAvailableTimeList; overload;
    function Clone : TFhirHealthcareServiceAvailableTimeList; overload;
    function GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
    
    //  Add a FhirHealthcareServiceAvailableTime to the end of the list.
    function Append : TFhirHealthcareServiceAvailableTime;
    
    // Add an already existing FhirHealthcareServiceAvailableTime to the end of the list.
    procedure AddItem(value : TFhirHealthcareServiceAvailableTime); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceAvailableTime) : Integer;
    
    // Insert FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceAvailableTime;
    
    // Insert an existing FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // Get the iIndexth FhirHealthcareServiceAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceAvailableTimes[index : Integer] : TFhirHealthcareServiceAvailableTime read GetItemN write SetItemN; default;
  End;

  // The HealthcareService is not available during this period of time due to the provided reason.
  TFhirHealthcareServiceNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDuring(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceNotAvailable; overload;
    function Clone : TFhirHealthcareServiceNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirHealthcareServiceNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceNotAvailableList;
    function GetCurrent : TFhirHealthcareServiceNotAvailable;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceNotAvailable read GetCurrent;
  end;

  TFhirHealthcareServiceNotAvailableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceNotAvailableList; overload;
    function Clone : TFhirHealthcareServiceNotAvailableList; overload;
    function GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
    
    //  Add a FhirHealthcareServiceNotAvailable to the end of the list.
    function Append : TFhirHealthcareServiceNotAvailable;
    
    // Add an already existing FhirHealthcareServiceNotAvailable to the end of the list.
    procedure AddItem(value : TFhirHealthcareServiceNotAvailable); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceNotAvailable) : Integer;
    
    // Insert FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceNotAvailable;
    
    // Insert an existing FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // Get the iIndexth FhirHealthcareServiceNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceNotAvailables[index : Integer] : TFhirHealthcareServiceNotAvailable read GetItemN write SetItemN; default;
  End;

  // The details of a healthcare service available at a location.
  TFhirHealthcareService = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FProvidedBy : TFhirReference;
    FcategoryList : TFhirCodeableConceptList;
    Ftype_List : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FName : TFhirString;
    FComment : TFhirString;
    FExtraDetails : TFhirMarkdown;
    FPhoto : TFhirAttachment;
    FtelecomList : TFhirContactPointList;
    FcoverageAreaList : TFhirReferenceList;
    FserviceProvisionCodeList : TFhirCodeableConceptList;
    FeligibilityList : TFhirHealthcareServiceEligibilityList;
    Fprogram_List : TFhirCodeableConceptList;
    FcharacteristicList : TFhirCodeableConceptList;
    FcommunicationList : TFhirCodeableConceptList;
    FreferralMethodList : TFhirCodeableConceptList;
    FAppointmentRequired : TFhirBoolean;
    FavailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    FnotAvailableList : TFhirHealthcareServiceNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetProvidedBy(value : TFhirReference);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetExtraDetails(value : TFhirMarkdown);
    function GetExtraDetailsST : String;
    procedure SetExtraDetailsST(value : String);
    procedure SetPhoto(value : TFhirAttachment);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetServiceProvisionCodeList : TFhirCodeableConceptList;
    function GetHasServiceProvisionCodeList : Boolean;
    function GetEligibilityList : TFhirHealthcareServiceEligibilityList;
    function GetHasEligibilityList : Boolean;
    function GetProgram_List : TFhirCodeableConceptList;
    function GetHasProgram_List : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
    function GetReferralMethodList : TFhirCodeableConceptList;
    function GetHasReferralMethodList : Boolean;
    procedure SetAppointmentRequired(value : TFhirBoolean);
    function GetAppointmentRequiredST : Boolean;
    procedure SetAppointmentRequiredST(value : Boolean);
    function GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareService; overload;
    function Clone : TFhirHealthcareService; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifiers for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property active : Boolean read GetActiveST write SetActiveST;
    // This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The organization that provides this healthcare service. (defined for API consistency)
    property providedBy : TFhirReference read FProvidedBy write SetProvidedBy;
    // The organization that provides this healthcare service.
    property providedByElement : TFhirReference read FProvidedBy write SetProvidedBy;

    // Identifies the broad category of service being performed or delivered.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The specific type of service that may be delivered or performed.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Collection of specialties handled by the service site. This is more of a medical term.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) where this healthcare service may be provided.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to Further description of the service as it would be presented to a consumer while searching.
    property name : String read GetNameST write SetNameST;
    // Further description of the service as it would be presented to a consumer while searching.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property comment : String read GetCommentST write SetCommentST;
    // Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Extra details about the service that can't be placed in the other fields.
    property extraDetails : String read GetExtraDetailsST write SetExtraDetailsST;
    // Extra details about the service that can't be placed in the other fields.
    property extraDetailsElement : TFhirMarkdown read FExtraDetails write SetExtraDetails;

    // Typed access to If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // List of contacts related to this specific healthcare service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // The location(s) that this service is available to (not where the service is provided).
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The code(s) that detail the conditions under which the healthcare service is available/offered.
    property serviceProvisionCodeList : TFhirCodeableConceptList read GetServiceProvisionCodeList;
    property hasServiceProvisionCodeList : boolean read GetHasServiceProvisionCodeList;

    // Does this service have specific eligibility requirements that need to be met in order to use the service?
    property eligibilityList : TFhirHealthcareServiceEligibilityList read GetEligibilityList;
    property hasEligibilityList : boolean read GetHasEligibilityList;

    // Programs that this service is applicable to.
    property program_List : TFhirCodeableConceptList read GetProgram_List;
    property hasProgram_List : boolean read GetHasProgram_List;

    // Collection of characteristics (attributes).
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Some services are specifically made available in multiple languages, this property permits a directory to declare the languages this is offered in. Typically this is only provided where a service operates in communities with mixed languages used.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
    property referralMethodList : TFhirCodeableConceptList read GetReferralMethodList;
    property hasReferralMethodList : boolean read GetHasReferralMethodList;

    // Typed access to Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequired : Boolean read GetAppointmentRequiredST write SetAppointmentRequiredST;
    // Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequiredElement : TFhirBoolean read FAppointmentRequired write SetAppointmentRequired;

    // A collection of times that the Service Site is available.
    property availableTimeList : TFhirHealthcareServiceAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The HealthcareService is not available during this period of time due to the provided reason.
    property notAvailableList : TFhirHealthcareServiceNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirHealthcareServiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceList;
    function GetCurrent : TFhirHealthcareService;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareService read GetCurrent;
  end;

  TFhirHealthcareServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareService;
    procedure SetItemN(index : Integer; value : TFhirHealthcareService);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceList; overload;
    function Clone : TFhirHealthcareServiceList; overload;
    function GetEnumerator : TFhirHealthcareServiceListEnumerator;
    
    //  Add a FhirHealthcareService to the end of the list.
    function Append : TFhirHealthcareService;
    
    // Add an already existing FhirHealthcareService to the end of the list.
    procedure AddItem(value : TFhirHealthcareService); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareService) : Integer;
    
    // Insert FhirHealthcareService before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareService;
    
    // Insert an existing FhirHealthcareService before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareService);
    
    // Get the iIndexth FhirHealthcareService. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareService);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareService;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServices[index : Integer] : TFhirHealthcareService read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
  TFhirLocationPosition = class (TFhirBackboneElement)
  protected
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    procedure SetLongitude(value : TFhirDecimal);
    function GetLongitudeST : String;
    procedure SetLongitudeST(value : String);
    procedure SetLatitude(value : TFhirDecimal);
    function GetLatitudeST : String;
    procedure SetLatitudeST(value : String);
    procedure SetAltitude(value : TFhirDecimal);
    function GetAltitudeST : String;
    procedure SetAltitudeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitude : String read GetLongitudeST write SetLongitudeST;
    // Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitudeElement : TFhirDecimal read FLongitude write SetLongitude;

    // Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitude : String read GetLatitudeST write SetLatitudeST;
    // Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitudeElement : TFhirDecimal read FLatitude write SetLatitude;

    // Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitude : String read GetAltitudeST write SetAltitudeST;
    // Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitudeElement : TFhirDecimal read FAltitude write SetAltitude;

  end;

  TFhirLocationPositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationPositionList;
    function GetCurrent : TFhirLocationPosition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLocationPositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationPosition read GetCurrent;
  end;

  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationPositionList; overload;
    function Clone : TFhirLocationPositionList; overload;
    function GetEnumerator : TFhirLocationPositionListEnumerator;
    
    //  Add a FhirLocationPosition to the end of the list.
    function Append : TFhirLocationPosition;
    
    // Add an already existing FhirLocationPosition to the end of the list.
    procedure AddItem(value : TFhirLocationPosition); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationPosition) : Integer;
    
    // Insert FhirLocationPosition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationPosition;
    
    // Insert an existing FhirLocationPosition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    // Get the iIndexth FhirLocationPosition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationPosition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;

  // What days/times during a week is this location usually open.
  TFhirLocationHoursOfOperation = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FOpeningTime : TFhirTime;
    FClosingTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetOpeningTime(value : TFhirTime);
    function GetOpeningTimeST : String;
    procedure SetOpeningTimeST(value : String);
    procedure SetClosingTime(value : TFhirTime);
    function GetClosingTimeST : String;
    procedure SetClosingTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationHoursOfOperation; overload;
    function Clone : TFhirLocationHoursOfOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to The Location is open all day.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // The Location is open all day.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to Time that the Location opens.
    property openingTime : String read GetOpeningTimeST write SetOpeningTimeST;
    // Time that the Location opens.
    property openingTimeElement : TFhirTime read FOpeningTime write SetOpeningTime;

    // Typed access to Time that the Location closes.
    property closingTime : String read GetClosingTimeST write SetClosingTimeST;
    // Time that the Location closes.
    property closingTimeElement : TFhirTime read FClosingTime write SetClosingTime;

  end;

  TFhirLocationHoursOfOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationHoursOfOperationList;
    function GetCurrent : TFhirLocationHoursOfOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLocationHoursOfOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationHoursOfOperation read GetCurrent;
  end;

  TFhirLocationHoursOfOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationHoursOfOperation;
    procedure SetItemN(index : Integer; value : TFhirLocationHoursOfOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationHoursOfOperationList; overload;
    function Clone : TFhirLocationHoursOfOperationList; overload;
    function GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
    
    //  Add a FhirLocationHoursOfOperation to the end of the list.
    function Append : TFhirLocationHoursOfOperation;
    
    // Add an already existing FhirLocationHoursOfOperation to the end of the list.
    procedure AddItem(value : TFhirLocationHoursOfOperation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationHoursOfOperation) : Integer;
    
    // Insert FhirLocationHoursOfOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationHoursOfOperation;
    
    // Insert an existing FhirLocationHoursOfOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // Get the iIndexth FhirLocationHoursOfOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationHoursOfOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocationHoursOfOperations[index : Integer] : TFhirLocationHoursOfOperation read GetItemN write SetItemN; default;
  End;

  // Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
  TFhirLocation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FOperationalStatus : TFhirCoding;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FDescription : TFhirString;
    FMode : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FPhysicalType : TFhirCodeableConcept;
    FPosition : TFhirLocationPosition;
    FManagingOrganization : TFhirReference;
    FPartOf : TFhirReference;
    FhoursOfOperationList : TFhirLocationHoursOfOperationList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirLocationStatusEnum;
    procedure SetStatusST(value : TFhirLocationStatusEnum);
    procedure SetOperationalStatus(value : TFhirCoding);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirLocationModeEnum;
    procedure SetModeST(value : TFhirLocationModeEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetPhysicalType(value : TFhirCodeableConcept);
    procedure SetPosition(value : TFhirLocationPosition);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetPartOf(value : TFhirReference);
    function GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
    function GetHasHoursOfOperationList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocation; overload;
    function Clone : TFhirLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique code or number identifying the location to its users.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status property covers the general availability of the resource, not the current value which may be covered by the operationStatus, or by a schedule/slots if they are configured for the location.
    property status : TFhirLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance. (defined for API consistency)
    property operationalStatus : TFhirCoding read FOperationalStatus write SetOperationalStatus;
    // The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance.
    property operationalStatusElement : TFhirCoding read FOperationalStatus write SetOperationalStatus;

    // Typed access to Name of the location as used by humans. Does not need to be unique.
    property name : String read GetNameST write SetNameST;
    // Name of the location as used by humans. Does not need to be unique.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the location is known as, or was known as, in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to Description of the Location, which helps in finding or referencing the place.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the Location, which helps in finding or referencing the place.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Indicates whether a resource instance represents a specific location or a class of locations.
    property mode : TFhirLocationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Indicates the type of function performed at the location.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Physical location. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Physical location.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Typed access to Physical form of the location, e.g. building, room, vehicle, road. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // Physical form of the location, e.g. building, room, vehicle, road.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML). (defined for API consistency)
    property position : TFhirLocationPosition read FPosition write SetPosition;
    // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
    property positionElement : TFhirLocationPosition read FPosition write SetPosition;

    // Typed access to The organization responsible for the provisioning and upkeep of the location. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization responsible for the provisioning and upkeep of the location.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to Another Location of which this Location is physically a part of. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Location of which this Location is physically a part of.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // What days/times during a week is this location usually open.
    property hoursOfOperationList : TFhirLocationHoursOfOperationList read GetHoursOfOperationList;
    property hasHoursOfOperationList : boolean read GetHasHoursOfOperationList;

    // Typed access to A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the location.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationList;
    function GetCurrent : TFhirLocation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocation read GetCurrent;
  end;

  TFhirLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocation;
    procedure SetItemN(index : Integer; value : TFhirLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationList; overload;
    function Clone : TFhirLocationList; overload;
    function GetEnumerator : TFhirLocationListEnumerator;
    
    //  Add a FhirLocation to the end of the list.
    function Append : TFhirLocation;
    
    // Add an already existing FhirLocation to the end of the list.
    procedure AddItem(value : TFhirLocation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocation) : Integer;
    
    // Insert FhirLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocation;
    
    // Insert an existing FhirLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocation);
    
    // Get the iIndexth FhirLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocations[index : Integer] : TFhirLocation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
  // Contact for the organization for a certain purpose.
  TFhirOrganizationContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    procedure SetPurpose(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirOrganizationContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationContactList;
    function GetCurrent : TFhirOrganizationContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationContact read GetCurrent;
  end;

  TFhirOrganizationContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationContactList; overload;
    function Clone : TFhirOrganizationContactList; overload;
    function GetEnumerator : TFhirOrganizationContactListEnumerator;
    
    //  Add a FhirOrganizationContact to the end of the list.
    function Append : TFhirOrganizationContact;
    
    // Add an already existing FhirOrganizationContact to the end of the list.
    procedure AddItem(value : TFhirOrganizationContact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    
    // Insert FhirOrganizationContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationContact;
    
    // Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    // Get the iIndexth FhirOrganizationContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;

  // A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
  TFhirOrganization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FPartOf : TFhirReference;
    FcontactList : TFhirOrganizationContactList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetPartOf(value : TFhirReference);
    function GetContactList : TFhirOrganizationContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganization; overload;
    function Clone : TFhirOrganization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the organization across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether the organization's record is still in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether the organization's record is still in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The kind(s) of organization that this is.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A name associated with the organization.
    property name : String read GetNameST write SetNameST;
    // A name associated with the organization.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the organization is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // A contact detail for the organization.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // An address for the organization.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to The organization of which this organization forms a part. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // The organization of which this organization forms a part.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // Contact for the organization for a certain purpose.
    property contactList : TFhirOrganizationContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Technical endpoints providing access to services operated for the organization.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationList;
    function GetCurrent : TFhirOrganization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganization read GetCurrent;
  end;

  TFhirOrganizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganization;
    procedure SetItemN(index : Integer; value : TFhirOrganization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationList; overload;
    function Clone : TFhirOrganizationList; overload;
    function GetEnumerator : TFhirOrganizationListEnumerator;
    
    //  Add a FhirOrganization to the end of the list.
    function Append : TFhirOrganization;
    
    // Add an already existing FhirOrganization to the end of the list.
    procedure AddItem(value : TFhirOrganization); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganization) : Integer;
    
    // Insert FhirOrganization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganization;
    
    // Insert an existing FhirOrganization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganization);
    
    // Get the iIndexth FhirOrganization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizations[index : Integer] : TFhirOrganization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  // Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship.
  TFhirOrganizationAffiliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FOrganization : TFhirReference;
    FParticipatingOrganization : TFhirReference;
    FnetworkList : TFhirReferenceList;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetOrganization(value : TFhirReference);
    procedure SetParticipatingOrganization(value : TFhirReference);
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationAffiliation; overload;
    function Clone : TFhirOrganizationAffiliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers that are specific to this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this organization affiliation record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this organization affiliation record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the participatingOrganization is affiliated with the primary organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the participatingOrganization is affiliated with the primary organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization where the role is available (primary organization/has members). (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization where the role is available (primary organization/has members).
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of). (defined for API consistency)
    property participatingOrganization : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;
    // The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of).
    property participatingOrganizationElement : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;

    // Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined).
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Definition of the role the participatingOrganization plays in the association.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the participatingOrganization in the context of the role.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which the role occurs.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Healthcare services provided through the role.
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details at the participatingOrganization relevant to this Affiliation.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Technical endpoints providing access to services operated for this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationAffiliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationAffiliationList;
    function GetCurrent : TFhirOrganizationAffiliation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationAffiliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationAffiliation read GetCurrent;
  end;

  TFhirOrganizationAffiliationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationAffiliation;
    procedure SetItemN(index : Integer; value : TFhirOrganizationAffiliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationAffiliationList; overload;
    function Clone : TFhirOrganizationAffiliationList; overload;
    function GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
    
    //  Add a FhirOrganizationAffiliation to the end of the list.
    function Append : TFhirOrganizationAffiliation;
    
    // Add an already existing FhirOrganizationAffiliation to the end of the list.
    procedure AddItem(value : TFhirOrganizationAffiliation); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationAffiliation) : Integer;
    
    // Insert FhirOrganizationAffiliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationAffiliation;
    
    // Insert an existing FhirOrganizationAffiliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationAffiliation);
    
    // Get the iIndexth FhirOrganizationAffiliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationAffiliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationAffiliation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationAffiliations[index : Integer] : TFhirOrganizationAffiliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  // A contact party (e.g. guardian, partner, friend) for the patient.
  TFhirPatientContact = class (TFhirBackboneElement)
  protected
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FGender : TFhirEnum;
    FOrganization : TFhirReference;
    FPeriod : TFhirPeriod;
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetOrganization(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The nature of the relationship between the patient and the contact person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to A name associated with the contact person. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact person.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Address for the contact person. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Address for the contact person.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to Organization on behalf of which the contact is acting or for which the contact is working. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization on behalf of which the contact is acting or for which the contact is working.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The period during which this contact person or organization is valid to be contacted relating to this patient. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which this contact person or organization is valid to be contacted relating to this patient.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirPatientContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientContactList;
    function GetCurrent : TFhirPatientContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPatientContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientContact read GetCurrent;
  end;

  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientContactList; overload;
    function Clone : TFhirPatientContactList; overload;
    function GetEnumerator : TFhirPatientContactListEnumerator;
    
    //  Add a FhirPatientContact to the end of the list.
    function Append : TFhirPatientContact;
    
    // Add an already existing FhirPatientContact to the end of the list.
    procedure AddItem(value : TFhirPatientContact); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientContact) : Integer;
    
    // Insert FhirPatientContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientContact;
    
    // Insert an existing FhirPatientContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    // Get the iIndexth FhirPatientContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;

  // A language which may be used to communicate with the patient about his or her health.
  TFhirPatientCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientCommunication; overload;
    function Clone : TFhirPatientCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirPatientCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientCommunicationList;
    function GetCurrent : TFhirPatientCommunication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPatientCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientCommunication read GetCurrent;
  end;

  TFhirPatientCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientCommunication;
    procedure SetItemN(index : Integer; value : TFhirPatientCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientCommunicationList; overload;
    function Clone : TFhirPatientCommunicationList; overload;
    function GetEnumerator : TFhirPatientCommunicationListEnumerator;
    
    //  Add a FhirPatientCommunication to the end of the list.
    function Append : TFhirPatientCommunication;
    
    // Add an already existing FhirPatientCommunication to the end of the list.
    procedure AddItem(value : TFhirPatientCommunication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientCommunication) : Integer;
    
    // Insert FhirPatientCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientCommunication;
    
    // Insert an existing FhirPatientCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientCommunication);
    
    // Get the iIndexth FhirPatientCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientCommunications[index : Integer] : TFhirPatientCommunication read GetItemN write SetItemN; default;
  End;

  // Link to another patient resource that concerns the same actual patient.
  TFhirPatientLink = class (TFhirBackboneElement)
  protected
    FOther : TFhirReference;
    FType_ : TFhirEnum;
    procedure SetOther(value : TFhirReference);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirLinkTypeEnum;
    procedure SetType_ST(value : TFhirLinkTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The other patient resource that the link refers to. (defined for API consistency)
    property other : TFhirReference read FOther write SetOther;
    // The other patient resource that the link refers to.
    property otherElement : TFhirReference read FOther write SetOther;

    // The type of link between this patient resource and another patient resource.
    property type_ : TFhirLinkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirPatientLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientLinkList;
    function GetCurrent : TFhirPatientLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPatientLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientLink read GetCurrent;
  end;

  TFhirPatientLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientLinkList; overload;
    function Clone : TFhirPatientLinkList; overload;
    function GetEnumerator : TFhirPatientLinkListEnumerator;
    
    //  Add a FhirPatientLink to the end of the list.
    function Append : TFhirPatientLink;
    
    // Add an already existing FhirPatientLink to the end of the list.
    procedure AddItem(value : TFhirPatientLink); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientLink) : Integer;
    
    // Insert FhirPatientLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientLink;
    
    // Insert an existing FhirPatientLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    // Get the iIndexth FhirPatientLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;

  // Demographics and other administrative information about an individual or animal receiving care or other health-related services.
  TFhirPatient = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirDataType;
    FaddressList : TFhirAddressList;
    FMaritalStatus : TFhirCodeableConcept;
    FMultipleBirth : TFhirDataType;
    FphotoList : TFhirAttachmentList;
    FcontactList : TFhirPatientContactList;
    FcommunicationList : TFhirPatientCommunicationList;
    FgeneralPractitionerList : TFhirReferenceList;
    FManagingOrganization : TFhirReference;
    Flink_List : TFhirPatientLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    procedure SetDeceased(value : TFhirDataType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetMaritalStatus(value : TFhirCodeableConcept);
    procedure SetMultipleBirth(value : TFhirDataType);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetContactList : TFhirPatientContactList;
    function GetHasContactList : Boolean;
    function GetCommunicationList : TFhirPatientCommunicationList;
    function GetHasCommunicationList : Boolean;
    function GetGeneralPractitionerList : TFhirReferenceList;
    function GetHasGeneralPractitionerList : Boolean;
    procedure SetManagingOrganization(value : TFhirReference);
    function GetLink_List : TFhirPatientLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatient; overload;
    function Clone : TFhirPatient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for this patient.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A name associated with the individual.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the individual.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the individual.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the individual is deceased or not. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Indicates if the individual is deceased or not.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // An address for the individual.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to This field contains a patient's most recent marital (civil) status. (defined for API consistency)
    property maritalStatus : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;
    // This field contains a patient's most recent marital (civil) status.
    property maritalStatusElement : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;

    // Typed access to Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). (defined for API consistency)
    property multipleBirth : TFhirDataType read FMultipleBirth write SetMultipleBirth;
    // Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
    property multipleBirthElement : TFhirDataType read FMultipleBirth write SetMultipleBirth;

    // Image of the patient.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // A contact party (e.g. guardian, partner, friend) for the patient.
    property contactList : TFhirPatientContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // A language which may be used to communicate with the patient about his or her health.
    property communicationList : TFhirPatientCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Patient's nominated care provider.
    property generalPractitionerList : TFhirReferenceList read GetGeneralPractitionerList;
    property hasGeneralPractitionerList : boolean read GetHasGeneralPractitionerList;

    // Typed access to Organization that is the custodian of the patient record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // Organization that is the custodian of the patient record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Link to another patient resource that concerns the same actual patient.
    property link_List : TFhirPatientLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPatientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientList;
    function GetCurrent : TFhirPatient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPatientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatient read GetCurrent;
  end;

  TFhirPatientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatient;
    procedure SetItemN(index : Integer; value : TFhirPatient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientList; overload;
    function Clone : TFhirPatientList; overload;
    function GetEnumerator : TFhirPatientListEnumerator;
    
    //  Add a FhirPatient to the end of the list.
    function Append : TFhirPatient;
    
    // Add an already existing FhirPatient to the end of the list.
    procedure AddItem(value : TFhirPatient); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatient) : Integer;
    
    // Insert FhirPatient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatient;
    
    // Insert an existing FhirPatient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatient);
    
    // Get the iIndexth FhirPatient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatients[index : Integer] : TFhirPatient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  // Link to a resource that concerns the same actual person.
  TFhirPersonLink = class (TFhirBackboneElement)
  protected
    FTarget : TFhirReference;
    FAssurance : TFhirEnum;
    procedure SetTarget(value : TFhirReference);
    procedure SetAssurance(value : TFhirEnum);
    function GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
    procedure SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPersonLink; overload;
    function Clone : TFhirPersonLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The resource to which this actual person is associated. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The resource to which this actual person is associated.
    property targetElement : TFhirReference read FTarget write SetTarget;

    // Level of assurance that this link is associated with the target resource.
    property assurance : TFhirIdentityAssuranceLevelEnum read GetAssuranceST write SetAssuranceST;
    property assuranceElement : TFhirEnum read FAssurance write SetAssurance;

  end;

  TFhirPersonLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonLinkList;
    function GetCurrent : TFhirPersonLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPersonLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPersonLink read GetCurrent;
  end;

  TFhirPersonLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPersonLink;
    procedure SetItemN(index : Integer; value : TFhirPersonLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonLinkList; overload;
    function Clone : TFhirPersonLinkList; overload;
    function GetEnumerator : TFhirPersonLinkListEnumerator;
    
    //  Add a FhirPersonLink to the end of the list.
    function Append : TFhirPersonLink;
    
    // Add an already existing FhirPersonLink to the end of the list.
    procedure AddItem(value : TFhirPersonLink); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPersonLink) : Integer;
    
    // Insert FhirPersonLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPersonLink;
    
    // Insert an existing FhirPersonLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPersonLink);
    
    // Get the iIndexth FhirPersonLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPersonLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPersonLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPersonLinks[index : Integer] : TFhirPersonLink read GetItemN write SetItemN; default;
  End;

  // Demographics and administrative information about a person independent of a specific health-related context.
  TFhirPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FPhoto : TFhirAttachment;
    FManagingOrganization : TFhirReference;
    FActive : TFhirBoolean;
    Flink_List : TFhirPersonLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetPhoto(value : TFhirAttachment);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetLink_List : TFhirPersonLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPerson; overload;
    function Clone : TFhirPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The birth date for the person.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The birth date for the person.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // One or more addresses for the person.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to An image that can be displayed as a thumbnail of the person to enhance the identification of the individual. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // An image that can be displayed as a thumbnail of the person to enhance the identification of the individual.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // Typed access to The organization that is the custodian of the person record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that is the custodian of the person record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to Whether this person's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this person's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Link to a resource that concerns the same actual person.
    property link_List : TFhirPersonLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonList;
    function GetCurrent : TFhirPerson;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPerson read GetCurrent;
  end;

  TFhirPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPerson;
    procedure SetItemN(index : Integer; value : TFhirPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonList; overload;
    function Clone : TFhirPersonList; overload;
    function GetEnumerator : TFhirPersonListEnumerator;
    
    //  Add a FhirPerson to the end of the list.
    function Append : TFhirPerson;
    
    // Add an already existing FhirPerson to the end of the list.
    procedure AddItem(value : TFhirPerson); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPerson) : Integer;
    
    // Insert FhirPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPerson;
    
    // Insert an existing FhirPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPerson);
    
    // Get the iIndexth FhirPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPeople[index : Integer] : TFhirPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIssuer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person's qualification in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Coded representation of the qualification. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded representation of the qualification.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Period during which the qualification is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Period during which the qualification is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that regulates and issues the qualification. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // Organization that regulates and issues the qualification.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

  end;

  TFhirPractitionerQualificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerQualificationList;
    function GetCurrent : TFhirPractitionerQualification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerQualificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerQualification read GetCurrent;
  end;

  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerQualificationList; overload;
    function Clone : TFhirPractitionerQualificationList; overload;
    function GetEnumerator : TFhirPractitionerQualificationListEnumerator;
    
    //  Add a FhirPractitionerQualification to the end of the list.
    function Append : TFhirPractitionerQualification;
    
    // Add an already existing FhirPractitionerQualification to the end of the list.
    procedure AddItem(value : TFhirPractitionerQualification); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    
    // Insert FhirPractitionerQualification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerQualification;
    
    // Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    // Get the iIndexth FhirPractitionerQualification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;

  // A person who is directly or indirectly involved in the provisioning of healthcare.
  TFhirPractitioner = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FphotoList : TFhirAttachmentList;
    FqualificationList : TFhirPractitionerQualificationList;
    FcommunicationList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetQualificationList : TFhirPractitionerQualificationList;
    function GetHasQualificationList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitioner; overload;
    function Clone : TFhirPractitioner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The name(s) associated with the practitioner.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the practitioner, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the practitioner.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the practitioner.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
    property qualificationList : TFhirPractitionerQualificationList read GetQualificationList;
    property hasQualificationList : boolean read GetHasQualificationList;

    // A language the practitioner can use in patient communication.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirPractitionerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerList;
    function GetCurrent : TFhirPractitioner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitioner read GetCurrent;
  end;

  TFhirPractitionerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitioner;
    procedure SetItemN(index : Integer; value : TFhirPractitioner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerList; overload;
    function Clone : TFhirPractitionerList; overload;
    function GetEnumerator : TFhirPractitionerListEnumerator;
    
    //  Add a FhirPractitioner to the end of the list.
    function Append : TFhirPractitioner;
    
    // Add an already existing FhirPractitioner to the end of the list.
    procedure AddItem(value : TFhirPractitioner); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitioner) : Integer;
    
    // Insert FhirPractitioner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitioner;
    
    // Insert an existing FhirPractitioner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitioner);
    
    // Get the iIndexth FhirPractitioner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitioner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitioner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitioners[index : Integer] : TFhirPractitioner read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
  TFhirPractitionerRoleAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetAvailableStartTime(value : TFhirTime);
    function GetAvailableStartTimeST : String;
    procedure SetAvailableStartTimeST(value : String);
    procedure SetAvailableEndTime(value : TFhirTime);
    function GetAvailableEndTimeST : String;
    procedure SetAvailableEndTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleAvailableTime; overload;
    function Clone : TFhirPractitionerRoleAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Indicates always available, hence times are irrelevant.  (e.g. 24-hour service).
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Indicates always available, hence times are irrelevant.  (e.g. 24-hour service).
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirPractitionerRoleAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleAvailableTimeList;
    function GetCurrent : TFhirPractitionerRoleAvailableTime;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleAvailableTime read GetCurrent;
  end;

  TFhirPractitionerRoleAvailableTimeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRoleAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleAvailableTimeList; overload;
    function Clone : TFhirPractitionerRoleAvailableTimeList; overload;
    function GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
    
    //  Add a FhirPractitionerRoleAvailableTime to the end of the list.
    function Append : TFhirPractitionerRoleAvailableTime;
    
    // Add an already existing FhirPractitionerRoleAvailableTime to the end of the list.
    procedure AddItem(value : TFhirPractitionerRoleAvailableTime); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleAvailableTime) : Integer;
    
    // Insert FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleAvailableTime;
    
    // Insert an existing FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // Get the iIndexth FhirPractitionerRoleAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoleAvailableTimes[index : Integer] : TFhirPractitionerRoleAvailableTime read GetItemN write SetItemN; default;
  End;

  // The practitioner is not available or performing this role during this period of time due to the provided reason.
  TFhirPractitionerRoleNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDuring(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleNotAvailable; overload;
    function Clone : TFhirPractitionerRoleNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirPractitionerRoleNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleNotAvailableList;
    function GetCurrent : TFhirPractitionerRoleNotAvailable;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleNotAvailable read GetCurrent;
  end;

  TFhirPractitionerRoleNotAvailableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRoleNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleNotAvailableList; overload;
    function Clone : TFhirPractitionerRoleNotAvailableList; overload;
    function GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
    
    //  Add a FhirPractitionerRoleNotAvailable to the end of the list.
    function Append : TFhirPractitionerRoleNotAvailable;
    
    // Add an already existing FhirPractitionerRoleNotAvailable to the end of the list.
    procedure AddItem(value : TFhirPractitionerRoleNotAvailable); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleNotAvailable) : Integer;
    
    // Insert FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleNotAvailable;
    
    // Insert an existing FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // Get the iIndexth FhirPractitionerRoleNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoleNotAvailables[index : Integer] : TFhirPractitionerRoleNotAvailable read GetItemN write SetItemN; default;
  End;

  // A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
  TFhirPractitionerRole = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FPractitioner : TFhirReference;
    FOrganization : TFhirReference;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FavailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    FnotAvailableList : TFhirPractitionerRoleNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetPractitioner(value : TFhirReference);
    procedure SetOrganization(value : TFhirReference);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRole; overload;
    function Clone : TFhirPractitionerRole; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business Identifiers that are specific to a role/location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner role record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner role record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the person is authorized to act as a practitioner in these role(s) for the organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Practitioner that is able to provide the defined services for the organization. (defined for API consistency)
    property practitioner : TFhirReference read FPractitioner write SetPractitioner;
    // Practitioner that is able to provide the defined services for the organization.
    property practitionerElement : TFhirReference read FPractitioner write SetPractitioner;

    // Typed access to The organization where the Practitioner performs the roles associated. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // The organization where the Practitioner performs the roles associated.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Roles which this practitioner is authorized to perform for the organization.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the practitioner.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which this practitioner provides care.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // The list of healthcare services that this worker provides for this role's Organization/Location(s).
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details that are specific to the role/location/service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
    property availableTimeList : TFhirPractitionerRoleAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The practitioner is not available or performing this role during this period of time due to the provided reason.
    property notAvailableList : TFhirPractitionerRoleNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the practitioner with this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirPractitionerRoleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleList;
    function GetCurrent : TFhirPractitionerRole;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRole read GetCurrent;
  end;

  TFhirPractitionerRoleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRole;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRole);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleList; overload;
    function Clone : TFhirPractitionerRoleList; overload;
    function GetEnumerator : TFhirPractitionerRoleListEnumerator;
    
    //  Add a FhirPractitionerRole to the end of the list.
    function Append : TFhirPractitionerRole;
    
    // Add an already existing FhirPractitionerRole to the end of the list.
    procedure AddItem(value : TFhirPractitionerRole); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRole) : Integer;
    
    // Insert FhirPractitionerRole before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRole;
    
    // Insert an existing FhirPractitionerRole before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRole);
    
    // Get the iIndexth FhirPractitionerRole. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRole);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRole;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoles[index : Integer] : TFhirPractitionerRole read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  // A language which may be used to communicate with about the patient's health.
  TFhirRelatedPersonCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPersonCommunication; overload;
    function Clone : TFhirRelatedPersonCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirRelatedPersonCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonCommunicationList;
    function GetCurrent : TFhirRelatedPersonCommunication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPersonCommunication read GetCurrent;
  end;

  TFhirRelatedPersonCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPersonCommunication;
    procedure SetItemN(index : Integer; value : TFhirRelatedPersonCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonCommunicationList; overload;
    function Clone : TFhirRelatedPersonCommunicationList; overload;
    function GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
    
    //  Add a FhirRelatedPersonCommunication to the end of the list.
    function Append : TFhirRelatedPersonCommunication;
    
    // Add an already existing FhirRelatedPersonCommunication to the end of the list.
    procedure AddItem(value : TFhirRelatedPersonCommunication); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPersonCommunication) : Integer;
    
    // Insert FhirRelatedPersonCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPersonCommunication;
    
    // Insert an existing FhirRelatedPersonCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // Get the iIndexth FhirRelatedPersonCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPersonCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPersonCommunications[index : Integer] : TFhirRelatedPersonCommunication read GetItemN write SetItemN; default;
  End;

  // Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
  TFhirRelatedPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPatient : TFhirReference;
    FrelationshipList : TFhirCodeableConceptList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FphotoList : TFhirAttachmentList;
    FPeriod : TFhirPeriod;
    FcommunicationList : TFhirRelatedPersonCommunicationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPatient(value : TFhirReference);
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetCommunicationList : TFhirRelatedPersonCommunicationList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPerson; overload;
    function Clone : TFhirRelatedPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this related person record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this related person record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The patient this person is related to. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient this person is related to.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // The nature of the relationship between a patient and the related person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date on which the related person was born.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date on which the related person was born.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Address where the related person can be contacted or visited.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // Typed access to The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // A language which may be used to communicate with about the patient's health.
    property communicationList : TFhirRelatedPersonCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirRelatedPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonList;
    function GetCurrent : TFhirRelatedPerson;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPerson read GetCurrent;
  end;

  TFhirRelatedPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPerson;
    procedure SetItemN(index : Integer; value : TFhirRelatedPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonList; overload;
    function Clone : TFhirRelatedPersonList; overload;
    function GetEnumerator : TFhirRelatedPersonListEnumerator;
    
    //  Add a FhirRelatedPerson to the end of the list.
    function Append : TFhirRelatedPerson;
    
    // Add an already existing FhirRelatedPerson to the end of the list.
    procedure AddItem(value : TFhirRelatedPerson); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPerson) : Integer;
    
    // Insert FhirRelatedPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPerson;
    
    // Insert an existing FhirRelatedPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPerson);
    
    // Get the iIndexth FhirRelatedPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPeople[index : Integer] : TFhirRelatedPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  // A container for slots of time that may be available for booking appointments.
  TFhirSchedule = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FactorList : TFhirReferenceList;
    FPlanningHorizon : TFhirPeriod;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetActorList : TFhirReferenceList;
    function GetHasActorList : Boolean;
    procedure SetPlanningHorizon(value : TFhirPeriod);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSchedule; overload;
    function Clone : TFhirSchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this schedule record is in active use or should not be used (such as was entered in error).
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this schedule record is in active use or should not be used (such as was entered in error).
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Slots that reference this schedule resource provide the availability details to these referenced resource(s).
    property actorList : TFhirReferenceList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Typed access to The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates. (defined for API consistency)
    property planningHorizon : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;
    // The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    property planningHorizonElement : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;

    // Typed access to Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirScheduleList;
    function GetCurrent : TFhirSchedule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSchedule read GetCurrent;
  end;

  TFhirScheduleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSchedule;
    procedure SetItemN(index : Integer; value : TFhirSchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirScheduleList; overload;
    function Clone : TFhirScheduleList; overload;
    function GetEnumerator : TFhirScheduleListEnumerator;
    
    //  Add a FhirSchedule to the end of the list.
    function Append : TFhirSchedule;
    
    // Add an already existing FhirSchedule to the end of the list.
    procedure AddItem(value : TFhirSchedule); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSchedule) : Integer;
    
    // Insert FhirSchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSchedule;
    
    // Insert an existing FhirSchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSchedule);
    
    // Get the iIndexth FhirSchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSchedule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSchedules[index : Integer] : TFhirSchedule read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  // A slot of time on a schedule that may be available for booking appointments.
  TFhirSlot = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FSchedule : TFhirReference;
    FStatus : TFhirEnum;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FOverbooked : TFhirBoolean;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    procedure SetAppointmentType(value : TFhirCodeableConcept);
    procedure SetSchedule(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSlotStatusEnum;
    procedure SetStatusST(value : TFhirSlotStatusEnum);
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetOverbooked(value : TFhirBoolean);
    function GetOverbookedST : Boolean;
    procedure SetOverbookedST(value : Boolean);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSlot; overload;
    function Clone : TFhirSlot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the availability resource.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that may be booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that may be booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // Typed access to The schedule resource that this slot defines an interval of status information. (defined for API consistency)
    property schedule : TFhirReference read FSchedule write SetSchedule;
    // The schedule resource that this slot defines an interval of status information.
    property scheduleElement : TFhirReference read FSchedule write SetSchedule;

    // busy | free | busy-unavailable | busy-tentative | entered-in-error.
    property status : TFhirSlotStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Date/Time that the slot is to begin.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the slot is to begin.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the slot is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the slot is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbooked : Boolean read GetOverbookedST write SetOverbookedST;
    // This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbookedElement : TFhirBoolean read FOverbooked write SetOverbooked;

    // Typed access to Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirSlotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSlotList;
    function GetCurrent : TFhirSlot;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSlotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSlot read GetCurrent;
  end;

  TFhirSlotList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSlot;
    procedure SetItemN(index : Integer; value : TFhirSlot);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSlotList; overload;
    function Clone : TFhirSlotList; overload;
    function GetEnumerator : TFhirSlotListEnumerator;
    
    //  Add a FhirSlot to the end of the list.
    function Append : TFhirSlot;
    
    // Add an already existing FhirSlot to the end of the list.
    procedure AddItem(value : TFhirSlot); overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSlot) : Integer;
    
    // Insert FhirSlot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSlot;
    
    // Insert an existing FhirSlot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSlot);
    
    // Get the iIndexth FhirSlot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSlot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSlot;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSlots[index : Integer] : TFhirSlot read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SLOT}

implementation

uses
  fhir5_utilities;

{$IFDEF FHIR_CATALOGENTRY}
{ TFhirCatalogEntryRelatedEntry }

constructor TFhirCatalogEntryRelatedEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntryRelatedEntry.Destroy;
begin
  FRelationship.free;
  FTarget.free;
  inherited;
end;

procedure TFhirCatalogEntryRelatedEntry.Assign(oSource : TFslObject);
begin
  inherited;
  relationshipElement := TFhirCatalogEntryRelatedEntry(oSource).relationshipElement.Clone;
  target := TFhirCatalogEntryRelatedEntry(oSource).target.Clone;
end;

procedure TFhirCatalogEntryRelatedEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirCatalogEntryRelatedEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirEnum, FRelationship.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link)); {L1172}
end;

function TFhirCatalogEntryRelatedEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirCatalogEntryRelationTypeEnum, CODES_TFhirCatalogEntryRelationTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCatalogEntryRelatedEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCatalogEntryRelatedEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationship') then result := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryRelationTypeEnum[CatalogEntryRelationTypeNull], CODES_TFhirCatalogEntryRelationTypeEnum[CatalogEntryRelationTypeNull])  {L1211}
  else if (propName = 'target') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntryRelatedEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationship') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntryRelatedEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntryRelatedEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirCatalogEntryRelationTypeEnum, CODES_TFhirCatalogEntryRelationTypeEnum, new) {L1210}
  else if (propName = 'target') then TargetElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntryRelatedEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntryRelatedEntry.fhirType : string;
begin
  result := 'CatalogEntry.relatedEntry';
end;

function TFhirCatalogEntryRelatedEntry.Link : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Link);
end;

function TFhirCatalogEntryRelatedEntry.Clone : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntryRelatedEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntryRelatedEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntryRelatedEntry(other);
    result := compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCatalogEntryRelatedEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationship) and isEmptyProp(FTarget);
end;

procedure TFhirCatalogEntryRelatedEntry.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirCatalogEntryRelatedEntry.GetRelationshipST : TFhirCatalogEntryRelationTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirCatalogEntryRelationTypeEnum(0)
  else
    result := TFhirCatalogEntryRelationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCatalogEntryRelationTypeEnum, FRelationship.value));
end;

procedure TFhirCatalogEntryRelatedEntry.SetRelationshipST(value : TFhirCatalogEntryRelationTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryRelationTypeEnum[value], CODES_TFhirCatalogEntryRelationTypeEnum[value]);
end;

procedure TFhirCatalogEntryRelatedEntry.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value; {L1134}
end;

procedure TFhirCatalogEntryRelatedEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relationship');
  fields.add('target');
end;

function TFhirCatalogEntryRelatedEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRelationship.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirCatalogEntryRelatedEntryListEnumerator }

constructor TFhirCatalogEntryRelatedEntryListEnumerator.Create(list : TFhirCatalogEntryRelatedEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryRelatedEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.GetCurrent : TFhirCatalogEntryRelatedEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCatalogEntryRelatedEntryList }

procedure TFhirCatalogEntryRelatedEntryList.AddItem(value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value.ClassName = 'TFhirCatalogEntryRelatedEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCatalogEntryRelatedEntry');
  add(value);
end;

function TFhirCatalogEntryRelatedEntryList.Append: TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryRelatedEntryList.GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
begin
  result := TFhirCatalogEntryRelatedEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryRelatedEntryList.Clone: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryRelatedEntryList.GetItemN(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntryRelatedEntry;
end;
function TFhirCatalogEntryRelatedEntryList.IndexOf(value: TFhirCatalogEntryRelatedEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryRelatedEntryList.Insert(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.InsertItem(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryRelatedEntryList.Item(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.Link: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Link);
end;

procedure TFhirCatalogEntryRelatedEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  FhirCatalogEntryRelatedEntries[index] := value;
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemN(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirCatalogEntry }

constructor TFhirCatalogEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntry.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FType_.free;
  FStatus.free;
  FEffectivePeriod.free;
  FOrderable.free;
  FReferencedItem.free;
  FRelatedEntryList.Free;
  FUpdatedBy.free;
  FNoteList.Free;
  FEstimatedDuration.free;
  FBillingCodeList.Free;
  FBillingSummary.free;
  FScheduleSummary.free;
  FLimitationSummary.free;
  FRegulatorySummary.free;
  inherited;
end;

procedure TFhirCatalogEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCatalogEntry(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCatalogEntry(oSource).FIdentifierList);
  end;
  nameElement := TFhirCatalogEntry(oSource).nameElement.Clone;
  type_Element := TFhirCatalogEntry(oSource).type_Element.Clone;
  statusElement := TFhirCatalogEntry(oSource).statusElement.Clone;
  effectivePeriod := TFhirCatalogEntry(oSource).effectivePeriod.Clone;
  orderableElement := TFhirCatalogEntry(oSource).orderableElement.Clone;
  referencedItem := TFhirCatalogEntry(oSource).referencedItem.Clone;
  if (TFhirCatalogEntry(oSource).FRelatedEntryList = nil) then
  begin
    FRelatedEntryList.free;
    FRelatedEntryList := nil;
  end
  else
  begin
    if FRelatedEntryList = nil then
      FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
    FRelatedEntryList.Assign(TFhirCatalogEntry(oSource).FRelatedEntryList);
  end;
  updatedBy := TFhirCatalogEntry(oSource).updatedBy.Clone;
  if (TFhirCatalogEntry(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCatalogEntry(oSource).FNoteList);
  end;
  estimatedDuration := TFhirCatalogEntry(oSource).estimatedDuration.Clone;
  if (TFhirCatalogEntry(oSource).FBillingCodeList = nil) then
  begin
    FBillingCodeList.free;
    FBillingCodeList := nil;
  end
  else
  begin
    if FBillingCodeList = nil then
      FBillingCodeList := TFhirCodeableConceptList.Create;
    FBillingCodeList.Assign(TFhirCatalogEntry(oSource).FBillingCodeList);
  end;
  billingSummaryElement := TFhirCatalogEntry(oSource).billingSummaryElement.Clone;
  scheduleSummaryElement := TFhirCatalogEntry(oSource).scheduleSummaryElement.Clone;
  limitationSummaryElement := TFhirCatalogEntry(oSource).limitationSummaryElement.Clone;
  regulatorySummaryElement := TFhirCatalogEntry(oSource).regulatorySummaryElement.Clone;
end;

function TFhirCatalogEntry.GetResourceType : TFhirResourceType;
begin
  result := frtCatalogEntry;
end;

procedure TFhirCatalogEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'orderable') Then
     list.add(self.link, 'orderable', FOrderable.Link);
  if (child_name = 'referencedItem') Then
     list.add(self.link, 'referencedItem', FReferencedItem.Link);
  if (child_name = 'relatedEntry') Then
    list.addAll(self, 'relatedEntry', FRelatedEntryList);
  if (child_name = 'updatedBy') Then
     list.add(self.link, 'updatedBy', FUpdatedBy.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'estimatedDuration') Then
     list.add(self.link, 'estimatedDuration', FEstimatedDuration.Link);
  if (child_name = 'billingCode') Then
    list.addAll(self, 'billingCode', FBillingCodeList);
  if (child_name = 'billingSummary') Then
     list.add(self.link, 'billingSummary', FBillingSummary.Link);
  if (child_name = 'scheduleSummary') Then
     list.add(self.link, 'scheduleSummary', FScheduleSummary.Link);
  if (child_name = 'limitationSummary') Then
     list.add(self.link, 'limitationSummary', FLimitationSummary.Link);
  if (child_name = 'regulatorySummary') Then
     list.add(self.link, 'regulatorySummary', FRegulatorySummary.Link);
end;

procedure TFhirCatalogEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'orderable', 'boolean', false, TFhirBoolean, FOrderable.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'referencedItem', 'Reference', false, TFhirReference, FReferencedItem.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relatedEntry', 'BackboneElement', true, TFhirCatalogEntryRelatedEntry, FRelatedEntryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'updatedBy', 'Reference', false, TFhirReference, FUpdatedBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'estimatedDuration', 'Duration', false, TFhirDuration, FEstimatedDuration.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'billingCode', 'CodeableConcept', true, TFhirCodeableConcept, FBillingCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'billingSummary', 'string', false, TFhirString, FBillingSummary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'scheduleSummary', 'string', false, TFhirString, FScheduleSummary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'limitationSummary', 'string', false, TFhirString, FLimitationSummary.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'regulatorySummary', 'string', false, TFhirString, FRegulatorySummary.Link)); {L1172}
end;

function TFhirCatalogEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirCatalogEntryTypeEnum, CODES_TFhirCatalogEntryTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCatalogEntryStatusEnum, CODES_TFhirCatalogEntryStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'orderable') then
  begin
    OrderableElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'referencedItem') then
  begin
    ReferencedItem := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relatedEntry') then
  begin
    RelatedEntryList.add(propValue as TFhirCatalogEntryRelatedEntry) {L1048};
    result := propValue;
  end
  else if (propName = 'updatedBy') then
  begin
    UpdatedBy := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'estimatedDuration') then
  begin
    EstimatedDuration := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'billingCode') then
  begin
    BillingCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'billingSummary') then
  begin
    BillingSummaryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'scheduleSummary') then
  begin
    ScheduleSummaryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'limitationSummary') then
  begin
    LimitationSummaryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'regulatorySummary') then
  begin
    RegulatorySummaryElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCatalogEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'relatedEntry') then RelatedEntryList.insertItem(index, propValue as TFhirCatalogEntryRelatedEntry) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'billingCode') then BillingCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirCatalogEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryTypeEnum[CatalogEntryTypeNull], CODES_TFhirCatalogEntryTypeEnum[CatalogEntryTypeNull])  {L1211}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryStatusEnum[CatalogEntryStatusNull], CODES_TFhirCatalogEntryStatusEnum[CatalogEntryStatusNull])  {L1211}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'orderable') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'referencedItem') then result := TFhirReference.create() {L1203}
  else if (propName = 'relatedEntry') then result := RelatedEntryList.new() {L1053}
  else if (propName = 'updatedBy') then result := TFhirReference.create() {L1203}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'estimatedDuration') then result := TFhirDuration.create() {L1203}
  else if (propName = 'billingCode') then result := BillingCodeList.new() {L1053}
  else if (propName = 'billingSummary') then result := TFhirString.create() {L1223}
  else if (propName = 'scheduleSummary') then result := TFhirString.create() {L1223}
  else if (propName = 'limitationSummary') then result := TFhirString.create() {L1223}
  else if (propName = 'regulatorySummary') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'orderable') then result := 'boolean'
  else if (propName = 'referencedItem') then result := 'Reference'
  else if (propName = 'relatedEntry') then result := 'BackboneElement'
  else if (propName = 'updatedBy') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'estimatedDuration') then result := 'Duration'
  else if (propName = 'billingCode') then result := 'CodeableConcept'
  else if (propName = 'billingSummary') then result := 'string'
  else if (propName = 'scheduleSummary') then result := 'string'
  else if (propName = 'limitationSummary') then result := 'string'
  else if (propName = 'regulatorySummary') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'orderable') then OrderableElement := nil
  else if (propName = 'referencedItem') then ReferencedItemElement := nil
  else if (propName = 'relatedEntry') then deletePropertyValue('relatedEntry', RelatedEntryList, value) {L1054}
  else if (propName = 'updatedBy') then UpdatedByElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'estimatedDuration') then EstimatedDurationElement := nil
  else if (propName = 'billingCode') then deletePropertyValue('billingCode', BillingCodeList, value) {L1054}
  else if (propName = 'billingSummary') then BillingSummaryElement := nil
  else if (propName = 'scheduleSummary') then ScheduleSummaryElement := nil
  else if (propName = 'limitationSummary') then LimitationSummaryElement := nil
  else if (propName = 'regulatorySummary') then RegulatorySummaryElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirCatalogEntryTypeEnum, CODES_TFhirCatalogEntryTypeEnum, new) {L1210}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCatalogEntryStatusEnum, CODES_TFhirCatalogEntryStatusEnum, new) {L1210}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'orderable') then OrderableElement := asBoolean(new) {L1222}
  else if (propName = 'referencedItem') then ReferencedItemElement := new as TFhirReference {L1195}
  else if (propName = 'relatedEntry') then replacePropertyValue('relatedEntry', RelatedEntryList, existing, new) {L1055}
  else if (propName = 'updatedBy') then UpdatedByElement := new as TFhirReference {L1195}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'estimatedDuration') then EstimatedDurationElement := new as TFhirDuration {L1195}
  else if (propName = 'billingCode') then replacePropertyValue('billingCode', BillingCodeList, existing, new) {L1055}
  else if (propName = 'billingSummary') then BillingSummaryElement := asString(new) {L1222}
  else if (propName = 'scheduleSummary') then ScheduleSummaryElement := asString(new) {L1222}
  else if (propName = 'limitationSummary') then LimitationSummaryElement := asString(new) {L1222}
  else if (propName = 'regulatorySummary') then RegulatorySummaryElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'relatedEntry') then RelatedEntryList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'billingCode') then BillingCodeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntry.fhirType : string;
begin
  result := 'CatalogEntry';
end;

function TFhirCatalogEntry.Link : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Link);
end;

function TFhirCatalogEntry.Clone : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Clone);
end;

function TFhirCatalogEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntry(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(orderableElement, o.orderableElement, true) and 
      compareDeep(referencedItemElement, o.referencedItemElement, true) and compareDeep(relatedEntryList, o.relatedEntryList, true) and 
      compareDeep(updatedByElement, o.updatedByElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(estimatedDurationElement, o.estimatedDurationElement, true) and compareDeep(billingCodeList, o.billingCodeList, true) and 
      compareDeep(billingSummaryElement, o.billingSummaryElement, true) and compareDeep(scheduleSummaryElement, o.scheduleSummaryElement, true) and 
      compareDeep(limitationSummaryElement, o.limitationSummaryElement, true) and compareDeep(regulatorySummaryElement, o.regulatorySummaryElement, true);
  end;
end;

function TFhirCatalogEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FOrderable) and isEmptyProp(FReferencedItem) and isEmptyProp(FrelatedEntryList) and isEmptyProp(FUpdatedBy) and isEmptyProp(FnoteList) and isEmptyProp(FEstimatedDuration) and isEmptyProp(FbillingCodeList) and isEmptyProp(FBillingSummary) and isEmptyProp(FScheduleSummary) and isEmptyProp(FLimitationSummary) and isEmptyProp(FRegulatorySummary);
end;

function TFhirCatalogEntry.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCatalogEntry.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCatalogEntry.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirCatalogEntry.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCatalogEntry.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCatalogEntry.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirCatalogEntry.GetType_ST : TFhirCatalogEntryTypeEnum;
begin
  if FType_ = nil then
    result := TFhirCatalogEntryTypeEnum(0)
  else
    result := TFhirCatalogEntryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCatalogEntryTypeEnum, FType_.value));
end;

procedure TFhirCatalogEntry.SetType_ST(value : TFhirCatalogEntryTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryTypeEnum[value], CODES_TFhirCatalogEntryTypeEnum[value]);
end;

procedure TFhirCatalogEntry.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCatalogEntry.GetStatusST : TFhirCatalogEntryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCatalogEntryStatusEnum(0)
  else
    result := TFhirCatalogEntryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCatalogEntryStatusEnum, FStatus.value));
end;

procedure TFhirCatalogEntry.SetStatusST(value : TFhirCatalogEntryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCatalogEntryStatusEnum[value], CODES_TFhirCatalogEntryStatusEnum[value]);
end;

procedure TFhirCatalogEntry.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value; {L1134}
end;

procedure TFhirCatalogEntry.SetOrderable(value : TFhirBoolean);
begin
  FOrderable.free;
  FOrderable := value; {L1134}
end;

function TFhirCatalogEntry.GetOrderableST : Boolean;
begin
  if FOrderable = nil then
    result := false
  else
    result := FOrderable.value;
end;

procedure TFhirCatalogEntry.SetOrderableST(value : Boolean);
begin
  if FOrderable = nil then
    FOrderable := TFhirBoolean.create;
  FOrderable.value := value
end;

procedure TFhirCatalogEntry.SetReferencedItem(value : TFhirReference);
begin
  FReferencedItem.free;
  FReferencedItem := value; {L1134}
end;

function TFhirCatalogEntry.GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
begin
  if FRelatedEntryList = nil then
    FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
  result := FRelatedEntryList;
end;

function TFhirCatalogEntry.GetHasRelatedEntryList : boolean;
begin
  result := (FRelatedEntryList <> nil) and (FRelatedEntryList.count > 0);
end;

procedure TFhirCatalogEntry.SetUpdatedBy(value : TFhirReference);
begin
  FUpdatedBy.free;
  FUpdatedBy := value; {L1134}
end;

function TFhirCatalogEntry.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCatalogEntry.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirCatalogEntry.SetEstimatedDuration(value : TFhirDuration);
begin
  FEstimatedDuration.free;
  FEstimatedDuration := value; {L1134}
end;

function TFhirCatalogEntry.GetBillingCodeList : TFhirCodeableConceptList;
begin
  if FBillingCodeList = nil then
    FBillingCodeList := TFhirCodeableConceptList.Create;
  result := FBillingCodeList;
end;

function TFhirCatalogEntry.GetHasBillingCodeList : boolean;
begin
  result := (FBillingCodeList <> nil) and (FBillingCodeList.count > 0);
end;

procedure TFhirCatalogEntry.SetBillingSummary(value : TFhirString);
begin
  FBillingSummary.free;
  FBillingSummary := value; {L1134}
end;

function TFhirCatalogEntry.GetBillingSummaryST : String;
begin
  if FBillingSummary = nil then
    result := ''
  else
    result := FBillingSummary.value;
end;

procedure TFhirCatalogEntry.SetBillingSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FBillingSummary = nil then
      FBillingSummary := TFhirString.create;
    FBillingSummary.value := value
  end
  else if FBillingSummary <> nil then
    FBillingSummary.value := '';
end;

procedure TFhirCatalogEntry.SetScheduleSummary(value : TFhirString);
begin
  FScheduleSummary.free;
  FScheduleSummary := value; {L1134}
end;

function TFhirCatalogEntry.GetScheduleSummaryST : String;
begin
  if FScheduleSummary = nil then
    result := ''
  else
    result := FScheduleSummary.value;
end;

procedure TFhirCatalogEntry.SetScheduleSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FScheduleSummary = nil then
      FScheduleSummary := TFhirString.create;
    FScheduleSummary.value := value
  end
  else if FScheduleSummary <> nil then
    FScheduleSummary.value := '';
end;

procedure TFhirCatalogEntry.SetLimitationSummary(value : TFhirString);
begin
  FLimitationSummary.free;
  FLimitationSummary := value; {L1134}
end;

function TFhirCatalogEntry.GetLimitationSummaryST : String;
begin
  if FLimitationSummary = nil then
    result := ''
  else
    result := FLimitationSummary.value;
end;

procedure TFhirCatalogEntry.SetLimitationSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FLimitationSummary = nil then
      FLimitationSummary := TFhirString.create;
    FLimitationSummary.value := value
  end
  else if FLimitationSummary <> nil then
    FLimitationSummary.value := '';
end;

procedure TFhirCatalogEntry.SetRegulatorySummary(value : TFhirString);
begin
  FRegulatorySummary.free;
  FRegulatorySummary := value; {L1134}
end;

function TFhirCatalogEntry.GetRegulatorySummaryST : String;
begin
  if FRegulatorySummary = nil then
    result := ''
  else
    result := FRegulatorySummary.value;
end;

procedure TFhirCatalogEntry.SetRegulatorySummaryST(value : String);
begin
  if value <> '' then
  begin
    if FRegulatorySummary = nil then
      FRegulatorySummary := TFhirString.create;
    FRegulatorySummary.value := value
  end
  else if FRegulatorySummary <> nil then
    FRegulatorySummary.value := '';
end;

procedure TFhirCatalogEntry.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('effectivePeriod');
  fields.add('orderable');
  fields.add('referencedItem');
  fields.add('relatedEntry');
  fields.add('updatedBy');
  fields.add('note');
  fields.add('estimatedDuration');
  fields.add('billingCode');
  fields.add('billingSummary');
  fields.add('scheduleSummary');
  fields.add('limitationSummary');
  fields.add('regulatorySummary');
end;

function TFhirCatalogEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FOrderable.sizeInBytes);
  inc(result, FReferencedItem.sizeInBytes);
  inc(result, FrelatedEntryList.sizeInBytes);
  inc(result, FUpdatedBy.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FEstimatedDuration.sizeInBytes);
  inc(result, FbillingCodeList.sizeInBytes);
  inc(result, FBillingSummary.sizeInBytes);
  inc(result, FScheduleSummary.sizeInBytes);
  inc(result, FLimitationSummary.sizeInBytes);
  inc(result, FRegulatorySummary.sizeInBytes);
end;

{ TFhirCatalogEntryListEnumerator }

constructor TFhirCatalogEntryListEnumerator.Create(list : TFhirCatalogEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCatalogEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryListEnumerator.GetCurrent : TFhirCatalogEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCatalogEntryList }

procedure TFhirCatalogEntryList.AddItem(value: TFhirCatalogEntry);
begin
  assert(value.ClassName = 'TFhirCatalogEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCatalogEntry');
  add(value);
end;

function TFhirCatalogEntryList.Append: TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryList.GetEnumerator : TFhirCatalogEntryListEnumerator;
begin
  result := TFhirCatalogEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryList.Clone: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Clone);
end;

function TFhirCatalogEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryList.GetItemN(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntry;
end;
function TFhirCatalogEntryList.IndexOf(value: TFhirCatalogEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryList.Insert(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.InsertItem(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryList.Item(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.Link: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Link);
end;

procedure TFhirCatalogEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  FhirCatalogEntries[index] := value;
end;

procedure TFhirCatalogEntryList.SetItemN(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
{ TFhirDeviceUdiCarrier }

constructor TFhirDeviceUdiCarrier.Create;
begin
  inherited;
end;

destructor TFhirDeviceUdiCarrier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  FCarrierAIDC.free;
  FCarrierHRF.free;
  FEntryType.free;
  inherited;
end;

procedure TFhirDeviceUdiCarrier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceUdiCarrier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceUdiCarrier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceUdiCarrier(oSource).jurisdictionElement.Clone;
  carrierAIDCElement := TFhirDeviceUdiCarrier(oSource).carrierAIDCElement.Clone;
  carrierHRFElement := TFhirDeviceUdiCarrier(oSource).carrierHRFElement.Clone;
  entryTypeElement := TFhirDeviceUdiCarrier(oSource).entryTypeElement.Clone;
end;

procedure TFhirDeviceUdiCarrier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'carrierAIDC') Then
     list.add(self.link, 'carrierAIDC', FCarrierAIDC.Link);
  if (child_name = 'carrierHRF') Then
     list.add(self.link, 'carrierHRF', FCarrierHRF.Link);
  if (child_name = 'entryType') Then
     list.add(self.link, 'entryType', FEntryType.Link);
end;

procedure TFhirDeviceUdiCarrier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'carrierAIDC', 'base64Binary', false, TFhirBase64Binary, FCarrierAIDC.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'carrierHRF', 'string', false, TFhirString, FCarrierHRF.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'entryType', 'code', false, TFhirEnum, FEntryType.Link)); {L1170}
end;

function TFhirDeviceUdiCarrier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'carrierAIDC') then
  begin
    CarrierAIDCElement := asBase64Binary(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'carrierHRF') then
  begin
    CarrierHRFElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'entryType') then
  begin
    EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUdiCarrier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceUdiCarrier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.create() {L1223}
  else if (propName = 'issuer') then result := TFhirUri.create() {L1223}
  else if (propName = 'jurisdiction') then result := TFhirUri.create() {L1223}
  else if (propName = 'carrierAIDC') then result := TFhirBase64Binary.create() {L1223}
  else if (propName = 'carrierHRF') then result := TFhirString.create() {L1223}
  else if (propName = 'entryType') then result := TFhirEnum.create(SYSTEMS_TFhirUDIEntryTypeEnum[UDIEntryTypeNull], CODES_TFhirUDIEntryTypeEnum[UDIEntryTypeNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUdiCarrier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else if (propName = 'carrierAIDC') then result := 'base64Binary'
  else if (propName = 'carrierHRF') then result := 'string'
  else if (propName = 'entryType') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUdiCarrier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := nil
  else if (propName = 'carrierHRF') then CarrierHRFElement := nil
  else if (propName = 'entryType') then EntryTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUdiCarrier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new) {L1222}
  else if (propName = 'issuer') then IssuerElement := asUri(new) {L1222}
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new) {L1222}
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := asBase64Binary(new) {L1222}
  else if (propName = 'carrierHRF') then CarrierHRFElement := asString(new) {L1222}
  else if (propName = 'entryType') then EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUdiCarrier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUdiCarrier.fhirType : string;
begin
  result := 'Device.udiCarrier';
end;

function TFhirDeviceUdiCarrier.Link : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Link);
end;

function TFhirDeviceUdiCarrier.Clone : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Clone);
end;

function TFhirDeviceUdiCarrier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUdiCarrier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUdiCarrier)) then
    result := false
  else
  begin
    o := TFhirDeviceUdiCarrier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(carrierAIDCElement, o.carrierAIDCElement, true) and compareDeep(carrierHRFElement, o.carrierHRFElement, true) and 
      compareDeep(entryTypeElement, o.entryTypeElement, true);
  end;
end;

function TFhirDeviceUdiCarrier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction) and isEmptyProp(FCarrierAIDC) and isEmptyProp(FCarrierHRF) and isEmptyProp(FEntryType);
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value; {L1134}
end;

function TFhirDeviceUdiCarrier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value; {L1134}
end;

function TFhirDeviceUdiCarrier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceUdiCarrier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value; {L1134}
end;

function TFhirDeviceUdiCarrier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceUdiCarrier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDC(value : TFhirBase64Binary);
begin
  FCarrierAIDC.free;
  FCarrierAIDC := value; {L1134}
end;

function TFhirDeviceUdiCarrier.GetCarrierAIDCST : TBytes;
begin
  if FCarrierAIDC = nil then
    result := nil {L1148}
  else
    result := FCarrierAIDC.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDCST(value : TBytes);
begin
  if value <> nil then
  begin
    if FCarrierAIDC = nil then
      FCarrierAIDC := TFhirBase64Binary.create;
    FCarrierAIDC.value := value
  end
  else if FCarrierAIDC <> nil then
    FCarrierAIDC.value := nil;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRF(value : TFhirString);
begin
  FCarrierHRF.free;
  FCarrierHRF := value; {L1134}
end;

function TFhirDeviceUdiCarrier.GetCarrierHRFST : String;
begin
  if FCarrierHRF = nil then
    result := ''
  else
    result := FCarrierHRF.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRFST(value : String);
begin
  if value <> '' then
  begin
    if FCarrierHRF = nil then
      FCarrierHRF := TFhirString.create;
    FCarrierHRF.value := value
  end
  else if FCarrierHRF <> nil then
    FCarrierHRF.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetEntryType(value : TFhirEnum);
begin
  FEntryType.free;
  FEntryType := value;
end;

function TFhirDeviceUdiCarrier.GetEntryTypeST : TFhirUDIEntryTypeEnum;
begin
  if FEntryType = nil then
    result := TFhirUDIEntryTypeEnum(0)
  else
    result := TFhirUDIEntryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirUDIEntryTypeEnum, FEntryType.value));
end;

procedure TFhirDeviceUdiCarrier.SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
begin
  if ord(value) = 0 then
    EntryTypeElement := nil
  else
    EntryTypeElement := TFhirEnum.create(SYSTEMS_TFhirUDIEntryTypeEnum[value], CODES_TFhirUDIEntryTypeEnum[value]);
end;

procedure TFhirDeviceUdiCarrier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
  fields.add('carrierAIDC');
  fields.add('carrierHRF');
  fields.add('entryType');
end;

function TFhirDeviceUdiCarrier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDeviceIdentifier.sizeInBytes);
  inc(result, FIssuer.sizeInBytes);
  inc(result, FJurisdiction.sizeInBytes);
  inc(result, FCarrierAIDC.sizeInBytes);
  inc(result, FCarrierHRF.sizeInBytes);
  inc(result, FEntryType.sizeInBytes);
end;

{ TFhirDeviceUdiCarrierListEnumerator }

constructor TFhirDeviceUdiCarrierListEnumerator.Create(list : TFhirDeviceUdiCarrierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUdiCarrierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUdiCarrierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUdiCarrierListEnumerator.GetCurrent : TFhirDeviceUdiCarrier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUdiCarrierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceUdiCarrierList }

procedure TFhirDeviceUdiCarrierList.AddItem(value: TFhirDeviceUdiCarrier);
begin
  assert(value.ClassName = 'TFhirDeviceUdiCarrier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUdiCarrier');
  add(value);
end;

function TFhirDeviceUdiCarrierList.Append: TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUdiCarrierList.GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
begin
  result := TFhirDeviceUdiCarrierListEnumerator.Create(self.link);
end;

function TFhirDeviceUdiCarrierList.Clone: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Clone);
end;

function TFhirDeviceUdiCarrierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUdiCarrierList.GetItemN(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUdiCarrier;
end;
function TFhirDeviceUdiCarrierList.IndexOf(value: TFhirDeviceUdiCarrier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUdiCarrierList.Insert(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.InsertItem(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  Inherited Insert(index, value);
end;

function TFhirDeviceUdiCarrierList.Item(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.Link: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Link);
end;

procedure TFhirDeviceUdiCarrierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUdiCarrierList.SetItemByIndex(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  FhirDeviceUdiCarriers[index] := value;
end;

procedure TFhirDeviceUdiCarrierList.SetItemN(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDeviceName }

constructor TFhirDeviceDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
end;

function TFhirDeviceDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDeviceName.fhirType : string;
begin
  result := 'Device.deviceName';
end;

function TFhirDeviceDeviceName.Link : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Link);
end;

function TFhirDeviceDeviceName.Clone : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Clone);
end;

function TFhirDeviceDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirDeviceDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

procedure TFhirDeviceDeviceName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDeviceName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirDeviceDeviceNameListEnumerator }

constructor TFhirDeviceDeviceNameListEnumerator.Create(list : TFhirDeviceDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDeviceNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDeviceNameListEnumerator.GetCurrent : TFhirDeviceDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDeviceNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDeviceNameList }

procedure TFhirDeviceDeviceNameList.AddItem(value: TFhirDeviceDeviceName);
begin
  assert(value.ClassName = 'TFhirDeviceDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDeviceName');
  add(value);
end;

function TFhirDeviceDeviceNameList.Append: TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDeviceNameList.GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
begin
  result := TFhirDeviceDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDeviceNameList.Clone: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Clone);
end;

function TFhirDeviceDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDeviceNameList.GetItemN(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDeviceName;
end;
function TFhirDeviceDeviceNameList.IndexOf(value: TFhirDeviceDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDeviceNameList.Insert(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDeviceNameList.Item(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.Link: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  FhirDeviceDeviceNames[index] := value;
end;

procedure TFhirDeviceDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceSpecialization }

constructor TFhirDeviceSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  inherited;
end;

procedure TFhirDeviceSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemType := TFhirDeviceSpecialization(oSource).systemType.Clone;
  versionElement := TFhirDeviceSpecialization(oSource).versionElement.Clone;
end;

procedure TFhirDeviceSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirDeviceSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'systemType', 'CodeableConcept', false, TFhirCodeableConcept, FSystemType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link)); {L1172}
end;

function TFhirDeviceSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'version') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'version') then VersionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceSpecialization.fhirType : string;
begin
  result := 'Device.specialization';
end;

function TFhirDeviceSpecialization.Link : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Link);
end;

function TFhirDeviceSpecialization.Clone : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Clone);
end;

function TFhirDeviceSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirDeviceSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion);
end;

procedure TFhirDeviceSpecialization.SetSystemType(value : TFhirCodeableConcept);
begin
  FSystemType.free;
  FSystemType := value; {L1134}
end;

procedure TFhirDeviceSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value; {L1134}
end;

function TFhirDeviceSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirDeviceSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirDeviceSpecialization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
end;

function TFhirDeviceSpecialization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystemType.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
end;

{ TFhirDeviceSpecializationListEnumerator }

constructor TFhirDeviceSpecializationListEnumerator.Create(list : TFhirDeviceSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceSpecializationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceSpecializationListEnumerator.GetCurrent : TFhirDeviceSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceSpecializationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceSpecializationList }

procedure TFhirDeviceSpecializationList.AddItem(value: TFhirDeviceSpecialization);
begin
  assert(value.ClassName = 'TFhirDeviceSpecialization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceSpecialization');
  add(value);
end;

function TFhirDeviceSpecializationList.Append: TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceSpecializationList.GetEnumerator : TFhirDeviceSpecializationListEnumerator;
begin
  result := TFhirDeviceSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceSpecializationList.Clone: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Clone);
end;

function TFhirDeviceSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceSpecializationList.GetItemN(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceSpecialization;
end;
function TFhirDeviceSpecializationList.IndexOf(value: TFhirDeviceSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceSpecializationList.Insert(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.InsertItem(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceSpecializationList.Item(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.Link: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Link);
end;

procedure TFhirDeviceSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  FhirDeviceSpecializations[index] := value;
end;

procedure TFhirDeviceSpecializationList.SetItemN(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceVersion }

constructor TFhirDeviceVersion.Create;
begin
  inherited;
end;

destructor TFhirDeviceVersion.Destroy;
begin
  FType_.free;
  FComponent.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceVersion.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceVersion(oSource).type_.Clone;
  component := TFhirDeviceVersion(oSource).component.Clone;
  valueElement := TFhirDeviceVersion(oSource).valueElement.Clone;
end;

procedure TFhirDeviceVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'component') Then
     list.add(self.link, 'component', FComponent.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirDeviceVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'component', 'Identifier', false, TFhirIdentifier, FComponent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link)); {L1172}
end;

function TFhirDeviceVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    Component := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'component') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'value') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'Identifier'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'component') then ComponentElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'component') then ComponentElement := new as TFhirIdentifier {L1195}
  else if (propName = 'value') then ValueElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceVersion.fhirType : string;
begin
  result := 'Device.version';
end;

function TFhirDeviceVersion.Link : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Link);
end;

function TFhirDeviceVersion.Clone : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Clone);
end;

function TFhirDeviceVersion.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceVersion)) then
    result := false
  else
  begin
    o := TFhirDeviceVersion(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(componentElement, o.componentElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FComponent) and isEmptyProp(FValue);
end;

procedure TFhirDeviceVersion.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirDeviceVersion.SetComponent(value : TFhirIdentifier);
begin
  FComponent.free;
  FComponent := value; {L1134}
end;

procedure TFhirDeviceVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirDeviceVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirDeviceVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

procedure TFhirDeviceVersion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('component');
  fields.add('value');
end;

function TFhirDeviceVersion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FComponent.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirDeviceVersionListEnumerator }

constructor TFhirDeviceVersionListEnumerator.Create(list : TFhirDeviceVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceVersionListEnumerator.GetCurrent : TFhirDeviceVersion;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceVersionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceVersionList }

procedure TFhirDeviceVersionList.AddItem(value: TFhirDeviceVersion);
begin
  assert(value.ClassName = 'TFhirDeviceVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceVersion');
  add(value);
end;

function TFhirDeviceVersionList.Append: TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceVersionList.GetEnumerator : TFhirDeviceVersionListEnumerator;
begin
  result := TFhirDeviceVersionListEnumerator.Create(self.link);
end;

function TFhirDeviceVersionList.Clone: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Clone);
end;

function TFhirDeviceVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceVersionList.GetItemN(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceVersion;
end;
function TFhirDeviceVersionList.IndexOf(value: TFhirDeviceVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceVersionList.Insert(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.InsertItem(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  Inherited Insert(index, value);
end;

function TFhirDeviceVersionList.Item(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.Link: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Link);
end;

procedure TFhirDeviceVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceVersionList.SetItemByIndex(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  FhirDeviceVersions[index] := value;
end;

procedure TFhirDeviceVersionList.SetItemN(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceProperty }

constructor TFhirDeviceProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceProperty.Destroy;
begin
  FType_.free;
  FValueQuantityList.Free;
  FValueCodeList.Free;
  inherited;
end;

procedure TFhirDeviceProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceProperty(oSource).type_.Clone;
  if (TFhirDeviceProperty(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirDeviceProperty(oSource).FValueQuantityList);
  end;
  if (TFhirDeviceProperty(oSource).FValueCodeList = nil) then
  begin
    FValueCodeList.free;
    FValueCodeList := nil;
  end
  else
  begin
    if FValueCodeList = nil then
      FValueCodeList := TFhirCodeableConceptList.Create;
    FValueCodeList.Assign(TFhirDeviceProperty(oSource).FValueCodeList);
  end;
end;

procedure TFhirDeviceProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueCode') Then
    list.addAll(self, 'valueCode', FValueCodeList);
end;

procedure TFhirDeviceProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'valueCode', 'CodeableConcept', true, TFhirCodeableConcept, FValueCodeList.Link)) {L1039};
end;

function TFhirDeviceProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity) {L1048};
    result := propValue;
  end
  else if (propName = 'valueCode') then
  begin
    ValueCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity) {L1049}
  else if (propName = 'valueCode') then ValueCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDeviceProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new() {L1053}
  else if (propName = 'valueCode') then result := ValueCodeList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value) {L1054}
  else if (propName = 'valueCode') then deletePropertyValue('valueCode', ValueCodeList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new) {L1055}
  else if (propName = 'valueCode') then replacePropertyValue('valueCode', ValueCodeList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination) {L1050}
  else if (propName = 'valueCode') then ValueCodeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceProperty.fhirType : string;
begin
  result := 'Device.property';
end;

function TFhirDeviceProperty.Link : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Link);
end;

function TFhirDeviceProperty.Clone : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Clone);
end;

function TFhirDeviceProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueQuantityList, o.valueQuantityList, true) and 
      compareDeep(valueCodeList, o.valueCodeList, true);
  end;
end;

function TFhirDeviceProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueCodeList);
end;

procedure TFhirDeviceProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirDeviceProperty.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirDeviceProperty.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirDeviceProperty.GetValueCodeList : TFhirCodeableConceptList;
begin
  if FValueCodeList = nil then
    FValueCodeList := TFhirCodeableConceptList.Create;
  result := FValueCodeList;
end;

function TFhirDeviceProperty.GetHasValueCodeList : boolean;
begin
  result := (FValueCodeList <> nil) and (FValueCodeList.count > 0);
end;

procedure TFhirDeviceProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('valueQuantity');
  fields.add('valueCode');
end;

function TFhirDeviceProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FvalueQuantityList.sizeInBytes);
  inc(result, FvalueCodeList.sizeInBytes);
end;

{ TFhirDevicePropertyListEnumerator }

constructor TFhirDevicePropertyListEnumerator.Create(list : TFhirDevicePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDevicePropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDevicePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDevicePropertyListEnumerator.GetCurrent : TFhirDeviceProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDevicePropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDevicePropertyList }

procedure TFhirDevicePropertyList.AddItem(value: TFhirDeviceProperty);
begin
  assert(value.ClassName = 'TFhirDeviceProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceProperty');
  add(value);
end;

function TFhirDevicePropertyList.Append: TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDevicePropertyList.GetEnumerator : TFhirDevicePropertyListEnumerator;
begin
  result := TFhirDevicePropertyListEnumerator.Create(self.link);
end;

function TFhirDevicePropertyList.Clone: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Clone);
end;

function TFhirDevicePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDevicePropertyList.GetItemN(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceProperty;
end;
function TFhirDevicePropertyList.IndexOf(value: TFhirDeviceProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDevicePropertyList.Insert(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.InsertItem(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  Inherited Insert(index, value);
end;

function TFhirDevicePropertyList.Item(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.Link: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Link);
end;

procedure TFhirDevicePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDevicePropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  FhirDeviceProperties[index] := value;
end;

procedure TFhirDevicePropertyList.SetItemN(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceOperationalStatus }

constructor TFhirDeviceOperationalStatus.Create;
begin
  inherited;
end;

destructor TFhirDeviceOperationalStatus.Destroy;
begin
  FValue.free;
  FReasonList.Free;
  inherited;
end;

procedure TFhirDeviceOperationalStatus.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirDeviceOperationalStatus(oSource).value.Clone;
  if (TFhirDeviceOperationalStatus(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirDeviceOperationalStatus(oSource).FReasonList);
  end;
end;

procedure TFhirDeviceOperationalStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
end;

procedure TFhirDeviceOperationalStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)) {L1039};
end;

function TFhirDeviceOperationalStatus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceOperationalStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDeviceOperationalStatus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceOperationalStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceOperationalStatus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceOperationalStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceOperationalStatus.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceOperationalStatus.fhirType : string;
begin
  result := 'Device.operationalStatus';
end;

function TFhirDeviceOperationalStatus.Link : TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus(inherited Link);
end;

function TFhirDeviceOperationalStatus.Clone : TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus(inherited Clone);
end;

function TFhirDeviceOperationalStatus.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceOperationalStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceOperationalStatus)) then
    result := false
  else
  begin
    o := TFhirDeviceOperationalStatus(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonList, o.reasonList, true);
  end;
end;

function TFhirDeviceOperationalStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FreasonList);
end;

procedure TFhirDeviceOperationalStatus.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirDeviceOperationalStatus.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirDeviceOperationalStatus.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirDeviceOperationalStatus.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('reason');
end;

function TFhirDeviceOperationalStatus.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
end;

{ TFhirDeviceOperationalStatusListEnumerator }

constructor TFhirDeviceOperationalStatusListEnumerator.Create(list : TFhirDeviceOperationalStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceOperationalStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceOperationalStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceOperationalStatusListEnumerator.GetCurrent : TFhirDeviceOperationalStatus;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceOperationalStatusListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceOperationalStatusList }

procedure TFhirDeviceOperationalStatusList.AddItem(value: TFhirDeviceOperationalStatus);
begin
  assert(value.ClassName = 'TFhirDeviceOperationalStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceOperationalStatus');
  add(value);
end;

function TFhirDeviceOperationalStatusList.Append: TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceOperationalStatusList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceOperationalStatusList.GetEnumerator : TFhirDeviceOperationalStatusListEnumerator;
begin
  result := TFhirDeviceOperationalStatusListEnumerator.Create(self.link);
end;

function TFhirDeviceOperationalStatusList.Clone: TFhirDeviceOperationalStatusList;
begin
  result := TFhirDeviceOperationalStatusList(inherited Clone);
end;

function TFhirDeviceOperationalStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceOperationalStatusList.GetItemN(index: Integer): TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus(ObjectByIndex[index]);
end;

function TFhirDeviceOperationalStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceOperationalStatus;
end;
function TFhirDeviceOperationalStatusList.IndexOf(value: TFhirDeviceOperationalStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceOperationalStatusList.Insert(index: Integer): TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceOperationalStatusList.InsertItem(index: Integer; value: TFhirDeviceOperationalStatus);
begin
  assert(value is TFhirDeviceOperationalStatus);
  Inherited Insert(index, value);
end;

function TFhirDeviceOperationalStatusList.Item(index: Integer): TFhirDeviceOperationalStatus;
begin
  result := TFhirDeviceOperationalStatus(ObjectByIndex[index]);
end;

function TFhirDeviceOperationalStatusList.Link: TFhirDeviceOperationalStatusList;
begin
  result := TFhirDeviceOperationalStatusList(inherited Link);
end;

procedure TFhirDeviceOperationalStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceOperationalStatusList.SetItemByIndex(index: Integer; value: TFhirDeviceOperationalStatus);
begin
  assert(value is TFhirDeviceOperationalStatus);
  FhirDeviceOperationalStatuses[index] := value;
end;

procedure TFhirDeviceOperationalStatusList.SetItemN(index: Integer; value: TFhirDeviceOperationalStatus);
begin
  assert(value is TFhirDeviceOperationalStatus);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceAssociationStatus }

constructor TFhirDeviceAssociationStatus.Create;
begin
  inherited;
end;

destructor TFhirDeviceAssociationStatus.Destroy;
begin
  FValue.free;
  FReasonList.Free;
  inherited;
end;

procedure TFhirDeviceAssociationStatus.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirDeviceAssociationStatus(oSource).value.Clone;
  if (TFhirDeviceAssociationStatus(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirDeviceAssociationStatus(oSource).FReasonList);
  end;
end;

procedure TFhirDeviceAssociationStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
end;

procedure TFhirDeviceAssociationStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)) {L1039};
end;

function TFhirDeviceAssociationStatus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceAssociationStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDeviceAssociationStatus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceAssociationStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceAssociationStatus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceAssociationStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceAssociationStatus.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceAssociationStatus.fhirType : string;
begin
  result := 'Device.associationStatus';
end;

function TFhirDeviceAssociationStatus.Link : TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus(inherited Link);
end;

function TFhirDeviceAssociationStatus.Clone : TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus(inherited Clone);
end;

function TFhirDeviceAssociationStatus.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceAssociationStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceAssociationStatus)) then
    result := false
  else
  begin
    o := TFhirDeviceAssociationStatus(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonList, o.reasonList, true);
  end;
end;

function TFhirDeviceAssociationStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FreasonList);
end;

procedure TFhirDeviceAssociationStatus.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value; {L1134}
end;

function TFhirDeviceAssociationStatus.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirDeviceAssociationStatus.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirDeviceAssociationStatus.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('reason');
end;

function TFhirDeviceAssociationStatus.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
end;

{ TFhirDeviceAssociationStatusListEnumerator }

constructor TFhirDeviceAssociationStatusListEnumerator.Create(list : TFhirDeviceAssociationStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceAssociationStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceAssociationStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceAssociationStatusListEnumerator.GetCurrent : TFhirDeviceAssociationStatus;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceAssociationStatusListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceAssociationStatusList }

procedure TFhirDeviceAssociationStatusList.AddItem(value: TFhirDeviceAssociationStatus);
begin
  assert(value.ClassName = 'TFhirDeviceAssociationStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceAssociationStatus');
  add(value);
end;

function TFhirDeviceAssociationStatusList.Append: TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceAssociationStatusList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceAssociationStatusList.GetEnumerator : TFhirDeviceAssociationStatusListEnumerator;
begin
  result := TFhirDeviceAssociationStatusListEnumerator.Create(self.link);
end;

function TFhirDeviceAssociationStatusList.Clone: TFhirDeviceAssociationStatusList;
begin
  result := TFhirDeviceAssociationStatusList(inherited Clone);
end;

function TFhirDeviceAssociationStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceAssociationStatusList.GetItemN(index: Integer): TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus(ObjectByIndex[index]);
end;

function TFhirDeviceAssociationStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceAssociationStatus;
end;
function TFhirDeviceAssociationStatusList.IndexOf(value: TFhirDeviceAssociationStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceAssociationStatusList.Insert(index: Integer): TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceAssociationStatusList.InsertItem(index: Integer; value: TFhirDeviceAssociationStatus);
begin
  assert(value is TFhirDeviceAssociationStatus);
  Inherited Insert(index, value);
end;

function TFhirDeviceAssociationStatusList.Item(index: Integer): TFhirDeviceAssociationStatus;
begin
  result := TFhirDeviceAssociationStatus(ObjectByIndex[index]);
end;

function TFhirDeviceAssociationStatusList.Link: TFhirDeviceAssociationStatusList;
begin
  result := TFhirDeviceAssociationStatusList(inherited Link);
end;

procedure TFhirDeviceAssociationStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceAssociationStatusList.SetItemByIndex(index: Integer; value: TFhirDeviceAssociationStatus);
begin
  assert(value is TFhirDeviceAssociationStatus);
  FhirDeviceAssociationStatuses[index] := value;
end;

procedure TFhirDeviceAssociationStatusList.SetItemN(index: Integer; value: TFhirDeviceAssociationStatus);
begin
  assert(value is TFhirDeviceAssociationStatus);
  ObjectByIndex[index] := value;
end;

{ TFhirDevice }

constructor TFhirDevice.Create;
begin
  inherited;
end;

destructor TFhirDevice.Destroy;
begin
  FIdentifierList.Free;
  FDisplayName.free;
  FDefinition.free;
  FUdiCarrierList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FDistinctIdentifier.free;
  FManufacturer.free;
  FManufactureDate.free;
  FExpirationDate.free;
  FLotNumber.free;
  FSerialNumber.free;
  FDeviceNameList.Free;
  FModelNumber.free;
  FPartNumber.free;
  FType_List.Free;
  FSpecializationList.Free;
  FVersionList.Free;
  FProperty_List.Free;
  FPatient.free;
  FOperationalStatus.free;
  FAssociationStatus.free;
  FOwner.free;
  FContactList.Free;
  FLocation.free;
  FUrl.free;
  FNoteList.Free;
  FSafetyList.Free;
  FParent.free;
  inherited;
end;

procedure TFhirDevice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDevice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDevice(oSource).FIdentifierList);
  end;
  displayNameElement := TFhirDevice(oSource).displayNameElement.Clone;
  definition := TFhirDevice(oSource).definition.Clone;
  if (TFhirDevice(oSource).FUdiCarrierList = nil) then
  begin
    FUdiCarrierList.free;
    FUdiCarrierList := nil;
  end
  else
  begin
    if FUdiCarrierList = nil then
      FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
    FUdiCarrierList.Assign(TFhirDevice(oSource).FUdiCarrierList);
  end;
  statusElement := TFhirDevice(oSource).statusElement.Clone;
  if (TFhirDevice(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirDevice(oSource).FStatusReasonList);
  end;
  distinctIdentifierElement := TFhirDevice(oSource).distinctIdentifierElement.Clone;
  manufacturerElement := TFhirDevice(oSource).manufacturerElement.Clone;
  manufactureDateElement := TFhirDevice(oSource).manufactureDateElement.Clone;
  expirationDateElement := TFhirDevice(oSource).expirationDateElement.Clone;
  lotNumberElement := TFhirDevice(oSource).lotNumberElement.Clone;
  serialNumberElement := TFhirDevice(oSource).serialNumberElement.Clone;
  if (TFhirDevice(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDevice(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDevice(oSource).modelNumberElement.Clone;
  partNumberElement := TFhirDevice(oSource).partNumberElement.Clone;
  if (TFhirDevice(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirDevice(oSource).FType_List);
  end;
  if (TFhirDevice(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceSpecializationList.Create;
    FSpecializationList.Assign(TFhirDevice(oSource).FSpecializationList);
  end;
  if (TFhirDevice(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirDeviceVersionList.Create;
    FVersionList.Assign(TFhirDevice(oSource).FVersionList);
  end;
  if (TFhirDevice(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDevicePropertyList.Create;
    FProperty_List.Assign(TFhirDevice(oSource).FProperty_List);
  end;
  patient := TFhirDevice(oSource).patient.Clone;
  operationalStatus := TFhirDevice(oSource).operationalStatus.Clone;
  associationStatus := TFhirDevice(oSource).associationStatus.Clone;
  owner := TFhirDevice(oSource).owner.Clone;
  if (TFhirDevice(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDevice(oSource).FContactList);
  end;
  location := TFhirDevice(oSource).location.Clone;
  urlElement := TFhirDevice(oSource).urlElement.Clone;
  if (TFhirDevice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDevice(oSource).FNoteList);
  end;
  if (TFhirDevice(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDevice(oSource).FSafetyList);
  end;
  parent := TFhirDevice(oSource).parent.Clone;
end;

function TFhirDevice.GetResourceType : TFhirResourceType;
begin
  result := frtDevice;
end;

procedure TFhirDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'displayName') Then
     list.add(self.link, 'displayName', FDisplayName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'udiCarrier') Then
    list.addAll(self, 'udiCarrier', FUdiCarrierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'distinctIdentifier') Then
     list.add(self.link, 'distinctIdentifier', FDistinctIdentifier.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'manufactureDate') Then
     list.add(self.link, 'manufactureDate', FManufactureDate.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'serialNumber') Then
     list.add(self.link, 'serialNumber', FSerialNumber.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'partNumber') Then
     list.add(self.link, 'partNumber', FPartNumber.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'associationStatus') Then
     list.add(self.link, 'associationStatus', FAssociationStatus.Link);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
end;

procedure TFhirDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'displayName', 'string', false, TFhirString, FDisplayName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference', false, TFhirReference, FDefinition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'udiCarrier', 'BackboneElement', true, TFhirDeviceUdiCarrier, FUdiCarrierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'distinctIdentifier', 'string', false, TFhirString, FDistinctIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'string', false, TFhirString, FManufacturer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'manufactureDate', 'dateTime', false, TFhirDateTime, FManufactureDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'serialNumber', 'string', false, TFhirString, FSerialNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDeviceName, FDeviceNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'partNumber', 'string', false, TFhirString, FPartNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialization', 'BackboneElement', true, TFhirDeviceSpecialization, FSpecializationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'version', 'BackboneElement', true, TFhirDeviceVersion, FVersionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirDeviceProperty, FProperty_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'operationalStatus', 'BackboneElement', false, TFhirDeviceOperationalStatus, FOperationalStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'associationStatus', 'BackboneElement', false, TFhirDeviceAssociationStatus, FAssociationStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link)); {L1172}
end;

function TFhirDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'displayName') then
  begin
    DisplayNameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'udiCarrier') then
  begin
    UdiCarrierList.add(propValue as TFhirDeviceUdiCarrier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'distinctIdentifier') then
  begin
    DistinctIdentifierElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'manufactureDate') then
  begin
    ManufactureDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'serialNumber') then
  begin
    SerialNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDeviceName) {L1048};
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'partNumber') then
  begin
    PartNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceSpecialization) {L1048};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirDeviceVersion) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceProperty) {L1048};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatus := propValue as TFhirDeviceOperationalStatus {L1199};
    result := propValue;
  end
  else if (propName = 'associationStatus') then
  begin
    AssociationStatus := propValue as TFhirDeviceAssociationStatus {L1199};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'udiCarrier') then UdiCarrierList.insertItem(index, propValue as TFhirDeviceUdiCarrier) {L1049}
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDeviceName) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceSpecialization) {L1049}
  else if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirDeviceVersion) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceProperty) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'displayName') then result := TFhirString.create() {L1223}
  else if (propName = 'definition') then result := TFhirReference.create() {L1203}
  else if (propName = 'udiCarrier') then result := UdiCarrierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull], CODES_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull])  {L1211}
  else if (propName = 'statusReason') then result := StatusReasonList.new() {L1053}
  else if (propName = 'distinctIdentifier') then result := TFhirString.create() {L1223}
  else if (propName = 'manufacturer') then result := TFhirString.create() {L1223}
  else if (propName = 'manufactureDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'expirationDate') then result := TFhirDateTime.create() {L1223}
  else if (propName = 'lotNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'serialNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'deviceName') then result := DeviceNameList.new() {L1053}
  else if (propName = 'modelNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'partNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'specialization') then result := SpecializationList.new() {L1053}
  else if (propName = 'version') then result := VersionList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'operationalStatus') then result := TFhirDeviceOperationalStatus.create() {L1203}
  else if (propName = 'associationStatus') then result := TFhirDeviceAssociationStatus.create() {L1203}
  else if (propName = 'owner') then result := TFhirReference.create() {L1203}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'url') then result := TFhirUri.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'safety') then result := SafetyList.new() {L1053}
  else if (propName = 'parent') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'displayName') then result := 'string'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'udiCarrier') then result := 'BackboneElement'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'distinctIdentifier') then result := 'string'
  else if (propName = 'manufacturer') then result := 'string'
  else if (propName = 'manufactureDate') then result := 'dateTime'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'serialNumber') then result := 'string'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'partNumber') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialization') then result := 'BackboneElement'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'operationalStatus') then result := 'BackboneElement'
  else if (propName = 'associationStatus') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'parent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'displayName') then DisplayNameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'udiCarrier') then deletePropertyValue('udiCarrier', UdiCarrierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value) {L1054}
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'manufactureDate') then ManufactureDateElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'serialNumber') then SerialNumberElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value) {L1054}
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'partNumber') then PartNumberElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value) {L1054}
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'associationStatus') then AssociationStatusElement := nil
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value) {L1054}
  else if (propName = 'parent') then ParentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'displayName') then DisplayNameElement := asString(new) {L1222}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference {L1195}
  else if (propName = 'udiCarrier') then replacePropertyValue('udiCarrier', UdiCarrierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, new) {L1210}
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new) {L1055}
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := asString(new) {L1222}
  else if (propName = 'manufacturer') then ManufacturerElement := asString(new) {L1222}
  else if (propName = 'manufactureDate') then ManufactureDateElement := asDateTime(new) {L1222}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new) {L1222}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new) {L1222}
  else if (propName = 'serialNumber') then SerialNumberElement := asString(new) {L1222}
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new) {L1055}
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new) {L1222}
  else if (propName = 'partNumber') then PartNumberElement := asString(new) {L1222}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new) {L1055}
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'operationalStatus') then OperationalStatusElement := new as TFhirDeviceOperationalStatus {L1195}
  else if (propName = 'associationStatus') then AssociationStatusElement := new as TFhirDeviceAssociationStatus {L1195}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference {L1195}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'url') then UrlElement := asUri(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new) {L1055}
  else if (propName = 'parent') then ParentElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDevice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'udiCarrier') then UdiCarrierList.move(source, destination) {L1050}
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination) {L1050}
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'specialization') then SpecializationList.move(source, destination) {L1050}
  else if (propName = 'version') then VersionList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'safety') then SafetyList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDevice.fhirType : string;
begin
  result := 'Device';
end;

function TFhirDevice.Link : TFhirDevice;
begin
  result := TFhirDevice(inherited Link);
end;

function TFhirDevice.Clone : TFhirDevice;
begin
  result := TFhirDevice(inherited Clone);
end;

function TFhirDevice.equals(other : TObject) : boolean; 
var
  o : TFhirDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDevice)) then
    result := false
  else
  begin
    o := TFhirDevice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(displayNameElement, o.displayNameElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(udiCarrierList, o.udiCarrierList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonList, o.statusReasonList, true) and 
      compareDeep(distinctIdentifierElement, o.distinctIdentifierElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(manufactureDateElement, o.manufactureDateElement, true) and 
      compareDeep(expirationDateElement, o.expirationDateElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and 
      compareDeep(serialNumberElement, o.serialNumberElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(partNumberElement, o.partNumberElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(specializationList, o.specializationList, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(operationalStatusElement, o.operationalStatusElement, true) and 
      compareDeep(associationStatusElement, o.associationStatusElement, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(urlElement, o.urlElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(parentElement, o.parentElement, true);
  end;
end;

function TFhirDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDisplayName) and isEmptyProp(FDefinition) and isEmptyProp(FudiCarrierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FDistinctIdentifier) and isEmptyProp(FManufacturer) and isEmptyProp(FManufactureDate) and isEmptyProp(FExpirationDate) and isEmptyProp(FLotNumber) and isEmptyProp(FSerialNumber) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FPartNumber) and isEmptyProp(Ftype_List) and isEmptyProp(FspecializationList) and isEmptyProp(FversionList) and isEmptyProp(Fproperty_List) and isEmptyProp(FPatient) and isEmptyProp(FOperationalStatus) and isEmptyProp(FAssociationStatus) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FLocation) and isEmptyProp(FUrl) and isEmptyProp(FnoteList) and isEmptyProp(FsafetyList) and isEmptyProp(FParent);
end;

function TFhirDevice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDevice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDevice.SetDisplayName(value : TFhirString);
begin
  FDisplayName.free;
  FDisplayName := value; {L1134}
end;

function TFhirDevice.GetDisplayNameST : String;
begin
  if FDisplayName = nil then
    result := ''
  else
    result := FDisplayName.value;
end;

procedure TFhirDevice.SetDisplayNameST(value : String);
begin
  if value <> '' then
  begin
    if FDisplayName = nil then
      FDisplayName := TFhirString.create;
    FDisplayName.value := value
  end
  else if FDisplayName <> nil then
    FDisplayName.value := '';
end;

procedure TFhirDevice.SetDefinition(value : TFhirReference);
begin
  FDefinition.free;
  FDefinition := value; {L1134}
end;

function TFhirDevice.GetUdiCarrierList : TFhirDeviceUdiCarrierList;
begin
  if FUdiCarrierList = nil then
    FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
  result := FUdiCarrierList;
end;

function TFhirDevice.GetHasUdiCarrierList : boolean;
begin
  result := (FUdiCarrierList <> nil) and (FUdiCarrierList.count > 0);
end;

procedure TFhirDevice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDevice.GetStatusST : TFhirFHIRDeviceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRDeviceStatusEnum(0)
  else
    result := TFhirFHIRDeviceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRDeviceStatusEnum, FStatus.value));
end;

procedure TFhirDevice.SetStatusST(value : TFhirFHIRDeviceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFHIRDeviceStatusEnum[value], CODES_TFhirFHIRDeviceStatusEnum[value]);
end;

function TFhirDevice.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirDevice.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirDevice.SetDistinctIdentifier(value : TFhirString);
begin
  FDistinctIdentifier.free;
  FDistinctIdentifier := value; {L1134}
end;

function TFhirDevice.GetDistinctIdentifierST : String;
begin
  if FDistinctIdentifier = nil then
    result := ''
  else
    result := FDistinctIdentifier.value;
end;

procedure TFhirDevice.SetDistinctIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDistinctIdentifier = nil then
      FDistinctIdentifier := TFhirString.create;
    FDistinctIdentifier.value := value
  end
  else if FDistinctIdentifier <> nil then
    FDistinctIdentifier.value := '';
end;

procedure TFhirDevice.SetManufacturer(value : TFhirString);
begin
  FManufacturer.free;
  FManufacturer := value; {L1134}
end;

function TFhirDevice.GetManufacturerST : String;
begin
  if FManufacturer = nil then
    result := ''
  else
    result := FManufacturer.value;
end;

procedure TFhirDevice.SetManufacturerST(value : String);
begin
  if value <> '' then
  begin
    if FManufacturer = nil then
      FManufacturer := TFhirString.create;
    FManufacturer.value := value
  end
  else if FManufacturer <> nil then
    FManufacturer.value := '';
end;

procedure TFhirDevice.SetManufactureDate(value : TFhirDateTime);
begin
  FManufactureDate.free;
  FManufactureDate := value; {L1134}
end;

function TFhirDevice.GetManufactureDateST : TFslDateTime;
begin
  if FManufactureDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FManufactureDate.value;
end;

procedure TFhirDevice.SetManufactureDateST(value : TFslDateTime);
begin
  if FManufactureDate = nil then
    FManufactureDate := TFhirDateTime.create;
  FManufactureDate.value := value
end;

procedure TFhirDevice.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value; {L1134}
end;

function TFhirDevice.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirDevice.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

procedure TFhirDevice.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value; {L1134}
end;

function TFhirDevice.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirDevice.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirDevice.SetSerialNumber(value : TFhirString);
begin
  FSerialNumber.free;
  FSerialNumber := value; {L1134}
end;

function TFhirDevice.GetSerialNumberST : String;
begin
  if FSerialNumber = nil then
    result := ''
  else
    result := FSerialNumber.value;
end;

procedure TFhirDevice.SetSerialNumberST(value : String);
begin
  if value <> '' then
  begin
    if FSerialNumber = nil then
      FSerialNumber := TFhirString.create;
    FSerialNumber.value := value
  end
  else if FSerialNumber <> nil then
    FSerialNumber.value := '';
end;

function TFhirDevice.GetDeviceNameList : TFhirDeviceDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDevice.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDevice.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value; {L1134}
end;

function TFhirDevice.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDevice.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

procedure TFhirDevice.SetPartNumber(value : TFhirString);
begin
  FPartNumber.free;
  FPartNumber := value; {L1134}
end;

function TFhirDevice.GetPartNumberST : String;
begin
  if FPartNumber = nil then
    result := ''
  else
    result := FPartNumber.value;
end;

procedure TFhirDevice.SetPartNumberST(value : String);
begin
  if value <> '' then
  begin
    if FPartNumber = nil then
      FPartNumber := TFhirString.create;
    FPartNumber.value := value
  end
  else if FPartNumber <> nil then
    FPartNumber.value := '';
end;

function TFhirDevice.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirDevice.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirDevice.GetSpecializationList : TFhirDeviceSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceSpecializationList.Create;
  result := FSpecializationList;
end;

function TFhirDevice.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDevice.GetVersionList : TFhirDeviceVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirDeviceVersionList.Create;
  result := FVersionList;
end;

function TFhirDevice.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDevice.GetProperty_List : TFhirDevicePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDevicePropertyList.Create;
  result := FProperty_List;
end;

function TFhirDevice.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirDevice.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

procedure TFhirDevice.SetOperationalStatus(value : TFhirDeviceOperationalStatus);
begin
  FOperationalStatus.free;
  FOperationalStatus := value; {L1134}
end;

procedure TFhirDevice.SetAssociationStatus(value : TFhirDeviceAssociationStatus);
begin
  FAssociationStatus.free;
  FAssociationStatus := value; {L1134}
end;

procedure TFhirDevice.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value; {L1134}
end;

function TFhirDevice.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDevice.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirDevice.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirDevice.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value; {L1134}
end;

function TFhirDevice.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirDevice.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirDevice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDevice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDevice.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDevice.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

procedure TFhirDevice.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value; {L1134}
end;

procedure TFhirDevice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('displayName');
  fields.add('definition');
  fields.add('udiCarrier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('distinctIdentifier');
  fields.add('manufacturer');
  fields.add('manufactureDate');
  fields.add('expirationDate');
  fields.add('lotNumber');
  fields.add('serialNumber');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('partNumber');
  fields.add('type');
  fields.add('specialization');
  fields.add('version');
  fields.add('property');
  fields.add('patient');
  fields.add('operationalStatus');
  fields.add('associationStatus');
  fields.add('owner');
  fields.add('contact');
  fields.add('location');
  fields.add('url');
  fields.add('note');
  fields.add('safety');
  fields.add('parent');
end;

function TFhirDevice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDisplayName.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FudiCarrierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusReasonList.sizeInBytes);
  inc(result, FDistinctIdentifier.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FManufactureDate.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FSerialNumber.sizeInBytes);
  inc(result, FdeviceNameList.sizeInBytes);
  inc(result, FModelNumber.sizeInBytes);
  inc(result, FPartNumber.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FspecializationList.sizeInBytes);
  inc(result, FversionList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FOperationalStatus.sizeInBytes);
  inc(result, FAssociationStatus.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsafetyList.sizeInBytes);
end;

{ TFhirDeviceListEnumerator }

constructor TFhirDeviceListEnumerator.Create(list : TFhirDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceListEnumerator.GetCurrent : TFhirDevice;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceList }

procedure TFhirDeviceList.AddItem(value: TFhirDevice);
begin
  assert(value.ClassName = 'TFhirDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDevice');
  add(value);
end;

function TFhirDeviceList.Append: TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceList.GetEnumerator : TFhirDeviceListEnumerator;
begin
  result := TFhirDeviceListEnumerator.Create(self.link);
end;

function TFhirDeviceList.Clone: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Clone);
end;

function TFhirDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceList.GetItemN(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDevice;
end;
function TFhirDeviceList.IndexOf(value: TFhirDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceList.Insert(index: Integer): TFhirDevice;
begin
  result := TFhirDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.InsertItem(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceList.Item(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.Link: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Link);
end;

procedure TFhirDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceList.SetItemByIndex(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  FhirDevices[index] := value;
end;

procedure TFhirDeviceList.SetItemN(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
{ TFhirDeviceDefinitionUdiDeviceIdentifier }

constructor TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  inherited;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).jurisdictionElement.Clone;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link)); {L1172}
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.create() {L1223}
  else if (propName = 'issuer') then result := TFhirUri.create() {L1223}
  else if (propName = 'jurisdiction') then result := TFhirUri.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new) {L1222}
  else if (propName = 'issuer') then IssuerElement := asUri(new) {L1222}
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.fhirType : string;
begin
  result := 'DeviceDefinition.udiDeviceIdentifier';
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Link : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Clone : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionUdiDeviceIdentifier)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionUdiDeviceIdentifier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true);
  end;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value; {L1134}
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value; {L1134}
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value; {L1134}
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDeviceIdentifier.sizeInBytes);
  inc(result, FIssuer.sizeInBytes);
  inc(result, FJurisdiction.sizeInBytes);
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator }

constructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierList }

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.AddItem(value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionUdiDeviceIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionUdiDeviceIdentifier');
  add(value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Append: TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Clone: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetItemN(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier;
end;
function TFhirDeviceDefinitionUdiDeviceIdentifierList.IndexOf(value: TFhirDeviceDefinitionUdiDeviceIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Insert(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.InsertItem(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Item(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Link: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  FhirDeviceDefinitionUdiDeviceIdentifiers[index] := value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemN(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionDeviceName }

constructor TFhirDeviceDefinitionDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDefinitionDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDefinitionDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDefinitionDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDefinitionDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDefinitionDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
end;

function TFhirDeviceDefinitionDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionDeviceName.fhirType : string;
begin
  result := 'DeviceDefinition.deviceName';
end;

function TFhirDeviceDefinitionDeviceName.Link : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Link);
end;

function TFhirDeviceDefinitionDeviceName.Clone : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDefinitionDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDefinitionDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirDeviceDefinitionDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDefinitionDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

procedure TFhirDeviceDefinitionDeviceName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDefinitionDeviceName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirDeviceDefinitionDeviceNameListEnumerator }

constructor TFhirDeviceDefinitionDeviceNameListEnumerator.Create(list : TFhirDeviceDefinitionDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionDeviceNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.GetCurrent : TFhirDeviceDefinitionDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionDeviceNameList }

procedure TFhirDeviceDefinitionDeviceNameList.AddItem(value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionDeviceName');
  add(value);
end;

function TFhirDeviceDefinitionDeviceNameList.Append: TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionDeviceNameList.GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
begin
  result := TFhirDeviceDefinitionDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionDeviceNameList.Clone: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionDeviceNameList.GetItemN(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionDeviceName;
end;
function TFhirDeviceDefinitionDeviceNameList.IndexOf(value: TFhirDeviceDefinitionDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionDeviceNameList.Insert(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionDeviceNameList.Item(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.Link: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDefinitionDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  FhirDeviceDefinitionDeviceNames[index] := value;
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionSpecialization }

constructor TFhirDeviceDefinitionSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  inherited;
end;

procedure TFhirDeviceDefinitionSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemTypeElement := TFhirDeviceDefinitionSpecialization(oSource).systemTypeElement.Clone;
  versionElement := TFhirDeviceDefinitionSpecialization(oSource).versionElement.Clone;
end;

procedure TFhirDeviceDefinitionSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirDeviceDefinitionSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'systemType', 'string', false, TFhirString, FSystemType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link)); {L1172}
end;

function TFhirDeviceDefinitionSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemTypeElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirString.create() {L1223}
  else if (propName = 'version') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := asString(new) {L1222}
  else if (propName = 'version') then VersionElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionSpecialization.fhirType : string;
begin
  result := 'DeviceDefinition.specialization';
end;

function TFhirDeviceDefinitionSpecialization.Link : TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(inherited Link);
end;

function TFhirDeviceDefinitionSpecialization.Clone : TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(inherited Clone);
end;

function TFhirDeviceDefinitionSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirDeviceDefinitionSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion);
end;

procedure TFhirDeviceDefinitionSpecialization.SetSystemType(value : TFhirString);
begin
  FSystemType.free;
  FSystemType := value; {L1134}
end;

function TFhirDeviceDefinitionSpecialization.GetSystemTypeST : String;
begin
  if FSystemType = nil then
    result := ''
  else
    result := FSystemType.value;
end;

procedure TFhirDeviceDefinitionSpecialization.SetSystemTypeST(value : String);
begin
  if value <> '' then
  begin
    if FSystemType = nil then
      FSystemType := TFhirString.create;
    FSystemType.value := value
  end
  else if FSystemType <> nil then
    FSystemType.value := '';
end;

procedure TFhirDeviceDefinitionSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value; {L1134}
end;

function TFhirDeviceDefinitionSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirDeviceDefinitionSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirDeviceDefinitionSpecialization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
end;

function TFhirDeviceDefinitionSpecialization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystemType.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
end;

{ TFhirDeviceDefinitionSpecializationListEnumerator }

constructor TFhirDeviceDefinitionSpecializationListEnumerator.Create(list : TFhirDeviceDefinitionSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionSpecializationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.GetCurrent : TFhirDeviceDefinitionSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionSpecializationList }

procedure TFhirDeviceDefinitionSpecializationList.AddItem(value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionSpecialization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionSpecialization');
  add(value);
end;

function TFhirDeviceDefinitionSpecializationList.Append: TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionSpecializationList.GetEnumerator : TFhirDeviceDefinitionSpecializationListEnumerator;
begin
  result := TFhirDeviceDefinitionSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionSpecializationList.Clone: TFhirDeviceDefinitionSpecializationList;
begin
  result := TFhirDeviceDefinitionSpecializationList(inherited Clone);
end;

function TFhirDeviceDefinitionSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionSpecializationList.GetItemN(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionSpecialization;
end;
function TFhirDeviceDefinitionSpecializationList.IndexOf(value: TFhirDeviceDefinitionSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionSpecializationList.Insert(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionSpecializationList.InsertItem(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionSpecializationList.Item(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionSpecializationList.Link: TFhirDeviceDefinitionSpecializationList;
begin
  result := TFhirDeviceDefinitionSpecializationList(inherited Link);
end;

procedure TFhirDeviceDefinitionSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  FhirDeviceDefinitionSpecializations[index] := value;
end;

procedure TFhirDeviceDefinitionSpecializationList.SetItemN(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionCapability }

constructor TFhirDeviceDefinitionCapability.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionCapability.Destroy;
begin
  FType_.free;
  FDescriptionList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionCapability.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionCapability(oSource).type_.Clone;
  if (TFhirDeviceDefinitionCapability(oSource).FDescriptionList = nil) then
  begin
    FDescriptionList.free;
    FDescriptionList := nil;
  end
  else
  begin
    if FDescriptionList = nil then
      FDescriptionList := TFhirCodeableConceptList.Create;
    FDescriptionList.Assign(TFhirDeviceDefinitionCapability(oSource).FDescriptionList);
  end;
end;

procedure TFhirDeviceDefinitionCapability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
    list.addAll(self, 'description', FDescriptionList);
end;

procedure TFhirDeviceDefinitionCapability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', true, TFhirCodeableConcept, FDescriptionList.Link)) {L1039};
end;

function TFhirDeviceDefinitionCapability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionCapability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'description') then DescriptionList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDeviceDefinitionCapability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'description') then result := DescriptionList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionCapability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionCapability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then deletePropertyValue('description', DescriptionList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionCapability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'description') then replacePropertyValue('description', DescriptionList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionCapability.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'description') then DescriptionList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionCapability.fhirType : string;
begin
  result := 'DeviceDefinition.capability';
end;

function TFhirDeviceDefinitionCapability.Link : TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(inherited Link);
end;

function TFhirDeviceDefinitionCapability.Clone : TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(inherited Clone);
end;

function TFhirDeviceDefinitionCapability.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionCapability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionCapability)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionCapability(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionList, o.descriptionList, true);
  end;
end;

function TFhirDeviceDefinitionCapability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdescriptionList);
end;

procedure TFhirDeviceDefinitionCapability.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirDeviceDefinitionCapability.GetDescriptionList : TFhirCodeableConceptList;
begin
  if FDescriptionList = nil then
    FDescriptionList := TFhirCodeableConceptList.Create;
  result := FDescriptionList;
end;

function TFhirDeviceDefinitionCapability.GetHasDescriptionList : boolean;
begin
  result := (FDescriptionList <> nil) and (FDescriptionList.count > 0);
end;

procedure TFhirDeviceDefinitionCapability.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('description');
end;

function TFhirDeviceDefinitionCapability.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FdescriptionList.sizeInBytes);
end;

{ TFhirDeviceDefinitionCapabilityListEnumerator }

constructor TFhirDeviceDefinitionCapabilityListEnumerator.Create(list : TFhirDeviceDefinitionCapabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionCapabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.GetCurrent : TFhirDeviceDefinitionCapability;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionCapabilityList }

procedure TFhirDeviceDefinitionCapabilityList.AddItem(value: TFhirDeviceDefinitionCapability);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionCapability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionCapability');
  add(value);
end;

function TFhirDeviceDefinitionCapabilityList.Append: TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCapabilityList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionCapabilityList.GetEnumerator : TFhirDeviceDefinitionCapabilityListEnumerator;
begin
  result := TFhirDeviceDefinitionCapabilityListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionCapabilityList.Clone: TFhirDeviceDefinitionCapabilityList;
begin
  result := TFhirDeviceDefinitionCapabilityList(inherited Clone);
end;

function TFhirDeviceDefinitionCapabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionCapabilityList.GetItemN(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCapabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionCapability;
end;
function TFhirDeviceDefinitionCapabilityList.IndexOf(value: TFhirDeviceDefinitionCapability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionCapabilityList.Insert(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCapabilityList.InsertItem(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionCapabilityList.Item(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCapabilityList.Link: TFhirDeviceDefinitionCapabilityList;
begin
  result := TFhirDeviceDefinitionCapabilityList(inherited Link);
end;

procedure TFhirDeviceDefinitionCapabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionCapabilityList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  FhirDeviceDefinitionCapabilities[index] := value;
end;

procedure TFhirDeviceDefinitionCapabilityList.SetItemN(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionProperty }

constructor TFhirDeviceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionProperty.Destroy;
begin
  FType_.free;
  FValueQuantityList.Free;
  FValueCodeList.Free;
  inherited;
end;

procedure TFhirDeviceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionProperty(oSource).type_.Clone;
  if (TFhirDeviceDefinitionProperty(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirDeviceDefinitionProperty(oSource).FValueQuantityList);
  end;
  if (TFhirDeviceDefinitionProperty(oSource).FValueCodeList = nil) then
  begin
    FValueCodeList.free;
    FValueCodeList := nil;
  end
  else
  begin
    if FValueCodeList = nil then
      FValueCodeList := TFhirCodeableConceptList.Create;
    FValueCodeList.Assign(TFhirDeviceDefinitionProperty(oSource).FValueCodeList);
  end;
end;

procedure TFhirDeviceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueCode') Then
    list.addAll(self, 'valueCode', FValueCodeList);
end;

procedure TFhirDeviceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'valueCode', 'CodeableConcept', true, TFhirCodeableConcept, FValueCodeList.Link)) {L1039};
end;

function TFhirDeviceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity) {L1048};
    result := propValue;
  end
  else if (propName = 'valueCode') then
  begin
    ValueCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity) {L1049}
  else if (propName = 'valueCode') then ValueCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirDeviceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new() {L1053}
  else if (propName = 'valueCode') then result := ValueCodeList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value) {L1054}
  else if (propName = 'valueCode') then deletePropertyValue('valueCode', ValueCodeList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new) {L1055}
  else if (propName = 'valueCode') then replacePropertyValue('valueCode', ValueCodeList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination) {L1050}
  else if (propName = 'valueCode') then ValueCodeList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionProperty.fhirType : string;
begin
  result := 'DeviceDefinition.property';
end;

function TFhirDeviceDefinitionProperty.Link : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Link);
end;

function TFhirDeviceDefinitionProperty.Clone : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Clone);
end;

function TFhirDeviceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueQuantityList, o.valueQuantityList, true) and 
      compareDeep(valueCodeList, o.valueCodeList, true);
  end;
end;

function TFhirDeviceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueCodeList);
end;

procedure TFhirDeviceDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirDeviceDefinitionProperty.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirDeviceDefinitionProperty.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirDeviceDefinitionProperty.GetValueCodeList : TFhirCodeableConceptList;
begin
  if FValueCodeList = nil then
    FValueCodeList := TFhirCodeableConceptList.Create;
  result := FValueCodeList;
end;

function TFhirDeviceDefinitionProperty.GetHasValueCodeList : boolean;
begin
  result := (FValueCodeList <> nil) and (FValueCodeList.count > 0);
end;

procedure TFhirDeviceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('valueQuantity');
  fields.add('valueCode');
end;

function TFhirDeviceDefinitionProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FvalueQuantityList.sizeInBytes);
  inc(result, FvalueCodeList.sizeInBytes);
end;

{ TFhirDeviceDefinitionPropertyListEnumerator }

constructor TFhirDeviceDefinitionPropertyListEnumerator.Create(list : TFhirDeviceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.GetCurrent : TFhirDeviceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionPropertyList }

procedure TFhirDeviceDefinitionPropertyList.AddItem(value: TFhirDeviceDefinitionProperty);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionProperty');
  add(value);
end;

function TFhirDeviceDefinitionPropertyList.Append: TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionPropertyList.GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
begin
  result := TFhirDeviceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionPropertyList.Clone: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Clone);
end;

function TFhirDeviceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionPropertyList.GetItemN(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionProperty;
end;
function TFhirDeviceDefinitionPropertyList.IndexOf(value: TFhirDeviceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionPropertyList.Insert(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionPropertyList.Item(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.Link: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Link);
end;

procedure TFhirDeviceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  FhirDeviceDefinitionProperties[index] := value;
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionMaterial }

constructor TFhirDeviceDefinitionMaterial.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionMaterial.Destroy;
begin
  FSubstance.free;
  FAlternate.free;
  FAllergenicIndicator.free;
  inherited;
end;

procedure TFhirDeviceDefinitionMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirDeviceDefinitionMaterial(oSource).substance.Clone;
  alternateElement := TFhirDeviceDefinitionMaterial(oSource).alternateElement.Clone;
  allergenicIndicatorElement := TFhirDeviceDefinitionMaterial(oSource).allergenicIndicatorElement.Clone;
end;

procedure TFhirDeviceDefinitionMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'alternate') Then
     list.add(self.link, 'alternate', FAlternate.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
end;

procedure TFhirDeviceDefinitionMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alternate', 'boolean', false, TFhirBoolean, FAlternate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link)); {L1172}
end;

function TFhirDeviceDefinitionMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'alternate') then
  begin
    AlternateElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'alternate') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'alternate') then result := 'boolean'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'alternate') then AlternateElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'alternate') then AlternateElement := asBoolean(new) {L1222}
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionMaterial.fhirType : string;
begin
  result := 'DeviceDefinition.material';
end;

function TFhirDeviceDefinitionMaterial.Link : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Link);
end;

function TFhirDeviceDefinitionMaterial.Clone : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Clone);
end;

function TFhirDeviceDefinitionMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionMaterial)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionMaterial(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(alternateElement, o.alternateElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true);
  end;
end;

function TFhirDeviceDefinitionMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FAlternate) and isEmptyProp(FAllergenicIndicator);
end;

procedure TFhirDeviceDefinitionMaterial.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value; {L1134}
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternate(value : TFhirBoolean);
begin
  FAlternate.free;
  FAlternate := value; {L1134}
end;

function TFhirDeviceDefinitionMaterial.GetAlternateST : Boolean;
begin
  if FAlternate = nil then
    result := false
  else
    result := FAlternate.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternateST(value : Boolean);
begin
  if FAlternate = nil then
    FAlternate := TFhirBoolean.create;
  FAlternate.value := value
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value; {L1134}
end;

function TFhirDeviceDefinitionMaterial.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

procedure TFhirDeviceDefinitionMaterial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance');
  fields.add('alternate');
  fields.add('allergenicIndicator');
end;

function TFhirDeviceDefinitionMaterial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FAlternate.sizeInBytes);
  inc(result, FAllergenicIndicator.sizeInBytes);
end;

{ TFhirDeviceDefinitionMaterialListEnumerator }

constructor TFhirDeviceDefinitionMaterialListEnumerator.Create(list : TFhirDeviceDefinitionMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.GetCurrent : TFhirDeviceDefinitionMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionMaterialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionMaterialList }

procedure TFhirDeviceDefinitionMaterialList.AddItem(value: TFhirDeviceDefinitionMaterial);
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionMaterial');
  add(value);
end;

function TFhirDeviceDefinitionMaterialList.Append: TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionMaterialList.GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
begin
  result := TFhirDeviceDefinitionMaterialListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionMaterialList.Clone: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Clone);
end;

function TFhirDeviceDefinitionMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionMaterialList.GetItemN(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionMaterial;
end;
function TFhirDeviceDefinitionMaterialList.IndexOf(value: TFhirDeviceDefinitionMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionMaterialList.Insert(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.InsertItem(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionMaterialList.Item(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.Link: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Link);
end;

procedure TFhirDeviceDefinitionMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  FhirDeviceDefinitionMaterials[index] := value;
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemN(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinition }

constructor TFhirDeviceDefinition.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinition.Destroy;
begin
  FIdentifierList.Free;
  FUdiDeviceIdentifierList.Free;
  FManufacturer.free;
  FDeviceNameList.Free;
  FModelNumber.free;
  FType_.free;
  FSpecializationList.Free;
  FVersionList.Free;
  FSafetyList.Free;
  FShelfLifeStorageList.Free;
  FPhysicalCharacteristics.free;
  FLanguageCodeList.Free;
  FCapabilityList.Free;
  FProperty_List.Free;
  FOwner.free;
  FContactList.Free;
  FOnlineInformation.free;
  FNoteList.Free;
  FQuantity.free;
  FParentDevice.free;
  FMaterialList.Free;
  inherited;
end;

procedure TFhirDeviceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceDefinition(oSource).FIdentifierList);
  end;
  if (TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList = nil) then
  begin
    FUdiDeviceIdentifierList.free;
    FUdiDeviceIdentifierList := nil;
  end
  else
  begin
    if FUdiDeviceIdentifierList = nil then
      FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
    FUdiDeviceIdentifierList.Assign(TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList);
  end;
  manufacturer := TFhirDeviceDefinition(oSource).manufacturer.Clone;
  if (TFhirDeviceDefinition(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDeviceDefinition(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDeviceDefinition(oSource).modelNumberElement.Clone;
  type_ := TFhirDeviceDefinition(oSource).type_.Clone;
  if (TFhirDeviceDefinition(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceDefinitionSpecializationList.Create;
    FSpecializationList.Assign(TFhirDeviceDefinition(oSource).FSpecializationList);
  end;
  if (TFhirDeviceDefinition(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirStringList.Create;
    FVersionList.Assign(TFhirDeviceDefinition(oSource).FVersionList);
  end;
  if (TFhirDeviceDefinition(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDeviceDefinition(oSource).FSafetyList);
  end;
  if (TFhirDeviceDefinition(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirDeviceDefinition(oSource).FShelfLifeStorageList);
  end;
  physicalCharacteristics := TFhirDeviceDefinition(oSource).physicalCharacteristics.Clone;
  if (TFhirDeviceDefinition(oSource).FLanguageCodeList = nil) then
  begin
    FLanguageCodeList.free;
    FLanguageCodeList := nil;
  end
  else
  begin
    if FLanguageCodeList = nil then
      FLanguageCodeList := TFhirCodeableConceptList.Create;
    FLanguageCodeList.Assign(TFhirDeviceDefinition(oSource).FLanguageCodeList);
  end;
  if (TFhirDeviceDefinition(oSource).FCapabilityList = nil) then
  begin
    FCapabilityList.free;
    FCapabilityList := nil;
  end
  else
  begin
    if FCapabilityList = nil then
      FCapabilityList := TFhirDeviceDefinitionCapabilityList.Create;
    FCapabilityList.Assign(TFhirDeviceDefinition(oSource).FCapabilityList);
  end;
  if (TFhirDeviceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirDeviceDefinition(oSource).FProperty_List);
  end;
  owner := TFhirDeviceDefinition(oSource).owner.Clone;
  if (TFhirDeviceDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDeviceDefinition(oSource).FContactList);
  end;
  onlineInformationElement := TFhirDeviceDefinition(oSource).onlineInformationElement.Clone;
  if (TFhirDeviceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceDefinition(oSource).FNoteList);
  end;
  quantity := TFhirDeviceDefinition(oSource).quantity.Clone;
  parentDevice := TFhirDeviceDefinition(oSource).parentDevice.Clone;
  if (TFhirDeviceDefinition(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
    FMaterialList.Assign(TFhirDeviceDefinition(oSource).FMaterialList);
  end;
end;

function TFhirDeviceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceDefinition;
end;

procedure TFhirDeviceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'udiDeviceIdentifier') Then
    list.addAll(self, 'udiDeviceIdentifier', FUdiDeviceIdentifierList);
  if (child_name = 'manufacturer[x]') or (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer[x]', FManufacturer.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'physicalCharacteristics') Then
     list.add(self.link, 'physicalCharacteristics', FPhysicalCharacteristics.Link);
  if (child_name = 'languageCode') Then
    list.addAll(self, 'languageCode', FLanguageCodeList);
  if (child_name = 'capability') Then
    list.addAll(self, 'capability', FCapabilityList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'onlineInformation') Then
     list.add(self.link, 'onlineInformation', FOnlineInformation.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parentDevice') Then
     list.add(self.link, 'parentDevice', FParentDevice.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
end;

procedure TFhirDeviceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'udiDeviceIdentifier', 'BackboneElement', true, TFhirDeviceDefinitionUdiDeviceIdentifier, FUdiDeviceIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'manufacturer[x]', 'string|Reference', false, TFhirDataType, FManufacturer.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDefinitionDeviceName, FDeviceNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'specialization', 'BackboneElement', true, TFhirDeviceDefinitionSpecialization, FSpecializationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'version', 'string', true, TFhirString, FVersionList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'physicalCharacteristics', 'ProdCharacteristic', false, TFhirProdCharacteristic, FPhysicalCharacteristics.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'languageCode', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'capability', 'BackboneElement', true, TFhirDeviceDefinitionCapability, FCapabilityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirDeviceDefinitionProperty, FProperty_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'onlineInformation', 'uri', false, TFhirUri, FOnlineInformation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parentDevice', 'Reference', false, TFhirReference, FParentDevice.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'material', 'BackboneElement', true, TFhirDeviceDefinitionMaterial, FMaterialList.Link)) {L1039};
end;

function TFhirDeviceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'udiDeviceIdentifier') then
  begin
    UdiDeviceIdentifierList.add(propValue as TFhirDeviceDefinitionUdiDeviceIdentifier) {L1048};
    result := propValue;
  end
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then
  begin
    Manufacturer := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDefinitionDeviceName) {L1048};
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceDefinitionSpecialization) {L1048};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife) {L1048};
    result := propValue;
  end
  else if (propName = 'physicalCharacteristics') then
  begin
    PhysicalCharacteristics := propValue as TFhirProdCharacteristic {L1199};
    result := propValue;
  end
  else if (propName = 'languageCode') then
  begin
    LanguageCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'capability') then
  begin
    CapabilityList.add(propValue as TFhirDeviceDefinitionCapability) {L1048};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceDefinitionProperty) {L1048};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'onlineInformation') then
  begin
    OnlineInformationElement := asUri(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation) {L1048};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity {L1199};
    result := propValue;
  end
  else if (propName = 'parentDevice') then
  begin
    ParentDevice := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirDeviceDefinitionMaterial) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.insertItem(index, propValue as TFhirDeviceDefinitionUdiDeviceIdentifier) {L1049}
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDefinitionDeviceName) {L1049}
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceDefinitionSpecialization) {L1049}
  else if (propName = 'version') then VersionList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife) {L1049}
  else if (propName = 'languageCode') then LanguageCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'capability') then CapabilityList.insertItem(index, propValue as TFhirDeviceDefinitionCapability) {L1049}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceDefinitionProperty) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation) {L1049}
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirDeviceDefinitionMaterial) {L1049}
  else inherited;
end;

function TFhirDeviceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'udiDeviceIdentifier') then result := UdiDeviceIdentifierList.new() {L1053}
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then raise EFHIRException.create('Cannot make property Manufacturer') {L1191}
  else if (propName = 'deviceName') then result := DeviceNameList.new() {L1053}
  else if (propName = 'modelNumber') then result := TFhirString.create() {L1223}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'specialization') then result := SpecializationList.new() {L1053}
  else if (propName = 'version') then result := VersionList.new() {L1053}
  else if (propName = 'safety') then result := SafetyList.new() {L1053}
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new() {L1053}
  else if (propName = 'physicalCharacteristics') then result := TFhirProdCharacteristic.create() {L1203}
  else if (propName = 'languageCode') then result := LanguageCodeList.new() {L1053}
  else if (propName = 'capability') then result := CapabilityList.new() {L1053}
  else if (propName = 'property') then result := Property_List.new() {L1053}
  else if (propName = 'owner') then result := TFhirReference.create() {L1203}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'onlineInformation') then result := TFhirUri.create() {L1223}
  else if (propName = 'note') then result := NoteList.new() {L1053}
  else if (propName = 'quantity') then result := TFhirQuantity.create() {L1203}
  else if (propName = 'parentDevice') then result := TFhirReference.create() {L1203}
  else if (propName = 'material') then result := MaterialList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'udiDeviceIdentifier') then result := 'BackboneElement'
  else if (propName = 'manufacturer[x]') then result := 'string|Reference'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialization') then result := 'BackboneElement'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'physicalCharacteristics') then result := 'ProdCharacteristic'
  else if (propName = 'languageCode') then result := 'CodeableConcept'
  else if (propName = 'capability') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'onlineInformation') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'parentDevice') then result := 'Reference'
  else if (propName = 'material') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'udiDeviceIdentifier') then deletePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, value) {L1054}
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then ManufacturerElement := nil {L1189}
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value) {L1054}
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value) {L1054}
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value) {L1054}
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value) {L1054}
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value) {L1054}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := nil
  else if (propName = 'languageCode') then deletePropertyValue('languageCode', LanguageCodeList, value) {L1054}
  else if (propName = 'capability') then deletePropertyValue('capability', CapabilityList, value) {L1054}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {L1054}
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'onlineInformation') then OnlineInformationElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {L1054}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parentDevice') then ParentDeviceElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'udiDeviceIdentifier') then replacePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, existing, new) {L1055}
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then ManufacturerElement := new as TFhirDataType {L1190}
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new) {L1055}
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new) {L1222}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new) {L1055}
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new) {L1055}
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new) {L1055}
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new) {L1055}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := new as TFhirProdCharacteristic {L1195}
  else if (propName = 'languageCode') then replacePropertyValue('languageCode', LanguageCodeList, existing, new) {L1055}
  else if (propName = 'capability') then replacePropertyValue('capability', CapabilityList, existing, new) {L1055}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {L1055}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference {L1195}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'onlineInformation') then OnlineInformationElement := asUri(new) {L1222}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {L1055}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity {L1195}
  else if (propName = 'parentDevice') then ParentDeviceElement := new as TFhirReference {L1195}
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.move(source, destination) {L1050}
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination) {L1050}
  else if (propName = 'specialization') then SpecializationList.move(source, destination) {L1050}
  else if (propName = 'version') then VersionList.move(source, destination) {L1046}
  else if (propName = 'safety') then SafetyList.move(source, destination) {L1050}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination) {L1050}
  else if (propName = 'languageCode') then LanguageCodeList.move(source, destination) {L1050}
  else if (propName = 'capability') then CapabilityList.move(source, destination) {L1050}
  else if (propName = 'property') then Property_List.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'note') then NoteList.move(source, destination) {L1050}
  else if (propName = 'material') then MaterialList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinition.fhirType : string;
begin
  result := 'DeviceDefinition';
end;

function TFhirDeviceDefinition.Link : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Link);
end;

function TFhirDeviceDefinition.Clone : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Clone);
end;

function TFhirDeviceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinition)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(udiDeviceIdentifierList, o.udiDeviceIdentifierList, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(specializationList, o.specializationList, true) and compareDeep(versionList, o.versionList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(physicalCharacteristicsElement, o.physicalCharacteristicsElement, true) and 
      compareDeep(languageCodeList, o.languageCodeList, true) and compareDeep(capabilityList, o.capabilityList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(onlineInformationElement, o.onlineInformationElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parentDeviceElement, o.parentDeviceElement, true) and compareDeep(materialList, o.materialList, true);
  end;
end;

function TFhirDeviceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FudiDeviceIdentifierList) and isEmptyProp(FManufacturer) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FType_) and isEmptyProp(FspecializationList) and isEmptyProp(FversionList) and isEmptyProp(FsafetyList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FPhysicalCharacteristics) and isEmptyProp(FlanguageCodeList) and isEmptyProp(FcapabilityList) and isEmptyProp(Fproperty_List) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FOnlineInformation) and isEmptyProp(FnoteList) and isEmptyProp(FQuantity) and isEmptyProp(FParentDevice) and isEmptyProp(FmaterialList);
end;

function TFhirDeviceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceDefinition.GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  if FUdiDeviceIdentifierList = nil then
    FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
  result := FUdiDeviceIdentifierList;
end;

function TFhirDeviceDefinition.GetHasUdiDeviceIdentifierList : boolean;
begin
  result := (FUdiDeviceIdentifierList <> nil) and (FUdiDeviceIdentifierList.count > 0);
end;

procedure TFhirDeviceDefinition.SetManufacturer(value : TFhirDataType);
begin
  FManufacturer.free;
  FManufacturer := value; {L1134}
end;

function TFhirDeviceDefinition.GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDeviceDefinition.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDeviceDefinition.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value; {L1134}
end;

function TFhirDeviceDefinition.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDeviceDefinition.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

procedure TFhirDeviceDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

function TFhirDeviceDefinition.GetSpecializationList : TFhirDeviceDefinitionSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceDefinitionSpecializationList.Create;
  result := FSpecializationList;
end;

function TFhirDeviceDefinition.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDeviceDefinition.GetVersionList : TFhirStringList;
begin
  if FVersionList = nil then
    FVersionList := TFhirStringList.Create;
  result := FVersionList;
end;

function TFhirDeviceDefinition.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDeviceDefinition.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDeviceDefinition.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

function TFhirDeviceDefinition.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirDeviceDefinition.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

procedure TFhirDeviceDefinition.SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
begin
  FPhysicalCharacteristics.free;
  FPhysicalCharacteristics := value; {L1134}
end;

function TFhirDeviceDefinition.GetLanguageCodeList : TFhirCodeableConceptList;
begin
  if FLanguageCodeList = nil then
    FLanguageCodeList := TFhirCodeableConceptList.Create;
  result := FLanguageCodeList;
end;

function TFhirDeviceDefinition.GetHasLanguageCodeList : boolean;
begin
  result := (FLanguageCodeList <> nil) and (FLanguageCodeList.count > 0);
end;

function TFhirDeviceDefinition.GetCapabilityList : TFhirDeviceDefinitionCapabilityList;
begin
  if FCapabilityList = nil then
    FCapabilityList := TFhirDeviceDefinitionCapabilityList.Create;
  result := FCapabilityList;
end;

function TFhirDeviceDefinition.GetHasCapabilityList : boolean;
begin
  result := (FCapabilityList <> nil) and (FCapabilityList.count > 0);
end;

function TFhirDeviceDefinition.GetProperty_List : TFhirDeviceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirDeviceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirDeviceDefinition.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value; {L1134}
end;

function TFhirDeviceDefinition.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDeviceDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirDeviceDefinition.SetOnlineInformation(value : TFhirUri);
begin
  FOnlineInformation.free;
  FOnlineInformation := value; {L1134}
end;

function TFhirDeviceDefinition.GetOnlineInformationST : String;
begin
  if FOnlineInformation = nil then
    result := ''
  else
    result := FOnlineInformation.value;
end;

procedure TFhirDeviceDefinition.SetOnlineInformationST(value : String);
begin
  if value <> '' then
  begin
    if FOnlineInformation = nil then
      FOnlineInformation := TFhirUri.create;
    FOnlineInformation.value := value
  end
  else if FOnlineInformation <> nil then
    FOnlineInformation.value := '';
end;

function TFhirDeviceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirDeviceDefinition.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

procedure TFhirDeviceDefinition.SetParentDevice(value : TFhirReference);
begin
  FParentDevice.free;
  FParentDevice := value; {L1134}
end;

function TFhirDeviceDefinition.GetMaterialList : TFhirDeviceDefinitionMaterialList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
  result := FMaterialList;
end;

function TFhirDeviceDefinition.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

procedure TFhirDeviceDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('udiDeviceIdentifier');
  fields.add('manufacturer[x]');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('type');
  fields.add('specialization');
  fields.add('version');
  fields.add('safety');
  fields.add('shelfLifeStorage');
  fields.add('physicalCharacteristics');
  fields.add('languageCode');
  fields.add('capability');
  fields.add('property');
  fields.add('owner');
  fields.add('contact');
  fields.add('onlineInformation');
  fields.add('note');
  fields.add('quantity');
  fields.add('parentDevice');
  fields.add('material');
end;

function TFhirDeviceDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FudiDeviceIdentifierList.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FdeviceNameList.sizeInBytes);
  inc(result, FModelNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FspecializationList.sizeInBytes);
  inc(result, FversionList.sizeInBytes);
  inc(result, FsafetyList.sizeInBytes);
  inc(result, FshelfLifeStorageList.sizeInBytes);
  inc(result, FPhysicalCharacteristics.sizeInBytes);
  inc(result, FlanguageCodeList.sizeInBytes);
  inc(result, FcapabilityList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FOnlineInformation.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FParentDevice.sizeInBytes);
  inc(result, FmaterialList.sizeInBytes);
end;

{ TFhirDeviceDefinitionListEnumerator }

constructor TFhirDeviceDefinitionListEnumerator.Create(list : TFhirDeviceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionListEnumerator.GetCurrent : TFhirDeviceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceDefinitionList }

procedure TFhirDeviceDefinitionList.AddItem(value: TFhirDeviceDefinition);
begin
  assert(value.ClassName = 'TFhirDeviceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinition');
  add(value);
end;

function TFhirDeviceDefinitionList.Append: TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionList.GetEnumerator : TFhirDeviceDefinitionListEnumerator;
begin
  result := TFhirDeviceDefinitionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionList.Clone: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Clone);
end;

function TFhirDeviceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionList.GetItemN(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinition;
end;
function TFhirDeviceDefinitionList.IndexOf(value: TFhirDeviceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionList.Insert(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.InsertItem(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionList.Item(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.Link: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Link);
end;

procedure TFhirDeviceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  FhirDeviceDefinitions[index] := value;
end;

procedure TFhirDeviceDefinitionList.SetItemN(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
{ TFhirDeviceMetricCalibration }

constructor TFhirDeviceMetricCalibration.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetricCalibration.Destroy;
begin
  FType_.free;
  FState.free;
  FTime.free;
  inherited;
end;

procedure TFhirDeviceMetricCalibration.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirDeviceMetricCalibration(oSource).type_Element.Clone;
  stateElement := TFhirDeviceMetricCalibration(oSource).stateElement.Clone;
  timeElement := TFhirDeviceMetricCalibration(oSource).timeElement.Clone;
end;

procedure TFhirDeviceMetricCalibration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
end;

procedure TFhirDeviceMetricCalibration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'state', 'code', false, TFhirEnum, FState.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'time', 'instant', false, TFhirInstant, FTime.Link)); {L1172}
end;

function TFhirDeviceMetricCalibration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'state') then
  begin
    StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetricCalibration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceMetricCalibration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull], CODES_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull])  {L1211}
  else if (propName = 'state') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull], CODES_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull])  {L1211}
  else if (propName = 'time') then result := TFhirInstant.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetricCalibration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'state') then result := 'code'
  else if (propName = 'time') then result := 'instant'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetricCalibration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'state') then StateElement := nil
  else if (propName = 'time') then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetricCalibration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, new) {L1210}
  else if (propName = 'state') then StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, new) {L1210}
  else if (propName = 'time') then TimeElement := asInstant(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetricCalibration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetricCalibration.fhirType : string;
begin
  result := 'DeviceMetric.calibration';
end;

function TFhirDeviceMetricCalibration.Link : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Link);
end;

function TFhirDeviceMetricCalibration.Clone : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Clone);
end;

function TFhirDeviceMetricCalibration.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetricCalibration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetricCalibration)) then
    result := false
  else
  begin
    o := TFhirDeviceMetricCalibration(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(stateElement, o.stateElement, true) and 
      compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirDeviceMetricCalibration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FState) and isEmptyProp(FTime);
end;

procedure TFhirDeviceMetricCalibration.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceMetricCalibration.GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceMetricCalibrationTypeEnum(0)
  else
    result := TFhirDeviceMetricCalibrationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationTypeEnum, FType_.value));
end;

procedure TFhirDeviceMetricCalibration.SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[value], CODES_TFhirDeviceMetricCalibrationTypeEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetState(value : TFhirEnum);
begin
  FState.free;
  FState := value;
end;

function TFhirDeviceMetricCalibration.GetStateST : TFhirDeviceMetricCalibrationStateEnum;
begin
  if FState = nil then
    result := TFhirDeviceMetricCalibrationStateEnum(0)
  else
    result := TFhirDeviceMetricCalibrationStateEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationStateEnum, FState.value));
end;

procedure TFhirDeviceMetricCalibration.SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
begin
  if ord(value) = 0 then
    StateElement := nil
  else
    StateElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[value], CODES_TFhirDeviceMetricCalibrationStateEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetTime(value : TFhirInstant);
begin
  FTime.free;
  FTime := value; {L1134}
end;

function TFhirDeviceMetricCalibration.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirDeviceMetricCalibration.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirInstant.create;
  FTime.value := value
end;

procedure TFhirDeviceMetricCalibration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('state');
  fields.add('time');
end;

function TFhirDeviceMetricCalibration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FState.sizeInBytes);
  inc(result, FTime.sizeInBytes);
end;

{ TFhirDeviceMetricCalibrationListEnumerator }

constructor TFhirDeviceMetricCalibrationListEnumerator.Create(list : TFhirDeviceMetricCalibrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricCalibrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceMetricCalibrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricCalibrationListEnumerator.GetCurrent : TFhirDeviceMetricCalibration;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricCalibrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceMetricCalibrationList }

procedure TFhirDeviceMetricCalibrationList.AddItem(value: TFhirDeviceMetricCalibration);
begin
  assert(value.ClassName = 'TFhirDeviceMetricCalibration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetricCalibration');
  add(value);
end;

function TFhirDeviceMetricCalibrationList.Append: TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricCalibrationList.GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
begin
  result := TFhirDeviceMetricCalibrationListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricCalibrationList.Clone: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Clone);
end;

function TFhirDeviceMetricCalibrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricCalibrationList.GetItemN(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetricCalibration;
end;
function TFhirDeviceMetricCalibrationList.IndexOf(value: TFhirDeviceMetricCalibration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricCalibrationList.Insert(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.InsertItem(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricCalibrationList.Item(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.Link: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Link);
end;

procedure TFhirDeviceMetricCalibrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricCalibrationList.SetItemByIndex(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  FhirDeviceMetricCalibrations[index] := value;
end;

procedure TFhirDeviceMetricCalibrationList.SetItemN(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceMetric }

constructor TFhirDeviceMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetric.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FUnit_.free;
  FSource.free;
  FParent.free;
  FOperationalStatus.free;
  FColor.free;
  FCategory.free;
  FMeasurementPeriod.free;
  FCalibrationList.Free;
  inherited;
end;

procedure TFhirDeviceMetric.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceMetric(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceMetric(oSource).FIdentifierList);
  end;
  type_ := TFhirDeviceMetric(oSource).type_.Clone;
  unit_ := TFhirDeviceMetric(oSource).unit_.Clone;
  source := TFhirDeviceMetric(oSource).source.Clone;
  parent := TFhirDeviceMetric(oSource).parent.Clone;
  operationalStatusElement := TFhirDeviceMetric(oSource).operationalStatusElement.Clone;
  colorElement := TFhirDeviceMetric(oSource).colorElement.Clone;
  categoryElement := TFhirDeviceMetric(oSource).categoryElement.Clone;
  measurementPeriod := TFhirDeviceMetric(oSource).measurementPeriod.Clone;
  if (TFhirDeviceMetric(oSource).FCalibrationList = nil) then
  begin
    FCalibrationList.free;
    FCalibrationList := nil;
  end
  else
  begin
    if FCalibrationList = nil then
      FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
    FCalibrationList.Assign(TFhirDeviceMetric(oSource).FCalibrationList);
  end;
end;

function TFhirDeviceMetric.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceMetric;
end;

procedure TFhirDeviceMetric.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'measurementPeriod') Then
     list.add(self.link, 'measurementPeriod', FMeasurementPeriod.Link);
  if (child_name = 'calibration') Then
    list.addAll(self, 'calibration', FCalibrationList);
end;

procedure TFhirDeviceMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'operationalStatus', 'code', false, TFhirEnum, FOperationalStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'color', 'code', false, TFhirEnum, FColor.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFhirEnum, FCategory.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'measurementPeriod', 'Timing', false, TFhirTiming, FMeasurementPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'calibration', 'BackboneElement', true, TFhirDeviceMetricCalibration, FCalibrationList.Link)) {L1039};
end;

function TFhirDeviceMetric.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'measurementPeriod') then
  begin
    MeasurementPeriod := propValue as TFhirTiming {L1199};
    result := propValue;
  end
  else if (propName = 'calibration') then
  begin
    CalibrationList.add(propValue as TFhirDeviceMetricCalibration) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetric.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'calibration') then CalibrationList.insertItem(index, propValue as TFhirDeviceMetricCalibration) {L1049}
  else inherited;
end;

function TFhirDeviceMetric.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'type') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'source') then result := TFhirReference.create() {L1203}
  else if (propName = 'parent') then result := TFhirReference.create() {L1203}
  else if (propName = 'operationalStatus') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull], CODES_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull])  {L1211}
  else if (propName = 'color') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricColorEnum[DeviceMetricColorNull], CODES_TFhirDeviceMetricColorEnum[DeviceMetricColorNull])  {L1211}
  else if (propName = 'category') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull], CODES_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull])  {L1211}
  else if (propName = 'measurementPeriod') then result := TFhirTiming.create() {L1203}
  else if (propName = 'calibration') then result := CalibrationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetric.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'operationalStatus') then result := 'code'
  else if (propName = 'color') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'measurementPeriod') then result := 'Timing'
  else if (propName = 'calibration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetric.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := nil
  else if (propName = 'calibration') then deletePropertyValue('calibration', CalibrationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetric.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept {L1195}
  else if (propName = 'source') then SourceElement := new as TFhirReference {L1195}
  else if (propName = 'parent') then ParentElement := new as TFhirReference {L1195}
  else if (propName = 'operationalStatus') then OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, new) {L1210}
  else if (propName = 'color') then ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, new) {L1210}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, new) {L1210}
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := new as TFhirTiming {L1195}
  else if (propName = 'calibration') then replacePropertyValue('calibration', CalibrationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetric.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'calibration') then CalibrationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetric.fhirType : string;
begin
  result := 'DeviceMetric';
end;

function TFhirDeviceMetric.Link : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Link);
end;

function TFhirDeviceMetric.Clone : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Clone);
end;

function TFhirDeviceMetric.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetric;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetric)) then
    result := false
  else
  begin
    o := TFhirDeviceMetric(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(operationalStatusElement, o.operationalStatusElement, true) and 
      compareDeep(colorElement, o.colorElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(measurementPeriodElement, o.measurementPeriodElement, true) and compareDeep(calibrationList, o.calibrationList, true);
  end;
end;

function TFhirDeviceMetric.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FUnit_) and isEmptyProp(FSource) and isEmptyProp(FParent) and isEmptyProp(FOperationalStatus) and isEmptyProp(FColor) and isEmptyProp(FCategory) and isEmptyProp(FMeasurementPeriod) and isEmptyProp(FcalibrationList);
end;

function TFhirDeviceMetric.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceMetric.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDeviceMetric.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value; {L1134}
end;

procedure TFhirDeviceMetric.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value; {L1134}
end;

procedure TFhirDeviceMetric.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value; {L1134}
end;

procedure TFhirDeviceMetric.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value; {L1134}
end;

procedure TFhirDeviceMetric.SetOperationalStatus(value : TFhirEnum);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

function TFhirDeviceMetric.GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
begin
  if FOperationalStatus = nil then
    result := TFhirDeviceMetricOperationalStatusEnum(0)
  else
    result := TFhirDeviceMetricOperationalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricOperationalStatusEnum, FOperationalStatus.value));
end;

procedure TFhirDeviceMetric.SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
begin
  if ord(value) = 0 then
    OperationalStatusElement := nil
  else
    OperationalStatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[value], CODES_TFhirDeviceMetricOperationalStatusEnum[value]);
end;

procedure TFhirDeviceMetric.SetColor(value : TFhirEnum);
begin
  FColor.free;
  FColor := value;
end;

function TFhirDeviceMetric.GetColorST : TFhirDeviceMetricColorEnum;
begin
  if FColor = nil then
    result := TFhirDeviceMetricColorEnum(0)
  else
    result := TFhirDeviceMetricColorEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricColorEnum, FColor.value));
end;

procedure TFhirDeviceMetric.SetColorST(value : TFhirDeviceMetricColorEnum);
begin
  if ord(value) = 0 then
    ColorElement := nil
  else
    ColorElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricColorEnum[value], CODES_TFhirDeviceMetricColorEnum[value]);
end;

procedure TFhirDeviceMetric.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirDeviceMetric.GetCategoryST : TFhirDeviceMetricCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirDeviceMetricCategoryEnum(0)
  else
    result := TFhirDeviceMetricCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCategoryEnum, FCategory.value));
end;

procedure TFhirDeviceMetric.SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirDeviceMetricCategoryEnum[value], CODES_TFhirDeviceMetricCategoryEnum[value]);
end;

procedure TFhirDeviceMetric.SetMeasurementPeriod(value : TFhirTiming);
begin
  FMeasurementPeriod.free;
  FMeasurementPeriod := value; {L1134}
end;

function TFhirDeviceMetric.GetCalibrationList : TFhirDeviceMetricCalibrationList;
begin
  if FCalibrationList = nil then
    FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
  result := FCalibrationList;
end;

function TFhirDeviceMetric.GetHasCalibrationList : boolean;
begin
  result := (FCalibrationList <> nil) and (FCalibrationList.count > 0);
end;

procedure TFhirDeviceMetric.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('unit');
  fields.add('source');
  fields.add('parent');
  fields.add('operationalStatus');
  fields.add('color');
  fields.add('category');
  fields.add('measurementPeriod');
  fields.add('calibration');
end;

function TFhirDeviceMetric.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FOperationalStatus.sizeInBytes);
  inc(result, FColor.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMeasurementPeriod.sizeInBytes);
  inc(result, FcalibrationList.sizeInBytes);
end;

{ TFhirDeviceMetricListEnumerator }

constructor TFhirDeviceMetricListEnumerator.Create(list : TFhirDeviceMetricList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceMetricListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricListEnumerator.GetCurrent : TFhirDeviceMetric;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceMetricList }

procedure TFhirDeviceMetricList.AddItem(value: TFhirDeviceMetric);
begin
  assert(value.ClassName = 'TFhirDeviceMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetric');
  add(value);
end;

function TFhirDeviceMetricList.Append: TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricList.GetEnumerator : TFhirDeviceMetricListEnumerator;
begin
  result := TFhirDeviceMetricListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricList.Clone: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Clone);
end;

function TFhirDeviceMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricList.GetItemN(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetric;
end;
function TFhirDeviceMetricList.IndexOf(value: TFhirDeviceMetric): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricList.Insert(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.InsertItem(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricList.Item(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.Link: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Link);
end;

procedure TFhirDeviceMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  FhirDeviceMetrics[index] := value;
end;

procedure TFhirDeviceMetricList.SetItemN(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
{ TFhirEncounterStatusHistory }

constructor TFhirEncounterStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirEncounterStatusHistory(oSource).statusElement.Clone;
  period := TFhirEncounterStatusHistory(oSource).period.Clone;
end;

procedure TFhirEncounterStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirEncounterStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull])  {L1211}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new) {L1210}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterStatusHistory.fhirType : string;
begin
  result := 'Encounter.statusHistory';
end;

function TFhirEncounterStatusHistory.Link : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Link);
end;

function TFhirEncounterStatusHistory.Clone : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Clone);
end;

function TFhirEncounterStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterStatusHistory.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounterStatusHistory.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

procedure TFhirEncounterStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEncounterStatusHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

function TFhirEncounterStatusHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirEncounterStatusHistoryListEnumerator }

constructor TFhirEncounterStatusHistoryListEnumerator.Create(list : TFhirEncounterStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterStatusHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterStatusHistoryListEnumerator.GetCurrent : TFhirEncounterStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterStatusHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterStatusHistoryList }

procedure TFhirEncounterStatusHistoryList.AddItem(value: TFhirEncounterStatusHistory);
begin
  assert(value.ClassName = 'TFhirEncounterStatusHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterStatusHistory');
  add(value);
end;

function TFhirEncounterStatusHistoryList.Append: TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterStatusHistoryList.GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
begin
  result := TFhirEncounterStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterStatusHistoryList.Clone: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Clone);
end;

function TFhirEncounterStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterStatusHistoryList.GetItemN(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterStatusHistory;
end;
function TFhirEncounterStatusHistoryList.IndexOf(value: TFhirEncounterStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterStatusHistoryList.Insert(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.InsertItem(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterStatusHistoryList.Item(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.Link: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Link);
end;

procedure TFhirEncounterStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  FhirEncounterStatusHistories[index] := value;
end;

procedure TFhirEncounterStatusHistoryList.SetItemN(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterClassHistory }

constructor TFhirEncounterClassHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterClassHistory.Destroy;
begin
  FClass_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterClassHistory.Assign(oSource : TFslObject);
begin
  inherited;
  class_ := TFhirEncounterClassHistory(oSource).class_.Clone;
  period := TFhirEncounterClassHistory(oSource).period.Clone;
end;

procedure TFhirEncounterClassHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterClassHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirEncounterClassHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterClassHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterClassHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'class') then result := TFhirCoding.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterClassHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'class') then result := 'Coding'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterClassHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterClassHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := new as TFhirCoding {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterClassHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterClassHistory.fhirType : string;
begin
  result := 'Encounter.classHistory';
end;

function TFhirEncounterClassHistory.Link : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Link);
end;

function TFhirEncounterClassHistory.Clone : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Clone);
end;

function TFhirEncounterClassHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterClassHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterClassHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterClassHistory(other);
    result := compareDeep(class_Element, o.class_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterClassHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClass_) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterClassHistory.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value; {L1134}
end;

procedure TFhirEncounterClassHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEncounterClassHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('class');
  fields.add('period');
end;

function TFhirEncounterClassHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClass_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirEncounterClassHistoryListEnumerator }

constructor TFhirEncounterClassHistoryListEnumerator.Create(list : TFhirEncounterClassHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterClassHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterClassHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterClassHistoryListEnumerator.GetCurrent : TFhirEncounterClassHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterClassHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterClassHistoryList }

procedure TFhirEncounterClassHistoryList.AddItem(value: TFhirEncounterClassHistory);
begin
  assert(value.ClassName = 'TFhirEncounterClassHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterClassHistory');
  add(value);
end;

function TFhirEncounterClassHistoryList.Append: TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterClassHistoryList.GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
begin
  result := TFhirEncounterClassHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterClassHistoryList.Clone: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Clone);
end;

function TFhirEncounterClassHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterClassHistoryList.GetItemN(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterClassHistory;
end;
function TFhirEncounterClassHistoryList.IndexOf(value: TFhirEncounterClassHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterClassHistoryList.Insert(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.InsertItem(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterClassHistoryList.Item(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.Link: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Link);
end;

procedure TFhirEncounterClassHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterClassHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  FhirEncounterClassHistories[index] := value;
end;

procedure TFhirEncounterClassHistoryList.SetItemN(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.Free;
  FPeriod.free;
  FIndividual.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounterParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  end;
  period := TFhirEncounterParticipant(oSource).period.Clone;
  individual := TFhirEncounterParticipant(oSource).individual.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'individual', 'Reference', false, TFhirReference, FIndividual.Link)); {L1172}
end;

function TFhirEncounterParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirEncounterParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'individual') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'individual') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'individual') then IndividualElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterParticipant.fhirType : string;
begin
  result := 'Encounter.participant';
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

function TFhirEncounterParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterParticipant)) then
    result := false
  else
  begin
    o := TFhirEncounterParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(individualElement, o.individualElement, true);
  end;
end;

function TFhirEncounterParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FPeriod) and isEmptyProp(FIndividual);
end;

function TFhirEncounterParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounterParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirEncounterParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEncounterParticipant.SetIndividual(value : TFhirReference);
begin
  FIndividual.free;
  FIndividual := value; {L1134}
end;

procedure TFhirEncounterParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('individual');
end;

function TFhirEncounterParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FIndividual.sizeInBytes);
end;

{ TFhirEncounterParticipantListEnumerator }

constructor TFhirEncounterParticipantListEnumerator.Create(list : TFhirEncounterParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterParticipantListEnumerator.GetCurrent : TFhirEncounterParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterParticipantList }

procedure TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant);
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
end;

function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.GetEnumerator : TFhirEncounterParticipantListEnumerator;
begin
  result := TFhirEncounterParticipantListEnumerator.Create(self.link);
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterParticipant;
end;
function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterDiagnosis }

constructor TFhirEncounterDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEncounterDiagnosis.Destroy;
begin
  FCondition.free;
  FUse.free;
  FRank.free;
  inherited;
end;

procedure TFhirEncounterDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEncounterDiagnosis(oSource).condition.Clone;
  use := TFhirEncounterDiagnosis(oSource).use.Clone;
  rankElement := TFhirEncounterDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEncounterDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEncounterDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'use', 'CodeableConcept', false, TFhirCodeableConcept, FUse.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link)); {L1172}
end;

function TFhirEncounterDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference.create() {L1203}
  else if (propName = 'use') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'rank') then result := TFhirPositiveInt.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'use') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference {L1195}
  else if (propName = 'use') then UseElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'rank') then RankElement := asPositiveInt(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterDiagnosis.fhirType : string;
begin
  result := 'Encounter.diagnosis';
end;

function TFhirEncounterDiagnosis.Link : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Link);
end;

function TFhirEncounterDiagnosis.Clone : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Clone);
end;

function TFhirEncounterDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEncounterDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEncounterDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FUse) and isEmptyProp(FRank);
end;

procedure TFhirEncounterDiagnosis.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value; {L1134}
end;

procedure TFhirEncounterDiagnosis.SetUse(value : TFhirCodeableConcept);
begin
  FUse.free;
  FUse := value; {L1134}
end;

procedure TFhirEncounterDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value; {L1134}
end;

function TFhirEncounterDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

procedure TFhirEncounterDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

procedure TFhirEncounterDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('condition');
  fields.add('use');
  fields.add('rank');
end;

function TFhirEncounterDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCondition.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FRank.sizeInBytes);
end;

{ TFhirEncounterDiagnosisListEnumerator }

constructor TFhirEncounterDiagnosisListEnumerator.Create(list : TFhirEncounterDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterDiagnosisListEnumerator.GetCurrent : TFhirEncounterDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterDiagnosisList }

procedure TFhirEncounterDiagnosisList.AddItem(value: TFhirEncounterDiagnosis);
begin
  assert(value.ClassName = 'TFhirEncounterDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterDiagnosis');
  add(value);
end;

function TFhirEncounterDiagnosisList.Append: TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterDiagnosisList.GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
begin
  result := TFhirEncounterDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEncounterDiagnosisList.Clone: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Clone);
end;

function TFhirEncounterDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterDiagnosisList.GetItemN(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterDiagnosis;
end;
function TFhirEncounterDiagnosisList.IndexOf(value: TFhirEncounterDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterDiagnosisList.Insert(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.InsertItem(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEncounterDiagnosisList.Item(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.Link: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Link);
end;

procedure TFhirEncounterDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  FhirEncounterDiagnoses[index] := value;
end;

procedure TFhirEncounterDiagnosisList.SetItemN(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FReAdmission.free;
  FDietPreferenceList.Free;
  FSpecialCourtesyList.Free;
  FSpecialArrangementList.Free;
  FDestination.free;
  FDischargeDisposition.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TFslObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  reAdmission := TFhirEncounterHospitalization(oSource).reAdmission.Clone;
  if (TFhirEncounterHospitalization(oSource).FDietPreferenceList = nil) then
  begin
    FDietPreferenceList.free;
    FDietPreferenceList := nil;
  end
  else
  begin
    if FDietPreferenceList = nil then
      FDietPreferenceList := TFhirCodeableConceptList.Create;
    FDietPreferenceList.Assign(TFhirEncounterHospitalization(oSource).FDietPreferenceList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialCourtesyList = nil) then
  begin
    FSpecialCourtesyList.free;
    FSpecialCourtesyList := nil;
  end
  else
  begin
    if FSpecialCourtesyList = nil then
      FSpecialCourtesyList := TFhirCodeableConceptList.Create;
    FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialArrangementList = nil) then
  begin
    FSpecialArrangementList.free;
    FSpecialArrangementList := nil;
  end
  else
  begin
    if FSpecialArrangementList = nil then
      FSpecialArrangementList := TFhirCodeableConceptList.Create;
    FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  end;
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(self.link, 'preAdmissionIdentifier', FPreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'admitSource') Then
     list.add(self.link, 'admitSource', FAdmitSource.Link);
  if (child_name = 'reAdmission') Then
     list.add(self.link, 'reAdmission', FReAdmission.Link);
  if (child_name = 'dietPreference') Then
    list.addAll(self, 'dietPreference', FDietPreferenceList);
  if (child_name = 'specialCourtesy') Then
    list.addAll(self, 'specialCourtesy', FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
    list.addAll(self, 'specialArrangement', FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(self.link, 'dischargeDisposition', FDischargeDisposition.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'preAdmissionIdentifier', 'Identifier', false, TFhirIdentifier, FPreAdmissionIdentifier.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'origin', 'Reference', false, TFhirReference, FOrigin.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'admitSource', 'CodeableConcept', false, TFhirCodeableConcept, FAdmitSource.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FReAdmission.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dietPreference', 'CodeableConcept', true, TFhirCodeableConcept, FDietPreferenceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialCourtesy', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialCourtesyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialArrangement', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialArrangementList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'dischargeDisposition', 'CodeableConcept', false, TFhirCodeableConcept, FDischargeDisposition.Link)); {L1172}
end;

function TFhirEncounterHospitalization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then
  begin
    PreAdmissionIdentifier := propValue as TFhirIdentifier {L1199};
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    Origin := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'admitSource') then
  begin
    AdmitSource := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'reAdmission') then
  begin
    ReAdmission := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'dietPreference') then
  begin
    DietPreferenceList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialCourtesy') then
  begin
    SpecialCourtesyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialArrangement') then
  begin
    SpecialArrangementList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'dischargeDisposition') then
  begin
    DischargeDisposition := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterHospitalization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialArrangement') then SpecialArrangementList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirEncounterHospitalization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then result := TFhirIdentifier.create() {L1203}
  else if (propName = 'origin') then result := TFhirReference.create() {L1203}
  else if (propName = 'admitSource') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'reAdmission') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'dietPreference') then result := DietPreferenceList.new() {L1053}
  else if (propName = 'specialCourtesy') then result := SpecialCourtesyList.new() {L1053}
  else if (propName = 'specialArrangement') then result := SpecialArrangementList.new() {L1053}
  else if (propName = 'destination') then result := TFhirReference.create() {L1203}
  else if (propName = 'dischargeDisposition') then result := TFhirCodeableConcept.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterHospitalization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'preAdmissionIdentifier') then result := 'Identifier'
  else if (propName = 'origin') then result := 'Reference'
  else if (propName = 'admitSource') then result := 'CodeableConcept'
  else if (propName = 'reAdmission') then result := 'CodeableConcept'
  else if (propName = 'dietPreference') then result := 'CodeableConcept'
  else if (propName = 'specialCourtesy') then result := 'CodeableConcept'
  else if (propName = 'specialArrangement') then result := 'CodeableConcept'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'dischargeDisposition') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterHospitalization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'admitSource') then AdmitSourceElement := nil
  else if (propName = 'reAdmission') then ReAdmissionElement := nil
  else if (propName = 'dietPreference') then deletePropertyValue('dietPreference', DietPreferenceList, value) {L1054}
  else if (propName = 'specialCourtesy') then deletePropertyValue('specialCourtesy', SpecialCourtesyList, value) {L1054}
  else if (propName = 'specialArrangement') then deletePropertyValue('specialArrangement', SpecialArrangementList, value) {L1054}
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterHospitalization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := new as TFhirIdentifier {L1195}
  else if (propName = 'origin') then OriginElement := new as TFhirReference {L1195}
  else if (propName = 'admitSource') then AdmitSourceElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'reAdmission') then ReAdmissionElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'dietPreference') then replacePropertyValue('dietPreference', DietPreferenceList, existing, new) {L1055}
  else if (propName = 'specialCourtesy') then replacePropertyValue('specialCourtesy', SpecialCourtesyList, existing, new) {L1055}
  else if (propName = 'specialArrangement') then replacePropertyValue('specialArrangement', SpecialArrangementList, existing, new) {L1055}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference {L1195}
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := new as TFhirCodeableConcept {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterHospitalization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.move(source, destination) {L1050}
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.move(source, destination) {L1050}
  else if (propName = 'specialArrangement') then SpecialArrangementList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterHospitalization.fhirType : string;
begin
  result := 'Encounter.hospitalization';
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

function TFhirEncounterHospitalization.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterHospitalization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterHospitalization)) then
    result := false
  else
  begin
    o := TFhirEncounterHospitalization(other);
    result := compareDeep(preAdmissionIdentifierElement, o.preAdmissionIdentifierElement, true) and 
      compareDeep(originElement, o.originElement, true) and compareDeep(admitSourceElement, o.admitSourceElement, true) and 
      compareDeep(reAdmissionElement, o.reAdmissionElement, true) and compareDeep(dietPreferenceList, o.dietPreferenceList, true) and 
      compareDeep(specialCourtesyList, o.specialCourtesyList, true) and compareDeep(specialArrangementList, o.specialArrangementList, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(dischargeDispositionElement, o.dischargeDispositionElement, true);
  end;
end;

function TFhirEncounterHospitalization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPreAdmissionIdentifier) and isEmptyProp(FOrigin) and isEmptyProp(FAdmitSource) and isEmptyProp(FReAdmission) and isEmptyProp(FdietPreferenceList) and isEmptyProp(FspecialCourtesyList) and isEmptyProp(FspecialArrangementList) and isEmptyProp(FDestination) and isEmptyProp(FDischargeDisposition);
end;

procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value; {L1134}
end;

procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirReference);
begin
  FOrigin.free;
  FOrigin := value; {L1134}
end;

procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value; {L1134}
end;

procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirCodeableConcept);
begin
  FReAdmission.free;
  FReAdmission := value; {L1134}
end;

function TFhirEncounterHospitalization.GetDietPreferenceList : TFhirCodeableConceptList;
begin
  if FDietPreferenceList = nil then
    FDietPreferenceList := TFhirCodeableConceptList.Create;
  result := FDietPreferenceList;
end;

function TFhirEncounterHospitalization.GetHasDietPreferenceList : boolean;
begin
  result := (FDietPreferenceList <> nil) and (FDietPreferenceList.count > 0);
end;

function TFhirEncounterHospitalization.GetSpecialCourtesyList : TFhirCodeableConceptList;
begin
  if FSpecialCourtesyList = nil then
    FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  result := FSpecialCourtesyList;
end;

function TFhirEncounterHospitalization.GetHasSpecialCourtesyList : boolean;
begin
  result := (FSpecialCourtesyList <> nil) and (FSpecialCourtesyList.count > 0);
end;

function TFhirEncounterHospitalization.GetSpecialArrangementList : TFhirCodeableConceptList;
begin
  if FSpecialArrangementList = nil then
    FSpecialArrangementList := TFhirCodeableConceptList.Create;
  result := FSpecialArrangementList;
end;

function TFhirEncounterHospitalization.GetHasSpecialArrangementList : boolean;
begin
  result := (FSpecialArrangementList <> nil) and (FSpecialArrangementList.count > 0);
end;

procedure TFhirEncounterHospitalization.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value; {L1134}
end;

procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value; {L1134}
end;

procedure TFhirEncounterHospitalization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('preAdmissionIdentifier');
  fields.add('origin');
  fields.add('admitSource');
  fields.add('reAdmission');
  fields.add('dietPreference');
  fields.add('specialCourtesy');
  fields.add('specialArrangement');
  fields.add('destination');
  fields.add('dischargeDisposition');
end;

function TFhirEncounterHospitalization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPreAdmissionIdentifier.sizeInBytes);
  inc(result, FOrigin.sizeInBytes);
  inc(result, FAdmitSource.sizeInBytes);
  inc(result, FReAdmission.sizeInBytes);
  inc(result, FdietPreferenceList.sizeInBytes);
  inc(result, FspecialCourtesyList.sizeInBytes);
  inc(result, FspecialArrangementList.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FDischargeDisposition.sizeInBytes);
end;

{ TFhirEncounterHospitalizationListEnumerator }

constructor TFhirEncounterHospitalizationListEnumerator.Create(list : TFhirEncounterHospitalizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterHospitalizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterHospitalizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterHospitalizationListEnumerator.GetCurrent : TFhirEncounterHospitalization;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterHospitalizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterHospitalizationList }

procedure TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization);
begin
  assert(value.ClassName = 'TFhirEncounterHospitalization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalization');
  add(value);
end;

function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
begin
  result := TFhirEncounterHospitalizationListEnumerator.Create(self.link);
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterHospitalization;
end;
function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FStatus.free;
  FPhysicalType.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TFslObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  statusElement := TFhirEncounterLocation(oSource).statusElement.Clone;
  physicalType := TFhirEncounterLocation(oSource).physicalType.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirEncounterLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'location') then
  begin
    Location := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'location') then result := TFhirReference.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull], CODES_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull])  {L1211}
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'location') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := new as TFhirReference {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, new) {L1210}
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterLocation.fhirType : string;
begin
  result := 'Encounter.location';
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

function TFhirEncounterLocation.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterLocation)) then
    result := false
  else
  begin
    o := TFhirEncounterLocation(other);
    result := compareDeep(locationElement, o.locationElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLocation) and isEmptyProp(FStatus) and isEmptyProp(FPhysicalType) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterLocation.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value; {L1134}
end;

procedure TFhirEncounterLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterLocation.GetStatusST : TFhirEncounterLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterLocationStatusEnum(0)
  else
    result := TFhirEncounterLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterLocationStatusEnum, FStatus.value));
end;

procedure TFhirEncounterLocation.SetStatusST(value : TFhirEncounterLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterLocationStatusEnum[value], CODES_TFhirEncounterLocationStatusEnum[value]);
end;

procedure TFhirEncounterLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value; {L1134}
end;

procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEncounterLocation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('location');
  fields.add('status');
  fields.add('physicalType');
  fields.add('period');
end;

function TFhirEncounterLocation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLocation.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPhysicalType.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirEncounterLocationListEnumerator }

constructor TFhirEncounterLocationListEnumerator.Create(list : TFhirEncounterLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterLocationListEnumerator.GetCurrent : TFhirEncounterLocation;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterLocationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterLocationList }

procedure TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation);
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
end;

function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.GetEnumerator : TFhirEncounterLocationListEnumerator;
begin
  result := TFhirEncounterLocationListEnumerator.Create(self.link);
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterLocation;
end;
function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounter }

constructor TFhirEncounter.Create;
begin
  inherited;
end;

destructor TFhirEncounter.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusHistoryList.Free;
  FClass_.free;
  FClassHistoryList.Free;
  FType_List.Free;
  FServiceType.free;
  FPriority.free;
  FSubject.free;
  FSubjectStatus.free;
  FEpisodeOfCareList.Free;
  FBasedOnList.Free;
  FParticipantList.Free;
  FAppointmentList.Free;
  FPeriod.free;
  FLength.free;
  FReasonList.Free;
  FDiagnosisList.Free;
  FAccountList.Free;
  FHospitalization.free;
  FLocationList.Free;
  FServiceProvider.free;
  FPartOf.free;
  inherited;
end;

procedure TFhirEncounter.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounter(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEncounter(oSource).FIdentifierList);
  end;
  statusElement := TFhirEncounter(oSource).statusElement.Clone;
  if (TFhirEncounter(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEncounter(oSource).FStatusHistoryList);
  end;
  class_ := TFhirEncounter(oSource).class_.Clone;
  if (TFhirEncounter(oSource).FClassHistoryList = nil) then
  begin
    FClassHistoryList.free;
    FClassHistoryList := nil;
  end
  else
  begin
    if FClassHistoryList = nil then
      FClassHistoryList := TFhirEncounterClassHistoryList.Create;
    FClassHistoryList.Assign(TFhirEncounter(oSource).FClassHistoryList);
  end;
  if (TFhirEncounter(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounter(oSource).FType_List);
  end;
  serviceType := TFhirEncounter(oSource).serviceType.Clone;
  priority := TFhirEncounter(oSource).priority.Clone;
  subject := TFhirEncounter(oSource).subject.Clone;
  subjectStatus := TFhirEncounter(oSource).subjectStatus.Clone;
  if (TFhirEncounter(oSource).FEpisodeOfCareList = nil) then
  begin
    FEpisodeOfCareList.free;
    FEpisodeOfCareList := nil;
  end
  else
  begin
    if FEpisodeOfCareList = nil then
      FEpisodeOfCareList := TFhirReferenceList.Create;
    FEpisodeOfCareList.Assign(TFhirEncounter(oSource).FEpisodeOfCareList);
  end;
  if (TFhirEncounter(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirEncounter(oSource).FBasedOnList);
  end;
  if (TFhirEncounter(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirEncounterParticipantList.Create;
    FParticipantList.Assign(TFhirEncounter(oSource).FParticipantList);
  end;
  if (TFhirEncounter(oSource).FAppointmentList = nil) then
  begin
    FAppointmentList.free;
    FAppointmentList := nil;
  end
  else
  begin
    if FAppointmentList = nil then
      FAppointmentList := TFhirReferenceList.Create;
    FAppointmentList.Assign(TFhirEncounter(oSource).FAppointmentList);
  end;
  period := TFhirEncounter(oSource).period.Clone;
  length := TFhirEncounter(oSource).length.Clone;
  if (TFhirEncounter(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableReferenceList.Create;
    FReasonList.Assign(TFhirEncounter(oSource).FReasonList);
  end;
  if (TFhirEncounter(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEncounterDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEncounter(oSource).FDiagnosisList);
  end;
  if (TFhirEncounter(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirEncounter(oSource).FAccountList);
  end;
  hospitalization := TFhirEncounter(oSource).hospitalization.Clone;
  if (TFhirEncounter(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirEncounterLocationList.Create;
    FLocationList.Assign(TFhirEncounter(oSource).FLocationList);
  end;
  serviceProvider := TFhirEncounter(oSource).serviceProvider.Clone;
  partOf := TFhirEncounter(oSource).partOf.Clone;
end;

function TFhirEncounter.GetResourceType : TFhirResourceType;
begin
  result := frtEncounter;
end;

procedure TFhirEncounter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'classHistory') Then
    list.addAll(self, 'classHistory', FClassHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'serviceType') Then
     list.add(self.link, 'serviceType', FServiceType.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'subjectStatus') Then
     list.add(self.link, 'subjectStatus', FSubjectStatus.Link);
  if (child_name = 'episodeOfCare') Then
    list.addAll(self, 'episodeOfCare', FEpisodeOfCareList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'appointment') Then
    list.addAll(self, 'appointment', FAppointmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'hospitalization') Then
     list.add(self.link, 'hospitalization', FHospitalization.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'serviceProvider') Then
     list.add(self.link, 'serviceProvider', FServiceProvider.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
end;

procedure TFhirEncounter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'statusHistory', 'BackboneElement', true, TFhirEncounterStatusHistory, FStatusHistoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'classHistory', 'BackboneElement', true, TFhirEncounterClassHistory, FClassHistoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', false, TFhirCodeableConcept, FServiceType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'subjectStatus', 'CodeableConcept', false, TFhirCodeableConcept, FSubjectStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'episodeOfCare', 'Reference', true, TFhirReference, FEpisodeOfCareList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirEncounterParticipant, FParticipantList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference', true, TFhirReference, FAppointmentList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'length', 'Duration', false, TFhirDuration, FLength.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableReference', true, TFhirCodeableReference, FReasonList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirEncounterDiagnosis, FDiagnosisList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'hospitalization', 'BackboneElement', false, TFhirEncounterHospitalization, FHospitalization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'location', 'BackboneElement', true, TFhirEncounterLocation, FLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceProvider', 'Reference', false, TFhirReference, FServiceProvider.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link)); {L1172}
end;

function TFhirEncounter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEncounterStatusHistory) {L1048};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'classHistory') then
  begin
    ClassHistoryList.add(propValue as TFhirEncounterClassHistory) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'subjectStatus') then
  begin
    SubjectStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'episodeOfCare') then
  begin
    EpisodeOfCareList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirEncounterParticipant) {L1048};
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    AppointmentList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    Length := propValue as TFhirDuration {L1199};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableReference) {L1048};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEncounterDiagnosis) {L1048};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'hospitalization') then
  begin
    Hospitalization := propValue as TFhirEncounterHospitalization {L1199};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirEncounterLocation) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceProvider') then
  begin
    ServiceProvider := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEncounterStatusHistory) {L1049}
  else if (propName = 'classHistory') then ClassHistoryList.insertItem(index, propValue as TFhirEncounterClassHistory) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirEncounterParticipant) {L1049}
  else if (propName = 'appointment') then AppointmentList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableReference) {L1049}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEncounterDiagnosis) {L1049}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirEncounterLocation) {L1049}
  else inherited;
end;

function TFhirEncounter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull])  {L1211}
  else if (propName = 'statusHistory') then result := StatusHistoryList.new() {L1053}
  else if (propName = 'class') then result := TFhirCoding.create() {L1203}
  else if (propName = 'classHistory') then result := ClassHistoryList.new() {L1053}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'serviceType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'subject') then result := TFhirReference.create() {L1203}
  else if (propName = 'subjectStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'episodeOfCare') then result := EpisodeOfCareList.new() {L1053}
  else if (propName = 'basedOn') then result := BasedOnList.new() {L1053}
  else if (propName = 'participant') then result := ParticipantList.new() {L1053}
  else if (propName = 'appointment') then result := AppointmentList.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'length') then result := TFhirDuration.create() {L1203}
  else if (propName = 'reason') then result := ReasonList.new() {L1053}
  else if (propName = 'diagnosis') then result := DiagnosisList.new() {L1053}
  else if (propName = 'account') then result := AccountList.new() {L1053}
  else if (propName = 'hospitalization') then result := TFhirEncounterHospitalization.create() {L1203}
  else if (propName = 'location') then result := LocationList.new() {L1053}
  else if (propName = 'serviceProvider') then result := TFhirReference.create() {L1203}
  else if (propName = 'partOf') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := 'BackboneElement'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'classHistory') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'subjectStatus') then result := 'CodeableConcept'
  else if (propName = 'episodeOfCare') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'length') then result := 'Duration'
  else if (propName = 'reason') then result := 'CodeableReference'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'hospitalization') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'BackboneElement'
  else if (propName = 'serviceProvider') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value) {L1054}
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'classHistory') then deletePropertyValue('classHistory', ClassHistoryList, value) {L1054}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'serviceType') then ServiceTypeElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'subjectStatus') then SubjectStatusElement := nil
  else if (propName = 'episodeOfCare') then deletePropertyValue('episodeOfCare', EpisodeOfCareList, value) {L1054}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {L1054}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {L1054}
  else if (propName = 'appointment') then deletePropertyValue('appointment', AppointmentList, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {L1054}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {L1054}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {L1054}
  else if (propName = 'hospitalization') then HospitalizationElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {L1054}
  else if (propName = 'serviceProvider') then ServiceProviderElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new) {L1210}
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new) {L1055}
  else if (propName = 'class') then Class_Element := new as TFhirCoding {L1195}
  else if (propName = 'classHistory') then replacePropertyValue('classHistory', ClassHistoryList, existing, new) {L1055}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'serviceType') then ServiceTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference {L1195}
  else if (propName = 'subjectStatus') then SubjectStatusElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'episodeOfCare') then replacePropertyValue('episodeOfCare', EpisodeOfCareList, existing, new) {L1055}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {L1055}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {L1055}
  else if (propName = 'appointment') then replacePropertyValue('appointment', AppointmentList, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'length') then LengthElement := new as TFhirDuration {L1195}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {L1055}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {L1055}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {L1055}
  else if (propName = 'hospitalization') then HospitalizationElement := new as TFhirEncounterHospitalization {L1195}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {L1055}
  else if (propName = 'serviceProvider') then ServiceProviderElement := new as TFhirReference {L1195}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination) {L1050}
  else if (propName = 'classHistory') then ClassHistoryList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.move(source, destination) {L1050}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination) {L1050}
  else if (propName = 'participant') then ParticipantList.move(source, destination) {L1050}
  else if (propName = 'appointment') then AppointmentList.move(source, destination) {L1050}
  else if (propName = 'reason') then ReasonList.move(source, destination) {L1050}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination) {L1050}
  else if (propName = 'account') then AccountList.move(source, destination) {L1050}
  else if (propName = 'location') then LocationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounter.fhirType : string;
begin
  result := 'Encounter';
end;

function TFhirEncounter.Link : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Link);
end;

function TFhirEncounter.Clone : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Clone);
end;

function TFhirEncounter.equals(other : TObject) : boolean; 
var
  o : TFhirEncounter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounter)) then
    result := false
  else
  begin
    o := TFhirEncounter(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(class_Element, o.class_Element, true) and 
      compareDeep(classHistoryList, o.classHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(serviceTypeElement, o.serviceTypeElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(subjectStatusElement, o.subjectStatusElement, true) and 
      compareDeep(episodeOfCareList, o.episodeOfCareList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(appointmentList, o.appointmentList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(lengthElement, o.lengthElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(accountList, o.accountList, true) and compareDeep(hospitalizationElement, o.hospitalizationElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(serviceProviderElement, o.serviceProviderElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true);
  end;
end;

function TFhirEncounter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(FClass_) and isEmptyProp(FclassHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FServiceType) and isEmptyProp(FPriority) and isEmptyProp(FSubject) and isEmptyProp(FSubjectStatus) and isEmptyProp(FepisodeOfCareList) and isEmptyProp(FbasedOnList) and isEmptyProp(FparticipantList) and isEmptyProp(FappointmentList) and isEmptyProp(FPeriod) and isEmptyProp(FLength) and isEmptyProp(FreasonList) and isEmptyProp(FdiagnosisList) and isEmptyProp(FaccountList) and isEmptyProp(FHospitalization) and isEmptyProp(FlocationList) and isEmptyProp(FServiceProvider) and isEmptyProp(FPartOf);
end;

function TFhirEncounter.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEncounter.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEncounter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounter.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounter.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

function TFhirEncounter.GetStatusHistoryList : TFhirEncounterStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

function TFhirEncounter.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

procedure TFhirEncounter.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value; {L1134}
end;

function TFhirEncounter.GetClassHistoryList : TFhirEncounterClassHistoryList;
begin
  if FClassHistoryList = nil then
    FClassHistoryList := TFhirEncounterClassHistoryList.Create;
  result := FClassHistoryList;
end;

function TFhirEncounter.GetHasClassHistoryList : boolean;
begin
  result := (FClassHistoryList <> nil) and (FClassHistoryList.count > 0);
end;

function TFhirEncounter.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounter.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirEncounter.SetServiceType(value : TFhirCodeableConcept);
begin
  FServiceType.free;
  FServiceType := value; {L1134}
end;

procedure TFhirEncounter.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value; {L1134}
end;

procedure TFhirEncounter.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value; {L1134}
end;

procedure TFhirEncounter.SetSubjectStatus(value : TFhirCodeableConcept);
begin
  FSubjectStatus.free;
  FSubjectStatus := value; {L1134}
end;

function TFhirEncounter.GetEpisodeOfCareList : TFhirReferenceList;
begin
  if FEpisodeOfCareList = nil then
    FEpisodeOfCareList := TFhirReferenceList.Create;
  result := FEpisodeOfCareList;
end;

function TFhirEncounter.GetHasEpisodeOfCareList : boolean;
begin
  result := (FEpisodeOfCareList <> nil) and (FEpisodeOfCareList.count > 0);
end;

function TFhirEncounter.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirEncounter.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirEncounter.GetParticipantList : TFhirEncounterParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirEncounterParticipantList.Create;
  result := FParticipantList;
end;

function TFhirEncounter.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirEncounter.GetAppointmentList : TFhirReferenceList;
begin
  if FAppointmentList = nil then
    FAppointmentList := TFhirReferenceList.Create;
  result := FAppointmentList;
end;

function TFhirEncounter.GetHasAppointmentList : boolean;
begin
  result := (FAppointmentList <> nil) and (FAppointmentList.count > 0);
end;

procedure TFhirEncounter.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirEncounter.SetLength(value : TFhirDuration);
begin
  FLength.free;
  FLength := value; {L1134}
end;

function TFhirEncounter.GetReasonList : TFhirCodeableReferenceList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableReferenceList.Create;
  result := FReasonList;
end;

function TFhirEncounter.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirEncounter.GetDiagnosisList : TFhirEncounterDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEncounterDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirEncounter.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirEncounter.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirEncounter.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

procedure TFhirEncounter.SetHospitalization(value : TFhirEncounterHospitalization);
begin
  FHospitalization.free;
  FHospitalization := value; {L1134}
end;

function TFhirEncounter.GetLocationList : TFhirEncounterLocationList;
begin
  if FLocationList = nil then
    FLocationList := TFhirEncounterLocationList.Create;
  result := FLocationList;
end;

function TFhirEncounter.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirEncounter.SetServiceProvider(value : TFhirReference);
begin
  FServiceProvider.free;
  FServiceProvider := value; {L1134}
end;

procedure TFhirEncounter.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value; {L1134}
end;

procedure TFhirEncounter.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('class');
  fields.add('classHistory');
  fields.add('type');
  fields.add('serviceType');
  fields.add('priority');
  fields.add('subject');
  fields.add('subjectStatus');
  fields.add('episodeOfCare');
  fields.add('basedOn');
  fields.add('participant');
  fields.add('appointment');
  fields.add('period');
  fields.add('length');
  fields.add('reason');
  fields.add('diagnosis');
  fields.add('account');
  fields.add('hospitalization');
  fields.add('location');
  fields.add('serviceProvider');
  fields.add('partOf');
end;

function TFhirEncounter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FstatusHistoryList.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FclassHistoryList.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FServiceType.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FSubjectStatus.sizeInBytes);
  inc(result, FepisodeOfCareList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FappointmentList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, FaccountList.sizeInBytes);
  inc(result, FHospitalization.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FServiceProvider.sizeInBytes);
  inc(result, FPartOf.sizeInBytes);
end;

{ TFhirEncounterListEnumerator }

constructor TFhirEncounterListEnumerator.Create(list : TFhirEncounterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEncounterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterListEnumerator.GetCurrent : TFhirEncounter;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEncounterList }

procedure TFhirEncounterList.AddItem(value: TFhirEncounter);
begin
  assert(value.ClassName = 'TFhirEncounter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounter');
  add(value);
end;

function TFhirEncounterList.Append: TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterList.GetEnumerator : TFhirEncounterListEnumerator;
begin
  result := TFhirEncounterListEnumerator.Create(self.link);
end;

function TFhirEncounterList.Clone: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Clone);
end;

function TFhirEncounterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterList.GetItemN(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounter;
end;
function TFhirEncounterList.IndexOf(value: TFhirEncounter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterList.Insert(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.InsertItem(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  Inherited Insert(index, value);
end;

function TFhirEncounterList.Item(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.Link: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Link);
end;

procedure TFhirEncounterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterList.SetItemByIndex(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  FhirEncounters[index] := value;
end;

procedure TFhirEncounterList.SetItemN(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
{ TFhirEndpoint }

constructor TFhirEndpoint.Create;
begin
  inherited;
end;

destructor TFhirEndpoint.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FConnectionType.free;
  FName.free;
  FManagingOrganization.free;
  FContactList.Free;
  FPeriod.free;
  FPayloadTypeList.Free;
  FPayloadMimeTypeList.Free;
  FAddress.free;
  FHeaderList.Free;
  inherited;
end;

procedure TFhirEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEndpoint(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEndpoint(oSource).FIdentifierList);
  end;
  statusElement := TFhirEndpoint(oSource).statusElement.Clone;
  connectionType := TFhirEndpoint(oSource).connectionType.Clone;
  nameElement := TFhirEndpoint(oSource).nameElement.Clone;
  managingOrganization := TFhirEndpoint(oSource).managingOrganization.Clone;
  if (TFhirEndpoint(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirEndpoint(oSource).FContactList);
  end;
  period := TFhirEndpoint(oSource).period.Clone;
  if (TFhirEndpoint(oSource).FPayloadTypeList = nil) then
  begin
    FPayloadTypeList.free;
    FPayloadTypeList := nil;
  end
  else
  begin
    if FPayloadTypeList = nil then
      FPayloadTypeList := TFhirCodeableConceptList.Create;
    FPayloadTypeList.Assign(TFhirEndpoint(oSource).FPayloadTypeList);
  end;
  if (TFhirEndpoint(oSource).FPayloadMimeTypeList = nil) then
  begin
    FPayloadMimeTypeList.free;
    FPayloadMimeTypeList := nil;
  end
  else
  begin
    if FPayloadMimeTypeList = nil then
      FPayloadMimeTypeList := TFhirCodeList.Create;
    FPayloadMimeTypeList.Assign(TFhirEndpoint(oSource).FPayloadMimeTypeList);
  end;
  addressElement := TFhirEndpoint(oSource).addressElement.Clone;
  if (TFhirEndpoint(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirEndpoint(oSource).FHeaderList);
  end;
end;

function TFhirEndpoint.GetResourceType : TFhirResourceType;
begin
  result := frtEndpoint;
end;

procedure TFhirEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'connectionType') Then
     list.add(self.link, 'connectionType', FConnectionType.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payloadType') Then
    list.addAll(self, 'payloadType', FPayloadTypeList);
  if (child_name = 'payloadMimeType') Then
    list.addAll(self, 'payloadMimeType', FPayloadMimeTypeList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'connectionType', 'Coding', false, TFhirCoding, FConnectionType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'payloadType', 'CodeableConcept', true, TFhirCodeableConcept, FPayloadTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'payloadMimeType', 'code', true, TFhirCode, FPayloadMimeTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'url', false, TFhirUrl, FAddress.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link)) {L1039};
end;

function TFhirEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'connectionType') then
  begin
    ConnectionType := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'payloadType') then
  begin
    PayloadTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'payloadMimeType') then
  begin
    PayloadMimeTypeList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'address') then
  begin
    AddressElement := asUrl(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'payloadType') then PayloadTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.insertItem(index, asCode(propValue)) {L1045}
  else if (propName = 'header') then HeaderList.insertItem(index, asString(propValue)) {L1045}
  else inherited;
end;

function TFhirEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEndpointStatusEnum[EndpointStatusNull], CODES_TFhirEndpointStatusEnum[EndpointStatusNull])  {L1211}
  else if (propName = 'connectionType') then result := TFhirCoding.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'managingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'payloadType') then result := PayloadTypeList.new() {L1053}
  else if (propName = 'payloadMimeType') then result := PayloadMimeTypeList.new() {L1053}
  else if (propName = 'address') then result := TFhirUrl.create() {L1223}
  else if (propName = 'header') then result := HeaderList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'connectionType') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payloadType') then result := 'CodeableConcept'
  else if (propName = 'payloadMimeType') then result := 'code'
  else if (propName = 'address') then result := 'url'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'connectionType') then ConnectionTypeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payloadType') then deletePropertyValue('payloadType', PayloadTypeList, value) {L1054}
  else if (propName = 'payloadMimeType') then deletePropertyValue('payloadMimeType', PayloadMimeTypeList, value) {L1054}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, new) {L1210}
  else if (propName = 'connectionType') then ConnectionTypeElement := new as TFhirCoding {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'payloadType') then replacePropertyValue('payloadType', PayloadTypeList, existing, new) {L1055}
  else if (propName = 'payloadMimeType') then replacePropertyValue('payloadMimeType', PayloadMimeTypeList, existing, new) {L1055}
  else if (propName = 'address') then AddressElement := asUrl(new) {L1222}
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'payloadType') then PayloadTypeList.move(source, destination) {L1050}
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.move(source, destination) {L1046}
  else if (propName = 'header') then HeaderList.move(source, destination) {L1046}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEndpoint.fhirType : string;
begin
  result := 'Endpoint';
end;

function TFhirEndpoint.Link : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Link);
end;

function TFhirEndpoint.Clone : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Clone);
end;

function TFhirEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEndpoint)) then
    result := false
  else
  begin
    o := TFhirEndpoint(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(connectionTypeElement, o.connectionTypeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payloadTypeList, o.payloadTypeList, true) and compareDeep(payloadMimeTypeList, o.payloadMimeTypeList, true) and 
      compareDeep(addressElement, o.addressElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FConnectionType) and isEmptyProp(FName) and isEmptyProp(FManagingOrganization) and isEmptyProp(FcontactList) and isEmptyProp(FPeriod) and isEmptyProp(FpayloadTypeList) and isEmptyProp(FpayloadMimeTypeList) and isEmptyProp(FAddress) and isEmptyProp(FheaderList);
end;

function TFhirEndpoint.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEndpoint.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEndpoint.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEndpoint.GetStatusST : TFhirEndpointStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEndpointStatusEnum(0)
  else
    result := TFhirEndpointStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEndpointStatusEnum, FStatus.value));
end;

procedure TFhirEndpoint.SetStatusST(value : TFhirEndpointStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEndpointStatusEnum[value], CODES_TFhirEndpointStatusEnum[value]);
end;

procedure TFhirEndpoint.SetConnectionType(value : TFhirCoding);
begin
  FConnectionType.free;
  FConnectionType := value; {L1134}
end;

procedure TFhirEndpoint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirEndpoint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEndpoint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEndpoint.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value; {L1134}
end;

function TFhirEndpoint.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirEndpoint.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirEndpoint.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirEndpoint.GetPayloadTypeList : TFhirCodeableConceptList;
begin
  if FPayloadTypeList = nil then
    FPayloadTypeList := TFhirCodeableConceptList.Create;
  result := FPayloadTypeList;
end;

function TFhirEndpoint.GetHasPayloadTypeList : boolean;
begin
  result := (FPayloadTypeList <> nil) and (FPayloadTypeList.count > 0);
end;

function TFhirEndpoint.GetPayloadMimeTypeList : TFhirCodeList;
begin
  if FPayloadMimeTypeList = nil then
    FPayloadMimeTypeList := TFhirCodeList.Create;
  result := FPayloadMimeTypeList;
end;

function TFhirEndpoint.GetHasPayloadMimeTypeList : boolean;
begin
  result := (FPayloadMimeTypeList <> nil) and (FPayloadMimeTypeList.count > 0);
end;

procedure TFhirEndpoint.SetAddress(value : TFhirUrl);
begin
  FAddress.free;
  FAddress := value; {L1134}
end;

function TFhirEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

procedure TFhirEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUrl.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

function TFhirEndpoint.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

function TFhirEndpoint.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

procedure TFhirEndpoint.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('connectionType');
  fields.add('name');
  fields.add('managingOrganization');
  fields.add('contact');
  fields.add('period');
  fields.add('payloadType');
  fields.add('payloadMimeType');
  fields.add('address');
  fields.add('header');
end;

function TFhirEndpoint.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FConnectionType.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FManagingOrganization.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FpayloadTypeList.sizeInBytes);
  inc(result, FpayloadMimeTypeList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
  inc(result, FheaderList.sizeInBytes);
end;

{ TFhirEndpointListEnumerator }

constructor TFhirEndpointListEnumerator.Create(list : TFhirEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEndpointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEndpointListEnumerator.GetCurrent : TFhirEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirEndpointListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEndpointList }

procedure TFhirEndpointList.AddItem(value: TFhirEndpoint);
begin
  assert(value.ClassName = 'TFhirEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEndpoint');
  add(value);
end;

function TFhirEndpointList.Append: TFhirEndpoint;
begin
  result := TFhirEndpoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirEndpointList.GetEnumerator : TFhirEndpointListEnumerator;
begin
  result := TFhirEndpointListEnumerator.Create(self.link);
end;

function TFhirEndpointList.Clone: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Clone);
end;

function TFhirEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEndpointList.GetItemN(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirEndpoint;
end;
function TFhirEndpointList.IndexOf(value: TFhirEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEndpointList.Insert(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.InsertItem(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  Inherited Insert(index, value);
end;

function TFhirEndpointList.Item(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.Link: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Link);
end;

procedure TFhirEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEndpointList.SetItemByIndex(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  FhirEndpoints[index] := value;
end;

procedure TFhirEndpointList.SetItemN(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  excludeElement := TFhirGroupCharacteristic(oSource).excludeElement.Clone;
  period := TFhirGroupCharacteristic(oSource).period.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirDataType, FValue.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirGroupCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.create('Cannot make property Value') {L1191}
  else if (propName = 'exclude') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil {L1189}
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirDataType {L1190}
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new) {L1222}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupCharacteristic.fhirType : string;
begin
  result := 'Group.characteristic';
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

function TFhirGroupCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirGroupCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupCharacteristic)) then
    result := false
  else
  begin
    o := TFhirGroupCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirGroupCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirGroupCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value; {L1134}
end;

procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value; {L1134}
end;

function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirGroupCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirGroupCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

function TFhirGroupCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FExclude.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirGroupCharacteristicListEnumerator }

constructor TFhirGroupCharacteristicListEnumerator.Create(list : TFhirGroupCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupCharacteristicListEnumerator.GetCurrent : TFhirGroupCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirGroupCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGroupCharacteristicList }

procedure TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic);
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
end;

function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.GetEnumerator : TFhirGroupCharacteristicListEnumerator;
begin
  result := TFhirGroupCharacteristicListEnumerator.Create(self.link);
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupCharacteristic;
end;
function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupMember }

constructor TFhirGroupMember.Create;
begin
  inherited;
end;

destructor TFhirGroupMember.Destroy;
begin
  FEntity.free;
  FPeriod.free;
  FInactive.free;
  inherited;
end;

procedure TFhirGroupMember.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirGroupMember(oSource).entity.Clone;
  period := TFhirGroupMember(oSource).period.Clone;
  inactiveElement := TFhirGroupMember(oSource).inactiveElement.Clone;
end;

procedure TFhirGroupMember.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
end;

procedure TFhirGroupMember.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity', 'Reference', false, TFhirReference, FEntity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link)); {L1172}
end;

function TFhirGroupMember.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupMember.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupMember.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'inactive') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupMember.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'inactive') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupMember.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupMember.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'inactive') then InactiveElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupMember.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupMember.fhirType : string;
begin
  result := 'Group.member';
end;

function TFhirGroupMember.Link : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Link);
end;

function TFhirGroupMember.Clone : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Clone);
end;

function TFhirGroupMember.equals(other : TObject) : boolean; 
var
  o : TFhirGroupMember;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupMember)) then
    result := false
  else
  begin
    o := TFhirGroupMember(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(inactiveElement, o.inactiveElement, true);
  end;
end;

function TFhirGroupMember.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FPeriod) and isEmptyProp(FInactive);
end;

procedure TFhirGroupMember.SetEntity(value : TFhirReference);
begin
  FEntity.free;
  FEntity := value; {L1134}
end;

procedure TFhirGroupMember.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirGroupMember.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value; {L1134}
end;

function TFhirGroupMember.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

procedure TFhirGroupMember.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

procedure TFhirGroupMember.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity');
  fields.add('period');
  fields.add('inactive');
end;

function TFhirGroupMember.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FInactive.sizeInBytes);
end;

{ TFhirGroupMemberListEnumerator }

constructor TFhirGroupMemberListEnumerator.Create(list : TFhirGroupMemberList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupMemberListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupMemberListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupMemberListEnumerator.GetCurrent : TFhirGroupMember;
begin
  Result := FList[FIndex];
end;

function TFhirGroupMemberListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGroupMemberList }

procedure TFhirGroupMemberList.AddItem(value: TFhirGroupMember);
begin
  assert(value.ClassName = 'TFhirGroupMember', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupMember');
  add(value);
end;

function TFhirGroupMemberList.Append: TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.ClearItems;
begin
  Clear;
end;

function TFhirGroupMemberList.GetEnumerator : TFhirGroupMemberListEnumerator;
begin
  result := TFhirGroupMemberListEnumerator.Create(self.link);
end;

function TFhirGroupMemberList.Clone: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Clone);
end;

function TFhirGroupMemberList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupMemberList.GetItemN(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupMember;
end;
function TFhirGroupMemberList.IndexOf(value: TFhirGroupMember): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupMemberList.Insert(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.InsertItem(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  Inherited Insert(index, value);
end;

function TFhirGroupMemberList.Item(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.Link: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Link);
end;

procedure TFhirGroupMemberList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupMemberList.SetItemByIndex(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  FhirGroupMembers[index] := value;
end;

procedure TFhirGroupMemberList.SetItemN(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  ObjectByIndex[index] := value;
end;

{ TFhirGroup }

constructor TFhirGroup.Create;
begin
  inherited;
end;

destructor TFhirGroup.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FType_.free;
  FActual.free;
  FCode.free;
  FName.free;
  FQuantity.free;
  FManagingEntity.free;
  FCharacteristicList.Free;
  FMemberList.Free;
  inherited;
end;

procedure TFhirGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGroup(oSource).FIdentifierList);
  end;
  activeElement := TFhirGroup(oSource).activeElement.Clone;
  type_Element := TFhirGroup(oSource).type_Element.Clone;
  actualElement := TFhirGroup(oSource).actualElement.Clone;
  code := TFhirGroup(oSource).code.Clone;
  nameElement := TFhirGroup(oSource).nameElement.Clone;
  quantityElement := TFhirGroup(oSource).quantityElement.Clone;
  managingEntity := TFhirGroup(oSource).managingEntity.Clone;
  if (TFhirGroup(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirGroupCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirGroup(oSource).FCharacteristicList);
  end;
  if (TFhirGroup(oSource).FMemberList = nil) then
  begin
    FMemberList.free;
    FMemberList := nil;
  end
  else
  begin
    if FMemberList = nil then
      FMemberList := TFhirGroupMemberList.Create;
    FMemberList.Assign(TFhirGroup(oSource).FMemberList);
  end;
end;

function TFhirGroup.GetResourceType : TFhirResourceType;
begin
  result := frtGroup;
end;

procedure TFhirGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'managingEntity') Then
     list.add(self.link, 'managingEntity', FManagingEntity.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'member') Then
    list.addAll(self, 'member', FMemberList);
end;

procedure TFhirGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'quantity', 'unsignedInt', false, TFhirUnsignedInt, FQuantity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'managingEntity', 'Reference', false, TFhirReference, FManagingEntity.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirGroupCharacteristic, FCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'member', 'BackboneElement', true, TFhirGroupMember, FMemberList.Link)) {L1039};
end;

function TFhirGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asUnsignedInt(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'managingEntity') then
  begin
    ManagingEntity := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirGroupCharacteristic) {L1048};
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    MemberList.add(propValue as TFhirGroupMember) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirGroupCharacteristic) {L1049}
  else if (propName = 'member') then MemberList.insertItem(index, propValue as TFhirGroupMember) {L1049}
  else inherited;
end;

function TFhirGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirGroupTypeEnum[GroupTypeNull], CODES_TFhirGroupTypeEnum[GroupTypeNull])  {L1211}
  else if (propName = 'actual') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'quantity') then result := TFhirUnsignedInt.create() {L1223}
  else if (propName = 'managingEntity') then result := TFhirReference.create() {L1203}
  else if (propName = 'characteristic') then result := CharacteristicList.new() {L1053}
  else if (propName = 'member') then result := MemberList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'quantity') then result := 'unsignedInt'
  else if (propName = 'managingEntity') then result := 'Reference'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'member') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'managingEntity') then ManagingEntityElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {L1054}
  else if (propName = 'member') then deletePropertyValue('member', MemberList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, new) {L1210}
  else if (propName = 'actual') then ActualElement := asBoolean(new) {L1222}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'quantity') then QuantityElement := asUnsignedInt(new) {L1222}
  else if (propName = 'managingEntity') then ManagingEntityElement := new as TFhirReference {L1195}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {L1055}
  else if (propName = 'member') then replacePropertyValue('member', MemberList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination) {L1050}
  else if (propName = 'member') then MemberList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGroup.fhirType : string;
begin
  result := 'Group';
end;

function TFhirGroup.Link : TFhirGroup;
begin
  result := TFhirGroup(inherited Link);
end;

function TFhirGroup.Clone : TFhirGroup;
begin
  result := TFhirGroup(inherited Clone);
end;

function TFhirGroup.equals(other : TObject) : boolean; 
var
  o : TFhirGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroup)) then
    result := false
  else
  begin
    o := TFhirGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(managingEntityElement, o.managingEntityElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(memberList, o.memberList, true);
  end;
end;

function TFhirGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FType_) and isEmptyProp(FActual) and isEmptyProp(FCode) and isEmptyProp(FName) and isEmptyProp(FQuantity) and isEmptyProp(FManagingEntity) and isEmptyProp(FcharacteristicList) and isEmptyProp(FmemberList);
end;

function TFhirGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGroup.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirGroup.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirGroup.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirGroup.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirGroup.GetType_ST : TFhirGroupTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGroupTypeEnum(0)
  else
    result := TFhirGroupTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupTypeEnum, FType_.value));
end;

procedure TFhirGroup.SetType_ST(value : TFhirGroupTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirGroupTypeEnum[value], CODES_TFhirGroupTypeEnum[value]);
end;

procedure TFhirGroup.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value; {L1134}
end;

function TFhirGroup.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirGroup.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

procedure TFhirGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirGroup.SetQuantity(value : TFhirUnsignedInt);
begin
  FQuantity.free;
  FQuantity := value; {L1134}
end;

function TFhirGroup.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirGroup.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirUnsignedInt.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

procedure TFhirGroup.SetManagingEntity(value : TFhirReference);
begin
  FManagingEntity.free;
  FManagingEntity := value; {L1134}
end;

function TFhirGroup.GetCharacteristicList : TFhirGroupCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirGroupCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirGroup.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirGroup.GetMemberList : TFhirGroupMemberList;
begin
  if FMemberList = nil then
    FMemberList := TFhirGroupMemberList.Create;
  result := FMemberList;
end;

function TFhirGroup.GetHasMemberList : boolean;
begin
  result := (FMemberList <> nil) and (FMemberList.count > 0);
end;

procedure TFhirGroup.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('actual');
  fields.add('code');
  fields.add('name');
  fields.add('quantity');
  fields.add('managingEntity');
  fields.add('characteristic');
  fields.add('member');
end;

function TFhirGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FActual.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FManagingEntity.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
  inc(result, FmemberList.sizeInBytes);
end;

{ TFhirGroupListEnumerator }

constructor TFhirGroupListEnumerator.Create(list : TFhirGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupListEnumerator.GetCurrent : TFhirGroup;
begin
  Result := FList[FIndex];
end;

function TFhirGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGroupList }

procedure TFhirGroupList.AddItem(value: TFhirGroup);
begin
  assert(value.ClassName = 'TFhirGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroup');
  add(value);
end;

function TFhirGroupList.Append: TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.ClearItems;
begin
  Clear;
end;

function TFhirGroupList.GetEnumerator : TFhirGroupListEnumerator;
begin
  result := TFhirGroupListEnumerator.Create(self.link);
end;

function TFhirGroupList.Clone: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Clone);
end;

function TFhirGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupList.GetItemN(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroup;
end;
function TFhirGroupList.IndexOf(value: TFhirGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupList.Insert(index: Integer): TFhirGroup;
begin
  result := TFhirGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.InsertItem(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  Inherited Insert(index, value);
end;

function TFhirGroupList.Item(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.Link: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Link);
end;

procedure TFhirGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupList.SetItemByIndex(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  FhirGroups[index] := value;
end;

procedure TFhirGroupList.SetItemN(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
{ TFhirHealthcareServiceEligibility }

constructor TFhirHealthcareServiceEligibility.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceEligibility.Destroy;
begin
  FCode.free;
  FComment.free;
  inherited;
end;

procedure TFhirHealthcareServiceEligibility.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirHealthcareServiceEligibility(oSource).code.Clone;
  commentElement := TFhirHealthcareServiceEligibility(oSource).commentElement.Clone;
end;

procedure TFhirHealthcareServiceEligibility.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirHealthcareServiceEligibility.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link)); {L1172}
end;

function TFhirHealthcareServiceEligibility.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceEligibility.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceEligibility.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'comment') then result := TFhirMarkdown.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceEligibility.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'comment') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceEligibility.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceEligibility.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'comment') then CommentElement := asMarkdown(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceEligibility.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceEligibility.fhirType : string;
begin
  result := 'HealthcareService.eligibility';
end;

function TFhirHealthcareServiceEligibility.Link : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Link);
end;

function TFhirHealthcareServiceEligibility.Clone : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Clone);
end;

function TFhirHealthcareServiceEligibility.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceEligibility;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceEligibility)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceEligibility(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirHealthcareServiceEligibility.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FComment);
end;

procedure TFhirHealthcareServiceEligibility.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirHealthcareServiceEligibility.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirHealthcareServiceEligibility.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareServiceEligibility.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirHealthcareServiceEligibility.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('comment');
end;

function TFhirHealthcareServiceEligibility.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirHealthcareServiceEligibilityListEnumerator }

constructor TFhirHealthcareServiceEligibilityListEnumerator.Create(list : TFhirHealthcareServiceEligibilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceEligibilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.GetCurrent : TFhirHealthcareServiceEligibility;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceEligibilityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirHealthcareServiceEligibilityList }

procedure TFhirHealthcareServiceEligibilityList.AddItem(value: TFhirHealthcareServiceEligibility);
begin
  assert(value.ClassName = 'TFhirHealthcareServiceEligibility', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceEligibility');
  add(value);
end;

function TFhirHealthcareServiceEligibilityList.Append: TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceEligibilityList.GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
begin
  result := TFhirHealthcareServiceEligibilityListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceEligibilityList.Clone: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Clone);
end;

function TFhirHealthcareServiceEligibilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceEligibilityList.GetItemN(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceEligibility;
end;
function TFhirHealthcareServiceEligibilityList.IndexOf(value: TFhirHealthcareServiceEligibility): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceEligibilityList.Insert(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.InsertItem(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceEligibilityList.Item(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.Link: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Link);
end;

procedure TFhirHealthcareServiceEligibilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  FhirHealthcareServiceEligibilities[index] := value;
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemN(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceAvailableTime }

constructor TFhirHealthcareServiceAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceAvailableTime.Destroy;
begin
  FDaysOfWeek.Free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirHealthcareServiceAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirHealthcareServiceAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirHealthcareServiceAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirHealthcareServiceAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link)); {L1172}
end;

function TFhirHealthcareServiceAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {L995}
  else inherited;
end;

function TFhirHealthcareServiceAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'availableStartTime') then result := TFhirTime.create() {L1223}
  else if (propName = 'availableEndTime') then result := TFhirTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new) {L1222}
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new) {L1222}
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {L996}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceAvailableTime.fhirType : string;
begin
  result := 'HealthcareService.availableTime';
end;

function TFhirHealthcareServiceAvailableTime.Link : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Link);
end;

function TFhirHealthcareServiceAvailableTime.Clone : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceAvailableTime)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirHealthcareServiceAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

function TFhirHealthcareServiceAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirHealthcareServiceAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirHealthcareServiceAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirHealthcareServiceAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value; {L1134}
end;

function TFhirHealthcareServiceAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.create;
  FAllDay.value := value
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value; {L1134}
end;

function TFhirHealthcareServiceAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value; {L1134}
end;

function TFhirHealthcareServiceAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

procedure TFhirHealthcareServiceAvailableTime.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

function TFhirHealthcareServiceAvailableTime.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDaysOfWeek.sizeInBytes);
  inc(result, FAllDay.sizeInBytes);
  inc(result, FAvailableStartTime.sizeInBytes);
  inc(result, FAvailableEndTime.sizeInBytes);
end;

{ TFhirHealthcareServiceAvailableTimeListEnumerator }

constructor TFhirHealthcareServiceAvailableTimeListEnumerator.Create(list : TFhirHealthcareServiceAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceAvailableTimeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.GetCurrent : TFhirHealthcareServiceAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirHealthcareServiceAvailableTimeList }

procedure TFhirHealthcareServiceAvailableTimeList.AddItem(value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value.ClassName = 'TFhirHealthcareServiceAvailableTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceAvailableTime');
  add(value);
end;

function TFhirHealthcareServiceAvailableTimeList.Append: TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceAvailableTimeList.GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
begin
  result := TFhirHealthcareServiceAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceAvailableTimeList.Clone: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceAvailableTimeList.GetItemN(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceAvailableTime;
end;
function TFhirHealthcareServiceAvailableTimeList.IndexOf(value: TFhirHealthcareServiceAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceAvailableTimeList.Insert(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.InsertItem(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceAvailableTimeList.Item(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.Link: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Link);
end;

procedure TFhirHealthcareServiceAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  FhirHealthcareServiceAvailableTimes[index] := value;
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemN(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceNotAvailable }

constructor TFhirHealthcareServiceNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirHealthcareServiceNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirHealthcareServiceNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirHealthcareServiceNotAvailable(oSource).during.Clone;
end;

procedure TFhirHealthcareServiceNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirHealthcareServiceNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link)); {L1172}
end;

function TFhirHealthcareServiceNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'during') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'during') then DuringElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceNotAvailable.fhirType : string;
begin
  result := 'HealthcareService.notAvailable';
end;

function TFhirHealthcareServiceNotAvailable.Link : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Link);
end;

function TFhirHealthcareServiceNotAvailable.Clone : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceNotAvailable)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirHealthcareServiceNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirHealthcareServiceNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirHealthcareServiceNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirHealthcareServiceNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirHealthcareServiceNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value; {L1134}
end;

procedure TFhirHealthcareServiceNotAvailable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

function TFhirHealthcareServiceNotAvailable.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FDuring.sizeInBytes);
end;

{ TFhirHealthcareServiceNotAvailableListEnumerator }

constructor TFhirHealthcareServiceNotAvailableListEnumerator.Create(list : TFhirHealthcareServiceNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceNotAvailableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.GetCurrent : TFhirHealthcareServiceNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirHealthcareServiceNotAvailableList }

procedure TFhirHealthcareServiceNotAvailableList.AddItem(value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value.ClassName = 'TFhirHealthcareServiceNotAvailable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceNotAvailable');
  add(value);
end;

function TFhirHealthcareServiceNotAvailableList.Append: TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceNotAvailableList.GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
begin
  result := TFhirHealthcareServiceNotAvailableListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceNotAvailableList.Clone: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceNotAvailableList.GetItemN(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceNotAvailable;
end;
function TFhirHealthcareServiceNotAvailableList.IndexOf(value: TFhirHealthcareServiceNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceNotAvailableList.Insert(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.InsertItem(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceNotAvailableList.Item(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.Link: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Link);
end;

procedure TFhirHealthcareServiceNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  FhirHealthcareServiceNotAvailables[index] := value;
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemN(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareService }

constructor TFhirHealthcareService.Create;
begin
  inherited;
end;

destructor TFhirHealthcareService.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FProvidedBy.free;
  FCategoryList.Free;
  FType_List.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FName.free;
  FComment.free;
  FExtraDetails.free;
  FPhoto.free;
  FTelecomList.Free;
  FCoverageAreaList.Free;
  FServiceProvisionCodeList.Free;
  FEligibilityList.Free;
  FProgram_List.Free;
  FCharacteristicList.Free;
  FCommunicationList.Free;
  FReferralMethodList.Free;
  FAppointmentRequired.free;
  FAvailableTimeList.Free;
  FNotAvailableList.Free;
  FAvailabilityExceptions.free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirHealthcareService.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareService(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirHealthcareService(oSource).FIdentifierList);
  end;
  activeElement := TFhirHealthcareService(oSource).activeElement.Clone;
  providedBy := TFhirHealthcareService(oSource).providedBy.Clone;
  if (TFhirHealthcareService(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirHealthcareService(oSource).FCategoryList);
  end;
  if (TFhirHealthcareService(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirHealthcareService(oSource).FType_List);
  end;
  if (TFhirHealthcareService(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirHealthcareService(oSource).FSpecialtyList);
  end;
  if (TFhirHealthcareService(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirHealthcareService(oSource).FLocationList);
  end;
  nameElement := TFhirHealthcareService(oSource).nameElement.Clone;
  commentElement := TFhirHealthcareService(oSource).commentElement.Clone;
  extraDetailsElement := TFhirHealthcareService(oSource).extraDetailsElement.Clone;
  photo := TFhirHealthcareService(oSource).photo.Clone;
  if (TFhirHealthcareService(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirHealthcareService(oSource).FTelecomList);
  end;
  if (TFhirHealthcareService(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirHealthcareService(oSource).FCoverageAreaList);
  end;
  if (TFhirHealthcareService(oSource).FServiceProvisionCodeList = nil) then
  begin
    FServiceProvisionCodeList.free;
    FServiceProvisionCodeList := nil;
  end
  else
  begin
    if FServiceProvisionCodeList = nil then
      FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
    FServiceProvisionCodeList.Assign(TFhirHealthcareService(oSource).FServiceProvisionCodeList);
  end;
  if (TFhirHealthcareService(oSource).FEligibilityList = nil) then
  begin
    FEligibilityList.free;
    FEligibilityList := nil;
  end
  else
  begin
    if FEligibilityList = nil then
      FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
    FEligibilityList.Assign(TFhirHealthcareService(oSource).FEligibilityList);
  end;
  if (TFhirHealthcareService(oSource).FProgram_List = nil) then
  begin
    FProgram_List.free;
    FProgram_List := nil;
  end
  else
  begin
    if FProgram_List = nil then
      FProgram_List := TFhirCodeableConceptList.Create;
    FProgram_List.Assign(TFhirHealthcareService(oSource).FProgram_List);
  end;
  if (TFhirHealthcareService(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirHealthcareService(oSource).FCharacteristicList);
  end;
  if (TFhirHealthcareService(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirHealthcareService(oSource).FCommunicationList);
  end;
  if (TFhirHealthcareService(oSource).FReferralMethodList = nil) then
  begin
    FReferralMethodList.free;
    FReferralMethodList := nil;
  end
  else
  begin
    if FReferralMethodList = nil then
      FReferralMethodList := TFhirCodeableConceptList.Create;
    FReferralMethodList.Assign(TFhirHealthcareService(oSource).FReferralMethodList);
  end;
  appointmentRequiredElement := TFhirHealthcareService(oSource).appointmentRequiredElement.Clone;
  if (TFhirHealthcareService(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirHealthcareService(oSource).FAvailableTimeList);
  end;
  if (TFhirHealthcareService(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirHealthcareService(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirHealthcareService(oSource).availabilityExceptionsElement.Clone;
  if (TFhirHealthcareService(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirHealthcareService(oSource).FEndpointList);
  end;
end;

function TFhirHealthcareService.GetResourceType : TFhirResourceType;
begin
  result := frtHealthcareService;
end;

procedure TFhirHealthcareService.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'providedBy') Then
     list.add(self.link, 'providedBy', FProvidedBy.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'extraDetails') Then
     list.add(self.link, 'extraDetails', FExtraDetails.Link);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'serviceProvisionCode') Then
    list.addAll(self, 'serviceProvisionCode', FServiceProvisionCodeList);
  if (child_name = 'eligibility') Then
    list.addAll(self, 'eligibility', FEligibilityList);
  if (child_name = 'program') Then
    list.addAll(self, 'program', FProgram_List);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'referralMethod') Then
    list.addAll(self, 'referralMethod', FReferralMethodList);
  if (child_name = 'appointmentRequired') Then
     list.add(self.link, 'appointmentRequired', FAppointmentRequired.Link);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirHealthcareService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'providedBy', 'Reference', false, TFhirReference, FProvidedBy.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'extraDetails', 'markdown', false, TFhirMarkdown, FExtraDetails.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceProvisionCode', 'CodeableConcept', true, TFhirCodeableConcept, FServiceProvisionCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'eligibility', 'BackboneElement', true, TFhirHealthcareServiceEligibility, FEligibilityList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'program', 'CodeableConcept', true, TFhirCodeableConcept, FProgram_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'referralMethod', 'CodeableConcept', true, TFhirCodeableConcept, FReferralMethodList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'appointmentRequired', 'boolean', false, TFhirBoolean, FAppointmentRequired.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'availableTime', 'BackboneElement', true, TFhirHealthcareServiceAvailableTime, FAvailableTimeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'notAvailable', 'BackboneElement', true, TFhirHealthcareServiceNotAvailable, FNotAvailableList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
end;

function TFhirHealthcareService.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'providedBy') then
  begin
    ProvidedBy := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'extraDetails') then
  begin
    ExtraDetailsElement := asMarkdown(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceProvisionCode') then
  begin
    ServiceProvisionCodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'eligibility') then
  begin
    EligibilityList.add(propValue as TFhirHealthcareServiceEligibility) {L1048};
    result := propValue;
  end
  else if (propName = 'program') then
  begin
    Program_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'referralMethod') then
  begin
    ReferralMethodList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'appointmentRequired') then
  begin
    AppointmentRequiredElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirHealthcareServiceAvailableTime) {L1048};
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirHealthcareServiceNotAvailable) {L1048};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareService.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'eligibility') then EligibilityList.insertItem(index, propValue as TFhirHealthcareServiceEligibility) {L1049}
  else if (propName = 'program') then Program_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'referralMethod') then ReferralMethodList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirHealthcareServiceAvailableTime) {L1049}
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirHealthcareServiceNotAvailable) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirHealthcareService.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'providedBy') then result := TFhirReference.create() {L1203}
  else if (propName = 'category') then result := CategoryList.new() {L1053}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'location') then result := LocationList.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else if (propName = 'extraDetails') then result := TFhirMarkdown.create() {L1223}
  else if (propName = 'photo') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new() {L1053}
  else if (propName = 'serviceProvisionCode') then result := ServiceProvisionCodeList.new() {L1053}
  else if (propName = 'eligibility') then result := EligibilityList.new() {L1053}
  else if (propName = 'program') then result := Program_List.new() {L1053}
  else if (propName = 'characteristic') then result := CharacteristicList.new() {L1053}
  else if (propName = 'communication') then result := CommunicationList.new() {L1053}
  else if (propName = 'referralMethod') then result := ReferralMethodList.new() {L1053}
  else if (propName = 'appointmentRequired') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'availableTime') then result := AvailableTimeList.new() {L1053}
  else if (propName = 'notAvailable') then result := NotAvailableList.new() {L1053}
  else if (propName = 'availabilityExceptions') then result := TFhirString.create() {L1223}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareService.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'providedBy') then result := 'Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'extraDetails') then result := 'markdown'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'serviceProvisionCode') then result := 'CodeableConcept'
  else if (propName = 'eligibility') then result := 'BackboneElement'
  else if (propName = 'program') then result := 'CodeableConcept'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else if (propName = 'referralMethod') then result := 'CodeableConcept'
  else if (propName = 'appointmentRequired') then result := 'boolean'
  else if (propName = 'availableTime') then result := 'BackboneElement'
  else if (propName = 'notAvailable') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareService.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'providedBy') then ProvidedByElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {L1054}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'extraDetails') then ExtraDetailsElement := nil
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {L1054}
  else if (propName = 'serviceProvisionCode') then deletePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, value) {L1054}
  else if (propName = 'eligibility') then deletePropertyValue('eligibility', EligibilityList, value) {L1054}
  else if (propName = 'program') then deletePropertyValue('program', Program_List, value) {L1054}
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {L1054}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {L1054}
  else if (propName = 'referralMethod') then deletePropertyValue('referralMethod', ReferralMethodList, value) {L1054}
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := nil
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value) {L1054}
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value) {L1054}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareService.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'providedBy') then ProvidedByElement := new as TFhirReference {L1195}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {L1055}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else if (propName = 'extraDetails') then ExtraDetailsElement := asMarkdown(new) {L1222}
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment {L1195}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {L1055}
  else if (propName = 'serviceProvisionCode') then replacePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, existing, new) {L1055}
  else if (propName = 'eligibility') then replacePropertyValue('eligibility', EligibilityList, existing, new) {L1055}
  else if (propName = 'program') then replacePropertyValue('program', Program_List, existing, new) {L1055}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {L1055}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {L1055}
  else if (propName = 'referralMethod') then replacePropertyValue('referralMethod', ReferralMethodList, existing, new) {L1055}
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := asBoolean(new) {L1222}
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new) {L1055}
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new) {L1055}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new) {L1222}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareService.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'category') then CategoryList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else if (propName = 'location') then LocationList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination) {L1050}
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.move(source, destination) {L1050}
  else if (propName = 'eligibility') then EligibilityList.move(source, destination) {L1050}
  else if (propName = 'program') then Program_List.move(source, destination) {L1050}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination) {L1050}
  else if (propName = 'communication') then CommunicationList.move(source, destination) {L1050}
  else if (propName = 'referralMethod') then ReferralMethodList.move(source, destination) {L1050}
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination) {L1050}
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareService.fhirType : string;
begin
  result := 'HealthcareService';
end;

function TFhirHealthcareService.Link : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Link);
end;

function TFhirHealthcareService.Clone : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Clone);
end;

function TFhirHealthcareService.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareService;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareService)) then
    result := false
  else
  begin
    o := TFhirHealthcareService(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(providedByElement, o.providedByElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(commentElement, o.commentElement, true) and compareDeep(extraDetailsElement, o.extraDetailsElement, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(serviceProvisionCodeList, o.serviceProvisionCodeList, true) and 
      compareDeep(eligibilityList, o.eligibilityList, true) and compareDeep(program_List, o.program_List, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(communicationList, o.communicationList, true) and 
      compareDeep(referralMethodList, o.referralMethodList, true) and compareDeep(appointmentRequiredElement, o.appointmentRequiredElement, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirHealthcareService.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FProvidedBy) and isEmptyProp(FcategoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FName) and isEmptyProp(FComment) and isEmptyProp(FExtraDetails) and isEmptyProp(FPhoto) and isEmptyProp(FtelecomList) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FserviceProvisionCodeList) and isEmptyProp(FeligibilityList) and isEmptyProp(Fprogram_List) and isEmptyProp(FcharacteristicList) and isEmptyProp(FcommunicationList) and isEmptyProp(FreferralMethodList) and isEmptyProp(FAppointmentRequired) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirHealthcareService.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirHealthcareService.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirHealthcareService.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirHealthcareService.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirHealthcareService.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirHealthcareService.SetProvidedBy(value : TFhirReference);
begin
  FProvidedBy.free;
  FProvidedBy := value; {L1134}
end;

function TFhirHealthcareService.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirHealthcareService.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirHealthcareService.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirHealthcareService.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirHealthcareService.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirHealthcareService.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirHealthcareService.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirHealthcareService.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirHealthcareService.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirHealthcareService.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirHealthcareService.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirHealthcareService.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirHealthcareService.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareService.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirHealthcareService.SetExtraDetails(value : TFhirMarkdown);
begin
  FExtraDetails.free;
  FExtraDetails := value; {L1134}
end;

function TFhirHealthcareService.GetExtraDetailsST : String;
begin
  if FExtraDetails = nil then
    result := ''
  else
    result := FExtraDetails.value;
end;

procedure TFhirHealthcareService.SetExtraDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FExtraDetails = nil then
      FExtraDetails := TFhirMarkdown.create;
    FExtraDetails.value := value
  end
  else if FExtraDetails <> nil then
    FExtraDetails.value := '';
end;

procedure TFhirHealthcareService.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value; {L1134}
end;

function TFhirHealthcareService.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirHealthcareService.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirHealthcareService.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirHealthcareService.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirHealthcareService.GetServiceProvisionCodeList : TFhirCodeableConceptList;
begin
  if FServiceProvisionCodeList = nil then
    FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
  result := FServiceProvisionCodeList;
end;

function TFhirHealthcareService.GetHasServiceProvisionCodeList : boolean;
begin
  result := (FServiceProvisionCodeList <> nil) and (FServiceProvisionCodeList.count > 0);
end;

function TFhirHealthcareService.GetEligibilityList : TFhirHealthcareServiceEligibilityList;
begin
  if FEligibilityList = nil then
    FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
  result := FEligibilityList;
end;

function TFhirHealthcareService.GetHasEligibilityList : boolean;
begin
  result := (FEligibilityList <> nil) and (FEligibilityList.count > 0);
end;

function TFhirHealthcareService.GetProgram_List : TFhirCodeableConceptList;
begin
  if FProgram_List = nil then
    FProgram_List := TFhirCodeableConceptList.Create;
  result := FProgram_List;
end;

function TFhirHealthcareService.GetHasProgram_List : boolean;
begin
  result := (FProgram_List <> nil) and (FProgram_List.count > 0);
end;

function TFhirHealthcareService.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirHealthcareService.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirHealthcareService.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirHealthcareService.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirHealthcareService.GetReferralMethodList : TFhirCodeableConceptList;
begin
  if FReferralMethodList = nil then
    FReferralMethodList := TFhirCodeableConceptList.Create;
  result := FReferralMethodList;
end;

function TFhirHealthcareService.GetHasReferralMethodList : boolean;
begin
  result := (FReferralMethodList <> nil) and (FReferralMethodList.count > 0);
end;

procedure TFhirHealthcareService.SetAppointmentRequired(value : TFhirBoolean);
begin
  FAppointmentRequired.free;
  FAppointmentRequired := value; {L1134}
end;

function TFhirHealthcareService.GetAppointmentRequiredST : Boolean;
begin
  if FAppointmentRequired = nil then
    result := false
  else
    result := FAppointmentRequired.value;
end;

procedure TFhirHealthcareService.SetAppointmentRequiredST(value : Boolean);
begin
  if FAppointmentRequired = nil then
    FAppointmentRequired := TFhirBoolean.create;
  FAppointmentRequired.value := value
end;

function TFhirHealthcareService.GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

function TFhirHealthcareService.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

function TFhirHealthcareService.GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
  result := FNotAvailableList;
end;

function TFhirHealthcareService.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

procedure TFhirHealthcareService.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value; {L1134}
end;

function TFhirHealthcareService.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirHealthcareService.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirHealthcareService.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirHealthcareService.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirHealthcareService.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('providedBy');
  fields.add('category');
  fields.add('type');
  fields.add('specialty');
  fields.add('location');
  fields.add('name');
  fields.add('comment');
  fields.add('extraDetails');
  fields.add('photo');
  fields.add('telecom');
  fields.add('coverageArea');
  fields.add('serviceProvisionCode');
  fields.add('eligibility');
  fields.add('program');
  fields.add('characteristic');
  fields.add('communication');
  fields.add('referralMethod');
  fields.add('appointmentRequired');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirHealthcareService.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FProvidedBy.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FExtraDetails.sizeInBytes);
  inc(result, FPhoto.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FcoverageAreaList.sizeInBytes);
  inc(result, FserviceProvisionCodeList.sizeInBytes);
  inc(result, FeligibilityList.sizeInBytes);
  inc(result, Fprogram_List.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
  inc(result, FcommunicationList.sizeInBytes);
  inc(result, FreferralMethodList.sizeInBytes);
  inc(result, FAppointmentRequired.sizeInBytes);
  inc(result, FavailableTimeList.sizeInBytes);
  inc(result, FnotAvailableList.sizeInBytes);
  inc(result, FAvailabilityExceptions.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
end;

{ TFhirHealthcareServiceListEnumerator }

constructor TFhirHealthcareServiceListEnumerator.Create(list : TFhirHealthcareServiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHealthcareServiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceListEnumerator.GetCurrent : TFhirHealthcareService;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirHealthcareServiceList }

procedure TFhirHealthcareServiceList.AddItem(value: TFhirHealthcareService);
begin
  assert(value.ClassName = 'TFhirHealthcareService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareService');
  add(value);
end;

function TFhirHealthcareServiceList.Append: TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceList.GetEnumerator : TFhirHealthcareServiceListEnumerator;
begin
  result := TFhirHealthcareServiceListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceList.Clone: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Clone);
end;

function TFhirHealthcareServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceList.GetItemN(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareService;
end;
function TFhirHealthcareServiceList.IndexOf(value: TFhirHealthcareService): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceList.Insert(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.InsertItem(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceList.Item(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.Link: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Link);
end;

procedure TFhirHealthcareServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceList.SetItemByIndex(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  FhirHealthcareServices[index] := value;
end;

procedure TFhirHealthcareServiceList.SetItemN(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TFslObject);
begin
  inherited;
  longitudeElement := TFhirLocationPosition(oSource).longitudeElement.Clone;
  latitudeElement := TFhirLocationPosition(oSource).latitudeElement.Clone;
  altitudeElement := TFhirLocationPosition(oSource).altitudeElement.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(self.link, 'longitude', FLongitude.Link);
  if (child_name = 'latitude') Then
     list.add(self.link, 'latitude', FLatitude.Link);
  if (child_name = 'altitude') Then
     list.add(self.link, 'altitude', FAltitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'longitude', 'decimal', false, TFhirDecimal, FLongitude.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'latitude', 'decimal', false, TFhirDecimal, FLatitude.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'altitude', 'decimal', false, TFhirDecimal, FAltitude.Link)); {L1172}
end;

function TFhirLocationPosition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'longitude') then
  begin
    LongitudeElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'latitude') then
  begin
    LatitudeElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'altitude') then
  begin
    AltitudeElement := asDecimal(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationPosition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLocationPosition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'longitude') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'latitude') then result := TFhirDecimal.create() {L1223}
  else if (propName = 'altitude') then result := TFhirDecimal.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationPosition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'longitude') then result := 'decimal'
  else if (propName = 'latitude') then result := 'decimal'
  else if (propName = 'altitude') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationPosition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := nil
  else if (propName = 'latitude') then LatitudeElement := nil
  else if (propName = 'altitude') then AltitudeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationPosition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := asDecimal(new) {L1222}
  else if (propName = 'latitude') then LatitudeElement := asDecimal(new) {L1222}
  else if (propName = 'altitude') then AltitudeElement := asDecimal(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationPosition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationPosition.fhirType : string;
begin
  result := 'Location.position';
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

function TFhirLocationPosition.equals(other : TObject) : boolean; 
var
  o : TFhirLocationPosition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationPosition)) then
    result := false
  else
  begin
    o := TFhirLocationPosition(other);
    result := compareDeep(longitudeElement, o.longitudeElement, true) and compareDeep(latitudeElement, o.latitudeElement, true) and 
      compareDeep(altitudeElement, o.altitudeElement, true);
  end;
end;

function TFhirLocationPosition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLongitude) and isEmptyProp(FLatitude) and isEmptyProp(FAltitude);
end;

procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value; {L1134}
end;

function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := FLongitude.value;
end;

procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value; {L1134}
end;

function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := FLatitude.value;
end;

procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value; {L1134}
end;

function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := FAltitude.value;
end;

procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;

procedure TFhirLocationPosition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('longitude');
  fields.add('latitude');
  fields.add('altitude');
end;

function TFhirLocationPosition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLongitude.sizeInBytes);
  inc(result, FLatitude.sizeInBytes);
  inc(result, FAltitude.sizeInBytes);
end;

{ TFhirLocationPositionListEnumerator }

constructor TFhirLocationPositionListEnumerator.Create(list : TFhirLocationPositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationPositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationPositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationPositionListEnumerator.GetCurrent : TFhirLocationPosition;
begin
  Result := FList[FIndex];
end;

function TFhirLocationPositionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLocationPositionList }

procedure TFhirLocationPositionList.AddItem(value: TFhirLocationPosition);
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
end;

function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.GetEnumerator : TFhirLocationPositionListEnumerator;
begin
  result := TFhirLocationPositionListEnumerator.Create(self.link);
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationPosition;
end;
function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationHoursOfOperation }

constructor TFhirLocationHoursOfOperation.Create;
begin
  inherited;
end;

destructor TFhirLocationHoursOfOperation.Destroy;
begin
  FDaysOfWeek.Free;
  FAllDay.free;
  FOpeningTime.free;
  FClosingTime.free;
  inherited;
end;

procedure TFhirLocationHoursOfOperation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocationHoursOfOperation(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirLocationHoursOfOperation(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirLocationHoursOfOperation(oSource).allDayElement.Clone;
  openingTimeElement := TFhirLocationHoursOfOperation(oSource).openingTimeElement.Clone;
  closingTimeElement := TFhirLocationHoursOfOperation(oSource).closingTimeElement.Clone;
end;

procedure TFhirLocationHoursOfOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'openingTime') Then
     list.add(self.link, 'openingTime', FOpeningTime.Link);
  if (child_name = 'closingTime') Then
     list.add(self.link, 'closingTime', FClosingTime.Link);
end;

procedure TFhirLocationHoursOfOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'openingTime', 'time', false, TFhirTime, FOpeningTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'closingTime', 'time', false, TFhirTime, FClosingTime.Link)); {L1172}
end;

function TFhirLocationHoursOfOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'openingTime') then
  begin
    OpeningTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'closingTime') then
  begin
    ClosingTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationHoursOfOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {L995}
  else inherited;
end;

function TFhirLocationHoursOfOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'openingTime') then result := TFhirTime.create() {L1223}
  else if (propName = 'closingTime') then result := TFhirTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationHoursOfOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'openingTime') then result := 'time'
  else if (propName = 'closingTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationHoursOfOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'openingTime') then OpeningTimeElement := nil
  else if (propName = 'closingTime') then ClosingTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationHoursOfOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new) {L1222}
  else if (propName = 'openingTime') then OpeningTimeElement := asTime(new) {L1222}
  else if (propName = 'closingTime') then ClosingTimeElement := asTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationHoursOfOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {L996}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationHoursOfOperation.fhirType : string;
begin
  result := 'Location.hoursOfOperation';
end;

function TFhirLocationHoursOfOperation.Link : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Link);
end;

function TFhirLocationHoursOfOperation.Clone : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Clone);
end;

function TFhirLocationHoursOfOperation.equals(other : TObject) : boolean; 
var
  o : TFhirLocationHoursOfOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationHoursOfOperation)) then
    result := false
  else
  begin
    o := TFhirLocationHoursOfOperation(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(openingTimeElement, o.openingTimeElement, true) and compareDeep(closingTimeElement, o.closingTimeElement, true);
  end;
end;

function TFhirLocationHoursOfOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FOpeningTime) and isEmptyProp(FClosingTime);
end;

function TFhirLocationHoursOfOperation.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirLocationHoursOfOperation.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirLocationHoursOfOperation.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirLocationHoursOfOperation.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirLocationHoursOfOperation.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value; {L1134}
end;

function TFhirLocationHoursOfOperation.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirLocationHoursOfOperation.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.create;
  FAllDay.value := value
end;

procedure TFhirLocationHoursOfOperation.SetOpeningTime(value : TFhirTime);
begin
  FOpeningTime.free;
  FOpeningTime := value; {L1134}
end;

function TFhirLocationHoursOfOperation.GetOpeningTimeST : String;
begin
  if FOpeningTime = nil then
    result := ''
  else
    result := FOpeningTime.value;
end;

procedure TFhirLocationHoursOfOperation.SetOpeningTimeST(value : String);
begin
  if value <> '' then
  begin
    if FOpeningTime = nil then
      FOpeningTime := TFhirTime.create;
    FOpeningTime.value := value
  end
  else if FOpeningTime <> nil then
    FOpeningTime.value := '';
end;

procedure TFhirLocationHoursOfOperation.SetClosingTime(value : TFhirTime);
begin
  FClosingTime.free;
  FClosingTime := value; {L1134}
end;

function TFhirLocationHoursOfOperation.GetClosingTimeST : String;
begin
  if FClosingTime = nil then
    result := ''
  else
    result := FClosingTime.value;
end;

procedure TFhirLocationHoursOfOperation.SetClosingTimeST(value : String);
begin
  if value <> '' then
  begin
    if FClosingTime = nil then
      FClosingTime := TFhirTime.create;
    FClosingTime.value := value
  end
  else if FClosingTime <> nil then
    FClosingTime.value := '';
end;

procedure TFhirLocationHoursOfOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('openingTime');
  fields.add('closingTime');
end;

function TFhirLocationHoursOfOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDaysOfWeek.sizeInBytes);
  inc(result, FAllDay.sizeInBytes);
  inc(result, FOpeningTime.sizeInBytes);
  inc(result, FClosingTime.sizeInBytes);
end;

{ TFhirLocationHoursOfOperationListEnumerator }

constructor TFhirLocationHoursOfOperationListEnumerator.Create(list : TFhirLocationHoursOfOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationHoursOfOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationHoursOfOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationHoursOfOperationListEnumerator.GetCurrent : TFhirLocationHoursOfOperation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationHoursOfOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLocationHoursOfOperationList }

procedure TFhirLocationHoursOfOperationList.AddItem(value: TFhirLocationHoursOfOperation);
begin
  assert(value.ClassName = 'TFhirLocationHoursOfOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationHoursOfOperation');
  add(value);
end;

function TFhirLocationHoursOfOperationList.Append: TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationHoursOfOperationList.GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
begin
  result := TFhirLocationHoursOfOperationListEnumerator.Create(self.link);
end;

function TFhirLocationHoursOfOperationList.Clone: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Clone);
end;

function TFhirLocationHoursOfOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationHoursOfOperationList.GetItemN(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationHoursOfOperation;
end;
function TFhirLocationHoursOfOperationList.IndexOf(value: TFhirLocationHoursOfOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationHoursOfOperationList.Insert(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.InsertItem(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  Inherited Insert(index, value);
end;

function TFhirLocationHoursOfOperationList.Item(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.Link: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Link);
end;

procedure TFhirLocationHoursOfOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationHoursOfOperationList.SetItemByIndex(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  FhirLocationHoursOfOperations[index] := value;
end;

procedure TFhirLocationHoursOfOperationList.SetItemN(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirLocation }

constructor TFhirLocation.Create;
begin
  inherited;
end;

destructor TFhirLocation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FOperationalStatus.free;
  FName.free;
  FAliasList.Free;
  FDescription.free;
  FMode.free;
  FType_List.Free;
  FTelecomList.Free;
  FAddress.free;
  FPhysicalType.free;
  FPosition.free;
  FManagingOrganization.free;
  FPartOf.free;
  FHoursOfOperationList.Free;
  FAvailabilityExceptions.free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirLocation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLocation(oSource).FIdentifierList);
  end;
  statusElement := TFhirLocation(oSource).statusElement.Clone;
  operationalStatus := TFhirLocation(oSource).operationalStatus.Clone;
  nameElement := TFhirLocation(oSource).nameElement.Clone;
  if (TFhirLocation(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirLocation(oSource).FAliasList);
  end;
  descriptionElement := TFhirLocation(oSource).descriptionElement.Clone;
  modeElement := TFhirLocation(oSource).modeElement.Clone;
  if (TFhirLocation(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirLocation(oSource).FType_List);
  end;
  if (TFhirLocation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirLocation(oSource).FTelecomList);
  end;
  address := TFhirLocation(oSource).address.Clone;
  physicalType := TFhirLocation(oSource).physicalType.Clone;
  position := TFhirLocation(oSource).position.Clone;
  managingOrganization := TFhirLocation(oSource).managingOrganization.Clone;
  partOf := TFhirLocation(oSource).partOf.Clone;
  if (TFhirLocation(oSource).FHoursOfOperationList = nil) then
  begin
    FHoursOfOperationList.free;
    FHoursOfOperationList := nil;
  end
  else
  begin
    if FHoursOfOperationList = nil then
      FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
    FHoursOfOperationList.Assign(TFhirLocation(oSource).FHoursOfOperationList);
  end;
  availabilityExceptionsElement := TFhirLocation(oSource).availabilityExceptionsElement.Clone;
  if (TFhirLocation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirLocation(oSource).FEndpointList);
  end;
end;

function TFhirLocation.GetResourceType : TFhirResourceType;
begin
  result := frtLocation;
end;

procedure TFhirLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'position') Then
     list.add(self.link, 'position', FPosition.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'hoursOfOperation') Then
    list.addAll(self, 'hoursOfOperation', FHoursOfOperationList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'operationalStatus', 'Coding', false, TFhirCoding, FOperationalStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'position', 'BackboneElement', false, TFhirLocationPosition, FPosition.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'hoursOfOperation', 'BackboneElement', true, TFhirLocationHoursOfOperation, FHoursOfOperationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
end;

function TFhirLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatus := propValue as TFhirCoding {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress {L1199};
    result := propValue;
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'position') then
  begin
    Position := propValue as TFhirLocationPosition {L1199};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'hoursOfOperation') then
  begin
    HoursOfOperationList.add(propValue as TFhirLocationHoursOfOperation) {L1048};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.insertItem(index, propValue as TFhirLocationHoursOfOperation) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirLocationStatusEnum[LocationStatusNull], CODES_TFhirLocationStatusEnum[LocationStatusNull])  {L1211}
  else if (propName = 'operationalStatus') then result := TFhirCoding.create() {L1203}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'alias') then result := AliasList.new() {L1053}
  else if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirLocationModeEnum[LocationModeNull], CODES_TFhirLocationModeEnum[LocationModeNull])  {L1211}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := TFhirAddress.create() {L1203}
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'position') then result := TFhirLocationPosition.create() {L1203}
  else if (propName = 'managingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'partOf') then result := TFhirReference.create() {L1203}
  else if (propName = 'hoursOfOperation') then result := HoursOfOperationList.new() {L1053}
  else if (propName = 'availabilityExceptions') then result := TFhirString.create() {L1223}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'operationalStatus') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'position') then result := 'BackboneElement'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'hoursOfOperation') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {L1054}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'position') then PositionElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'hoursOfOperation') then deletePropertyValue('hoursOfOperation', HoursOfOperationList, value) {L1054}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, new) {L1210}
  else if (propName = 'operationalStatus') then OperationalStatusElement := new as TFhirCoding {L1195}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {L1055}
  else if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, new) {L1210}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then AddressElement := new as TFhirAddress {L1195}
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'position') then PositionElement := new as TFhirLocationPosition {L1195}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference {L1195}
  else if (propName = 'hoursOfOperation') then replacePropertyValue('hoursOfOperation', HoursOfOperationList, existing, new) {L1055}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new) {L1222}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'alias') then AliasList.move(source, destination) {L1046}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocation.fhirType : string;
begin
  result := 'Location';
end;

function TFhirLocation.Link : TFhirLocation;
begin
  result := TFhirLocation(inherited Link);
end;

function TFhirLocation.Clone : TFhirLocation;
begin
  result := TFhirLocation(inherited Clone);
end;

function TFhirLocation.equals(other : TObject) : boolean; 
var
  o : TFhirLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocation)) then
    result := false
  else
  begin
    o := TFhirLocation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(operationalStatusElement, o.operationalStatusElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(positionElement, o.positionElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true) and compareDeep(hoursOfOperationList, o.hoursOfOperationList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FOperationalStatus) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FDescription) and isEmptyProp(FMode) and isEmptyProp(Ftype_List) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FPhysicalType) and isEmptyProp(FPosition) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPartOf) and isEmptyProp(FhoursOfOperationList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirLocation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirLocation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirLocation.GetStatusST : TFhirLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirLocationStatusEnum(0)
  else
    result := TFhirLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationStatusEnum, FStatus.value));
end;

procedure TFhirLocation.SetStatusST(value : TFhirLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirLocationStatusEnum[value], CODES_TFhirLocationStatusEnum[value]);
end;

procedure TFhirLocation.SetOperationalStatus(value : TFhirCoding);
begin
  FOperationalStatus.free;
  FOperationalStatus := value; {L1134}
end;

procedure TFhirLocation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirLocation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirLocation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirLocation.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirLocation.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirLocation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirLocation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirLocation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirLocation.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirLocation.GetModeST : TFhirLocationModeEnum;
begin
  if FMode = nil then
    result := TFhirLocationModeEnum(0)
  else
    result := TFhirLocationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationModeEnum, FMode.value));
end;

procedure TFhirLocation.SetModeST(value : TFhirLocationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirLocationModeEnum[value], CODES_TFhirLocationModeEnum[value]);
end;

function TFhirLocation.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirLocation.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirLocation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirLocation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirLocation.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value; {L1134}
end;

procedure TFhirLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value; {L1134}
end;

procedure TFhirLocation.SetPosition(value : TFhirLocationPosition);
begin
  FPosition.free;
  FPosition := value; {L1134}
end;

procedure TFhirLocation.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value; {L1134}
end;

procedure TFhirLocation.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value; {L1134}
end;

function TFhirLocation.GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
begin
  if FHoursOfOperationList = nil then
    FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
  result := FHoursOfOperationList;
end;

function TFhirLocation.GetHasHoursOfOperationList : boolean;
begin
  result := (FHoursOfOperationList <> nil) and (FHoursOfOperationList.count > 0);
end;

procedure TFhirLocation.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value; {L1134}
end;

function TFhirLocation.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirLocation.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirLocation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirLocation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirLocation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('operationalStatus');
  fields.add('name');
  fields.add('alias');
  fields.add('description');
  fields.add('mode');
  fields.add('type');
  fields.add('telecom');
  fields.add('address');
  fields.add('physicalType');
  fields.add('position');
  fields.add('managingOrganization');
  fields.add('partOf');
  fields.add('hoursOfOperation');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirLocation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FOperationalStatus.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
  inc(result, FPhysicalType.sizeInBytes);
  inc(result, FPosition.sizeInBytes);
  inc(result, FManagingOrganization.sizeInBytes);
  inc(result, FPartOf.sizeInBytes);
  inc(result, FhoursOfOperationList.sizeInBytes);
  inc(result, FAvailabilityExceptions.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
end;

{ TFhirLocationListEnumerator }

constructor TFhirLocationListEnumerator.Create(list : TFhirLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationListEnumerator.GetCurrent : TFhirLocation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLocationList }

procedure TFhirLocationList.AddItem(value: TFhirLocation);
begin
  assert(value.ClassName = 'TFhirLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocation');
  add(value);
end;

function TFhirLocationList.Append: TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationList.GetEnumerator : TFhirLocationListEnumerator;
begin
  result := TFhirLocationListEnumerator.Create(self.link);
end;

function TFhirLocationList.Clone: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Clone);
end;

function TFhirLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationList.GetItemN(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocation;
end;
function TFhirLocationList.IndexOf(value: TFhirLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationList.Insert(index: Integer): TFhirLocation;
begin
  result := TFhirLocation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.InsertItem(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  Inherited Insert(index, value);
end;

function TFhirLocationList.Item(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.Link: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Link);
end;

procedure TFhirLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationList.SetItemByIndex(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  FhirLocations[index] := value;
end;

procedure TFhirLocationList.SetItemN(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  if (TFhirOrganizationContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  end;
  address := TFhirOrganizationContact(oSource).address.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link)); {L1172}
end;

function TFhirOrganizationContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName {L1199};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else inherited;
end;

function TFhirOrganizationContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'name') then result := TFhirHumanName.create() {L1203}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := TFhirAddress.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'name') then NameElement := new as TFhirHumanName {L1195}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then AddressElement := new as TFhirAddress {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationContact.fhirType : string;
begin
  result := 'Organization.contact';
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

function TFhirOrganizationContact.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationContact)) then
    result := false
  else
  begin
    o := TFhirOrganizationContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirOrganizationContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value; {L1134}
end;

procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirOrganizationContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganizationContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value; {L1134}
end;

procedure TFhirOrganizationContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

function TFhirOrganizationContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
end;

{ TFhirOrganizationContactListEnumerator }

constructor TFhirOrganizationContactListEnumerator.Create(list : TFhirOrganizationContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationContactListEnumerator.GetCurrent : TFhirOrganizationContact;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrganizationContactList }

procedure TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact);
begin
  assert(value.ClassName = 'TFhirOrganizationContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationContact');
  add(value);
end;

function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.GetEnumerator : TFhirOrganizationContactListEnumerator;
begin
  result := TFhirOrganizationContactListEnumerator.Create(self.link);
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationContact;
end;
function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganization }

constructor TFhirOrganization.Create;
begin
  inherited;
end;

destructor TFhirOrganization.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FType_List.Free;
  FName.free;
  FAliasList.Free;
  FTelecomList.Free;
  FAddressList.Free;
  FPartOf.free;
  FContactList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirOrganization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganization(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganization(oSource).activeElement.Clone;
  if (TFhirOrganization(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirOrganization(oSource).FType_List);
  end;
  nameElement := TFhirOrganization(oSource).nameElement.Clone;
  if (TFhirOrganization(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirOrganization(oSource).FAliasList);
  end;
  if (TFhirOrganization(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganization(oSource).FTelecomList);
  end;
  if (TFhirOrganization(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirOrganization(oSource).FAddressList);
  end;
  partOf := TFhirOrganization(oSource).partOf.Clone;
  if (TFhirOrganization(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirOrganizationContactList.Create;
    FContactList.Assign(TFhirOrganization(oSource).FContactList);
  end;
  if (TFhirOrganization(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganization(oSource).FEndpointList);
  end;
end;

function TFhirOrganization.GetResourceType : TFhirResourceType;
begin
  result := frtOrganization;
end;

procedure TFhirOrganization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirOrganizationContact, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
end;

function TFhirOrganization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirOrganizationContact) {L1048};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)) {L1045}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirOrganizationContact) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirOrganization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'type') then result := Type_List.new() {L1053}
  else if (propName = 'name') then result := TFhirString.create() {L1223}
  else if (propName = 'alias') then result := AliasList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'partOf') then result := TFhirReference.create() {L1203}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {L1055}
  else if (propName = 'name') then NameElement := asString(new) {L1222}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference {L1195}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'type') then Type_List.move(source, destination) {L1050}
  else if (propName = 'alias') then AliasList.move(source, destination) {L1046}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganization.fhirType : string;
begin
  result := 'Organization';
end;

function TFhirOrganization.Link : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Link);
end;

function TFhirOrganization.Clone : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Clone);
end;

function TFhirOrganization.equals(other : TObject) : boolean; 
var
  o : TFhirOrganization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganization)) then
    result := false
  else
  begin
    o := TFhirOrganization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(partOfElement, o.partOfElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FPartOf) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList);
end;

function TFhirOrganization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganization.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirOrganization.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganization.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirOrganization.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirOrganization.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirOrganization.SetName(value : TFhirString);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirOrganization.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirOrganization.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirOrganization.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirOrganization.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

function TFhirOrganization.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganization.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirOrganization.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirOrganization.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirOrganization.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value; {L1134}
end;

function TFhirOrganization.GetContactList : TFhirOrganizationContactList;
begin
  if FContactList = nil then
    FContactList := TFhirOrganizationContactList.Create;
  result := FContactList;
end;

function TFhirOrganization.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirOrganization.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganization.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirOrganization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('telecom');
  fields.add('address');
  fields.add('partOf');
  fields.add('contact');
  fields.add('endpoint');
end;

function TFhirOrganization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FPartOf.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
end;

{ TFhirOrganizationListEnumerator }

constructor TFhirOrganizationListEnumerator.Create(list : TFhirOrganizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationListEnumerator.GetCurrent : TFhirOrganization;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrganizationList }

procedure TFhirOrganizationList.AddItem(value: TFhirOrganization);
begin
  assert(value.ClassName = 'TFhirOrganization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganization');
  add(value);
end;

function TFhirOrganizationList.Append: TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationList.GetEnumerator : TFhirOrganizationListEnumerator;
begin
  result := TFhirOrganizationListEnumerator.Create(self.link);
end;

function TFhirOrganizationList.Clone: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Clone);
end;

function TFhirOrganizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationList.GetItemN(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganization;
end;
function TFhirOrganizationList.IndexOf(value: TFhirOrganization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationList.Insert(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.InsertItem(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  Inherited Insert(index, value);
end;

function TFhirOrganizationList.Item(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.Link: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Link);
end;

procedure TFhirOrganizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationList.SetItemByIndex(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  FhirOrganizations[index] := value;
end;

procedure TFhirOrganizationList.SetItemN(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
{ TFhirOrganizationAffiliation }

constructor TFhirOrganizationAffiliation.Create;
begin
  inherited;
end;

destructor TFhirOrganizationAffiliation.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPeriod.free;
  FOrganization.free;
  FParticipatingOrganization.free;
  FNetworkList.Free;
  FCodeList.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FHealthcareServiceList.Free;
  FTelecomList.Free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirOrganizationAffiliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganizationAffiliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganizationAffiliation(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganizationAffiliation(oSource).activeElement.Clone;
  period := TFhirOrganizationAffiliation(oSource).period.Clone;
  organization := TFhirOrganizationAffiliation(oSource).organization.Clone;
  participatingOrganization := TFhirOrganizationAffiliation(oSource).participatingOrganization.Clone;
  if (TFhirOrganizationAffiliation(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirOrganizationAffiliation(oSource).FNetworkList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirOrganizationAffiliation(oSource).FCodeList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirOrganizationAffiliation(oSource).FSpecialtyList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirOrganizationAffiliation(oSource).FLocationList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirOrganizationAffiliation(oSource).FHealthcareServiceList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationAffiliation(oSource).FTelecomList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganizationAffiliation(oSource).FEndpointList);
  end;
end;

function TFhirOrganizationAffiliation.GetResourceType : TFhirResourceType;
begin
  result := frtOrganizationAffiliation;
end;

procedure TFhirOrganizationAffiliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'participatingOrganization') Then
     list.add(self.link, 'participatingOrganization', FParticipatingOrganization.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganizationAffiliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'participatingOrganization', 'Reference', false, TFhirReference, FParticipatingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
end;

function TFhirOrganizationAffiliation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'participatingOrganization') then
  begin
    ParticipatingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationAffiliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirOrganizationAffiliation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'organization') then result := TFhirReference.create() {L1203}
  else if (propName = 'participatingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'network') then result := NetworkList.new() {L1053}
  else if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'location') then result := LocationList.new() {L1053}
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationAffiliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'participatingOrganization') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationAffiliation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {L1054}
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {L1054}
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationAffiliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {L1055}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {L1055}
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationAffiliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'network') then NetworkList.move(source, destination) {L1050}
  else if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else if (propName = 'location') then LocationList.move(source, destination) {L1050}
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationAffiliation.fhirType : string;
begin
  result := 'OrganizationAffiliation';
end;

function TFhirOrganizationAffiliation.Link : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Link);
end;

function TFhirOrganizationAffiliation.Clone : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Clone);
end;

function TFhirOrganizationAffiliation.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationAffiliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationAffiliation)) then
    result := false
  else
  begin
    o := TFhirOrganizationAffiliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(participatingOrganizationElement, o.participatingOrganizationElement, true) and 
      compareDeep(networkList, o.networkList, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganizationAffiliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FOrganization) and isEmptyProp(FParticipatingOrganization) and isEmptyProp(FnetworkList) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FendpointList);
end;

function TFhirOrganizationAffiliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganizationAffiliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganizationAffiliation.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirOrganizationAffiliation.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganizationAffiliation.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirOrganizationAffiliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirOrganizationAffiliation.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value; {L1134}
end;

procedure TFhirOrganizationAffiliation.SetParticipatingOrganization(value : TFhirReference);
begin
  FParticipatingOrganization.free;
  FParticipatingOrganization := value; {L1134}
end;

function TFhirOrganizationAffiliation.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirOrganizationAffiliation.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirOrganizationAffiliation.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirOrganizationAffiliation.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirOrganizationAffiliation.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirOrganizationAffiliation.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirOrganizationAffiliation.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirOrganizationAffiliation.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOrganizationAffiliation.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirOrganizationAffiliation.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirOrganizationAffiliation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganizationAffiliation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirOrganizationAffiliation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganizationAffiliation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirOrganizationAffiliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('organization');
  fields.add('participatingOrganization');
  fields.add('network');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('endpoint');
end;

function TFhirOrganizationAffiliation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FParticipatingOrganization.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FhealthcareServiceList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
end;

{ TFhirOrganizationAffiliationListEnumerator }

constructor TFhirOrganizationAffiliationListEnumerator.Create(list : TFhirOrganizationAffiliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationAffiliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOrganizationAffiliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationAffiliationListEnumerator.GetCurrent : TFhirOrganizationAffiliation;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationAffiliationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOrganizationAffiliationList }

procedure TFhirOrganizationAffiliationList.AddItem(value: TFhirOrganizationAffiliation);
begin
  assert(value.ClassName = 'TFhirOrganizationAffiliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationAffiliation');
  add(value);
end;

function TFhirOrganizationAffiliationList.Append: TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationAffiliationList.GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
begin
  result := TFhirOrganizationAffiliationListEnumerator.Create(self.link);
end;

function TFhirOrganizationAffiliationList.Clone: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Clone);
end;

function TFhirOrganizationAffiliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationAffiliationList.GetItemN(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationAffiliation;
end;
function TFhirOrganizationAffiliationList.IndexOf(value: TFhirOrganizationAffiliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationAffiliationList.Insert(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.InsertItem(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  Inherited Insert(index, value);
end;

function TFhirOrganizationAffiliationList.Item(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.Link: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Link);
end;

procedure TFhirOrganizationAffiliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationAffiliationList.SetItemByIndex(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  FhirOrganizationAffiliations[index] := value;
end;

procedure TFhirOrganizationAffiliationList.SetItemN(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.Free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatientContact(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  end;
  name := TFhirPatientContact(oSource).name.Clone;
  if (TFhirPatientContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  end;
  address := TFhirPatientContact(oSource).address.Clone;
  genderElement := TFhirPatientContact(oSource).genderElement.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
  period := TFhirPatientContact(oSource).period.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
end;

function TFhirPatientContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName {L1199};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress {L1199};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else inherited;
end;

function TFhirPatientContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationship') then result := RelationshipList.new() {L1053}
  else if (propName = 'name') then result := TFhirHumanName.create() {L1203}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := TFhirAddress.create() {L1203}
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull])  {L1211}
  else if (propName = 'organization') then result := TFhirReference.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {L1054}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {L1055}
  else if (propName = 'name') then NameElement := new as TFhirHumanName {L1195}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then AddressElement := new as TFhirAddress {L1195}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new) {L1210}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relationship') then RelationshipList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientContact.fhirType : string;
begin
  result := 'Patient.contact';
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

function TFhirPatientContact.equals(other : TObject) : boolean; 
var
  o : TFhirPatientContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientContact)) then
    result := false
  else
  begin
    o := TFhirPatientContact(other);
    result := compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirPatientContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelationshipList) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FGender) and isEmptyProp(FOrganization) and isEmptyProp(FPeriod);
end;

function TFhirPatientContact.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirPatientContact.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value; {L1134}
end;

function TFhirPatientContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatientContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value; {L1134}
end;

procedure TFhirPatientContact.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatientContact.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatientContact.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatientContact.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value; {L1134}
end;

procedure TFhirPatientContact.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirPatientContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('organization');
  fields.add('period');
end;

function TFhirPatientContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FrelationshipList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirPatientContactListEnumerator }

constructor TFhirPatientContactListEnumerator.Create(list : TFhirPatientContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientContactListEnumerator.GetCurrent : TFhirPatientContact;
begin
  Result := FList[FIndex];
end;

function TFhirPatientContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPatientContactList }

procedure TFhirPatientContactList.AddItem(value: TFhirPatientContact);
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
end;

function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.GetEnumerator : TFhirPatientContactListEnumerator;
begin
  result := TFhirPatientContactListEnumerator.Create(self.link);
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientContact;
end;
function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientCommunication }

constructor TFhirPatientCommunication.Create;
begin
  inherited;
end;

destructor TFhirPatientCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirPatientCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirPatientCommunication(oSource).language.Clone;
  preferredElement := TFhirPatientCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirPatientCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirPatientCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link)); {L1172}
end;

function TFhirPatientCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientCommunication.fhirType : string;
begin
  result := 'Patient.communication';
end;

function TFhirPatientCommunication.Link : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Link);
end;

function TFhirPatientCommunication.Clone : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Clone);
end;

function TFhirPatientCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirPatientCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientCommunication)) then
    result := false
  else
  begin
    o := TFhirPatientCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirPatientCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirPatientCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirPatientCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value; {L1134}
end;

function TFhirPatientCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirPatientCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

procedure TFhirPatientCommunication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirPatientCommunication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
end;

{ TFhirPatientCommunicationListEnumerator }

constructor TFhirPatientCommunicationListEnumerator.Create(list : TFhirPatientCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientCommunicationListEnumerator.GetCurrent : TFhirPatientCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirPatientCommunicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPatientCommunicationList }

procedure TFhirPatientCommunicationList.AddItem(value: TFhirPatientCommunication);
begin
  assert(value.ClassName = 'TFhirPatientCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientCommunication');
  add(value);
end;

function TFhirPatientCommunicationList.Append: TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirPatientCommunicationList.GetEnumerator : TFhirPatientCommunicationListEnumerator;
begin
  result := TFhirPatientCommunicationListEnumerator.Create(self.link);
end;

function TFhirPatientCommunicationList.Clone: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Clone);
end;

function TFhirPatientCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientCommunicationList.GetItemN(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientCommunication;
end;
function TFhirPatientCommunicationList.IndexOf(value: TFhirPatientCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientCommunicationList.Insert(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.InsertItem(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  Inherited Insert(index, value);
end;

function TFhirPatientCommunicationList.Item(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.Link: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Link);
end;

procedure TFhirPatientCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientCommunicationList.SetItemByIndex(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  FhirPatientCommunications[index] := value;
end;

procedure TFhirPatientCommunicationList.SetItemN(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TFslObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  type_Element := TFhirPatientLink(oSource).type_Element.Clone;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(self.link, 'other', FOther.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'other', 'Reference', false, TFhirReference, FOther.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link)); {L1170}
end;

function TFhirPatientLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'other') then
  begin
    Other := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'other') then result := TFhirReference.create() {L1203}
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirLinkTypeEnum[LinkTypeNull], CODES_TFhirLinkTypeEnum[LinkTypeNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'other') then result := 'Reference'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := new as TFhirReference {L1195}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientLink.fhirType : string;
begin
  result := 'Patient.link';
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

function TFhirPatientLink.equals(other : TObject) : boolean; 
var
  o : TFhirPatientLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientLink)) then
    result := false
  else
  begin
    o := TFhirPatientLink(other);
    result := compareDeep(otherElement, o.otherElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirPatientLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOther) and isEmptyProp(FType_);
end;

procedure TFhirPatientLink.SetOther(value : TFhirReference);
begin
  FOther.free;
  FOther := value; {L1134}
end;

procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPatientLink.GetType_ST : TFhirLinkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkTypeEnum(0)
  else
    result := TFhirLinkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkTypeEnum, FType_.value));
end;

procedure TFhirPatientLink.SetType_ST(value : TFhirLinkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkTypeEnum[value], CODES_TFhirLinkTypeEnum[value]);
end;

procedure TFhirPatientLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('other');
  fields.add('type');
end;

function TFhirPatientLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOther.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirPatientLinkListEnumerator }

constructor TFhirPatientLinkListEnumerator.Create(list : TFhirPatientLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientLinkListEnumerator.GetCurrent : TFhirPatientLink;
begin
  Result := FList[FIndex];
end;

function TFhirPatientLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPatientLinkList }

procedure TFhirPatientLinkList.AddItem(value: TFhirPatientLink);
begin
  assert(value.ClassName = 'TFhirPatientLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientLink');
  add(value);
end;

function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.GetEnumerator : TFhirPatientLinkListEnumerator;
begin
  result := TFhirPatientLinkListEnumerator.Create(self.link);
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientLink;
end;
function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPatient }

constructor TFhirPatient.Create;
begin
  inherited;
end;

destructor TFhirPatient.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.Free;
  FMaritalStatus.free;
  FMultipleBirth.free;
  FPhotoList.Free;
  FContactList.Free;
  FCommunicationList.Free;
  FGeneralPractitionerList.Free;
  FManagingOrganization.free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirPatient.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatient(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPatient(oSource).FIdentifierList);
  end;
  activeElement := TFhirPatient(oSource).activeElement.Clone;
  if (TFhirPatient(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPatient(oSource).FNameList);
  end;
  if (TFhirPatient(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatient(oSource).FTelecomList);
  end;
  genderElement := TFhirPatient(oSource).genderElement.Clone;
  birthDateElement := TFhirPatient(oSource).birthDateElement.Clone;
  deceased := TFhirPatient(oSource).deceased.Clone;
  if (TFhirPatient(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPatient(oSource).FAddressList);
  end;
  maritalStatus := TFhirPatient(oSource).maritalStatus.Clone;
  multipleBirth := TFhirPatient(oSource).multipleBirth.Clone;
  if (TFhirPatient(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPatient(oSource).FPhotoList);
  end;
  if (TFhirPatient(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirPatientContactList.Create;
    FContactList.Assign(TFhirPatient(oSource).FContactList);
  end;
  if (TFhirPatient(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirPatientCommunicationList.Create;
    FCommunicationList.Assign(TFhirPatient(oSource).FCommunicationList);
  end;
  if (TFhirPatient(oSource).FGeneralPractitionerList = nil) then
  begin
    FGeneralPractitionerList.free;
    FGeneralPractitionerList := nil;
  end
  else
  begin
    if FGeneralPractitionerList = nil then
      FGeneralPractitionerList := TFhirReferenceList.Create;
    FGeneralPractitionerList.Assign(TFhirPatient(oSource).FGeneralPractitionerList);
  end;
  managingOrganization := TFhirPatient(oSource).managingOrganization.Clone;
  if (TFhirPatient(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPatientLinkList.Create;
    FLink_List.Assign(TFhirPatient(oSource).FLink_List);
  end;
end;

function TFhirPatient.GetResourceType : TFhirResourceType;
begin
  result := frtPatient;
end;

procedure TFhirPatient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'maritalStatus') Then
     list.add(self.link, 'maritalStatus', FMaritalStatus.Link);
  if (child_name = 'multipleBirth[x]') or (child_name = 'multipleBirth') Then
     list.add(self.link, 'multipleBirth[x]', FMultipleBirth.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'generalPractitioner') Then
    list.addAll(self, 'generalPractitioner', FGeneralPractitionerList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPatient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirDataType, FDeceased.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'maritalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FMaritalStatus.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'multipleBirth[x]', 'boolean|integer', false, TFhirDataType, FMultipleBirth.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirPatientContact, FContactList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'communication', 'BackboneElement', true, TFhirPatientCommunication, FCommunicationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'generalPractitioner', 'Reference', true, TFhirReference, FGeneralPractitionerList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirPatientLink, FLink_List.Link)) {L1039};
end;

function TFhirPatient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'maritalStatus') then
  begin
    MaritalStatus := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then
  begin
    MultipleBirth := propValue as TFhirDataType {L1185};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment) {L1048};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirPatientContact) {L1048};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirPatientCommunication) {L1048};
    result := propValue;
  end
  else if (propName = 'generalPractitioner') then
  begin
    GeneralPractitionerList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPatientLink) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment) {L1049}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirPatientContact) {L1049}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirPatientCommunication) {L1049}
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPatientLink) {L1049}
  else inherited;
end;

function TFhirPatient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull])  {L1211}
  else if (propName = 'birthDate') then result := TFhirDate.create() {L1223}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.create('Cannot make property Deceased') {L1191}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'maritalStatus') then result := TFhirCodeableConcept.create() {L1203}
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then raise EFHIRException.create('Cannot make property MultipleBirth') {L1191}
  else if (propName = 'photo') then result := PhotoList.new() {L1053}
  else if (propName = 'contact') then result := ContactList.new() {L1053}
  else if (propName = 'communication') then result := CommunicationList.new() {L1053}
  else if (propName = 'generalPractitioner') then result := GeneralPractitionerList.new() {L1053}
  else if (propName = 'managingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'link') then result := Link_List.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'maritalStatus') then result := 'CodeableConcept'
  else if (propName = 'multipleBirth[x]') then result := 'boolean|integer'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'BackboneElement'
  else if (propName = 'generalPractitioner') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil {L1189}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'maritalStatus') then MaritalStatusElement := nil
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := nil {L1189}
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {L1054}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {L1054}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {L1054}
  else if (propName = 'generalPractitioner') then deletePropertyValue('generalPractitioner', GeneralPractitionerList, value) {L1054}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new) {L1210}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new) {L1222}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirDataType {L1190}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'maritalStatus') then MaritalStatusElement := new as TFhirCodeableConcept {L1195}
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := new as TFhirDataType {L1190}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {L1055}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {L1055}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {L1055}
  else if (propName = 'generalPractitioner') then replacePropertyValue('generalPractitioner', GeneralPractitionerList, existing, new) {L1055}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'photo') then PhotoList.move(source, destination) {L1050}
  else if (propName = 'contact') then ContactList.move(source, destination) {L1050}
  else if (propName = 'communication') then CommunicationList.move(source, destination) {L1050}
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.move(source, destination) {L1050}
  else if (propName = 'link') then Link_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatient.fhirType : string;
begin
  result := 'Patient';
end;

function TFhirPatient.Link : TFhirPatient;
begin
  result := TFhirPatient(inherited Link);
end;

function TFhirPatient.Clone : TFhirPatient;
begin
  result := TFhirPatient(inherited Clone);
end;

function TFhirPatient.equals(other : TObject) : boolean; 
var
  o : TFhirPatient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatient)) then
    result := false
  else
  begin
    o := TFhirPatient(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(maritalStatusElement, o.maritalStatusElement, true) and compareDeep(multipleBirthElement, o.multipleBirthElement, true) and 
      compareDeep(photoList, o.photoList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(generalPractitionerList, o.generalPractitionerList, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPatient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FMaritalStatus) and isEmptyProp(FMultipleBirth) and isEmptyProp(FphotoList) and isEmptyProp(FcontactList) and isEmptyProp(FcommunicationList) and isEmptyProp(FgeneralPractitionerList) and isEmptyProp(FManagingOrganization) and isEmptyProp(Flink_List);
end;

function TFhirPatient.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPatient.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPatient.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirPatient.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPatient.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPatient.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPatient.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPatient.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatient.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatient.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatient.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatient.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatient.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value; {L1134}
end;

function TFhirPatient.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPatient.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

procedure TFhirPatient.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value; {L1134}
end;

function TFhirPatient.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPatient.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPatient.SetMaritalStatus(value : TFhirCodeableConcept);
begin
  FMaritalStatus.free;
  FMaritalStatus := value; {L1134}
end;

procedure TFhirPatient.SetMultipleBirth(value : TFhirDataType);
begin
  FMultipleBirth.free;
  FMultipleBirth := value; {L1134}
end;

function TFhirPatient.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPatient.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPatient.GetContactList : TFhirPatientContactList;
begin
  if FContactList = nil then
    FContactList := TFhirPatientContactList.Create;
  result := FContactList;
end;

function TFhirPatient.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirPatient.GetCommunicationList : TFhirPatientCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirPatientCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirPatient.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirPatient.GetGeneralPractitionerList : TFhirReferenceList;
begin
  if FGeneralPractitionerList = nil then
    FGeneralPractitionerList := TFhirReferenceList.Create;
  result := FGeneralPractitionerList;
end;

function TFhirPatient.GetHasGeneralPractitionerList : boolean;
begin
  result := (FGeneralPractitionerList <> nil) and (FGeneralPractitionerList.count > 0);
end;

procedure TFhirPatient.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value; {L1134}
end;

function TFhirPatient.GetLink_List : TFhirPatientLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPatientLinkList.Create;
  result := FLink_List;
end;

function TFhirPatient.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

procedure TFhirPatient.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('maritalStatus');
  fields.add('multipleBirth[x]');
  fields.add('photo');
  fields.add('contact');
  fields.add('communication');
  fields.add('generalPractitioner');
  fields.add('managingOrganization');
  fields.add('link');
end;

function TFhirPatient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBirthDate.sizeInBytes);
  inc(result, FDeceased.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FMaritalStatus.sizeInBytes);
  inc(result, FMultipleBirth.sizeInBytes);
  inc(result, FphotoList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FcommunicationList.sizeInBytes);
  inc(result, FgeneralPractitionerList.sizeInBytes);
  inc(result, FManagingOrganization.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
end;

{ TFhirPatientListEnumerator }

constructor TFhirPatientListEnumerator.Create(list : TFhirPatientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPatientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientListEnumerator.GetCurrent : TFhirPatient;
begin
  Result := FList[FIndex];
end;

function TFhirPatientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPatientList }

procedure TFhirPatientList.AddItem(value: TFhirPatient);
begin
  assert(value.ClassName = 'TFhirPatient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatient');
  add(value);
end;

function TFhirPatientList.Append: TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.ClearItems;
begin
  Clear;
end;

function TFhirPatientList.GetEnumerator : TFhirPatientListEnumerator;
begin
  result := TFhirPatientListEnumerator.Create(self.link);
end;

function TFhirPatientList.Clone: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Clone);
end;

function TFhirPatientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientList.GetItemN(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatient;
end;
function TFhirPatientList.IndexOf(value: TFhirPatient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientList.Insert(index: Integer): TFhirPatient;
begin
  result := TFhirPatient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.InsertItem(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  Inherited Insert(index, value);
end;

function TFhirPatientList.Item(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.Link: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Link);
end;

procedure TFhirPatientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientList.SetItemByIndex(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  FhirPatients[index] := value;
end;

procedure TFhirPatientList.SetItemN(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
{ TFhirPersonLink }

constructor TFhirPersonLink.Create;
begin
  inherited;
end;

destructor TFhirPersonLink.Destroy;
begin
  FTarget.free;
  FAssurance.free;
  inherited;
end;

procedure TFhirPersonLink.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirPersonLink(oSource).target.Clone;
  assuranceElement := TFhirPersonLink(oSource).assuranceElement.Clone;
end;

procedure TFhirPersonLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'assurance') Then
     list.add(self.link, 'assurance', FAssurance.Link);
end;

procedure TFhirPersonLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'assurance', 'code', false, TFhirEnum, FAssurance.Link)); {L1170}
end;

function TFhirPersonLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'assurance') then
  begin
    AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, propValue) {L1209};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPersonLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPersonLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference.create() {L1203}
  else if (propName = 'assurance') then result := TFhirEnum.create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull], CODES_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull])  {L1211}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPersonLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'assurance') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPersonLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'assurance') then AssuranceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPersonLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirReference {L1195}
  else if (propName = 'assurance') then AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, new) {L1210}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPersonLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPersonLink.fhirType : string;
begin
  result := 'Person.link';
end;

function TFhirPersonLink.Link : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Link);
end;

function TFhirPersonLink.Clone : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Clone);
end;

function TFhirPersonLink.equals(other : TObject) : boolean; 
var
  o : TFhirPersonLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPersonLink)) then
    result := false
  else
  begin
    o := TFhirPersonLink(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(assuranceElement, o.assuranceElement, true);
  end;
end;

function TFhirPersonLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FAssurance);
end;

procedure TFhirPersonLink.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value; {L1134}
end;

procedure TFhirPersonLink.SetAssurance(value : TFhirEnum);
begin
  FAssurance.free;
  FAssurance := value;
end;

function TFhirPersonLink.GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
begin
  if FAssurance = nil then
    result := TFhirIdentityAssuranceLevelEnum(0)
  else
    result := TFhirIdentityAssuranceLevelEnum(StringArrayIndexOfSensitive(CODES_TFhirIdentityAssuranceLevelEnum, FAssurance.value));
end;

procedure TFhirPersonLink.SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
begin
  if ord(value) = 0 then
    AssuranceElement := nil
  else
    AssuranceElement := TFhirEnum.create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[value], CODES_TFhirIdentityAssuranceLevelEnum[value]);
end;

procedure TFhirPersonLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('target');
  fields.add('assurance');
end;

function TFhirPersonLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTarget.sizeInBytes);
  inc(result, FAssurance.sizeInBytes);
end;

{ TFhirPersonLinkListEnumerator }

constructor TFhirPersonLinkListEnumerator.Create(list : TFhirPersonLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPersonLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonLinkListEnumerator.GetCurrent : TFhirPersonLink;
begin
  Result := FList[FIndex];
end;

function TFhirPersonLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPersonLinkList }

procedure TFhirPersonLinkList.AddItem(value: TFhirPersonLink);
begin
  assert(value.ClassName = 'TFhirPersonLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPersonLink');
  add(value);
end;

function TFhirPersonLinkList.Append: TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPersonLinkList.GetEnumerator : TFhirPersonLinkListEnumerator;
begin
  result := TFhirPersonLinkListEnumerator.Create(self.link);
end;

function TFhirPersonLinkList.Clone: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Clone);
end;

function TFhirPersonLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonLinkList.GetItemN(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPersonLink;
end;
function TFhirPersonLinkList.IndexOf(value: TFhirPersonLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonLinkList.Insert(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.InsertItem(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  Inherited Insert(index, value);
end;

function TFhirPersonLinkList.Item(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.Link: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Link);
end;

procedure TFhirPersonLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonLinkList.SetItemByIndex(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  FhirPersonLinks[index] := value;
end;

procedure TFhirPersonLinkList.SetItemN(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPerson }

constructor TFhirPerson.Create;
begin
  inherited;
end;

destructor TFhirPerson.Destroy;
begin
  FIdentifierList.Free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FAddressList.Free;
  FPhoto.free;
  FManagingOrganization.free;
  FActive.free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPerson(oSource).FIdentifierList);
  end;
  if (TFhirPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPerson(oSource).FNameList);
  end;
  if (TFhirPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirPerson(oSource).birthDateElement.Clone;
  if (TFhirPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPerson(oSource).FAddressList);
  end;
  photo := TFhirPerson(oSource).photo.Clone;
  managingOrganization := TFhirPerson(oSource).managingOrganization.Clone;
  activeElement := TFhirPerson(oSource).activeElement.Clone;
  if (TFhirPerson(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPersonLinkList.Create;
    FLink_List.Assign(TFhirPerson(oSource).FLink_List);
  end;
end;

function TFhirPerson.GetResourceType : TFhirResourceType;
begin
  result := frtPerson;
end;

procedure TFhirPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirPersonLink, FLink_List.Link)) {L1039};
end;

function TFhirPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment {L1199};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPersonLink) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPersonLink) {L1049}
  else inherited;
end;

function TFhirPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull])  {L1211}
  else if (propName = 'birthDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'photo') then result := TFhirAttachment.create() {L1203}
  else if (propName = 'managingOrganization') then result := TFhirReference.create() {L1203}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'link') then result := Link_List.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new) {L1210}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new) {L1222}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment {L1195}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'link') then Link_List.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPerson.fhirType : string;
begin
  result := 'Person';
end;

function TFhirPerson.Link : TFhirPerson;
begin
  result := TFhirPerson(inherited Link);
end;

function TFhirPerson.Clone : TFhirPerson;
begin
  result := TFhirPerson(inherited Clone);
end;

function TFhirPerson.equals(other : TObject) : boolean; 
var
  o : TFhirPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPerson)) then
    result := false
  else
  begin
    o := TFhirPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameList, o.nameList, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(activeElement, o.activeElement, true) and compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FPhoto) and isEmptyProp(FManagingOrganization) and isEmptyProp(FActive) and isEmptyProp(Flink_List);
end;

function TFhirPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value; {L1134}
end;

function TFhirPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

function TFhirPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPerson.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value; {L1134}
end;

procedure TFhirPerson.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value; {L1134}
end;

procedure TFhirPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPerson.GetLink_List : TFhirPersonLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPersonLinkList.Create;
  result := FLink_List;
end;

function TFhirPerson.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

procedure TFhirPerson.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('managingOrganization');
  fields.add('active');
  fields.add('link');
end;

function TFhirPerson.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBirthDate.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FPhoto.sizeInBytes);
  inc(result, FManagingOrganization.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
end;

{ TFhirPersonListEnumerator }

constructor TFhirPersonListEnumerator.Create(list : TFhirPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonListEnumerator.GetCurrent : TFhirPerson;
begin
  Result := FList[FIndex];
end;

function TFhirPersonListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPersonList }

procedure TFhirPersonList.AddItem(value: TFhirPerson);
begin
  assert(value.ClassName = 'TFhirPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPerson');
  add(value);
end;

function TFhirPersonList.Append: TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.ClearItems;
begin
  Clear;
end;

function TFhirPersonList.GetEnumerator : TFhirPersonListEnumerator;
begin
  result := TFhirPersonListEnumerator.Create(self.link);
end;

function TFhirPersonList.Clone: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Clone);
end;

function TFhirPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonList.GetItemN(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirPerson;
end;
function TFhirPersonList.IndexOf(value: TFhirPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonList.Insert(index: Integer): TFhirPerson;
begin
  result := TFhirPerson.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.InsertItem(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  Inherited Insert(index, value);
end;

function TFhirPersonList.Item(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.Link: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Link);
end;

procedure TFhirPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonList.SetItemByIndex(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  FhirPeople[index] := value;
end;

procedure TFhirPersonList.SetItemN(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerQualification(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerQualification(oSource).FIdentifierList);
  end;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link)); {L1172}
end;

function TFhirPractitionerQualification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerQualification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else inherited;
end;

function TFhirPractitionerQualification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'code') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'issuer') then result := TFhirReference.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerQualification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'issuer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerQualification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerQualification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerQualification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerQualification.fhirType : string;
begin
  result := 'Practitioner.qualification';
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

function TFhirPractitionerQualification.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerQualification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerQualification)) then
    result := false
  else
  begin
    o := TFhirPractitionerQualification(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(issuerElement, o.issuerElement, true);
  end;
end;

function TFhirPractitionerQualification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FPeriod) and isEmptyProp(FIssuer);
end;

function TFhirPractitionerQualification.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerQualification.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value; {L1134}
end;

procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirPractitionerQualification.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value; {L1134}
end;

procedure TFhirPractitionerQualification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('period');
  fields.add('issuer');
end;

function TFhirPractitionerQualification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FIssuer.sizeInBytes);
end;

{ TFhirPractitionerQualificationListEnumerator }

constructor TFhirPractitionerQualificationListEnumerator.Create(list : TFhirPractitionerQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerQualificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerQualificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerQualificationListEnumerator.GetCurrent : TFhirPractitionerQualification;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerQualificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPractitionerQualificationList }

procedure TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification);
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
end;

function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.GetEnumerator : TFhirPractitionerQualificationListEnumerator;
begin
  result := TFhirPractitionerQualificationListEnumerator.Create(self.link);
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerQualification;
end;
function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitioner }

constructor TFhirPractitioner.Create;
begin
  inherited;
end;

destructor TFhirPractitioner.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FNameList.Free;
  FTelecomList.Free;
  FAddressList.Free;
  FGender.free;
  FBirthDate.free;
  FPhotoList.Free;
  FQualificationList.Free;
  FCommunicationList.Free;
  inherited;
end;

procedure TFhirPractitioner.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitioner(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitioner(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitioner(oSource).activeElement.Clone;
  if (TFhirPractitioner(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPractitioner(oSource).FNameList);
  end;
  if (TFhirPractitioner(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitioner(oSource).FTelecomList);
  end;
  if (TFhirPractitioner(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPractitioner(oSource).FAddressList);
  end;
  genderElement := TFhirPractitioner(oSource).genderElement.Clone;
  birthDateElement := TFhirPractitioner(oSource).birthDateElement.Clone;
  if (TFhirPractitioner(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPractitioner(oSource).FPhotoList);
  end;
  if (TFhirPractitioner(oSource).FQualificationList = nil) then
  begin
    FQualificationList.free;
    FQualificationList := nil;
  end
  else
  begin
    if FQualificationList = nil then
      FQualificationList := TFhirPractitionerQualificationList.Create;
    FQualificationList.Assign(TFhirPractitioner(oSource).FQualificationList);
  end;
  if (TFhirPractitioner(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirPractitioner(oSource).FCommunicationList);
  end;
end;

function TFhirPractitioner.GetResourceType : TFhirResourceType;
begin
  result := frtPractitioner;
end;

procedure TFhirPractitioner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'qualification') Then
    list.addAll(self, 'qualification', FQualificationList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirPractitioner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'qualification', 'BackboneElement', true, TFhirPractitionerQualification, FQualificationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link)) {L1039};
end;

function TFhirPractitioner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment) {L1048};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    QualificationList.add(propValue as TFhirPractitionerQualification) {L1048};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitioner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment) {L1049}
  else if (propName = 'qualification') then QualificationList.insertItem(index, propValue as TFhirPractitionerQualification) {L1049}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirPractitioner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull])  {L1211}
  else if (propName = 'birthDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'photo') then result := PhotoList.new() {L1053}
  else if (propName = 'qualification') then result := QualificationList.new() {L1053}
  else if (propName = 'communication') then result := CommunicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitioner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'qualification') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitioner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {L1054}
  else if (propName = 'qualification') then deletePropertyValue('qualification', QualificationList, value) {L1054}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitioner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new) {L1210}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new) {L1222}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {L1055}
  else if (propName = 'qualification') then replacePropertyValue('qualification', QualificationList, existing, new) {L1055}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitioner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'photo') then PhotoList.move(source, destination) {L1050}
  else if (propName = 'qualification') then QualificationList.move(source, destination) {L1050}
  else if (propName = 'communication') then CommunicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitioner.fhirType : string;
begin
  result := 'Practitioner';
end;

function TFhirPractitioner.Link : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Link);
end;

function TFhirPractitioner.Clone : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Clone);
end;

function TFhirPractitioner.equals(other : TObject) : boolean; 
var
  o : TFhirPractitioner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitioner)) then
    result := false
  else
  begin
    o := TFhirPractitioner(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(qualificationList, o.qualificationList, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirPractitioner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FphotoList) and isEmptyProp(FqualificationList) and isEmptyProp(FcommunicationList);
end;

function TFhirPractitioner.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitioner.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitioner.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirPractitioner.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitioner.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirPractitioner.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPractitioner.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPractitioner.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPractitioner.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirPractitioner.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPractitioner.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPractitioner.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPractitioner.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPractitioner.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPractitioner.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value; {L1134}
end;

function TFhirPractitioner.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPractitioner.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

function TFhirPractitioner.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPractitioner.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPractitioner.GetQualificationList : TFhirPractitionerQualificationList;
begin
  if FQualificationList = nil then
    FQualificationList := TFhirPractitionerQualificationList.Create;
  result := FQualificationList;
end;

function TFhirPractitioner.GetHasQualificationList : boolean;
begin
  result := (FQualificationList <> nil) and (FQualificationList.count > 0);
end;

function TFhirPractitioner.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirPractitioner.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

procedure TFhirPractitioner.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('photo');
  fields.add('qualification');
  fields.add('communication');
end;

function TFhirPractitioner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBirthDate.sizeInBytes);
  inc(result, FphotoList.sizeInBytes);
  inc(result, FqualificationList.sizeInBytes);
  inc(result, FcommunicationList.sizeInBytes);
end;

{ TFhirPractitionerListEnumerator }

constructor TFhirPractitionerListEnumerator.Create(list : TFhirPractitionerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerListEnumerator.GetCurrent : TFhirPractitioner;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPractitionerList }

procedure TFhirPractitionerList.AddItem(value: TFhirPractitioner);
begin
  assert(value.ClassName = 'TFhirPractitioner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitioner');
  add(value);
end;

function TFhirPractitionerList.Append: TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerList.GetEnumerator : TFhirPractitionerListEnumerator;
begin
  result := TFhirPractitionerListEnumerator.Create(self.link);
end;

function TFhirPractitionerList.Clone: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Clone);
end;

function TFhirPractitionerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerList.GetItemN(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitioner;
end;
function TFhirPractitionerList.IndexOf(value: TFhirPractitioner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerList.Insert(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.InsertItem(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  Inherited Insert(index, value);
end;

function TFhirPractitionerList.Item(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.Link: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Link);
end;

procedure TFhirPractitionerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerList.SetItemByIndex(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  FhirPractitioners[index] := value;
end;

procedure TFhirPractitionerList.SetItemN(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
{ TFhirPractitionerRoleAvailableTime }

constructor TFhirPractitionerRoleAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleAvailableTime.Destroy;
begin
  FDaysOfWeek.Free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirPractitionerRoleAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirPractitionerRoleAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirPractitionerRoleAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirPractitionerRoleAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link)) {L990};
  oList.add(TFHIRProperty.create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link)); {L1172}
end;

function TFhirPractitionerRoleAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {L994}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {L995}
  else inherited;
end;

function TFhirPractitionerRoleAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'availableStartTime') then result := TFhirTime.create() {L1223}
  else if (propName = 'availableEndTime') then result := TFhirTime.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new) {L1222}
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new) {L1222}
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {L996}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleAvailableTime.fhirType : string;
begin
  result := 'PractitionerRole.availableTime';
end;

function TFhirPractitionerRoleAvailableTime.Link : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Link);
end;

function TFhirPractitionerRoleAvailableTime.Clone : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleAvailableTime)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirPractitionerRoleAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

function TFhirPractitionerRoleAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirPractitionerRoleAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirPractitionerRoleAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirPractitionerRoleAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value; {L1134}
end;

function TFhirPractitionerRoleAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.create;
  FAllDay.value := value
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value; {L1134}
end;

function TFhirPractitionerRoleAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value; {L1134}
end;

function TFhirPractitionerRoleAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

procedure TFhirPractitionerRoleAvailableTime.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

function TFhirPractitionerRoleAvailableTime.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDaysOfWeek.sizeInBytes);
  inc(result, FAllDay.sizeInBytes);
  inc(result, FAvailableStartTime.sizeInBytes);
  inc(result, FAvailableEndTime.sizeInBytes);
end;

{ TFhirPractitionerRoleAvailableTimeListEnumerator }

constructor TFhirPractitionerRoleAvailableTimeListEnumerator.Create(list : TFhirPractitionerRoleAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleAvailableTimeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.GetCurrent : TFhirPractitionerRoleAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPractitionerRoleAvailableTimeList }

procedure TFhirPractitionerRoleAvailableTimeList.AddItem(value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value.ClassName = 'TFhirPractitionerRoleAvailableTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRoleAvailableTime');
  add(value);
end;

function TFhirPractitionerRoleAvailableTimeList.Append: TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleAvailableTimeList.GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
begin
  result := TFhirPractitionerRoleAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleAvailableTimeList.Clone: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleAvailableTimeList.GetItemN(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleAvailableTime;
end;
function TFhirPractitionerRoleAvailableTimeList.IndexOf(value: TFhirPractitionerRoleAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleAvailableTimeList.Insert(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.InsertItem(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleAvailableTimeList.Item(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.Link: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Link);
end;

procedure TFhirPractitionerRoleAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  FhirPractitionerRoleAvailableTimes[index] := value;
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemN(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRoleNotAvailable }

constructor TFhirPractitionerRoleNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirPractitionerRoleNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirPractitionerRoleNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirPractitionerRoleNotAvailable(oSource).during.Clone;
end;

procedure TFhirPractitionerRoleNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirPractitionerRoleNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link)); {L1172}
end;

function TFhirPractitionerRoleNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPractitionerRoleNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {L1223}
  else if (propName = 'during') then result := TFhirPeriod.create() {L1203}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new) {L1222}
  else if (propName = 'during') then DuringElement := new as TFhirPeriod {L1195}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleNotAvailable.fhirType : string;
begin
  result := 'PractitionerRole.notAvailable';
end;

function TFhirPractitionerRoleNotAvailable.Link : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Link);
end;

function TFhirPractitionerRoleNotAvailable.Clone : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleNotAvailable)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirPractitionerRoleNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirPractitionerRoleNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value; {L1134}
end;

function TFhirPractitionerRoleNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPractitionerRoleNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirPractitionerRoleNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value; {L1134}
end;

procedure TFhirPractitionerRoleNotAvailable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

function TFhirPractitionerRoleNotAvailable.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FDuring.sizeInBytes);
end;

{ TFhirPractitionerRoleNotAvailableListEnumerator }

constructor TFhirPractitionerRoleNotAvailableListEnumerator.Create(list : TFhirPractitionerRoleNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleNotAvailableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.GetCurrent : TFhirPractitionerRoleNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPractitionerRoleNotAvailableList }

procedure TFhirPractitionerRoleNotAvailableList.AddItem(value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value.ClassName = 'TFhirPractitionerRoleNotAvailable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRoleNotAvailable');
  add(value);
end;

function TFhirPractitionerRoleNotAvailableList.Append: TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleNotAvailableList.GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
begin
  result := TFhirPractitionerRoleNotAvailableListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleNotAvailableList.Clone: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleNotAvailableList.GetItemN(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleNotAvailable;
end;
function TFhirPractitionerRoleNotAvailableList.IndexOf(value: TFhirPractitionerRoleNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleNotAvailableList.Insert(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.InsertItem(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleNotAvailableList.Item(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.Link: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Link);
end;

procedure TFhirPractitionerRoleNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  FhirPractitionerRoleNotAvailables[index] := value;
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemN(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRole }

constructor TFhirPractitionerRole.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRole.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPeriod.free;
  FPractitioner.free;
  FOrganization.free;
  FCodeList.Free;
  FSpecialtyList.Free;
  FLocationList.Free;
  FHealthcareServiceList.Free;
  FTelecomList.Free;
  FAvailableTimeList.Free;
  FNotAvailableList.Free;
  FAvailabilityExceptions.free;
  FEndpointList.Free;
  inherited;
end;

procedure TFhirPractitionerRole.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRole(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerRole(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitionerRole(oSource).activeElement.Clone;
  period := TFhirPractitionerRole(oSource).period.Clone;
  practitioner := TFhirPractitionerRole(oSource).practitioner.Clone;
  organization := TFhirPractitionerRole(oSource).organization.Clone;
  if (TFhirPractitionerRole(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPractitionerRole(oSource).FCodeList);
  end;
  if (TFhirPractitionerRole(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirPractitionerRole(oSource).FSpecialtyList);
  end;
  if (TFhirPractitionerRole(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirPractitionerRole(oSource).FLocationList);
  end;
  if (TFhirPractitionerRole(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirPractitionerRole(oSource).FHealthcareServiceList);
  end;
  if (TFhirPractitionerRole(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitionerRole(oSource).FTelecomList);
  end;
  if (TFhirPractitionerRole(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirPractitionerRole(oSource).FAvailableTimeList);
  end;
  if (TFhirPractitionerRole(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirPractitionerRole(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirPractitionerRole(oSource).availabilityExceptionsElement.Clone;
  if (TFhirPractitionerRole(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirPractitionerRole(oSource).FEndpointList);
  end;
end;

function TFhirPractitionerRole.GetResourceType : TFhirResourceType;
begin
  result := frtPractitionerRole;
end;

procedure TFhirPractitionerRole.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'practitioner') Then
     list.add(self.link, 'practitioner', FPractitioner.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirPractitionerRole.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'practitioner', 'Reference', false, TFhirReference, FPractitioner.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'availableTime', 'BackboneElement', true, TFhirPractitionerRoleAvailableTime, FAvailableTimeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'notAvailable', 'BackboneElement', true, TFhirPractitionerRoleNotAvailable, FNotAvailableList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link)) {L1039};
end;

function TFhirPractitionerRole.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    Practitioner := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirPractitionerRoleAvailableTime) {L1048};
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirPractitionerRoleNotAvailable) {L1048};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRole.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirPractitionerRoleAvailableTime) {L1049}
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirPractitionerRoleNotAvailable) {L1049}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirPractitionerRole.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'practitioner') then result := TFhirReference.create() {L1203}
  else if (propName = 'organization') then result := TFhirReference.create() {L1203}
  else if (propName = 'code') then result := CodeList.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'location') then result := LocationList.new() {L1053}
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'availableTime') then result := AvailableTimeList.new() {L1053}
  else if (propName = 'notAvailable') then result := NotAvailableList.new() {L1053}
  else if (propName = 'availabilityExceptions') then result := TFhirString.create() {L1223}
  else if (propName = 'endpoint') then result := EndpointList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRole.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'practitioner') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'availableTime') then result := 'BackboneElement'
  else if (propName = 'notAvailable') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRole.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'practitioner') then PractitionerElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {L1054}
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value) {L1054}
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value) {L1054}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRole.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'practitioner') then PractitionerElement := new as TFhirReference {L1195}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference {L1195}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {L1055}
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new) {L1055}
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new) {L1055}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new) {L1222}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRole.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'code') then CodeList.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else if (propName = 'location') then LocationList.move(source, destination) {L1050}
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination) {L1050}
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination) {L1050}
  else if (propName = 'endpoint') then EndpointList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRole.fhirType : string;
begin
  result := 'PractitionerRole';
end;

function TFhirPractitionerRole.Link : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Link);
end;

function TFhirPractitionerRole.Clone : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Clone);
end;

function TFhirPractitionerRole.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRole;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRole)) then
    result := false
  else
  begin
    o := TFhirPractitionerRole(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(practitionerElement, o.practitionerElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirPractitionerRole.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FPractitioner) and isEmptyProp(FOrganization) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirPractitionerRole.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerRole.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerRole.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirPractitionerRole.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitionerRole.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirPractitionerRole.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

procedure TFhirPractitionerRole.SetPractitioner(value : TFhirReference);
begin
  FPractitioner.free;
  FPractitioner := value; {L1134}
end;

procedure TFhirPractitionerRole.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value; {L1134}
end;

function TFhirPractitionerRole.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirPractitionerRole.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirPractitionerRole.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirPractitionerRole.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirPractitionerRole.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirPractitionerRole.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirPractitionerRole.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirPractitionerRole.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirPractitionerRole.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPractitionerRole.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirPractitionerRole.GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

function TFhirPractitionerRole.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

function TFhirPractitionerRole.GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
  result := FNotAvailableList;
end;

function TFhirPractitionerRole.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

procedure TFhirPractitionerRole.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value; {L1134}
end;

function TFhirPractitionerRole.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirPractitionerRole.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirPractitionerRole.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirPractitionerRole.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirPractitionerRole.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('practitioner');
  fields.add('organization');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirPractitionerRole.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FPractitioner.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FhealthcareServiceList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FavailableTimeList.sizeInBytes);
  inc(result, FnotAvailableList.sizeInBytes);
  inc(result, FAvailabilityExceptions.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
end;

{ TFhirPractitionerRoleListEnumerator }

constructor TFhirPractitionerRoleListEnumerator.Create(list : TFhirPractitionerRoleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPractitionerRoleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleListEnumerator.GetCurrent : TFhirPractitionerRole;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPractitionerRoleList }

procedure TFhirPractitionerRoleList.AddItem(value: TFhirPractitionerRole);
begin
  assert(value.ClassName = 'TFhirPractitionerRole', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRole');
  add(value);
end;

function TFhirPractitionerRoleList.Append: TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleList.GetEnumerator : TFhirPractitionerRoleListEnumerator;
begin
  result := TFhirPractitionerRoleListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleList.Clone: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Clone);
end;

function TFhirPractitionerRoleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleList.GetItemN(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRole;
end;
function TFhirPractitionerRoleList.IndexOf(value: TFhirPractitionerRole): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleList.Insert(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.InsertItem(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleList.Item(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.Link: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Link);
end;

procedure TFhirPractitionerRoleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleList.SetItemByIndex(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  FhirPractitionerRoles[index] := value;
end;

procedure TFhirPractitionerRoleList.SetItemN(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
{ TFhirRelatedPersonCommunication }

constructor TFhirRelatedPersonCommunication.Create;
begin
  inherited;
end;

destructor TFhirRelatedPersonCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirRelatedPersonCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirRelatedPersonCommunication(oSource).language.Clone;
  preferredElement := TFhirRelatedPersonCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirRelatedPersonCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirRelatedPersonCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link)); {L1172}
end;

function TFhirRelatedPersonCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPersonCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRelatedPersonCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPersonCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPersonCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPersonCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPersonCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPersonCommunication.fhirType : string;
begin
  result := 'RelatedPerson.communication';
end;

function TFhirRelatedPersonCommunication.Link : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Link);
end;

function TFhirRelatedPersonCommunication.Clone : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Clone);
end;

function TFhirRelatedPersonCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPersonCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPersonCommunication)) then
    result := false
  else
  begin
    o := TFhirRelatedPersonCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirRelatedPersonCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirRelatedPersonCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value; {L1134}
end;

procedure TFhirRelatedPersonCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value; {L1134}
end;

function TFhirRelatedPersonCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirRelatedPersonCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

procedure TFhirRelatedPersonCommunication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirRelatedPersonCommunication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
end;

{ TFhirRelatedPersonCommunicationListEnumerator }

constructor TFhirRelatedPersonCommunicationListEnumerator.Create(list : TFhirRelatedPersonCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRelatedPersonCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonCommunicationListEnumerator.GetCurrent : TFhirRelatedPersonCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonCommunicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRelatedPersonCommunicationList }

procedure TFhirRelatedPersonCommunicationList.AddItem(value: TFhirRelatedPersonCommunication);
begin
  assert(value.ClassName = 'TFhirRelatedPersonCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPersonCommunication');
  add(value);
end;

function TFhirRelatedPersonCommunicationList.Append: TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonCommunicationList.GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
begin
  result := TFhirRelatedPersonCommunicationListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonCommunicationList.Clone: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Clone);
end;

function TFhirRelatedPersonCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonCommunicationList.GetItemN(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPersonCommunication;
end;
function TFhirRelatedPersonCommunicationList.IndexOf(value: TFhirRelatedPersonCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonCommunicationList.Insert(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.InsertItem(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonCommunicationList.Item(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.Link: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Link);
end;

procedure TFhirRelatedPersonCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonCommunicationList.SetItemByIndex(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  FhirRelatedPersonCommunications[index] := value;
end;

procedure TFhirRelatedPersonCommunicationList.SetItemN(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirRelatedPerson }

constructor TFhirRelatedPerson.Create;
begin
  inherited;
end;

destructor TFhirRelatedPerson.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FPatient.free;
  FRelationshipList.Free;
  FNameList.Free;
  FTelecomList.Free;
  FGender.free;
  FBirthDate.free;
  FAddressList.Free;
  FPhotoList.Free;
  FPeriod.free;
  FCommunicationList.Free;
  inherited;
end;

procedure TFhirRelatedPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRelatedPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRelatedPerson(oSource).FIdentifierList);
  end;
  activeElement := TFhirRelatedPerson(oSource).activeElement.Clone;
  patient := TFhirRelatedPerson(oSource).patient.Clone;
  if (TFhirRelatedPerson(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirRelatedPerson(oSource).FRelationshipList);
  end;
  if (TFhirRelatedPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirRelatedPerson(oSource).FNameList);
  end;
  if (TFhirRelatedPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirRelatedPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirRelatedPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirRelatedPerson(oSource).birthDateElement.Clone;
  if (TFhirRelatedPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirRelatedPerson(oSource).FAddressList);
  end;
  if (TFhirRelatedPerson(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirRelatedPerson(oSource).FPhotoList);
  end;
  period := TFhirRelatedPerson(oSource).period.Clone;
  if (TFhirRelatedPerson(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
    FCommunicationList.Assign(TFhirRelatedPerson(oSource).FCommunicationList);
  end;
end;

function TFhirRelatedPerson.GetResourceType : TFhirResourceType;
begin
  result := frtRelatedPerson;
end;

procedure TFhirRelatedPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirRelatedPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFhirEnum, FGender.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'communication', 'BackboneElement', true, TFhirRelatedPersonCommunication, FCommunicationList.Link)) {L1039};
end;

function TFhirRelatedPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName) {L1048};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint) {L1048};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress) {L1048};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment) {L1048};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirRelatedPersonCommunication) {L1048};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName) {L1049}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint) {L1049}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress) {L1049}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment) {L1049}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirRelatedPersonCommunication) {L1049}
  else inherited;
end;

function TFhirRelatedPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'patient') then result := TFhirReference.create() {L1203}
  else if (propName = 'relationship') then result := RelationshipList.new() {L1053}
  else if (propName = 'name') then result := NameList.new() {L1053}
  else if (propName = 'telecom') then result := TelecomList.new() {L1053}
  else if (propName = 'gender') then result := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull])  {L1211}
  else if (propName = 'birthDate') then result := TFhirDate.create() {L1223}
  else if (propName = 'address') then result := AddressList.new() {L1053}
  else if (propName = 'photo') then result := PhotoList.new() {L1053}
  else if (propName = 'period') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'communication') then result := CommunicationList.new() {L1053}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'communication') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {L1054}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {L1054}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {L1054}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {L1054}
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {L1054}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {L1054}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'patient') then PatientElement := new as TFhirReference {L1195}
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {L1055}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {L1055}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {L1055}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new) {L1210}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new) {L1222}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {L1055}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {L1055}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod {L1195}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {L1055}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'relationship') then RelationshipList.move(source, destination) {L1050}
  else if (propName = 'name') then NameList.move(source, destination) {L1050}
  else if (propName = 'telecom') then TelecomList.move(source, destination) {L1050}
  else if (propName = 'address') then AddressList.move(source, destination) {L1050}
  else if (propName = 'photo') then PhotoList.move(source, destination) {L1050}
  else if (propName = 'communication') then CommunicationList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPerson.fhirType : string;
begin
  result := 'RelatedPerson';
end;

function TFhirRelatedPerson.Link : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Link);
end;

function TFhirRelatedPerson.Clone : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Clone);
end;

function TFhirRelatedPerson.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPerson)) then
    result := false
  else
  begin
    o := TFhirRelatedPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(relationshipList, o.relationshipList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirRelatedPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPatient) and isEmptyProp(FrelationshipList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FphotoList) and isEmptyProp(FPeriod) and isEmptyProp(FcommunicationList);
end;

function TFhirRelatedPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRelatedPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRelatedPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirRelatedPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirRelatedPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirRelatedPerson.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value; {L1134}
end;

function TFhirRelatedPerson.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirRelatedPerson.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

function TFhirRelatedPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirRelatedPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirRelatedPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirRelatedPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirRelatedPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirRelatedPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirRelatedPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirRelatedPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value; {L1134}
end;

function TFhirRelatedPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirRelatedPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.create;
  FBirthDate.value := value
end;

function TFhirRelatedPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirRelatedPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirRelatedPerson.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirRelatedPerson.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

procedure TFhirRelatedPerson.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value; {L1134}
end;

function TFhirRelatedPerson.GetCommunicationList : TFhirRelatedPersonCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirRelatedPerson.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

procedure TFhirRelatedPerson.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('patient');
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('period');
  fields.add('communication');
end;

function TFhirRelatedPerson.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FrelationshipList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBirthDate.sizeInBytes);
  inc(result, FaddressList.sizeInBytes);
  inc(result, FphotoList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FcommunicationList.sizeInBytes);
end;

{ TFhirRelatedPersonListEnumerator }

constructor TFhirRelatedPersonListEnumerator.Create(list : TFhirRelatedPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRelatedPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonListEnumerator.GetCurrent : TFhirRelatedPerson;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRelatedPersonList }

procedure TFhirRelatedPersonList.AddItem(value: TFhirRelatedPerson);
begin
  assert(value.ClassName = 'TFhirRelatedPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPerson');
  add(value);
end;

function TFhirRelatedPersonList.Append: TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonList.GetEnumerator : TFhirRelatedPersonListEnumerator;
begin
  result := TFhirRelatedPersonListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonList.Clone: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Clone);
end;

function TFhirRelatedPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonList.GetItemN(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPerson;
end;
function TFhirRelatedPersonList.IndexOf(value: TFhirRelatedPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonList.Insert(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.InsertItem(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonList.Item(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.Link: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Link);
end;

procedure TFhirRelatedPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonList.SetItemByIndex(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  FhirRelatedPeople[index] := value;
end;

procedure TFhirRelatedPersonList.SetItemN(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
{ TFhirSchedule }

constructor TFhirSchedule.Create;
begin
  inherited;
end;

destructor TFhirSchedule.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FActorList.Free;
  FPlanningHorizon.free;
  FComment.free;
  inherited;
end;

procedure TFhirSchedule.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSchedule(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSchedule(oSource).FIdentifierList);
  end;
  activeElement := TFhirSchedule(oSource).activeElement.Clone;
  if (TFhirSchedule(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSchedule(oSource).FServiceCategoryList);
  end;
  if (TFhirSchedule(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSchedule(oSource).FServiceTypeList);
  end;
  if (TFhirSchedule(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSchedule(oSource).FSpecialtyList);
  end;
  if (TFhirSchedule(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirReferenceList.Create;
    FActorList.Assign(TFhirSchedule(oSource).FActorList);
  end;
  planningHorizon := TFhirSchedule(oSource).planningHorizon.Clone;
  commentElement := TFhirSchedule(oSource).commentElement.Clone;
end;

function TFhirSchedule.GetResourceType : TFhirResourceType;
begin
  result := frtSchedule;
end;

procedure TFhirSchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'planningHorizon') Then
     list.add(self.link, 'planningHorizon', FPlanningHorizon.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', true, TFhirReference, FActorList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'planningHorizon', 'Period', false, TFhirPeriod, FPlanningHorizon.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
end;

function TFhirSchedule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirReference) {L1048};
    result := propValue;
  end
  else if (propName = 'planningHorizon') then
  begin
    PlanningHorizon := propValue as TFhirPeriod {L1199};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirReference) {L1049}
  else inherited;
end;

function TFhirSchedule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'active') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new() {L1053}
  else if (propName = 'serviceType') then result := ServiceTypeList.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'actor') then result := ActorList.new() {L1053}
  else if (propName = 'planningHorizon') then result := TFhirPeriod.create() {L1203}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'planningHorizon') then result := 'Period'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSchedule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value) {L1054}
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {L1054}
  else if (propName = 'planningHorizon') then PlanningHorizonElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'active') then ActiveElement := asBoolean(new) {L1222}
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new) {L1055}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {L1055}
  else if (propName = 'planningHorizon') then PlanningHorizonElement := new as TFhirPeriod {L1195}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSchedule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination) {L1050}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else if (propName = 'actor') then ActorList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSchedule.fhirType : string;
begin
  result := 'Schedule';
end;

function TFhirSchedule.Link : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Link);
end;

function TFhirSchedule.Clone : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Clone);
end;

function TFhirSchedule.equals(other : TObject) : boolean; 
var
  o : TFhirSchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSchedule)) then
    result := false
  else
  begin
    o := TFhirSchedule(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(serviceCategoryList, o.serviceCategoryList, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(actorList, o.actorList, true) and 
      compareDeep(planningHorizonElement, o.planningHorizonElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FactorList) and isEmptyProp(FPlanningHorizon) and isEmptyProp(FComment);
end;

function TFhirSchedule.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSchedule.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSchedule.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value; {L1134}
end;

function TFhirSchedule.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirSchedule.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

function TFhirSchedule.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSchedule.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSchedule.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirSchedule.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSchedule.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSchedule.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirSchedule.GetActorList : TFhirReferenceList;
begin
  if FActorList = nil then
    FActorList := TFhirReferenceList.Create;
  result := FActorList;
end;

function TFhirSchedule.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

procedure TFhirSchedule.SetPlanningHorizon(value : TFhirPeriod);
begin
  FPlanningHorizon.free;
  FPlanningHorizon := value; {L1134}
end;

procedure TFhirSchedule.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirSchedule.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSchedule.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirSchedule.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('actor');
  fields.add('planningHorizon');
  fields.add('comment');
end;

function TFhirSchedule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FserviceCategoryList.sizeInBytes);
  inc(result, FserviceTypeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FPlanningHorizon.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirScheduleListEnumerator }

constructor TFhirScheduleListEnumerator.Create(list : TFhirScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirScheduleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirScheduleListEnumerator.GetCurrent : TFhirSchedule;
begin
  Result := FList[FIndex];
end;

function TFhirScheduleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirScheduleList }

procedure TFhirScheduleList.AddItem(value: TFhirSchedule);
begin
  assert(value.ClassName = 'TFhirSchedule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSchedule');
  add(value);
end;

function TFhirScheduleList.Append: TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirScheduleList.GetEnumerator : TFhirScheduleListEnumerator;
begin
  result := TFhirScheduleListEnumerator.Create(self.link);
end;

function TFhirScheduleList.Clone: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Clone);
end;

function TFhirScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirScheduleList.GetItemN(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirSchedule;
end;
function TFhirScheduleList.IndexOf(value: TFhirSchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirScheduleList.Insert(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.InsertItem(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  Inherited Insert(index, value);
end;

function TFhirScheduleList.Item(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.Link: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Link);
end;

procedure TFhirScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirScheduleList.SetItemByIndex(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  FhirSchedules[index] := value;
end;

procedure TFhirScheduleList.SetItemN(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
{ TFhirSlot }

constructor TFhirSlot.Create;
begin
  inherited;
end;

destructor TFhirSlot.Destroy;
begin
  FIdentifierList.Free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FAppointmentType.free;
  FSchedule.free;
  FStatus.free;
  FStart.free;
  FEnd_.free;
  FOverbooked.free;
  FComment.free;
  inherited;
end;

procedure TFhirSlot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSlot(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSlot(oSource).FIdentifierList);
  end;
  if (TFhirSlot(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSlot(oSource).FServiceCategoryList);
  end;
  if (TFhirSlot(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSlot(oSource).FServiceTypeList);
  end;
  if (TFhirSlot(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSlot(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirSlot(oSource).appointmentType.Clone;
  schedule := TFhirSlot(oSource).schedule.Clone;
  statusElement := TFhirSlot(oSource).statusElement.Clone;
  startElement := TFhirSlot(oSource).startElement.Clone;
  end_Element := TFhirSlot(oSource).end_Element.Clone;
  overbookedElement := TFhirSlot(oSource).overbookedElement.Clone;
  commentElement := TFhirSlot(oSource).commentElement.Clone;
end;

function TFhirSlot.GetResourceType : TFhirResourceType;
begin
  result := frtSlot;
end;

procedure TFhirSlot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'overbooked') Then
     list.add(self.link, 'overbooked', FOverbooked.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSlot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)) {L1039};
  oList.add(TFHIRProperty.create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Reference', false, TFhirReference, FSchedule.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link)); {L1170}
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'overbooked', 'boolean', false, TFhirBoolean, FOverbooked.Link)); {L1172}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link)); {L1172}
end;

function TFhirSlot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept) {L1048};
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept {L1199};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirReference {L1199};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, propValue) {L1209};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'overbooked') then
  begin
    OverbookedElement := asBoolean(propValue) {L1221};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue) {L1221};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSlot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier) {L1049}
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept) {L1049}
  else inherited;
end;

function TFhirSlot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new() {L1053}
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new() {L1053}
  else if (propName = 'serviceType') then result := ServiceTypeList.new() {L1053}
  else if (propName = 'specialty') then result := SpecialtyList.new() {L1053}
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.create() {L1203}
  else if (propName = 'schedule') then result := TFhirReference.create() {L1203}
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSlotStatusEnum[SlotStatusNull], CODES_TFhirSlotStatusEnum[SlotStatusNull])  {L1211}
  else if (propName = 'start') then result := TFhirInstant.create() {L1223}
  else if (propName = 'end') then result := TFhirInstant.create() {L1223}
  else if (propName = 'overbooked') then result := TFhirBoolean.create() {L1223}
  else if (propName = 'comment') then result := TFhirString.create() {L1223}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSlot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'overbooked') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSlot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {L1054}
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value) {L1054}
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {L1054}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {L1054}
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'overbooked') then OverbookedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSlot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {L1055}
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new) {L1055}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {L1055}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {L1055}
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept {L1195}
  else if (propName = 'schedule') then ScheduleElement := new as TFhirReference {L1195}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, new) {L1210}
  else if (propName = 'start') then StartElement := asInstant(new) {L1222}
  else if (propName = 'end') then End_Element := asInstant(new) {L1222}
  else if (propName = 'overbooked') then OverbookedElement := asBoolean(new) {L1222}
  else if (propName = 'comment') then CommentElement := asString(new) {L1222}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSlot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination) {L1050}
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination) {L1050}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination) {L1050}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination) {L1050}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSlot.fhirType : string;
begin
  result := 'Slot';
end;

function TFhirSlot.Link : TFhirSlot;
begin
  result := TFhirSlot(inherited Link);
end;

function TFhirSlot.Clone : TFhirSlot;
begin
  result := TFhirSlot(inherited Clone);
end;

function TFhirSlot.equals(other : TObject) : boolean; 
var
  o : TFhirSlot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSlot)) then
    result := false
  else
  begin
    o := TFhirSlot(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and compareDeep(scheduleElement, o.scheduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(overbookedElement, o.overbookedElement, true) and 
      compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSlot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FSchedule) and isEmptyProp(FStatus) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FOverbooked) and isEmptyProp(FComment);
end;

function TFhirSlot.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSlot.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirSlot.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSlot.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSlot.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirSlot.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSlot.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSlot.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

procedure TFhirSlot.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value; {L1134}
end;

procedure TFhirSlot.SetSchedule(value : TFhirReference);
begin
  FSchedule.free;
  FSchedule := value; {L1134}
end;

procedure TFhirSlot.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSlot.GetStatusST : TFhirSlotStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSlotStatusEnum(0)
  else
    result := TFhirSlotStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSlotStatusEnum, FStatus.value));
end;

procedure TFhirSlot.SetStatusST(value : TFhirSlotStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSlotStatusEnum[value], CODES_TFhirSlotStatusEnum[value]);
end;

procedure TFhirSlot.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value; {L1134}
end;

function TFhirSlot.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirSlot.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirSlot.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value; {L1134}
end;

function TFhirSlot.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirSlot.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirSlot.SetOverbooked(value : TFhirBoolean);
begin
  FOverbooked.free;
  FOverbooked := value; {L1134}
end;

function TFhirSlot.GetOverbookedST : Boolean;
begin
  if FOverbooked = nil then
    result := false
  else
    result := FOverbooked.value;
end;

procedure TFhirSlot.SetOverbookedST(value : Boolean);
begin
  if FOverbooked = nil then
    FOverbooked := TFhirBoolean.create;
  FOverbooked.value := value
end;

procedure TFhirSlot.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value; {L1134}
end;

function TFhirSlot.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSlot.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirSlot.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('schedule');
  fields.add('status');
  fields.add('start');
  fields.add('end');
  fields.add('overbooked');
  fields.add('comment');
end;

function TFhirSlot.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FserviceCategoryList.sizeInBytes);
  inc(result, FserviceTypeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FAppointmentType.sizeInBytes);
  inc(result, FSchedule.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FOverbooked.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirSlotListEnumerator }

constructor TFhirSlotListEnumerator.Create(list : TFhirSlotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSlotListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSlotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSlotListEnumerator.GetCurrent : TFhirSlot;
begin
  Result := FList[FIndex];
end;

function TFhirSlotListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSlotList }

procedure TFhirSlotList.AddItem(value: TFhirSlot);
begin
  assert(value.ClassName = 'TFhirSlot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSlot');
  add(value);
end;

function TFhirSlotList.Append: TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.ClearItems;
begin
  Clear;
end;

function TFhirSlotList.GetEnumerator : TFhirSlotListEnumerator;
begin
  result := TFhirSlotListEnumerator.Create(self.link);
end;

function TFhirSlotList.Clone: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Clone);
end;

function TFhirSlotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSlotList.GetItemN(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.ItemClass: TFslObjectClass;
begin
  result := TFhirSlot;
end;
function TFhirSlotList.IndexOf(value: TFhirSlot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSlotList.Insert(index: Integer): TFhirSlot;
begin
  result := TFhirSlot.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.InsertItem(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  Inherited Insert(index, value);
end;

function TFhirSlotList.Item(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.Link: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Link);
end;

procedure TFhirSlotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSlotList.SetItemByIndex(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  FhirSlots[index] := value;
end;

procedure TFhirSlotList.SetItemN(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SLOT}

end.

